<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/parser/parse_utilcmd.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_utilcmd.c
 *	  Perform parse analysis work for various utility commands
 *
 * Formerly we did this work during parse_analyze() in analyze.c.  However
 * that is fairly unsafe in the presence of querytree caching, since any
 * database state that we depend on in making the transformations might be
 * obsolete by the time the utility command is executed; and utility commands
 * have no infrastructure for holding locks or rechecking plan validity.
 * Hence these functions are now called at the start of execution of their
 * respective utility commands.
 *
 * NOTE: in general we must avoid scribbling on the passed-in raw parse
 * tree, since it might be in a plan cache.  The simplest solution is
 * a quick copyObject() call before manipulating the query tree.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *	src/backend/parser/parse_utilcmd.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ag_const.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_label.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/graphcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cypher_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cypher_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>


<comment type="block">/* State shared by transformCreateStmt and its subroutines */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>			<comment type="block">/* overall parser state */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtType</name></decl>;</decl_stmt>		<comment type="block">/* "CREATE [FOREIGN] TABLE" or "ALTER TABLE" */</comment>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>relation</name></decl>;</decl_stmt>		<comment type="block">/* relation to create */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* opened/locked rel, if ALTER */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inhRelations</name></decl>;</decl_stmt>	<comment type="block">/* relations to inherit from */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isforeign</name></decl>;</decl_stmt>		<comment type="block">/* true if CREATE/ALTER FOREIGN TABLE */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isalter</name></decl>;</decl_stmt>		<comment type="block">/* true if altering existing table */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>		<comment type="block">/* ColumnDef items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ckconstraints</name></decl>;</decl_stmt>	<comment type="block">/* CHECK constraints */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fkconstraints</name></decl>;</decl_stmt>	<comment type="block">/* FOREIGN KEY constraints */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ixconstraints</name></decl>;</decl_stmt>	<comment type="block">/* index-creating constraints */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>likeclauses</name></decl>;</decl_stmt>	<comment type="block">/* LIKE clauses that need post-processing */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>extstats</name></decl>;</decl_stmt>		<comment type="block">/* cloned extended statistics */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>blist</name></decl>;</decl_stmt>			<comment type="block">/* "before list" of things to do before
								 * creating the table */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>alist</name></decl>;</decl_stmt>			<comment type="block">/* "after list" of things to do after creating
								 * the table */</comment>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>pkey</name></decl>;</decl_stmt>			<comment type="block">/* PRIMARY KEY index, if any */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ispartitioned</name></decl>;</decl_stmt>	<comment type="block">/* true if table is partitioned */</comment>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>partbound</name></decl>;</decl_stmt>	<comment type="block">/* transformed FOR VALUES */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ofType</name></decl>;</decl_stmt>			<comment type="block">/* true if statement contains OF typename */</comment>
}</block></struct></type> <name>CreateStmtContext</name>;</typedef>

<comment type="block">/* State shared by transformCreateSchemaStmt and its subroutines */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtType</name></decl>;</decl_stmt>		<comment type="block">/* "CREATE SCHEMA" or "ALTER SCHEMA" */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>		<comment type="block">/* name of schema */</comment>
	<decl_stmt><decl><type><name>RoleSpec</name>   <modifier>*</modifier></type><name>authrole</name></decl>;</decl_stmt>		<comment type="block">/* owner of schema */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sequences</name></decl>;</decl_stmt>		<comment type="block">/* CREATE SEQUENCE items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tables</name></decl>;</decl_stmt>			<comment type="block">/* CREATE TABLE items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>views</name></decl>;</decl_stmt>			<comment type="block">/* CREATE VIEW items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexes</name></decl>;</decl_stmt>		<comment type="block">/* CREATE INDEX items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>triggers</name></decl>;</decl_stmt>		<comment type="block">/* CREATE TRIGGER items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>grants</name></decl>;</decl_stmt>			<comment type="block">/* GRANT items */</comment>
}</block></struct></type> <name>CreateSchemaStmtContext</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformColumnDefinition</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
									  <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformTableConstraint</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
									 <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformTableLikeClause</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
									 <parameter><decl><type><name>TableLikeClause</name> <modifier>*</modifier></type><name>table_like_clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformOfType</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
							<parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CreateStatsStmt</name> <modifier>*</modifier></type><name>generateClonedExtStatsStmt</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>heapRel</name></decl></parameter>,
												   <parameter><decl><type><name>Oid</name></type> <name>heapRelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>source_statsid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_collation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_opclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformIndexConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexStmt</name> <modifier>*</modifier></type><name>transformIndexConstraint</name><parameter_list>(<parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>,
										   <parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformExtendedStatistics</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformFKConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>skipValidation</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>isAddConstraint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformCheckConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>skipValidation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformConstraintAttrs</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraintList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformColumnType</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setSchemaName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>context_schema</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>stmt_schema_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformPartitionCmd</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformPartitionRangeBounds</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>blist</name></decl></parameter>,
										   <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validateInfiniteBounds</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>blist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type><name>transformPartitionBoundValue</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>con</name></decl></parameter>,
										   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>colType</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>colTypmod</name></decl></parameter>,
										   <parameter><decl><type><name>Oid</name></type> <name>partCollation</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* for agensgraph */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>makeVertexElements</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>makeEdgeElements</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>makeEdgeIndex</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isLabelKind</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>labkind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformLabelIdDefinition</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>col</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CommentStmt</name> <modifier>*</modifier></type><name>makeComment</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>prop_ref_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectType</name></type> <name>getLabelObjectType</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graphid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>figure_prop_index_colname_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>removeConstraintsFromColumnDefs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnDefs</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * transformCreateStmt -
 *	  parse analysis for CREATE TABLE
 *
 * Returns a List of utility commands to be done in sequence.  One of these
 * will be the transformed CreateStmt, but there may be additional actions
 * to be done before and after the actual DefineRelation() call.
 * In addition to normal utility commands such as AlterTableStmt and
 * IndexStmt, the result list may contain TableLikeClause(s), representing
 * the need to perform additional parse analysis after DefineRelation().
 *
 * SQL allows constraints to be scattered all over, so thumb through
 * the columns and collect all constraints into one place.
 * If there are any implied indices (e.g. UNIQUE or PRIMARY KEY)
 * then expand those into multiple IndexStmt blocks.
 *	  - thomas 1997-12-02
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformCreateStmt</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmtContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_alist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>existing_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_foreign_table</name> <init>= <expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must not scribble on the passed-in CreateStmt, so copy it.  (This is
	 * overkill, but easy.)
	 */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up pstate */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the creation namespace.  This also checks permissions on the
	 * target namespace, locks it against concurrent drops, checks for a
	 * preexisting relation in that namespace with the same name, and updates
	 * stmt-&gt;relation-&gt;relpersistence if the selected namespace is temporary.
	 */</comment>
	<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>,
									  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>namespaceid</name> <operator>=</operator>
		<call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>existing_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation already exists and the user specified "IF NOT EXISTS",
	 * bail out with a NOTICE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>existing_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are in an extension script, insist that the pre-existing
		 * object be a member of the extension, to avoid security risks.
		 */</comment>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>existing_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>checkMembershipInCurrentExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* OK to skip */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists, skipping"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the target relation name isn't schema-qualified, make it so.  This
	 * prevents some corner cases in which added-on rewritten commands might
	 * think they should apply to other relations that have the same name and
	 * are earlier in the search path.  But a local temp table is effectively
	 * specified to be in pg_temp, so no need for anything extra in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>==</operator> <name>NULL</name>
		<operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_graphname_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot create table in graph schema"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up CreateStmtContext */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"CREATE FOREIGN TABLE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isforeign</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"CREATE TABLE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isforeign</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>relation</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>inhRelations</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isalter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ckconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>fkconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ixconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>likeclauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>extstats</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ispartitioned</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>partbound</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ofType</name></name> <operator>=</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name> <operator>||</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* grammar enforces */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>transformOfType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create partitioned table as inheritance child"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Run through each primary element in the table creation clause. Separate
	 * column defs from constraints, and do preliminary analysis.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>elements</argument>, <argument>stmt-&gt;tableElts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>element</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_ColumnDef</name></expr>:</case>
				<expr_stmt><expr><call><name>transformColumnDefinition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_Constraint</name></expr>:</case>
				<expr_stmt><expr><call><name>transformTableConstraint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_TableLikeClause</name></expr>:</case>
				<expr_stmt><expr><call><name>transformTableLikeClause</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>TableLikeClause</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * Transfer anything we already have in cxt.alist into save_alist, to keep
	 * it separate from the output of transformIndexConstraints.  (This may
	 * not be necessary anymore, but we'll keep doing it to preserve the
	 * historical order of execution of the alist commands.)
	 */</comment>
	<expr_stmt><expr><name>save_alist</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>alist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Postprocess constraints that give rise to index definitions.
	 */</comment>
	<expr_stmt><expr><call><name>transformIndexConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-consideration of LIKE clauses should happen after creation of
	 * indexes, but before creation of foreign keys.  This order is critical
	 * because a LIKE clause may attempt to create a primary key.  If there's
	 * also a pkey in the main CREATE TABLE list, creation of that will not
	 * check for a duplicate at runtime (since index_check_primary_key()
	 * expects that we rejected dups here).  Creation of the LIKE-generated
	 * pkey behaves like ALTER TABLE ADD, so it will check, but obviously that
	 * only works if it happens second.  On the other hand, we want to make
	 * pkeys before foreign key constraints, in case the user tries to make a
	 * self-referential FK.
	 */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>likeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Postprocess foreign-key constraints.
	 */</comment>
	<expr_stmt><expr><call><name>transformFKConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Postprocess check constraints.
	 */</comment>
	<expr_stmt><expr><call><name>transformCheckConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>is_foreign_table</name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Postprocess extended statistics.
	 */</comment>
	<expr_stmt><expr><call><name>transformExtendedStatistics</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Output results.
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>columns</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>ckconstraints</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>save_alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generateSerialExtraStmts
 *		Generate CREATE SEQUENCE and ALTER SEQUENCE ... OWNED BY statements
 *		to create the sequence for a serial or identity column.
 *
 * This includes determining the name the sequence will have.  The caller
 * can ask to get back the name components by passing non-null pointers
 * for snamespace_p and sname_p.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generateSerialExtraStmts</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>seqtypid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>seqoptions</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>for_identity</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>col_exists</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>snamespace_p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sname_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>nameEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>snamespaceid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>snamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>seqstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>altseqstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnamelist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Determine namespace and name to use for the sequence.
	 *
	 * First, check if a sequence name was passed in as an option.  This is
	 * used by pg_dump.  Else, generate a name.
	 *
	 * Although we use ChooseRelationName, it's not guaranteed that the
	 * selected sequence name won't conflict; given sufficiently long field
	 * names, two different serial columns in the same table could be assigned
	 * the same sequence name, and we'd not notice since we aren't creating
	 * the sequence quite yet.  In practice this seems quite unlikely to be a
	 * problem, especially since few people would need two serial columns in
	 * one table.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>seqoptions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sequence_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nameEl</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nameEl</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>nameEl</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>nameEl</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>snamespace</name> <operator>=</operator> <name><name>rv</name><operator>-&gt;</operator><name>schemaname</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>snamespace</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Given unqualified SEQUENCE NAME, select namespace */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>snamespaceid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>snamespaceid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>snamespace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>snamespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>sname</name> <operator>=</operator> <name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr>;</expr_stmt>
		<comment type="block">/* Remove the SEQUENCE NAME item from seqoptions */</comment>
		<expr_stmt><expr><name>seqoptions</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>seqoptions</name></expr></argument>, <argument><expr><name>nameEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>snamespaceid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>snamespaceid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RangeVarAdjustRelationPersistence</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>snamespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>snamespace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>snamespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sname</name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
								   <argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>,
								   <argument><expr><literal type="string">"seq"</literal></expr></argument>,
								   <argument><expr><name>snamespaceid</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s will create implicit sequence \"%s\" for serial column \"%s.%s\""</literal></expr></argument>,
					<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>stmtType</name></name></expr></argument>, <argument><expr><name>sname</name></expr></argument>,
					<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a CREATE SEQUENCE command to create the sequence object, and add
	 * it to the list of things to be done before this CREATE/ALTER TABLE.
	 */</comment>
	<expr_stmt><expr><name>seqstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>for_identity</name></name> <operator>=</operator> <name>for_identity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>seqoptions</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a sequence data type was specified, add it to the options.  Prepend
	 * to the list rather than append; in case a user supplied their own AS
	 * clause, the "redundant options" error will point to their occurrence,
	 * not our synthetic one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>seqtypid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"as"</literal></expr></argument>,
											 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>seqtypid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this is ALTER ADD COLUMN, make sure the sequence will be owned by
	 * the table's owner.  The current user might be someone else (perhaps a
	 * superuser, or someone who's only a member of the owning role), but the
	 * SEQUENCE OWNED BY mechanisms will bleat unless table and sequence have
	 * exactly the same owning role.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>ownerId</name></name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>ownerId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>blist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>blist</name></name></expr></argument>, <argument><expr><name>seqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the identity sequence name that we decided on.  ALTER TABLE ...
	 * ADD COLUMN ... IDENTITY needs this so that it can fill the new column
	 * with values from the sequence, while the association of the sequence
	 * with the table is not set until after the ALTER TABLE.
	 */</comment>
	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>identitySequence</name></name> <operator>=</operator> <name><name>seqstmt</name><operator>-&gt;</operator><name>sequence</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build an ALTER SEQUENCE ... OWNED BY command to mark the sequence as
	 * owned by this column, and add it to the appropriate list of things to
	 * be done along with this CREATE/ALTER TABLE.  In a CREATE or ALTER ADD
	 * COLUMN, it must be done after the statement because we don't know the
	 * column's attnum yet.  But if we do have the attnum (in AT_AddIdentity),
	 * we can do the marking immediately, which improves some ALTER TABLE
	 * behaviors.
	 */</comment>
	<expr_stmt><expr><name>altseqstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnamelist</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"owned_by"</literal></expr></argument>,
												 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>attnamelist</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>for_identity</name></name> <operator>=</operator> <name>for_identity</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>col_exists</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>blist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>blist</name></name></expr></argument>, <argument><expr><name>altseqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>altseqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>snamespace_p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>snamespace_p</name> <operator>=</operator> <name>snamespace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sname_p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sname_p</name> <operator>=</operator> <name>sname</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformColumnDefinition -
 *		transform a single ColumnDef within CREATE TABLE
 *		Also used in ALTER TABLE ADD COLUMN
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformColumnDefinition</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_serial</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_nullable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_default</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_identity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_generated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>clist</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for SERIAL pseudo-types */</comment>
	<expr_stmt><expr><name>is_serial</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name></name>
		<operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
		<operator>&amp;&amp;</operator> <operator>!</operator><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>pct_type</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"smallserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"serial2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_serial</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>INT2OID</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"serial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"serial4"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_serial</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"bigserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"serial8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_serial</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We have to reject "serial[]" explicitly, because once we've set
		 * typeid, LookupTypeName won't notice arrayBounds.  We don't need any
		 * special coding for serial(typmod) though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_serial</name> <operator>&amp;&amp;</operator> <name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array of serial is not implemented"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
										<argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do necessary work on the column type declaration */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>transformColumnType</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Special actions for SERIAL pseudo-types */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_serial</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>snamespace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qstring</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>snamenode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>castnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>funccallnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>generateSerialExtraStmts</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>column</name></expr></argument>,
								 <argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>snamespace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create appropriate constraints for SERIAL.  We do this in full,
		 * rather than shortcutting, so that we will detect any conflicting
		 * constraints the user wrote (like a different DEFAULT).
		 *
		 * Create an expression tree representing the function call
		 * nextval('sequencename').  We cannot reduce the raw tree to cooked
		 * form until after the sequence is created, but there's no need to do
		 * so.
		 */</comment>
		<expr_stmt><expr><name>qstring</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snamenode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snamenode</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snamenode</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>qstring</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snamenode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>castnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castnode</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>SystemTypeName</name><argument_list>(<argument><expr><literal type="string">"regclass"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castnode</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>snamenode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>funccallnode</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"nextval"</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>castnode</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>funccallnode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>cooked_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>constraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_NOTNULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process column constraints, if any... */</comment>
	<expr_stmt><expr><call><name>transformConstraintAttrs</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>saw_nullable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saw_default</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saw_identity</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saw_generated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>clist</argument>, <argument>column-&gt;constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name>clist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_NULL</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>saw_nullable</name> <operator>&amp;&amp;</operator> <name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting NULL/NOT NULL declarations for column \"%s\" of table \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>saw_nullable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_NOTNULL</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>saw_nullable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting NULL/NOT NULL declarations for column \"%s\" of table \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>saw_nullable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_DEFAULT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>saw_default</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple default values specified for column \"%s\" of table \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>cooked_expr</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>saw_default</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_IDENTITY</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Type</name></type>		<name>ctype</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>ofType</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"identity columns are not supported on typed tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"identity columns are not supported on partitions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>ctype</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>saw_identity</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple identity specifications for column \"%s\" of table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
													<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>generateSerialExtraStmts</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>column</name></expr></argument>,
											 <argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>generated_when</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>saw_identity</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/* An identity column is implicitly NOT NULL */</comment>
					<if_stmt><if>if <condition>(<expr><name>saw_nullable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting NULL/NOT NULL declarations for column \"%s\" of table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
													<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>saw_nullable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>CONSTR_GENERATED</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>ofType</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"generated columns are not supported on typed tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"generated columns are not supported on partitions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>saw_generated</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple generation clauses specified for column \"%s\" of table \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>generated</name></name> <operator>=</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>cooked_expr</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>saw_generated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
				<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primary key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unique constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
				<comment type="block">/* grammar does not allow EXCLUDE as a column constraint */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column exclusion constraints are not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Fill in the current attribute's name and throw it into the
				 * list of FK constraints to be processed later.
				 */</comment>
				<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_attrs</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_ATTR_DEFERRABLE</name></expr>:</case>
			<case>case <expr><name>CONSTR_ATTR_NOT_DEFERRABLE</name></expr>:</case>
			<case>case <expr><name>CONSTR_ATTR_DEFERRED</name></expr>:</case>
			<case>case <expr><name>CONSTR_ATTR_IMMEDIATE</name></expr>:</case>
				<comment type="block">/* transformConstraintAttrs took care of these */</comment>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
					 <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>saw_default</name> <operator>&amp;&amp;</operator> <name>saw_identity</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"both default and identity specified for column \"%s\" of table \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
										<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>saw_default</name> <operator>&amp;&amp;</operator> <name>saw_generated</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"both default and generation expression specified for column \"%s\" of table \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
										<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>saw_identity</name> <operator>&amp;&amp;</operator> <name>saw_generated</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"both identity and generation expression specified for column \"%s\" of table \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
										<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If needed, generate ALTER FOREIGN TABLE ALTER COLUMN statement to add
	 * per-column foreign data wrapper options to this column after creation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>fdwoptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AlterColumnGenericOptions</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>column</name><operator>-&gt;</operator><name>fdwoptions</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name>DROP_RESTRICT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_FOREIGN_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformTableConstraint
 *		transform a Constraint node within CREATE TABLE or ALTER TABLE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformTableConstraint</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primary key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unique constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exclusion constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>ispartitioned</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exclusion constraints are not supported on partitioned tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_NULL</name></expr>:</case>
		<case>case <expr><name>CONSTR_NOTNULL</name></expr>:</case>
		<case>case <expr><name>CONSTR_DEFAULT</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_DEFERRABLE</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_NOT_DEFERRABLE</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_DEFERRED</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_IMMEDIATE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid context for constraint type %d"</literal></expr></argument>,
				 <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
				 <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * transformTableLikeClause
 *
 * Change the LIKE &lt;srctable&gt; portion of a CREATE TABLE statement into
 * column definitions that recreate the user defined column portions of
 * &lt;srctable&gt;.  Also, if there are any LIKE options that we can't fully
 * process at this point, add the TableLikeClause to cxt-&gt;likeclauses, which
 * will cause utility.c to call expandTableLikeClause() after the new
 * table has been created.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformTableLikeClause</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>TableLikeClause</name> <modifier>*</modifier></type><name>table_like_clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parent_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>comment</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
									  <argument><expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we could support LIKE in many cases, but worry about it another day */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LIKE is not supported for creating foreign tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Open the relation referenced by the LIKE clause */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, composite type, or foreign table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for privileges
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_TYPE</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert the copied attributes into the cxt for the new table definition.
	 * We must do this now so that they appear in the table in the relative
	 * position where the LIKE clause is, as required by SQL99.
	 */</comment>
	<for>for <control>(<init><expr><name>parent_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>parent_attno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition>
		 <incr><expr><name>parent_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
													<argument><expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore dropped columns in the parent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Create a new column, which is marked as NOT inherited.
		 *
		 * For constraints, ONLY the NOT NULL constraint is inherited by the
		 * new column definition per SQL99.
		 */</comment>
		<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add to column list
		 */</comment>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Although we don't transfer the column's default/generation
		 * expression now, we need to mark it GENERATED if appropriate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>&amp;&amp;</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_GENERATED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>generated</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Copy identity if requested
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_IDENTITY</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>seq_options</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * find sequence owned by old column; extract sequence parameters;
			 * build new create sequence command
			 */</comment>
			<expr_stmt><expr><name>seq_relid</name> <operator>=</operator> <call><name>getIdentitySequence</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>seq_options</name> <operator>=</operator> <call><name>sequence_options</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>generateSerialExtraStmts</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>def</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>seq_options</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attidentity</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Likewise, copy storage if requested */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_STORAGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Likewise, copy comment if requested */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_COMMENTS</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>comment</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>,
								  <argument><expr><name>RelationRelationId</name></expr></argument>,
								  <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CommentStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_COLUMN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <name>comment</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We cannot yet deal with defaults, CHECK constraints, or indexes, since
	 * we don't yet know what column numbers the copied columns will have in
	 * the finished table.  If any of those options are specified, add the
	 * LIKE clause to cxt-&gt;likeclauses so that expandTableLikeClause will be
	 * called after we do know that.  Also, remember the relation OID so that
	 * expandTableLikeClause is certain to open the same table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator>
		<operator>(</operator><name>CREATE_TABLE_LIKE_DEFAULTS</name> <operator>|</operator>
		 <name>CREATE_TABLE_LIKE_GENERATED</name> <operator>|</operator>
		 <name>CREATE_TABLE_LIKE_CONSTRAINTS</name> <operator>|</operator>
		 <name>CREATE_TABLE_LIKE_INDEXES</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>relationOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>likeclauses</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>likeclauses</name></name></expr></argument>, <argument><expr><name>table_like_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We may copy extended statistics if requested, since the representation
	 * of CreateStatsStmt doesn't depend on column numbers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_STATISTICS</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parent_extstats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_extstats</name> <operator>=</operator> <call><name>RelationGetStatExtList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parent_extstats</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>parent_stat_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CreateStatsStmt</name> <modifier>*</modifier></type><name>stats_stmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>stats_stmt</name> <operator>=</operator> <call><name>generateClonedExtStatsStmt</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
													<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><name>parent_stat_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Copy comment on statistics object, if requested */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_COMMENTS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>parent_stat_oid</name></expr></argument>, <argument><expr><name>StatisticExtRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We make use of CreateStatsStmt's stxcomment option, so as
				 * not to need to know now what name the statistics will have.
				 */</comment>
				<expr_stmt><expr><name><name>stats_stmt</name><operator>-&gt;</operator><name>stxcomment</name></name> <operator>=</operator> <name>comment</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>extstats</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>extstats</name></name></expr></argument>, <argument><expr><name>stats_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>parent_extstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Close the parent rel, but keep our AccessShareLock on it until xact
	 * commit.  That will prevent someone else from deleting or ALTERing the
	 * parent before we can run expandTableLikeClause.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * expandTableLikeClause
 *
 * Process LIKE options that require knowing the final column numbers
 * assigned to the new table's columns.  This executes after we have
 * run DefineRelation for the new table.  It returns a list of utility
 * commands that should be run to generate indexes etc.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>expandTableLikeClause</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>heapRel</name></decl></parameter>, <parameter><decl><type><name>TableLikeClause</name> <modifier>*</modifier></type><name>table_like_clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>atsubcmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parent_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrMap</name>    <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>comment</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Open the relation referenced by the LIKE clause.  We should still have
	 * the table lock obtained by transformTableLikeClause (and this'll throw
	 * an assertion failure if not).  Hence, no need to recheck privileges
	 * etc.  We must open the rel by OID not name, to be sure we get the same
	 * table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>relationOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expandTableLikeClause called on untransformed LIKE clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>relationOid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>constr</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the newly-created child relation; we have lock on that too.
	 */</comment>
	<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct a map from the LIKE relation's attnos to the child rel's.
	 * This re-checks type match etc, although it shouldn't be possible to
	 * have a failure since both tables are locked.
	 */</comment>
	<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>build_attrmap_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process defaults, if required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator>
		 <operator>(</operator><name>CREATE_TABLE_LIKE_DEFAULTS</name> <operator>|</operator> <name>CREATE_TABLE_LIKE_GENERATED</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>constr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name> <init>= <expr><name><name>constr</name><operator>-&gt;</operator><name>defval</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>parent_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>parent_attno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition>
			 <incr><expr><name>parent_attno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
														<argument><expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Ignore dropped columns in the parent.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Copy default, if present and it should be copied.  We have
			 * separate options for plain default expressions and GENERATED
			 * defaults.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><ternary><condition><expr><name><name>attribute</name><operator>-&gt;</operator><name>attgenerated</name></name></expr> ?</condition><then>
				 <expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_GENERATED</name><operator>)</operator></expr> </then><else>:
				 <expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_DEFAULTS</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>this_default</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>atsubcmd</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

				<comment type="block">/* Find default in constraint structure */</comment>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adnum</name> <operator>==</operator> <name>parent_attno</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>this_default</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>this_default</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>atsubcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>atsubcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_CookedColumnDefault</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>atsubcmd</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <name><name>attmap</name><operator>-&gt;</operator><name>attnums</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>atsubcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><name>this_default</name></expr></argument>,
													<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
													<argument><expr><name>attmap</name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Prevent this for the same reason as for constraints below.
				 * Note that defaults cannot contain any vars, so it's OK that
				 * the error message refers to generated columns.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Generation expression for column \"%s\" contains a whole-row reference to table \"%s\"."</literal></expr></argument>,
									   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>atsubcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>atsubcmds</name></expr></argument>, <argument><expr><name>atsubcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Copy CHECK constraints if requested, being careful to adjust attribute
	 * numbers so they match the child.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_CONSTRAINTS</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>constr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ccnum</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>ccnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ccnum</name> <operator>&lt;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr>;</condition> <incr><expr><name>ccnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccname</name> <init>= <expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>ccnum</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccbin</name> <init>= <expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>ccnum</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ccnoinherit</name> <init>= <expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>ccnum</name></expr>]</index></name><operator>.</operator><name>ccnoinherit</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ccbin_node</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>atsubcmd</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ccbin_node</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name>ccbin</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											 <argument><expr><name>attmap</name></expr></argument>,
											 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We reject whole-row variables because the whole point of LIKE
			 * is that the new table's rowtype might later diverge from the
			 * parent's.  So, while translation might be possible right now,
			 * it wouldn't be possible to guarantee it would work in future.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Constraint \"%s\" contains a whole-row reference to table \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>ccname</name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_CHECK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>ccname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_no_inherit</name></name> <operator>=</operator> <name>ccnoinherit</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cooked_expr</name></name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>ccbin_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We can skip validation, since the new table should be empty. */</comment>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>initially_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>atsubcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>atsubcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraint</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>atsubcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>atsubcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>atsubcmds</name></expr></argument>, <argument><expr><name>atsubcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Copy comment on constraint */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_COMMENTS</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>comment</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
																  <argument><expr><name><name>n</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>ConstraintRelationId</name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CommentStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TABCONSTRAINT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>heapRel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>heapRel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <name>comment</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we generated any ALTER TABLE actions above, wrap them into a single
	 * ALTER TABLE command.  Stick it at the front of the result, so it runs
	 * before any CommentStmts we made above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>atsubcmds</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>atcmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <name>atsubcmds</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>atcmd</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process indexes if required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_INDEXES</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parent_indexes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_indexes</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parent_indexes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>parent_index_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>parent_index</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>index_stmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>parent_index</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>parent_index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Build CREATE INDEX statement to recreate the parent_index */</comment>
			<expr_stmt><expr><name>index_stmt</name> <operator>=</operator> <call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>,
												 <argument><expr><name>parent_index</name></expr></argument>,
												 <argument><expr><name>attmap</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Copy comment on index, if requested */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_COMMENTS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>parent_index_oid</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We make use of IndexStmt's idxcomment option, so as not to
				 * need to know now what name the index will have.
				 */</comment>
				<expr_stmt><expr><name><name>index_stmt</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <name>comment</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>index_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>parent_index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Done with child rel */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close the parent rel, but keep our AccessShareLock on it until xact
	 * commit.  That will prevent someone else from deleting or ALTERing the
	 * parent before the child is committed.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformOfType</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ofTypeId</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>ofTypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ofTypename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_of_type</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ofTypeId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ofTypename</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>ofTypeId</name></expr>;</expr_stmt> <comment type="block">/* cached for later */</comment>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>ofTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generate an IndexStmt node using information from an already existing index
 * "source_idx".
 *
 * heapRel is stored into the IndexStmt's relation field, but we don't use it
 * otherwise; some callers pass NULL, if they don't need it to be valid.
 * (The target relation might not exist yet, so we mustn't try to access it.)
 *
 * Attribute numbers in expression Vars are adjusted according to attmap.
 *
 * If constraintOid isn't NULL, we store the OID of any constraint associated
 * with the index there.
 *
 * Unlike transformIndexConstraint, we don't make any effort to force primary
 * key columns to be NOT NULL.  The larger cloning process this is part of
 * should have cloned their NOT NULL status separately (and DefineIndex will
 * complain if that fails to happen).
 */</comment>
<function><type><name>IndexStmt</name> <modifier>*</modifier></type>
<name>generateClonedIndexStmt</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>heapRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>source_idx</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>AttrMap</name> <modifier>*</modifier></type><name>attmap</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>constraintOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>source_relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_idxrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_am</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>idxrelrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>idxrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_am</name></type>	<name>amrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>keycoltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>constraintOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>constraintOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch pg_class tuple of source index.  We can't use the copy in the
	 * relcache entry because it doesn't include optional fields.
	 */</comment>
	<expr_stmt><expr><name>ht_idxrel</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>source_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>source_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>idxrelrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch pg_index tuple for source index from relcache entry */</comment>
	<expr_stmt><expr><name>ht_idx</name> <operator>=</operator> <name><name>source_idx</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>idxrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indrelid</name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>

	<comment type="block">/* Fetch the pg_am tuple of the index' access method */</comment>
	<expr_stmt><expr><name>ht_am</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_am</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for access method %u"</literal></expr></argument>,
			 <argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>amrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_am</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract indcollation from the pg_index tuple */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
							<argument><expr><name>Anum_pg_index_indcollation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indcollation</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract indclass from the pg_index tuple */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
							<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Begin building the IndexStmt */</comment>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>heapRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>amrec</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tableSpace</name></name> <operator>=</operator> <call><name>get_tablespace_name</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tableSpace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>oldCreateSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>oldFirstRelfilenodeSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indisunique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>transformed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* don't need transformIndexStmt */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't try to preserve the name of the source index; instead, just
	 * let DefineIndex() choose a reasonable name.  (If we tried to preserve
	 * the name, we'd get duplicate-relation-name failures unless the source
	 * table was in a different schema.)
	 */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the index is marked PRIMARY or has an exclusion condition, it's
	 * certainly from a constraint; else, if it's not marked UNIQUE, it
	 * certainly isn't.  If it is or might be from a constraint, we have to
	 * fetch the pg_constraint record.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name> <operator>||</operator> <name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintId</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>source_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_constr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>conrec</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>constraintOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>constraintOid</name> <operator>=</operator> <name>constraintId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>ht_constr</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_constr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
					 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>conrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>conrec</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>conrec</name><operator>-&gt;</operator><name>condeferred</name></name></expr>;</expr_stmt>

			<comment type="block">/* If it's an exclusion constraint, we need the operator names */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>idxrec</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nElems</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conrec</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_EXCLUSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Extract operator OIDs from the pg_constraint tuple */</comment>
				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>ht_constr</name></expr></argument>,
										<argument><expr><name>Anum_pg_constraint_conexclop</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conexclop for constraint %u"</literal></expr></argument>,
						 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>elems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nElems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>operid</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>,
											  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>,
							 <argument><expr><name>operid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* For simplicity we always schema-qualify the op name */</comment>
					<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>namelist</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>,
													<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Get the index expressions, if any */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
							<argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprsString</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exprsString</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexprs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>indexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Build the list of IndexElem */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>indexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>iparam</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>idxrec</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>opt</name> <init>= <expr><name><name>source_idx</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>iparam</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple index column */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keycoltype</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>attname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Expressional index */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexprs</name></expr></argument>, <argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Adjust Vars to match new table's column numbering */</comment>
			<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>,
										   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>attmap</name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* As in expandTableLikeClause, reject whole-row variables */</comment>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" contains a whole-row table reference."</literal></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>indexkey</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>keycoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Copy the original index column name */</comment>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the collation name, if non-default */</comment>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>get_collation</name><argument_list>(<argument><expr><name><name>indcollation</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><name>keycoltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the operator class name, if non-default */</comment>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <call><name>get_opclass</name><argument_list>(<argument><expr><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><name>keycoltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>opclassopts</name></name> <operator>=</operator>
			<call><name>untransformRelOptions</name><argument_list>(<argument><expr><call><name>get_attoptions</name><argument_list>(<argument><expr><name>source_relid</name></expr></argument>, <argument><expr><name>keyno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>ordering</name></name> <operator>=</operator> <name>SORTBY_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>=</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>;</expr_stmt>

		<comment type="block">/* Adjust options if necessary */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>source_idx</name><operator>-&gt;</operator><name>rd_indam</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If it supports sort ordering, copy DESC and NULLS opts. Don't
			 * set non-default settings unnecessarily, though, so as to
			 * improve the chance of recognizing equivalence to constraint
			 * indexes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_DESC</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>ordering</name></name> <operator>=</operator> <name>SORTBY_DESC</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>=</operator> <name>SORTBY_NULLS_LAST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>=</operator> <name>SORTBY_NULLS_FIRST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name>iparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Handle included columns separately */</comment>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>iparam</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>idxrec</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>iparam</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple index column */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keycoltype</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>attname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expressions are not supported in included columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Copy the original index column name */</comment>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>, <argument><expr><name>iparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Copy reloptions if any */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>ht_idxrel</name></expr></argument>,
							<argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If it's a partial index, decompile and append the predicate */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
							<argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pred_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>pred_tree</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

		<comment type="block">/* Convert text string to node tree */</comment>
		<expr_stmt><expr><name>pred_str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pred_tree</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>pred_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Adjust Vars to match new table's column numbering */</comment>
		<expr_stmt><expr><name>pred_tree</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><name>pred_tree</name></expr></argument>,
										<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>attmap</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* As in expandTableLikeClause, reject whole-row variables */</comment>
		<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" contains a whole-row table reference."</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <name>pred_tree</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_am</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a CreateStatsStmt node using information from an already existing
 * extended statistic "source_statsid", for the rel identified by heapRel and
 * heapRelid.
 */</comment>
<function><type><specifier>static</specifier> <name>CreateStatsStmt</name> <modifier>*</modifier></type>
<name>generateClonedExtStatsStmt</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>heapRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>heapRelid</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>source_statsid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_statistic_ext</name></type> <name>statsrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStatsStmt</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stat_types</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>def_names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>enabled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>heapRel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch pg_statistic_ext tuple of source statistics object.
	 */</comment>
	<expr_stmt><expr><name>ht_stats</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>source_statsid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_stats</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for statistics object %u"</literal></expr></argument>, <argument><expr><name>source_statsid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>statsrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic_ext</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine which statistics types exist */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><name>ht_stats</name></expr></argument>,
							<argument><expr><name>Anum_pg_statistic_ext_stxkind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CHAROID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stxkind is not a 1-D char array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>enabled</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>STATS_EXT_NDISTINCT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stat_types</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stat_types</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ndistinct"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>STATS_EXT_DEPENDENCIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stat_types</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stat_types</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"dependencies"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>STATS_EXT_MCV</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stat_types</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stat_types</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"mcv"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized statistics kind %c"</literal></expr></argument>, <argument><expr><name><name>enabled</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Determine which columns the statistics are on */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>statsrec</name><operator>-&gt;</operator><name>stxkeys</name><operator>.</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>statsrec</name><operator>-&gt;</operator><name>stxkeys</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name>heapRelid</name></expr></argument>,
														 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>def_names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>def_names</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* finally, build the output node */</comment>
	<expr_stmt><expr><name>stats</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStatsStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>defnames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stat_types</name></name> <operator>=</operator> <name>stat_types</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <name>def_names</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>relations</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stxcomment</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_collation		- fetch qualified name of a collation
 *
 * If collation is InvalidOid or is the default for the given actual_datatype,
 * then the return value is NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_collation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_coll</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>coll_rec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nsp_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>coll_name</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* easy case */</comment>
	<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>actual_datatype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* just let it default */</comment>

	<expr_stmt><expr><name>ht_coll</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_coll</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>coll_rec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For simplicity, we always schema-qualify the name */</comment>
	<expr_stmt><expr><name>nsp_name</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>coll_rec</name><operator>-&gt;</operator><name>collnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>coll_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>coll_rec</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>nsp_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>coll_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_opclass			- fetch qualified name of an index operator class
 *
 * If the opclass is the default for the given actual_datatype, then
 * the return value is NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_opclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_opc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opc_rec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ht_opc</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opc_rec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>actual_datatype</name></expr></argument>, <argument><expr><name><name>opc_rec</name><operator>-&gt;</operator><name>opcmethod</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>opclass</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* For simplicity, we always schema-qualify the name */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nsp_name</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>opc_rec</name><operator>-&gt;</operator><name>opcnamespace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opc_name</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opc_rec</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>nsp_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>opc_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformIndexConstraints
 *		Handle UNIQUE, PRIMARY KEY, EXCLUDE constraints, which create indexes.
 *		We also merge in any index definitions arising from
 *		LIKE ... INCLUDING INDEXES.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformIndexConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>finalindexlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Run through the constraints that need to generate an index. For PRIMARY
	 * KEY, mark each column as NOT NULL and create an index. For UNIQUE or
	 * EXCLUDE, create an index as for PRIMARY KEY, but do not insist on NOT
	 * NULL.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cxt-&gt;ixconstraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name> <operator>||</operator>
			   <name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_UNIQUE</name> <operator>||</operator>
			   <name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_EXCLUSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>transformIndexConstraint</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Scan the index list and remove any redundant index specifications. This
	 * can happen if, for instance, the user writes UNIQUE PRIMARY KEY. A
	 * strict reading of SQL would suggest raising an error instead, but that
	 * strikes me as too anal-retentive. - tgl 2001-02-14
	 *
	 * XXX in ALTER TABLE case, it'd be nice to look for duplicate
	 * pre-existing indexes, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make sure we keep the PKEY index in preference to others... */</comment>
		<expr_stmt><expr><name>finalindexlist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>keep</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if it's pkey, it's already in finalindexlist */</comment>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>k</argument>, <argument>finalindexlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>priorindex</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>index</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>==</operator> <name><name>priorindex</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>&amp;&amp;</operator>
				<name><name>index</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>==</operator> <name><name>priorindex</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>priorindex</name><operator>-&gt;</operator><name>unique</name></name> <operator>|=</operator> <name><name>index</name><operator>-&gt;</operator><name>unique</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the prior index is as yet unnamed, and this one is
				 * named, then transfer the name to the prior index. This
				 * ensures that if we have named and unnamed constraints,
				 * we'll use (at least one of) the names for the index.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>priorindex</name><operator>-&gt;</operator><name>idxname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>priorindex</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>idxname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>keep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>keep</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>finalindexlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>finalindexlist</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now append all the IndexStmts to cxt-&gt;alist.  If we generated an ALTER
	 * TABLE SET NOT NULL statement to support a primary key, it's already in
	 * cxt-&gt;alist.
	 */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>finalindexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformIndexConstraint
 *		Transform one UNIQUE, PRIMARY KEY, or EXCLUDE constraint for
 *		transformIndexConstraints.
 *
 * We return an IndexStmt.  For a PRIMARY KEY constraint, we additionally
 * produce NOT NULL constraints, either by marking ColumnDefs in cxt-&gt;columns
 * as is_not_null or by adding an ALTER TABLE SET NOT NULL command to
 * cxt-&gt;alist.
 */</comment>
<function><type><specifier>static</specifier> <name>IndexStmt</name> <modifier>*</modifier></type>
<name>transformIndexConstraint</name><parameter_list>(<parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>, <parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>notnullcmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTR_EXCLUSION</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name> <operator>=</operator> <operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple primary keys for table \"%s\" are not allowed"</literal></expr></argument>,
							<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In ALTER TABLE case, a primary index might already exist, but
		 * DefineIndex will check for it.
		 */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* DefineIndex will choose name */</comment>

	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <ternary><condition><expr><name><name>constraint</name><operator>-&gt;</operator><name>access_method</name></name></expr> ?</condition><then> <expr><name><name>constraint</name><operator>-&gt;</operator><name>access_method</name></name></expr> </then><else>: <expr><name>DEFAULT_INDEX_TYPE</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tableSpace</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>indexspace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>where_clause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>oldCreateSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>oldFirstRelfilenodeSubid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>transformed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's ALTER TABLE ADD CONSTRAINT USING INDEX, look up the index and
	 * verify it's usable, then extract the implied column name list.  (We
	 * will not actually need the column name list at runtime, but we need it
	 * now to check for duplicate column entries below.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>indexname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>index_name</name> <init>= <expr><name><name>constraint</name><operator>-&gt;</operator><name>indexname</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>heap_rel</name> <init>= <expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>index_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>index_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index_form</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Grammar should not allow this with explicit column list */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Grammar should only allow PRIMARY and UNIQUE constraints */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name> <operator>||</operator>
			   <name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_UNIQUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Must be ALTER, not CREATE, but grammar doesn't enforce that */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cxt</name><operator>-&gt;</operator><name>isalter</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use an existing index in CREATE TABLE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Look for the index in the same schema as the table */</comment>
		<expr_stmt><expr><name>index_oid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>index_name</name></expr></argument>, <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>heap_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Open the index (this will throw an error if it is not an index) */</comment>
		<expr_stmt><expr><name>index_rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index_form</name> <operator>=</operator> <name><name>index_rel</name><operator>-&gt;</operator><name>rd_index</name></name></expr>;</expr_stmt>

		<comment type="block">/* Check that it does not have an associated constraint already */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is already associated with a constraint"</literal></expr></argument>,
							<argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Perform validity checks on the index */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index_form</name><operator>-&gt;</operator><name>indrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heap_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not belong to table \"%s\""</literal></expr></argument>,
							<argument><expr><name>index_name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heap_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index_form</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not valid"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index_form</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a unique index"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a primary key or unique constraint using such an index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains expressions"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a primary key or unique constraint using such an index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a partial index"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a primary key or unique constraint using such an index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * It's probably unsafe to change a deferred index to non-deferred. (A
		 * non-constraint index couldn't be deferred anyway, so this case
		 * should never occur; no need to sweat, but let's check it.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index_form</name><operator>-&gt;</operator><name>indimmediate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>constraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a deferrable index"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a non-deferrable constraint using a deferrable index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Insist on it being a btree.  That's the only kind that supports
		 * uniqueness at the moment anyway; but we must have an index that
		 * exactly matches what you'd get from plain ADD CONSTRAINT syntax,
		 * else dump and reload will produce a different index (breaking
		 * pg_upgrade in particular).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <call><name>get_index_am_oid</name><argument_list>(<argument><expr><name>DEFAULT_INDEX_TYPE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not a btree"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Must get indclass the hard way */</comment>
		<expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name><name>index_rel</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
										<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index_form</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int16</name></type>		<name>attnum</name> <init>= <expr><name><name>index_form</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attform</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>defopclass</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We shouldn't see attnum == 0 here, since we already rejected
			 * expression indexes.  If we do, SystemAttributeDefinition will
			 * throw an error.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>heap_rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attform</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>heap_rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>attform</name> <operator>=</operator> <call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attform</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>index_form</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Insist on default opclass, collation, and sort options.
				 * While the index would still work as a constraint with
				 * non-default settings, it might not provide exactly the same
				 * uniqueness semantics as you'd get from a normally-created
				 * constraint; and there's also the dump/reload problem
				 * mentioned above.
				 */</comment>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>attoptions</name> <init>=
				<expr><call><name>get_attoptions</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>defopclass</name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											   <argument><expr><name><name>index_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>defopclass</name> <operator>||</operator>
					<name><name>attform</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name><name>index_rel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
					<name>attoptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal> <operator>||</operator>
					<name><name>index_rel</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" column number %d does not have default sorting behavior"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a primary key or unique constraint using such an index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>including</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>including</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Close the index relation but keep the lock */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexOid</name></name> <operator>=</operator> <name>index_oid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's an EXCLUDE constraint, the grammar returns a list of pairs of
	 * IndexElems and operator names.  We have to break that apart into
	 * separate lists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_EXCLUSION</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraint-&gt;exclusions</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opname</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>lsecond_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>

	<comment type="block">/*
	 * For UNIQUE and PRIMARY KEY, we just have a list of column names.
	 *
	 * Make sure referenced keys exist.  If we are making a PRIMARY KEY index,
	 * also make sure they are NOT NULL.
	 */</comment>
	<else>else
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraint-&gt;keys</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>forced_not_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>iparam</name></decl>;</decl_stmt>

			<comment type="block">/* Make sure referenced column exists. */</comment>
			<macro><name>foreach</name><argument_list>(<argument>columns</argument>, <argument>cxt-&gt;columns</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * column is defined in the new table.  For PRIMARY KEY, we
				 * can apply the NOT NULL constraint cheaply here ... unless
				 * the column is marked is_from_type, in which case marking it
				 * here would be ineffective (see MergeAttributes).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name><name>column</name><operator>-&gt;</operator><name>is_from_type</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>forced_not_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>SystemAttributeByName</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * column will be a system column in the new table, so accept
				 * it. System columns can't ever be null, so no need to worry
				 * about PRIMARY/NOT NULL constraint.
				 */</comment>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* try inherited tables */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>inher</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>inher</argument>, <argument>cxt-&gt;inhRelations</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>inh</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>inher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name>inh</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* check user requested inheritance from valid relkind */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
						<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
						<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited relation \"%s\" is not a table or foreign table"</literal></expr></argument>,
										<argument><expr><name><name>inh</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>inhattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
																  <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inhname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>inhattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>inhattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>inhname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

							<comment type="block">/*
							 * It's tempting to set forced_not_null if the
							 * parent column is already NOT NULL, but that
							 * seems unsafe because the column's NOT NULL
							 * marking might disappear between now and
							 * execution.  Do the runtime check to be safe.
							 */</comment>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * In the ALTER TABLE case, don't complain about index keys not
			 * created in the command; they may well exist already.
			 * DefineIndex will complain about them if not.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cxt</name><operator>-&gt;</operator><name>isalter</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" named in key does not exist"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Check for PRIMARY KEY(foo, foo) */</comment>
			<macro><name>foreach</name><argument_list>(<argument>columns</argument>, <argument>index-&gt;indexParams</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>iparam</name> <operator>=</operator> <operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" appears twice in primary key constraint"</literal></expr></argument>,
										<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" appears twice in unique constraint"</literal></expr></argument>,
										<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* OK, add it to the index definition */</comment>
			<expr_stmt><expr><name>iparam</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>opclassopts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>ordering</name></name> <operator>=</operator> <name>SORTBY_DEFAULT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>=</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name>iparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * For a primary-key column, also create an item for ALTER TABLE
			 * SET NOT NULL if we couldn't ensure it via is_not_null above.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forced_not_null</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>notnullcmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>notnullcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_SetNotNull</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>notnullcmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>notnullcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>notnullcmds</name></expr></argument>, <argument><expr><name>notnullcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Add included columns to index definition.  This is much like the
	 * simple-column-name-list code above, except that we don't worry about
	 * NOT NULL marking; included columns in a primary key should not be
	 * forced NOT NULL.  We don't complain about duplicate columns, either,
	 * though maybe we should?
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraint-&gt;including</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>iparam</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>columns</argument>, <argument>cxt-&gt;columns</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>SystemAttributeByName</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * column will be a system column in the new table, so accept
				 * it.
				 */</comment>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* try inherited tables */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>inher</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>inher</argument>, <argument>cxt-&gt;inhRelations</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>inh</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>, <argument><expr><name>inher</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name>inh</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* check user requested inheritance from valid relkind */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
						<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
						<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited relation \"%s\" is not a table or foreign table"</literal></expr></argument>,
										<argument><expr><name><name>inh</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>inhattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
																  <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inhname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>inhattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>inhattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>inhname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In the ALTER TABLE case, don't complain about index keys not
		 * created in the command; they may well exist already. DefineIndex
		 * will complain about them if not.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cxt</name><operator>-&gt;</operator><name>isalter</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" named in key does not exist"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK, add it to the index definition */</comment>
		<expr_stmt><expr><name>iparam</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>opclassopts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>, <argument><expr><name>iparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we found anything that requires run-time SET NOT NULL, build a full
	 * ALTER TABLE command for that and add it to cxt-&gt;alist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>notnullcmds</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <name>notnullcmds</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>alterstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformExtendedStatistics
 *     Handle extended statistic objects
 *
 * Right now, there's nothing to do here, so we just append the list to
 * the existing "after" list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformExtendedStatistics</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>extstats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformCheckConstraints
 *		handle CHECK constraints
 *
 * Right now, there's nothing to do here when called from ALTER TABLE,
 * but the other constraint-transformation functions are called in both
 * the CREATE TABLE and ALTER TABLE paths, so do the same here, and just
 * don't do anything if we're not authorized to skip validation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformCheckConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipValidation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ckclist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If creating a new table (but not a foreign table), we can safely skip
	 * validation of check constraints, and nonetheless mark them valid. (This
	 * will override any user-supplied NOT VALID flag.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>skipValidation</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>ckclist</argument>, <argument>cxt-&gt;ckconstraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ckclist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>initially_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformFKConstraints
 *		handle FOREIGN KEY constraints
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformFKConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>skipValidation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isAddConstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>fkclist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If CREATE TABLE or adding a column with NULL default, we can safely
	 * skip validation of FK constraints, and nonetheless mark them valid.
	 * (This will override any user-supplied NOT VALID flag.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>skipValidation</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>fkclist</argument>, <argument>cxt-&gt;fkconstraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fkclist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>initially_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For CREATE TABLE or ALTER TABLE ADD COLUMN, gin up an ALTER TABLE ADD
	 * CONSTRAINT command to execute after the basic command is complete. (If
	 * called from ADD CONSTRAINT, that routine will add the FK constraints to
	 * its own subcommand list.)
	 *
	 * Note: the ADD CONSTRAINT command must also execute after any index
	 * creation commands.  Thus, this should run after
	 * transformIndexConstraints, so that the CREATE INDEX commands are
	 * already in cxt-&gt;alist.  See also the handling of cxt-&gt;likeclauses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isAddConstraint</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>fkclist</argument>, <argument>cxt-&gt;fkconstraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fkclist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>altercmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>altercmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraint</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>altercmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>altercmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>constraint</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>, <argument><expr><name>altercmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>alterstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformIndexStmt - parse analysis for CREATE INDEX and ALTER TABLE
 *
 * Note: this is a no-op for an index not using either index expressions or
 * a predicate expression.  There are several code paths that create indexes
 * without bothering to call this, because they know they don't have any
 * such expressions to deal with.
 *
 * To avoid race conditions, it's important that this function rely only on
 * the passed-in relid (and not on stmt-&gt;relation) to determine the target
 * relation.
 */</comment>
<function><type><name>IndexStmt</name> <modifier>*</modifier></type>
<name>transformIndexStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if statement already transformed. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>transformed</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>stmt</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must not scribble on the passed-in IndexStmt, so copy it.  (This is
	 * overkill, but easy.)
	 */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up pstate */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Put the parent table into the rtable so that the expressions can refer
	 * to its fields without qualification.  Caller is responsible for locking
	 * relation, but we still need to open it.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										   <argument><expr><name>AccessShareLock</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no to join list, yes to namespaces */</comment>
	<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* take care of the where clause */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
												 <argument><expr><name>EXPR_KIND_INDEX_PREDICATE</name></expr></argument>,
												 <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we have to fix its collations too */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* take care of any index expressions */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;indexParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>ielem</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Extract preliminary index col name before transforming expr */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ielem</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <call><name>FigureIndexColname</name><argument_list>(<argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Now do parse transformation of the expression */</comment>
			<expr_stmt><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										<argument><expr><name>EXPR_KIND_INDEX_EXPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We have to fix its collations too */</comment>
			<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * transformExpr() should have already rejected subqueries,
			 * aggregates, window functions, and SRFs, based on the EXPR_KIND_
			 * for an index expression.
			 *
			 * DefineIndex() will make more checks.
			 */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Check that only the base rel is mentioned.  (This should be dead code
	 * now that add_missing_from is history.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index expressions and predicates can refer only to the table being indexed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close relation */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark statement as successfully transformed */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>transformed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>stmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformRuleStmt -
 *	  transform a CREATE RULE Statement. The action is a list of parse
 *	  trees which is transformed into a list of query trees, and we also
 *	  transform the WHERE clause if any.
 *
 * actions and whereClause are output parameters that receive the
 * transformed results.
 *
 * Note that we must not scribble on the passed-in RuleStmt, so we do
 * copyObject() on the actions and WHERE clause.
 */</comment>
<function><type><name>void</name></type>
<name>transformRuleStmt</name><parameter_list>(<parameter><decl><type><name>RuleStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>actions</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>whereClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>oldnsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>newnsitem</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To avoid deadlock, make sure the first thing we do is grab
	 * AccessExclusiveLock on the target relation.  This will be needed by
	 * DefineQueryRewrite(), and we don't want to grab a lesser lock
	 * beforehand.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_relid_laboid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot create rule on graph label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rules on materialized views are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up pstate */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * NOTE: 'OLD' must always have a varno equal to 1 and 'NEW' equal to 2.
	 * Set up their ParseNamespaceItems in the main pstate for use in parsing
	 * the rule qualification.
	 */</comment>
	<expr_stmt><expr><name>oldnsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
											  <argument><expr><name>AccessShareLock</name></expr></argument>,
											  <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newnsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
											  <argument><expr><name>AccessShareLock</name></expr></argument>,
											  <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Must override addRangeTableEntry's default access-check flags */</comment>
	<expr_stmt><expr><name><name>oldnsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newnsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * They must be in the namespace too for lookup purposes, but only add the
	 * one(s) that are relevant for the current kind of rule.  In an UPDATE
	 * rule, quals must refer to OLD.field or NEW.field to be unambiguous, but
	 * there's no need to be so picky for INSERT &amp; DELETE.  We do not add them
	 * to the joinlist.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>event</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>
			<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>oldnsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>oldnsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newnsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newnsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>oldnsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized event type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* take care of the where clause */</comment>
	<expr_stmt><expr><operator>*</operator><name>whereClause</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>,
										<argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we have to fix its collations too */</comment>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>*</operator><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this is probably dead code without add_missing_from: */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* naughty, naughty... */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rule WHERE condition cannot contain references to other relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 'instead nothing' rules with a qualification need a query rangetable so
	 * the rewrite handler can add the negated rule qualification to the
	 * original query. We create a query with the new command type CMD_NOTHING
	 * here that is treated specially by the rewrite system.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>actions</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>nothing_qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>nothing_qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_NOTHING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nothing_qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nothing_qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no join wanted */</comment>

		<expr_stmt><expr><operator>*</operator><name>actions</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>nothing_qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newactions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * transform each statement, like parse_sub_analyze()
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;actions</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>action</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>sub_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>sub_qry</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>top_subqry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>has_old</name></decl>,
						<decl><type ref="prev"/><name>has_new</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Since outer ParseState isn't parent of inner, have to pass down
			 * the query text by hand.
			 */</comment>
			<expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Set up OLD/NEW in the rtable for this statement.  The entries
			 * are added only to relnamespace, not varnamespace, because we
			 * don't want them to be referred to by unqualified field names
			 * nor "*" in the rule actions.  We decide later whether to put
			 * them in the joinlist.
			 */</comment>
			<expr_stmt><expr><name>oldnsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													  <argument><expr><name>AccessShareLock</name></expr></argument>,
													  <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newnsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
													  <argument><expr><name>AccessShareLock</name></expr></argument>,
													  <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oldnsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newnsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name>oldnsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name>newnsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Transform the rule action statement */</comment>
			<expr_stmt><expr><name>top_subqry</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We cannot support utility-statement actions (eg NOTIFY) with
			 * nonempty rule WHERE conditions, because there's no way to make
			 * the utility action execute conditionally.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>top_subqry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
				<operator>*</operator><name>whereClause</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rules with WHERE conditions can only have SELECT, INSERT, UPDATE, or DELETE actions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If the action is INSERT...SELECT, OLD/NEW have been pushed down
			 * into the SELECT, and that's what we need to look at. (Ugly
			 * kluge ... try to fix this when we redesign querytrees.)
			 */</comment>
			<expr_stmt><expr><name>sub_qry</name> <operator>=</operator> <call><name>getInsertSelectQuery</name><argument_list>(<argument><expr><name>top_subqry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the sub_qry is a setop, we cannot attach any qualifications
			 * to it, because the planner won't notice them.  This could
			 * perhaps be relaxed someday, but for now, we may as well reject
			 * such a rule immediately.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sub_qry</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>whereClause</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional UNION/INTERSECT/EXCEPT statements are not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Validate action's use of OLD/NEW, qual too
			 */</comment>
			<expr_stmt><expr><name>has_old</name> <operator>=</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub_qry</name></expr></argument>, <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>*</operator><name>whereClause</name></expr></argument>, <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>has_new</name> <operator>=</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub_qry</name></expr></argument>, <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>*</operator><name>whereClause</name></expr></argument>, <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>event</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_SELECT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>has_old</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON SELECT rule cannot use OLD"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>has_new</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON SELECT rule cannot use NEW"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<comment type="block">/* both are OK */</comment>
					<break>break;</break>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>has_old</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON INSERT rule cannot use OLD"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_DELETE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>has_new</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON DELETE rule cannot use NEW"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized event type: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<comment type="block">/*
			 * OLD/NEW are not allowed in WITH queries, because they would
			 * amount to outer references for the WITH, which we disallow.
			 * However, they were already in the outer rangetable when we
			 * analyzed the query, so we have to check.
			 *
			 * Note that in the INSERT...SELECT case, we need to examine the
			 * CTE lists of both top_subqry and sub_qry.
			 *
			 * Note that we aren't digging into the body of the query looking
			 * for WITHs in nested sub-SELECTs.  A WITH down there can
			 * legitimately refer to OLD/NEW, because it'd be an
			 * indirect-correlated outer reference.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>top_subqry</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>,
									 <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sub_qry</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>,
									 <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot refer to OLD within WITH query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>top_subqry</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>,
									 <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sub_qry</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>,
									 <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot refer to NEW within WITH query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * For efficiency's sake, add OLD to the rule action's jointree
			 * only if it was actually referenced in the statement or qual.
			 *
			 * For INSERT, NEW is not really a relation (only a reference to
			 * the to-be-inserted tuple) and should never be added to the
			 * jointree.
			 *
			 * For UPDATE, we treat NEW as being another kind of reference to
			 * OLD, because it represents references to *transformed* tuples
			 * of the existing relation.  It would be wrong to enter NEW
			 * separately in the jointree, since that would cause a double
			 * join of the updated relation.  It's also wrong to fail to make
			 * a jointree entry if only NEW and not OLD is mentioned.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>has_old</name> <operator>||</operator> <operator>(</operator><name>has_new</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>event</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If sub_qry is a setop, manipulating its jointree will do no
				 * good at all, because the jointree is dummy. (This should be
				 * a can't-happen case because of prior tests.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>sub_qry</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional UNION/INTERSECT/EXCEPT statements are not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* hackishly add OLD to the already-built FROM clause */</comment>
				<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name><name>oldnsitem</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub_qry</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator>
					<call><name>lappend</name><argument_list>(<argument><expr><name><name>sub_qry</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>, <argument><expr><name>rtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>newactions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newactions</name></expr></argument>, <argument><expr><name>top_subqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><operator>*</operator><name>actions</name> <operator>=</operator> <name>newactions</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close relation, but keep the exclusive lock */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * transformAlterTableStmt -
 *		parse analysis for ALTER TABLE
 *
 * Returns the transformed AlterTableStmt.  There may be additional actions
 * to be done before and after the transformed statement, which are returned
 * in *beforeStmts and *afterStmts as lists of utility command parsetrees.
 *
 * To avoid race conditions, it's important that this function rely only on
 * the passed-in relid (and not on stmt-&gt;relation) to determine the target
 * relation.
 */</comment>
<function><type><name>AlterTableStmt</name> <modifier>*</modifier></type>
<name>transformAlterTableStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>beforeStmts</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>afterStmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmtContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_alist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipValidation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_relid_laboid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only superuser can ALTER TABLE on graph label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must not scribble on the passed-in AlterTableStmt, so copy it. (This
	 * is overkill, but easy.)
	 */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Caller is responsible for locking the relation */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up pstate */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										   <argument><expr><name>rel</name></expr></argument>,
										   <argument><expr><name>AccessShareLock</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up CreateStmtContext */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"ALTER FOREIGN TABLE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isforeign</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"ALTER TABLE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isforeign</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>relation</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isalter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ckconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>fkconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ixconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>likeclauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>extstats</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ispartitioned</name></name> <operator>=</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>partbound</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ofType</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transform ALTER subcommands that need it (most don't).  These largely
	 * re-use code from CREATE TABLE.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_AddColumn</name></expr>:</case>
			<case>case <expr><name>AT_AddColumnRecurse</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>transformColumnDefinition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If the column has a non-null default, we can't skip
					 * validation of foreign keys.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>skipValidation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * All constraints are processed in other ways. Remove the
					 * original list
					 */</comment>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>AT_AddConstraint</name></expr>:</case>
			<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>

				<comment type="block">/*
				 * The original AddConstraint cmd node doesn't go to newcmds
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>transformTableConstraint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>contype</name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>skipValidation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * For ALTER COLUMN TYPE, transform the USING clause if
					 * one was specified.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator>
							<call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_ALTER_COL_TRANSFORM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * For identity column, create ALTER SEQUENCE command to
					 * change the data type of the sequence.
					 */</comment>
					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
										<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
						<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attidentity</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name> <init>= <expr><call><name>getIdentitySequence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name> <init>= <expr><call><name>typenameTypeId</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>altseqstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"as"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>for_identity</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name></expr></argument>, <argument><expr><name>altseqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>newdef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>newdef</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newdef</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>generated_when</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newdef</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
										<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>generateSerialExtraStmts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>newdef</name></expr></argument>,
											 <argument><expr><call><name>get_atttype</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>def</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/*
					 * Create an ALTER SEQUENCE statement for the internal
					 * sequence of the identity column.
					 */</comment>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newseqopts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newdef</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Split options into those handled by ALTER SEQUENCE and
					 * those for ALTER TABLE proper.
					 */</comment>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>castNode(List, cmd-&gt;def)</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"generated"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>newdef</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newdef</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>newseqopts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newseqopts</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block>

					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
										<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>seq_relid</name> <operator>=</operator> <call><name>getIdentitySequence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>seq_relid</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>seqstmt</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>seqstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>newseqopts</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>for_identity</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name></expr></argument>, <argument><expr><name>seqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If column was not an identity column, we just let the
					 * ALTER TABLE command error out later.  (There are cases
					 * this fails to cover, but we'll need to restructure
					 * where creation of the sequence dependency linkage
					 * happens before we can fix it.)
					 */</comment>

					<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newdef</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partcmd</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>transformPartitionCmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>partcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* assign transformed value of the partition bound */</comment>
					<expr_stmt><expr><name><name>partcmd</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>partbound</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>

				<comment type="block">/*
				 * Currently, we shouldn't actually get here for subcommand
				 * types that don't require transformation; but if we do, just
				 * emit them unchanged.
				 */</comment>
				<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * Transfer anything we already have in cxt.alist into save_alist, to keep
	 * it separate from the output of transformIndexConstraints.
	 */</comment>
	<expr_stmt><expr><name>save_alist</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>alist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Postprocess constraints */</comment>
	<expr_stmt><expr><call><name>transformIndexConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>transformFKConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>skipValidation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>transformCheckConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Push any index-creation commands into the ALTER, so that they can be
	 * scheduled nicely by tablecmds.c.  Note that tablecmds.c assumes that
	 * the IndexStmt attached to an AT_AddIndex or AT_AddIndexConstraint
	 * subcommand has already been through transformIndexStmt.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>cxt.alist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>istmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We assume here that cxt.alist contains only IndexStmts and possibly
		 * ALTER TABLE SET NOT NULL statements generated from primary key
		 * constraints.  We absorb the subcommands of the latter directly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>idxstmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>istmt</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>idxstmt</name> <operator>=</operator> <call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>idxstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>indexOid</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>AT_AddIndexConstraint</name></expr> </then><else>: <expr><name>AT_AddIndex</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>idxstmt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterstmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>istmt</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected stmt type %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Append any CHECK or FK constraints to the commands list */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>cxt.ckconstraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraint</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>cxt.fkconstraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraint</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Append extended statistic objects */</comment>
	<expr_stmt><expr><call><name>transformExtendedStatistics</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close rel */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Output results.
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <name>newcmds</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>beforeStmts</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>blist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>afterStmts</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>, <argument><expr><name>save_alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Preprocess a list of column constraint clauses
 * to attach constraint attributes to their primary constraint nodes
 * and detect inconsistent/misplaced constraint attributes.
 *
 * NOTE: currently, attributes are only supported for FOREIGN KEY, UNIQUE,
 * EXCLUSION, and PRIMARY KEY constraints, but someday they ought to be
 * supported for other constraint types.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformConstraintAttrs</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraintList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>lastprimarycon</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_deferrability</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_initially</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>clist</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORTS_ATTRS</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro>				\
	<cpp:value>((node) != NULL &amp;&amp;						\
	 ((node)-&gt;contype == CONSTR_PRIMARY ||	\
	  (node)-&gt;contype == CONSTR_UNIQUE ||	\
	  (node)-&gt;contype == CONSTR_EXCLUSION || \
	  (node)-&gt;contype == CONSTR_FOREIGN))</cpp:value></cpp:define>

	<macro><name>foreach</name><argument_list>(<argument>clist</argument>, <argument>constraintList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>clist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_ATTR_DEFERRABLE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SUPPORTS_ATTRS</name><argument_list>(<argument><expr><name>lastprimarycon</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"misplaced DEFERRABLE clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_deferrability</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple DEFERRABLE/NOT DEFERRABLE clauses not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>saw_deferrability</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_ATTR_NOT_DEFERRABLE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SUPPORTS_ATTRS</name><argument_list>(<argument><expr><name>lastprimarycon</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"misplaced NOT DEFERRABLE clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_deferrability</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple DEFERRABLE/NOT DEFERRABLE clauses not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>saw_deferrability</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_initially</name> <operator>&amp;&amp;</operator>
					<name><name>lastprimarycon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint declared INITIALLY DEFERRED must be DEFERRABLE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_ATTR_DEFERRED</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SUPPORTS_ATTRS</name><argument_list>(<argument><expr><name>lastprimarycon</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"misplaced INITIALLY DEFERRED clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_initially</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple INITIALLY IMMEDIATE/DEFERRED clauses not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>saw_initially</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If only INITIALLY DEFERRED appears, assume DEFERRABLE
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>saw_deferrability</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>lastprimarycon</name><operator>-&gt;</operator><name>deferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint declared INITIALLY DEFERRED must be DEFERRABLE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_ATTR_IMMEDIATE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SUPPORTS_ATTRS</name><argument_list>(<argument><expr><name>lastprimarycon</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"misplaced INITIALLY IMMEDIATE clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_initially</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple INITIALLY IMMEDIATE/DEFERRED clauses not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>saw_initially</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<comment type="block">/* Otherwise it's not an attribute */</comment>
				<expr_stmt><expr><name>lastprimarycon</name> <operator>=</operator> <name>con</name></expr>;</expr_stmt>
				<comment type="block">/* reset flags for new primary node */</comment>
				<expr_stmt><expr><name>saw_deferrability</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>saw_initially</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Special handling of type definition for a column
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformColumnType</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * All we really need to do here is verify that the type is valid,
	 * including any collation spec that might be present.
	 */</comment>
	<decl_stmt><decl><type><name>Type</name></type>		<name>ctype</name> <init>= <expr><call><name>typenameType</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>collClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LookupCollation</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
						<argument><expr><name><name>column</name><operator>-&gt;</operator><name>collClause</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>,
						<argument><expr><name><name>column</name><operator>-&gt;</operator><name>collClause</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Complain if COLLATE is applied to an uncollatable type */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typcollation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations are not supported by type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
										<argument><expr><name><name>column</name><operator>-&gt;</operator><name>collClause</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * transformCreateSchemaStmt -
 *	  analyzes the CREATE SCHEMA statement
 *
 * Split the schema element list into individual commands and place
 * them in the result list in an order such that there are no forward
 * references (e.g. GRANT to a table created later in the list). Note
 * that the logic we use for determining forward references is
 * presently quite incomplete.
 *
 * SQL also allows constraints to make forward references, so thumb through
 * the table columns and move forward references to a posterior alter-table
 * command.
 *
 * The result is a list of parse nodes that still need to be analyzed ---
 * but we can't analyze the later commands until we've executed the earlier
 * ones, because of possible inter-object references.
 *
 * Note: this breaks the rules a little bit by modifying schema-name fields
 * within passed-in structs.  However, the transformation would be the same
 * if done over, so it should be all right to scribble on the input to this
 * extent.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformCreateSchemaStmt</name><parameter_list>(<parameter><decl><type><name>CreateSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateSchemaStmtContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"CREATE SCHEMA"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>schemaname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>authrole</name></name> <operator>=</operator> <operator>(</operator><name>RoleSpec</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>authrole</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>sequences</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>tables</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>views</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>indexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>triggers</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>grants</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run through each schema element in the schema element list. Separate
	 * statements by type, and do preliminary analysis.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>elements</argument>, <argument>stmt-&gt;schemaElts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>element</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>CreateSeqStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>sequences</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>sequences</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * XXX todo: deal with constraints
					 */</comment>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>tables</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>tables</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_ViewStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ViewStmt</name>   <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>ViewStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>view</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * XXX todo: deal with references between views
					 */</comment>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>views</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>views</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_IndexStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>indexes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>indexes</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>triggers</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>triggers</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_GrantStmt</name></expr>:</case>
				<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>grants</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>grants</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>sequences</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>views</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>indexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>triggers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>grants</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * setSchemaName
 *		Set or check schema name in an element of a CREATE SCHEMA command
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setSchemaName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>context_schema</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>stmt_schema_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>stmt_schema_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>stmt_schema_name</name> <operator>=</operator> <name>context_schema</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>context_schema</name></expr></argument>, <argument><expr><operator>*</operator><name>stmt_schema_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_SCHEMA_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE specifies a schema (%s) "</literal>
						<literal type="string">"different from the one being created (%s)"</literal></expr></argument>,
						<argument><expr><operator>*</operator><name>stmt_schema_name</name></expr></argument>, <argument><expr><name>context_schema</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformPartitionCmd
 *		Analyze the ATTACH/DETACH PARTITION command
 *
 * In case of the ATTACH PARTITION command, cxt-&gt;partbound is set to the
 * transformed value of cmd-&gt;bound.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformPartitionCmd</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parentRel</name> <init>= <expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>parentRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<comment type="block">/* transform the partition bound, if any */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>=</operator> <call><name>transformPartitionBound</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>parentRel</name></expr></argument>,
														 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>

			<comment type="block">/*
			 * A partitioned index cannot have a partition bound set.  ALTER
			 * INDEX prevents that with its grammar, but not ALTER TABLE.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a partitioned table"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
			<comment type="block">/* the table must be partitioned */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is not partitioned"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
			<comment type="block">/* the index must be partitioned */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not partitioned"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* parser shouldn't let this case through */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" is not a partitioned table or index"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * transformPartitionBound
 *
 * Transform a partition bound specification
 */</comment>
<function><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type>
<name>transformPartitionBound</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
						<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>result_spec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>strategy</name> <init>= <expr><call><name>get_partition_strategy</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name> <init>= <expr><call><name>get_partition_natts</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partexprs</name> <init>= <expr><call><name>get_partition_exprs</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Avoid scribbling on input */</comment>
	<expr_stmt><expr><name>result_spec</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Hash partitioning does not support a default partition; there's no
		 * use case for it (since the set of partitions to create is perfectly
		 * defined), and if users do get into it accidentally, it's hard to
		 * back out from it afterwards.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a hash-partitioned table may not have a default partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In case of the default partition, parser had no way to identify the
		 * partition strategy. Assign the parent's strategy to the default
		 * partition bound spec.
		 */</comment>
		<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>

		<return>return <expr><name>result_spec</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid bound specification for a hash partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modulus for hash partition must be an integer value greater than zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&gt;=</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remainder for hash partition must be less than modulus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>coltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>coltypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partcollation</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid bound specification for a list partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Get the only column's name in case we need to output an error */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>partexprs</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
															 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* Need its type data too */</comment>
		<expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <call><name>get_partition_col_typmod</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partcollation</name> <operator>=</operator> <call><name>get_partition_col_collation</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>duplicate</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
												 <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>,
												 <argument><expr><name>partcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Don't add to the result if the value is a duplicate */</comment>
			<expr_stmt><expr><name>duplicate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell2</argument>, <argument>result_spec-&gt;listdatums</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>value2</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>value2</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>duplicate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>duplicate</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>result_spec</name><operator>-&gt;</operator><name>listdatums</name></name></expr></argument>,
											  <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid bound specification for a range partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>partnatts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FROM must specify exactly one value per partitioning column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>partnatts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TO must specify exactly one value per partitioning column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Convert raw parse nodes into PartitionRangeDatum nodes and perform
		 * any necessary validation.
		 */</comment>
		<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator>
			<call><name>transformPartitionRangeBounds</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>,
										  <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator>
			<call><name>transformPartitionRangeBounds</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>,
										  <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result_spec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformPartitionRangeBounds
 *		This converts the expressions for range partition bounds from the raw
 *		grammar representation to PartitionRangeDatum structs
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformPartitionRangeBounds</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>blist</name></decl></parameter>,
							  <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partexprs</name> <init>= <expr><call><name>get_partition_exprs</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>blist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>prd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Infinite range bounds -- "minvalue" and "maxvalue" -- get passed in
		 * as ColumnRefs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name> <init>= <expr><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * There should be a single field named either "minvalue" or
			 * "maxvalue".
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>cname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * ColumnRef is not in the desired single-field-name form. For
				 * consistency between all partition strategies, let the
				 * expression transformation report any errors rather than
				 * doing it ourselves.
				 */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"minvalue"</literal></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>prd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>prd</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>prd</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"maxvalue"</literal></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>prd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>prd</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>prd</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>prd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>coltype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>coltypmod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>partcollation</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

			<comment type="block">/* Get the column's name in case we need to output an error */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>partexprs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
																 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Need its type data too */</comment>
			<expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <call><name>get_partition_col_typmod</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partcollation</name> <operator>=</operator> <call><name>get_partition_col_collation</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
												 <argument><expr><name>colname</name></expr></argument>,
												 <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>,
												 <argument><expr><name>partcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify NULL in range bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>prd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prd</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prd</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>value</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>prd</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Once we see MINVALUE or MAXVALUE for one column, the remaining columns
	 * must be the same.
	 */</comment>
	<expr_stmt><expr><call><name>validateInfiniteBounds</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * validateInfiniteBounds
 *
 * Check that a MAXVALUE or MINVALUE specification in a partition bound is
 * followed only by more of the same.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateInfiniteBounds</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>blist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeDatumKind</name></type> <name>kind</name> <init>= <expr><name>PARTITION_RANGE_DATUM_VALUE</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>blist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>prd</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name><name>prd</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PARTITION_RANGE_DATUM_VALUE</name></expr>:</case>
				<expr_stmt><expr><name>kind</name> <operator>=</operator> <name><name>prd</name><operator>-&gt;</operator><name>kind</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"every bound following MAXVALUE must also be MAXVALUE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"every bound following MINVALUE must also be MINVALUE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Transform one constant in a partition bound spec
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>transformPartitionBoundValue</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>val</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>colType</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>colTypmod</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>partCollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

	<comment type="block">/* Transform raw parsetree */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>EXPR_KIND_PARTITION_BOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that the input expression's collation is compatible with one
	 * specified for the parent's partition key (partcollation).  Don't throw
	 * an error if it's the default collation which we'll replace with the
	 * parent's collation anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>exprCollOid</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check we have a collation iff it is a collatable type.  The only
		 * expected failures here are (1) COLLATE applied to a noncollatable
		 * type, or (2) partition bound expression had an unresolved
		 * collation.  But we might as well code this to be a complete
		 * consistency check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>colType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>exprCollOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for partition bound expression"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>exprCollOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations are not supported by type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>colType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>exprCollOid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>exprCollOid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name> <operator>&amp;&amp;</operator>
			<name>exprCollOid</name> <operator>!=</operator> <name>partCollation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation of partition bound value for column \"%s\" does not match partition key collation \"%s\""</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>partCollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Coerce to correct type */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								  <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>colType</name></expr></argument>,
								  <argument><expr><name>colTypmod</name></expr></argument>,
								  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
								  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specified value cannot be cast to type %s for column \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>colType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Simplify the expression, in case we had a coercion */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * transformExpr() should have already rejected column references,
	 * subqueries, aggregates, window functions, and SRFs, based on the
	 * EXPR_KIND_ for a default expression.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>contain_var_clause</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Evaluate the expression, assigning the partition key's collation to the
	 * resulting Const expression.
	 */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>evaluate_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>value</name></expr></argument>, <argument><expr><name>colType</name></expr></argument>, <argument><expr><name>colTypmod</name></expr></argument>,
								   <argument><expr><name>partCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not evaluate partition bound expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CreateSeqStmt</name> <modifier>*</modifier></type>
<name>makeDefaultCreateAGLabelSeqStmt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>labseq</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateSeqStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>labseq</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>AG_LABEL_SEQ</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>labseq</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"maxvalue"</literal></expr></argument>,
											 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>GRAPHID_LABID_MAX</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"cycle"</literal></expr></argument>,
											 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>labseq</name><operator>-&gt;</operator><name>ownerId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>labseq</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>labseq</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CreateLabelStmt</name> <modifier>*</modifier></type>
<name>makeDefaultCreateAGLabelStmt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>, <parameter><decl><type><name>LabelKind</name></type> <name>labKind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateLabelStmt</name>	<modifier>*</modifier></type><name>createLabelStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateLabelStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>createLabelStmt</name><operator>-&gt;</operator><name>labelKind</name></name> <operator>=</operator> <name>labKind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createLabelStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>,
											 <argument><expr><ternary><condition><expr><name>labKind</name> <operator>==</operator> <name>LABEL_VERTEX</name></expr> ?</condition><then> <expr><name>AG_VERTEX</name></expr> </then><else>: <expr><name>AG_EDGE</name></expr></else></ternary></expr></argument>,
											 <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createLabelStmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createLabelStmt</name><operator>-&gt;</operator><name>only_base</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>createLabelStmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformCreateLabelStmt - parse analysis for CREATE VLABEL/ELABEL
 *
 * This function is based on transformCreateStmt().
 * Graph Labels have default inheritance, primary key, and sequence.
 * But they are not written in statements.
 * Thus this adds nodes for label statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformCreateLabelStmt</name><parameter_list>(<parameter><decl><type><name>CreateLabelStmt</name> <modifier>*</modifier></type><name>labelStmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>graphname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>existing_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmtContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>descbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>labdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tabdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>comment</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_alist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>labelStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set graph schema name, if not specified */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>label</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>label</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>graphname</name> <operator>=</operator> <name><name>label</name><operator>-&gt;</operator><name>schemaname</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>,
									  <argument><expr><name><name>label</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name>label</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>existing_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the label already exists and the user specified "IF NOT EXISTS",
	 * bail out with a NOTICE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>existing_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>labelStmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label \"%s\" already exists, skipping"</literal></expr></argument>,
							<argument><expr><name><name>label</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label \"%s\" already exists"</literal></expr></argument>, <argument><expr><name><name>label</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * create CreateStmt for label
	 */</comment>

	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>label</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>labelStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>ONCOMMIT_NOOP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <name><name>labelStmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name><name>labelStmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>;</expr_stmt>

	<comment type="block">/* set appropriate table elements and indexes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>labelStmt</name><operator>-&gt;</operator><name>labelKind</name></name> <operator>==</operator> <name>LABEL_VERTEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <call><name>makeVertexElements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>labelStmt</name><operator>-&gt;</operator><name>labelKind</name></name> <operator>==</operator> <name>LABEL_EDGE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <call><name>makeEdgeElements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexlist</name> <operator>=</operator> <call><name>makeEdgeIndex</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown label type: %d"</literal></expr></argument>, <argument><expr><name><name>labelStmt</name><operator>-&gt;</operator><name>labelKind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>labelStmt</name><operator>-&gt;</operator><name>only_base</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>removeConstraintsFromColumnDefs</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>labelStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>AG_VERTEX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>labelStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>AG_EDGE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* inherit base vertex/edge */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>labelStmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>labelStmt</name><operator>-&gt;</operator><name>only_base</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>labelStmt</name><operator>-&gt;</operator><name>labelKind</name></name> <operator>==</operator> <name>LABEL_VERTEX</name></expr> ?</condition><then> <expr><name>AG_VERTEX</name></expr> </then><else>: <expr><name>AG_EDGE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><name>graphname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* user requested inherit option */</comment>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>inhRel</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>labelStmt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>inhRel</argument>, <argument>stmt-&gt;inhRelations</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>inhRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* force schema */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <name>graphname</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>graphname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_SCHEMA_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parent graph label \"%s\" must be in the same graph path \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>graphname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>labelStmt</name><operator>-&gt;</operator><name>labelKind</name></name> <operator>==</operator> <name>LABEL_VERTEX</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>isLabelKind</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>LABEL_KIND_VERTEX</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_SCHEMA_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parent graph label \"%s\" is not vertex label."</literal></expr></argument>,
									<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>labelStmt</name><operator>-&gt;</operator><name>labelKind</name></name> <operator>==</operator> <name>LABEL_EDGE</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>isLabelKind</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>LABEL_KIND_EDGE</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_SCHEMA_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parent graph label \"%s\" is not edge label."</literal></expr></argument>,
									<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>labelStmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_SCHEMA_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"graph label \"%s\" is base label, inherit option is discarded"</literal></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * process CreateStmt
	 */</comment>

	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>labelStmt</name><operator>-&gt;</operator><name>labelKind</name></name> <operator>==</operator> <name>LABEL_VERTEX</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"CREATE VLABEL"</literal></expr>
														  </then><else>: <expr><literal type="string">"CREATE ELABEL"</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>relation</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>inhRelations</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isforeign</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isalter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ckconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>fkconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ixconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>extstats</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ispartitioned</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>partbound</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ofType</name></name> <operator>=</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>elements</argument>, <argument>stmt-&gt;tableElts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>element</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_ColumnDef</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>labelStmt</name><operator>-&gt;</operator><name>only_base</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>transformLabelIdDefinition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>transformColumnDefinition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Constraint</name></expr>:</case>
				<comment type="block">/* fall-through */</comment>
			<case>case <expr><name>T_TableLikeClause</name></expr>:</case>
				<comment type="block">/* fall-through */</comment>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"graph base label definition has columns only, element node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/* make descriptions for label and table */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>AG_VERTEX</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>descbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>descbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"base vertex label of graph %s"</literal></expr></argument>,
				 <argument><expr><name>graphname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>labdesc</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>descbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>makeComment</name><argument_list>(<argument><expr><name>OBJECT_VLABEL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>labdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>, <argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>labelStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>AG_EDGE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>descbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>descbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"base edge label of graph %s"</literal></expr></argument>,
				 <argument><expr><name>graphname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>labdesc</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>descbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>makeComment</name><argument_list>(<argument><expr><name>OBJECT_ELABEL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>labdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>, <argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>qname</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>graphname</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>descbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>descbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"base table for graph label %s"</literal></expr></argument>, <argument><expr><name>qname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tabdesc</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>descbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>makeComment</name><argument_list>(<argument><expr><name>OBJECT_TABLE</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>tabdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>, <argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transfer anything we already have in cxt.alist into save_alist, to keep
	 * it separate from the output of transformIndexConstraints.  (This may
	 * not be necessary anymore, but we'll keep doing it to preserve the
	 * historical order of execution of the alist commands.)
	 */</comment>
	<expr_stmt><expr><name>save_alist</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>alist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Postprocess constraints that give rise to index definitions.
	 */</comment>
	<expr_stmt><expr><call><name>transformIndexConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>, <argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Postprocess foreign-key constraints.
	 */</comment>
	<expr_stmt><expr><call><name>transformFKConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if `disable_index` is true
	 * then set DisableIndexStmt after CREATE INDEX statements
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>labelStmt</name><operator>-&gt;</operator><name>disable_index</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DisableIndexStmt</name> <modifier>*</modifier></type><name>disable_idx_stmt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>disable_idx_stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DisableIndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>disable_idx_stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>, <argument><expr><name>disable_idx_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Postprocess extended statistics.
	 */</comment>
	<expr_stmt><expr><call><name>transformExtendedStatistics</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Output results.
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>columns</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>ckconstraints</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>save_alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* make table elements for base `vertex` table */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>makeVertexElements</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>pk</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>id</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>notnull</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>jsonb_empty_obj</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>constrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>prop_map</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pk</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_PRIMARY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pk</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <name>AG_ELEM_LOCAL_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"graphid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>pk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>notnull</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_NOTNULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notnull</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>jsonb_empty_obj</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jsonb_empty_obj</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
			<call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"jsonb_build_object"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jsonb_empty_obj</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>constrs</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>notnull</name></expr></argument>, <argument><expr><name>jsonb_empty_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <name>AG_ELEM_PROP_MAP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>constrs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* make table elements for base `edge` table */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>makeEdgeElements</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>notnull</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>constrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>id</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>start</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>jsonb_empty_obj</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>prop_map</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>notnull</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_NOTNULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notnull</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>constrs</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>notnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <name>AG_ELEM_LOCAL_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"graphid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>constrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>start</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <name>AG_START_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"graphid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>constrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>end</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <name>AG_END_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"graphid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>constrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>jsonb_empty_obj</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jsonb_empty_obj</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
			<call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"jsonb_build_object"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jsonb_empty_obj</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>constrs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>constrs</name></expr></argument>, <argument><expr><name>jsonb_empty_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <name>AG_ELEM_PROP_MAP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"jsonb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>constrs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop_map</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make4</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>makeEdgeIndex</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>labname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>graphid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>id_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>start_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>end_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>edge_id_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>start_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>end_idx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>labname</name> <operator>=</operator> <name><name>label</name><operator>-&gt;</operator><name>relname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>graphid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make index elements */</comment>

	<expr_stmt><expr><name>id_col</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>id_col</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>AG_ELEM_LOCAL_ID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>start_col</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start_col</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>AG_START_ID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>end_col</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end_col</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>AG_END_ID</name></expr>;</expr_stmt>

	<comment type="block">/* make indexes */</comment>

	<expr_stmt><expr><name>edge_id_idx</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge_id_idx</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name>labname</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>,
											  <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><name>graphid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge_id_idx</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge_id_idx</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <literal type="string">"brin"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge_id_idx</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>id_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start_idx</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start_idx</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name>labname</name></expr></argument>, <argument><expr><name>AG_START_ID</name></expr></argument>,
											<argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><name>graphid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start_idx</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start_idx</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <literal type="string">"btree"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>start_idx</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>start_col</name></expr></argument>, <argument><expr><name>end_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>end_idx</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end_idx</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name>labname</name></expr></argument>, <argument><expr><name>AG_END_ID</name></expr></argument>,
										  <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><name>graphid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end_idx</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end_idx</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <literal type="string">"btree"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>end_idx</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>end_col</name></expr></argument>, <argument><expr><name>start_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>edge_id_idx</name></expr></argument>, <argument><expr><name>start_idx</name></expr></argument>, <argument><expr><name>end_idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isLabelKind</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>labkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>graphid</name> <init>= <expr><call><name>get_graphname_oid</name><argument_list>(<argument><expr><name><name>label</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><call><name>getLabelKind</name><argument_list>(<argument><expr><name><name>label</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>graphid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>labkind</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name></type>
<name>getLabelKind</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graphid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_ag_label</name></type> <name>labtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>labkind</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>LABELNAMEGRAPH</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>labname</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>graphid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"label \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>labname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>labtup</name> <operator>=</operator> <operator>(</operator><name>Form_ag_label</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>labkind</name> <operator>=</operator> <name><name>labtup</name><operator>-&gt;</operator><name>labkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>labkind</name> <operator>==</operator> <name>LABEL_KIND_VERTEX</name> <operator>||</operator> <name>labkind</name> <operator>==</operator> <name>LABEL_KIND_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>labkind</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* See transformColumnDefinition() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformLabelIdDefinition</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>snamespaceid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>snamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>seqstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>	   <modifier>*</modifier></type><name>maxval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnamelist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>	   <modifier>*</modifier></type><name>ownedby</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>altseqstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>fclabid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>seqname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>castseq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>fcnextval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>fcgraphid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>defid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>snamespaceid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RangeVarAdjustRelationPersistence</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>snamespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>snamespace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>snamespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sname</name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>,
							   <argument><expr><literal type="string">"seq"</literal></expr></argument>, <argument><expr><name>snamespaceid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* CREATE SEQUENCE before CREATE TABLE */</comment>

	<expr_stmt><expr><name>seqstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>ownerId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>blist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>blist</name></name></expr></argument>, <argument><expr><name>seqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ALTER SEQUENCE OWNED BY after CREATE TABLE */</comment>

	<expr_stmt><expr><name>maxval</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"maxvalue"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFloat</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><name>INT64_FORMAT</name></expr></argument>,
																 <argument><expr><name>GRAPHID_LOCID_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnamelist</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ownedby</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"owned_by"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>attnamelist</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>altseqstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>maxval</name></expr></argument>, <argument><expr><name>ownedby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>altseqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * add DEFAULT constraint to the column
	 *
	 * graphid(graph_labid(`relname`), nextval(`seqname`::regclass))
	 */</comment>

	<expr_stmt><expr><name>qname</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relname</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relname</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>qname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relname</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>fclabid</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"graph_labid"</literal></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qname</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>seqname</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqname</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqname</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>qname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqname</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>castseq</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>castseq</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>SystemTypeName</name><argument_list>(<argument><expr><literal type="string">"regclass"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>castseq</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>seqname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>castseq</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>fcnextval</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"nextval"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>castseq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fcgraphid</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"graphid"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>fclabid</name></expr></argument>, <argument><expr><name>fcnextval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>defid</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>defid</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>defid</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>defid</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fcgraphid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>col</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>defid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CommentStmt</name> <modifier>*</modifier></type>
<name>makeComment</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CommentStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>name</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>name</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AlterTableStmt</name> <modifier>*</modifier></type>
<name>transformAlterLabelStmt</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>laboid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>laboid</name> <operator>=</operator> <call><name>get_labname_laboid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><call><name>get_graph_path_oid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>laboid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"graph label \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"graph label \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CheckLabelType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>, <argument><expr><name>laboid</name></expr></argument>, <argument><expr><literal type="string">"ALTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_SetStorage</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/* storage option is meaningless for graph id
					 * so forced to graph property */</comment>
					<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>AG_ELEM_PROP_MAP</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>AT_AddInherit</name></expr>:</case>
			<case>case <expr><name>AT_DropInherit</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>par</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>par</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>AG_VERTEX</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
						<operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>par</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>AG_EDGE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot ALTER inheritance with base label"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>par</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_graph_path</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<default>default:</default>
				<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <name>newcmds</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformCreateConstraintStmt - parse analysis for CREATE CONSTRAINT
 *
 * This function transforms a CreateConstraintStmt to a AlterTableStmt,
 * and returns the AlterTableStmt.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformCreateConstraintStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							  <parameter><decl><type><name>CreateConstraintStmt</name> <modifier>*</modifier></type><name>constraintStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectType</name></type>	<name>objtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherGenericExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>propexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>atcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>atstmt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>label</name> <operator>=</operator> <name><name>constraintStmt</name><operator>-&gt;</operator><name>graphlabel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>label</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_graph_path</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>objtype</name> <operator>=</operator> <call><name>getLabelObjectType</name><argument_list>(<argument><expr><name><name>label</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><call><name>get_graph_path_oid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherGenericExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>prop_ref_mutator</name><argument_list>(<argument><expr><name><name>constraintStmt</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>propexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>constr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>constraintStmt</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name><name>constraintStmt</name><operator>-&gt;</operator><name>contype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <name><name>constraintStmt</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>=</operator> <name>propexpr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>initially_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>uniqueElem</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>equalOp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>excludeExpr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * We cannot create UNIQUE constraints on expressions in
				 * PostgreSQL. Instead, we can support the same functionality
				 * through EXCLUDE.
				 */</comment>

				<expr_stmt><expr><name>uniqueElem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>uniqueElem</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>propexpr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>equalOp</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>excludeExpr</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>uniqueElem</name></expr></argument>, <argument><expr><name>equalOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_EXCLUSION</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>access_method</name></name> <operator>=</operator> <name>DEFAULT_INDEX_TYPE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>exclusions</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>excludeExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <name><name>constraintStmt</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type> <name>nsid</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>nsid</name> <operator>=</operator> <call><name>LookupNamespaceNoError</name><argument_list>(<argument><expr><name><name>label</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name><name>label</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
														 <argument><expr><literal type="string">"unique"</literal></expr></argument>,
														 <argument><expr><literal type="string">"constraint"</literal></expr></argument>, <argument><expr><name>nsid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>constraintStmt</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>atcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraint</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>constr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>atstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>label</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>atcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>objtype</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>atstmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformDropConstraintStmt - parse analysis for DROP CONSTRAINT
 *
 * This function transforms a DropConstraintStmt to a AlterTableStmt,
 * and returns the AlterTableStmt.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformDropConstraintStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							<parameter><decl><type><name>DropConstraintStmt</name> <modifier>*</modifier></type><name>constraintStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectType</name></type>	<name>objtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>atcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>atstmt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>label</name> <operator>=</operator> <name><name>constraintStmt</name><operator>-&gt;</operator><name>graphlabel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>label</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_graph_path</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>objtype</name> <operator>=</operator> <call><name>getLabelObjectType</name><argument_list>(<argument><expr><name><name>label</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><call><name>get_graph_path_oid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>atcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DropConstraint</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>constraintStmt</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name>DROP_RESTRICT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>atstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>label</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>atcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>objtype</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>atstmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Change ColumnRef in `node` to an expression which is an indirection on
 * AG_ELEM_PROP_MAP
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>prop_ref_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cref</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>raw_expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prop_ref_mutator</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ObjectType</name></type>
<name>getLabelObjectType</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graphid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>labkind</name> <init>= <expr><call><name>getLabelKind</name><argument_list>(<argument><expr><name>labname</name></expr></argument>, <argument><expr><name>graphid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>labkind</name> <operator>==</operator> <name>LABEL_KIND_VERTEX</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>OBJECT_VLABEL</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>labkind</name> <operator>==</operator> <name>LABEL_KIND_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>OBJECT_ELABEL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformIndexStmt - parse analysis for CREATE PROPERTY INDEX
 *
 * This function is based on transformIndexStmt().
 *
 * Return an IndexStmt node using information from an PropertyIndexStmt.
 */</comment>
<function><type><name>IndexStmt</name> <modifier>*</modifier></type>
<name>transformCreatePropertyIndexStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>CreatePropertyIndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>idxstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_reserved_property</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>transformed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>idxstmt</name> <operator>=</operator> <operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NodeSetTag</name><argument_list>(<argument><expr><name>idxstmt</name></expr></argument>, <argument><expr><name>T_IndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up pstate */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Put the parent table into the rtable so that the expressions can refer
	 * to its fields without qualification.  Caller is responsible for locking
	 * relation, but we still need to open it.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										   <argument><expr><name>AccessShareLock</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no to join list, yes to namespaces */</comment>
	<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* take care of the where clause */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>idxstmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <call><name>prop_ref_mutator</name><argument_list>(<argument><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <call><name>transformCypherWhere</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													<argument><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
													<argument><expr><name>EXPR_KIND_INDEX_PREDICATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we have to fix its collations too */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* take care of any index expressions */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>idxstmt-&gt;indexParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>ielem</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ielem</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"property index must have expressions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * just fill indexcolname with a properly chosen name at here and
			 * let ChooseIndexName() build the name of the index later
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>figure_prop_index_colname_walker</name><argument_list>(<argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ielem</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ielem</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <call><name>FigureIndexColname</name><argument_list>(<argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>is_reserved_property</name> <operator>=</operator> <call><name>ConvertReservedColumnRefForIndex</name><argument_list>(<argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
																<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_reserved_property</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>prop_ref_mutator</name><argument_list>(<argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Now do parse transformation of the expression */</comment>
		<expr_stmt><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_INDEX_EXPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We have to fix its collations too */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * transformExpr() should have already rejected subqueries,
		 * aggregates, and window functions, based on the EXPR_KIND_ for
		 * an index expression.
		 *
		 * Also reject expressions returning sets; this is for consistency
		 * with what transformWhereClause() checks for the predicate.
		 * DefineIndex() will make more checks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"property index expression cannot return a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Check that only the base rel is mentioned.  (This should be dead code
	 * now that add_missing_from is history.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index expressions and predicates can refer only to the table being indexed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close relation */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark statement as successfully transformed */</comment>
	<expr_stmt><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>transformed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>idxstmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Just return the last valid name in the fields of ColumnRef or
 * in the indirection of A_Indirection.
 * It will be the last path element of the indirection on properties.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>figure_prop_index_colname_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>A_Indirection</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>indir</name> <init>= <expr><operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>li</argument>, <argument>indir-&gt;indirection</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>ind</name> <init>= <expr><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name>i</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ind</name><operator>-&gt;</operator><name>is_slice</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name><name>ind</name><operator>-&gt;</operator><name>uidx</name></name><operator>)</operator><operator>-&gt;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>colname</name> <operator>=</operator> <name>fname</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>figure_prop_index_colname_walker</name><argument_list>(<argument><expr><name><name>indir</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>FigureIndexColname</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>colname</name> <operator>=</operator> <name>fname</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>raw_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>figure_prop_index_colname_walker</name></expr></argument>,
									  <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>removeConstraintsFromColumnDefs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnDefs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>li</argument>, <argument>columnDefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name>	   <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function></unit>
