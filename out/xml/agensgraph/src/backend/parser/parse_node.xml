<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/parser/parse_node.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_node.c
 *	  various routines that make nodes for querytrees
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_node.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/int8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varbit.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pcb_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * make_parsestate
 *		Allocate and initialize a new ParseState.
 *
 * Caller should eventually release the ParseState via free_parsestate().
 */</comment>
<function><type><name>ParseState</name> <modifier>*</modifier></type>
<name>make_parsestate</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParseState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name> <operator>=</operator> <name>parentParseState</name></expr>;</expr_stmt>

	<comment type="block">/* Fill in fields that don't start at null/false/zero */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>parentParseState</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name><name>parentParseState</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr>;</expr_stmt>
		<comment type="block">/* all hooks are copied from parent */</comment>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name> <operator>=</operator> <name><name>parentParseState</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name> <operator>=</operator> <name><name>parentParseState</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_paramref_hook</name></name> <operator>=</operator> <name><name>parentParseState</name><operator>-&gt;</operator><name>p_paramref_hook</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_coerce_param_hook</name></name> <operator>=</operator> <name><name>parentParseState</name><operator>-&gt;</operator><name>p_coerce_param_hook</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name> <operator>=</operator> <name><name>parentParseState</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name></expr>;</expr_stmt>
		<comment type="block">/* query environment stays in context for the whole parse analysis */</comment>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_queryEnv</name></name> <operator>=</operator> <name><name>parentParseState</name><operator>-&gt;</operator><name>p_queryEnv</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>pstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * free_parsestate
 *		Release a ParseState and any subsidiary resources.
 */</comment>
<function><type><name>void</name></type>
<name>free_parsestate</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Check that we did not produce too many resnos; at the very least we
	 * cannot allow more than 2^16, since that would exceed the range of a
	 * AttrNumber. It seems safest to use MaxTupleAttributeNumber.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>MaxTupleAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"target lists can have at most %d entries"</literal></expr></argument>,
						<argument><expr><name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * parser_errposition
 *		Report a parse-analysis-time cursor position, if possible.
 *
 * This is expected to be used within an ereport() call.  The return value
 * is a dummy (always 0, in fact).
 *
 * The locations stored in raw parsetrees are byte offsets into the source
 * string.  We have to convert them to 1-based character indexes for reporting
 * to clients.  (We do things this way to avoid unnecessary overhead in the
 * normal non-error case: computing character indexes would be much more
 * expensive than storing token offsets.)
 */</comment>
<function><type><name>int</name></type>
<name>parser_errposition</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>

	<comment type="block">/* No-op if location was not provided */</comment>
	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Can't do anything if source text is not available */</comment>
	<if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Convert offset to character number */</comment>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* And pass it to the ereport mechanism */</comment>
	<return>return <expr><call><name>errposition</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * setup_parser_errposition_callback
 *		Arrange for non-parser errors to report an error position
 *
 * Sometimes the parser calls functions that aren't part of the parser
 * subsystem and can't reasonably be passed a ParseState; yet we would
 * like any errors thrown in those functions to be tagged with a parse
 * error location.  Use this function to set up an error context stack
 * entry that will accomplish that.  Usage pattern:
 *
 *		declare a local variable "ParseCallbackState pcbstate"
 *		...
 *		setup_parser_errposition_callback(&amp;pcbstate, pstate, location);
 *		call function that might throw error;
 *		cancel_parser_errposition_callback(&amp;pcbstate);
 */</comment>
<function><type><name>void</name></type>
<name>setup_parser_errposition_callback</name><parameter_list>(<parameter><decl><type><name>ParseCallbackState</name> <modifier>*</modifier></type><name>pcbstate</name></decl></parameter>,
								  <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Setup error traceback support for ereport() */</comment>
	<expr_stmt><expr><name><name>pcbstate</name><operator>-&gt;</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcbstate</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcbstate</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>pcb_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcbstate</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pcbstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcbstate</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name><name>pcbstate</name><operator>-&gt;</operator><name>errcallback</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cancel a previously-set-up errposition callback.
 */</comment>
<function><type><name>void</name></type>
<name>cancel_parser_errposition_callback</name><parameter_list>(<parameter><decl><type><name>ParseCallbackState</name> <modifier>*</modifier></type><name>pcbstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>pcbstate</name><operator>-&gt;</operator><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error context callback for inserting parser error location.
 *
 * Note that this will be called for *any* error occurring while the
 * callback is installed.  We avoid inserting an irrelevant error location
 * if the error is a query cancel --- are there any other important cases?
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pcb_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseCallbackState</name> <modifier>*</modifier></type><name>pcbstate</name> <init>= <expr><operator>(</operator><name>ParseCallbackState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>geterrcode</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ERRCODE_QUERY_CANCELED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>pcbstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>pcbstate</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * transformContainerType()
 *		Identify the types involved in a subscripting operation for container
 *
 *
 * On entry, containerType/containerTypmod identify the type of the input value
 * to be subscripted (which could be a domain type).  These are modified if
 * necessary to identify the actual container type and typmod, and the
 * container's element type is returned.  An error is thrown if the input isn't
 * an array type.
 */</comment>
<function><type><name>Oid</name></type>
<name>transformContainerType</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>containerType</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>containerTypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>origContainerType</name> <init>= <expr><operator>*</operator><name>containerType</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elementType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>type_tuple_container</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>type_struct_container</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the input is a domain, smash to base type, and extract the actual
	 * typmod to be applied to the base type. Subscripting a domain is an
	 * operation that necessarily works on the base container type, not the
	 * domain itself. (Note that we provide no method whereby the creator of a
	 * domain over a container type could hide its ability to be subscripted.)
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>containerType</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><operator>*</operator><name>containerType</name></expr></argument>, <argument><expr><name>containerTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here is an array specific code. We treat int2vector and oidvector as
	 * though they were domains over int2[] and oid[].  This is needed because
	 * array slicing could create an array that doesn't satisfy the
	 * dimensionality constraints of the xxxvector type; so we want the result
	 * of a slice operation to be considered to be of the more general type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>containerType</name> <operator>==</operator> <name>INT2VECTOROID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>containerType</name> <operator>=</operator> <name>INT2ARRAYOID</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>containerType</name> <operator>==</operator> <name>OIDVECTOROID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>containerType</name> <operator>=</operator> <name>OIDARRAYOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the type tuple for the container */</comment>
	<expr_stmt><expr><name>type_tuple_container</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><operator>*</operator><name>containerType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>type_tuple_container</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><operator>*</operator><name>containerType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>type_struct_container</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>type_tuple_container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* needn't check typisdefined since this will fail anyway */</comment>

	<expr_stmt><expr><name>elementType</name> <operator>=</operator> <name><name>type_struct_container</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>elementType</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot subscript type %s because it is not an array"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>origContainerType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>type_tuple_container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>elementType</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformContainerSubscripts()
 *		Transform container (array, etc) subscripting.  This is used for both
 *		container fetch and container assignment.
 *
 * In a container fetch, we are given a source container value and we produce
 * an expression that represents the result of extracting a single container
 * element or a container slice.
 *
 * In a container assignment, we are given a destination container value plus a
 * source value that is to be assigned to a single element or a slice of that
 * container. We produce an expression that represents the new container value
 * with the source data inserted into the right part of the container.
 *
 * For both cases, if the source container is of a domain-over-array type,
 * the result is of the base array type or its element type; essentially,
 * we must fold a domain to its base type before applying subscripting.
 * (Note that int2vector and oidvector are treated as domains here.)
 *
 * pstate			Parse state
 * containerBase	Already-transformed expression for the container as a whole
 * containerType	OID of container's datatype (should match type of
 *					containerBase, or be the base type of containerBase's
 *					domain type)
 * elementType		OID of container's element type (fetch with
 *					transformContainerType, or pass InvalidOid to do it here)
 * containerTypMod	typmod for the container (which is also typmod for the
 *					elements)
 * indirection		Untransformed list of subscripts (must not be NIL)
 * assignFrom		NULL for container fetch, else transformed expression for
 *					source.
 */</comment>
<function><type><name>SubscriptingRef</name> <modifier>*</modifier></type>
<name>transformContainerSubscripts</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>containerBase</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>containerType</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>elementType</name></decl></parameter>,
							 <parameter><decl><type><name>int32</name></type> <name>containerTypMod</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indirection</name></decl></parameter>,
							 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>assignFrom</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSlice</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>upperIndexpr</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lowerIndexpr</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Caller may or may not have bothered to determine elementType.  Note
	 * that if the caller did do so, containerType/containerTypMod must be as
	 * modified by transformContainerType, ie, smash domain to base type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elementType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elementType</name> <operator>=</operator> <call><name>transformContainerType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>containerType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>containerTypMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A list containing only simple subscripts refers to a single container
	 * element.  If any of the items are slice specifiers (lower:upper), then
	 * the subscript expression means a container slice operation.  In this
	 * case, we convert any non-slice items to slices by treating the single
	 * subscript as the upper bound and supplying an assumed lower bound of 1.
	 * We have to prescan the list to see if there are any slice items.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>idx</argument>, <argument>indirection</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>ai</name> <init>= <expr><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>is_slice</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isSlice</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Transform the subscript expressions.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>idx</argument>, <argument>indirection</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>ai</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>A_Indices</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>subexpr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isSlice</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>lidx</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>subexpr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ai</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* If it's not int4 already, try to coerce */</comment>
				<expr_stmt><expr><name>subexpr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><name>subexpr</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												<argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
												<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
												<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>subexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript must have type integer"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>ai</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>ai</name><operator>-&gt;</operator><name>is_slice</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Make a constant 1 */</comment>
				<expr_stmt><expr><name>subexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											 <argument><expr><name>InvalidOid</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
											 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* pass by value */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Slice with omitted lower bound, put NULL into the list */</comment>
				<expr_stmt><expr><name>subexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>lowerIndexpr</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lowerIndexpr</name></expr></argument>, <argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ai</name><operator>-&gt;</operator><name>lidx</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ai</name><operator>-&gt;</operator><name>is_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>uidx</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subexpr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ai</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* If it's not int4 already, try to coerce */</comment>
			<expr_stmt><expr><name>subexpr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><name>subexpr</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											<argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
											<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>subexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array subscript must have type integer"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>ai</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Slice with omitted upper bound, put NULL into the list */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>isSlice</name> <operator>&amp;&amp;</operator> <name><name>ai</name><operator>-&gt;</operator><name>is_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>upperIndexpr</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>upperIndexpr</name></expr></argument>, <argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If doing an array store, coerce the source value to the right type.
	 * (This should agree with the coercion done by transformAssignedExpr.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>assignFrom</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typesource</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>assignFrom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typeneeded</name> <init>= <expr><ternary><condition><expr><name>isSlice</name></expr> ?</condition><then> <expr><name>containerType</name></expr> </then><else>: <expr><name>elementType</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newFrom</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newFrom</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>assignFrom</name></expr></argument>, <argument><expr><name>typesource</name></expr></argument>,
										<argument><expr><name>typeneeded</name></expr></argument>, <argument><expr><name>containerTypMod</name></expr></argument>,
										<argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
										<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newFrom</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array assignment requires type %s"</literal>
							<literal type="string">" but expression is of type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeneeded</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typesource</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You will need to rewrite or cast the expression."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>assignFrom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>assignFrom</name> <operator>=</operator> <name>newFrom</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Ready to build the SubscriptingRef node.
	 */</comment>
	<expr_stmt><expr><name>sbsref</name> <operator>=</operator> <operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>assignFrom</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>assignFrom</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refcontainertype</name></name> <operator>=</operator> <name>containerType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refelemtype</name></name> <operator>=</operator> <name>elementType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sbsref</name><operator>-&gt;</operator><name>reftypmod</name></name> <operator>=</operator> <name>containerTypMod</name></expr>;</expr_stmt>
	<comment type="block">/* refcollid will be set by parse_collate.c */</comment>
	<expr_stmt><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refupperindexpr</name></name> <operator>=</operator> <name>upperIndexpr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sbsref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name> <operator>=</operator> <name>lowerIndexpr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>containerBase</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>assignFrom</name></expr>;</expr_stmt>

	<return>return <expr><name>sbsref</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_const
 *
 *	Convert a Value node (as returned by the grammar) to a Const node
 *	of the "natural" type for the constant.  Note that this routine is
 *	only used when there is no explicit cast for the constant, so we
 *	have to guess what type is wanted.
 *
 *	For string literals we produce a constant of type UNKNOWN ---- whose
 *	representation is the same as cstring, but it indicates to later type
 *	resolution that we're not sure yet what type it should be considered.
 *	Explicit "NULL" constants are also typed as UNKNOWN.
 *
 *	For integers and floats we produce int4, int8, or numeric depending
 *	on the value of the number.  XXX We should produce int2 as well,
 *	but additional cleanup is needed before we can do that; there are
 *	too many examples that fail if we try.
 */</comment>
<function><type><name>Const</name> <modifier>*</modifier></type>
<name>make_const</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Value</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>val64</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typebyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Integer</name></expr>:</case>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>intVal</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>typelen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>typebyval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Float</name></expr>:</case>
			<comment type="block">/* could be an oversize integer as well as a float ... */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>scanint8</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val64</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * It might actually fit in int32. Probably only INT_MIN can
				 * occur, but we'll code the test generally just to be sure.
				 */</comment>
				<decl_stmt><decl><type><name>int32</name></type>		<name>val32</name> <init>= <expr><operator>(</operator><name>int32</name><operator>)</operator> <name>val64</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>val64</name> <operator>==</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>val32</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>val32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>typelen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><name>typebyval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>val64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>typelen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><name>typebyval</name> <operator>=</operator> <name>FLOAT8PASSBYVAL</name></expr>;</expr_stmt>	<comment type="block">/* int8 and float8 alike */</comment>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* arrange to report location if numeric_in() fails */</comment>
				<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_in</name></expr></argument>,
										  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name>NUMERICOID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>typelen</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* variable len */</comment>
				<expr_stmt><expr><name>typebyval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_String</name></expr>:</case>

			<comment type="block">/*
			 * We assume here that UNKNOWN's internal representation is the
			 * same as CSTRING
			 */</comment>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name>UNKNOWNOID</name></expr>;</expr_stmt>	<comment type="block">/* will be coerced later */</comment>
			<expr_stmt><expr><name>typelen</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>		<comment type="block">/* cstring-style varwidth type */</comment>
			<expr_stmt><expr><name>typebyval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitString</name></expr>:</case>
			<comment type="block">/* arrange to report location if bit_in() fails */</comment>
			<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>bit_in</name></expr></argument>,
									  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name>BITOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>typelen</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>typebyval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Null</name></expr>:</case>
			<comment type="block">/* return a null const */</comment>
			<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>UNKNOWNOID</name></expr></argument>,
							<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							<argument><expr><name>InvalidOid</name></expr></argument>,
							<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
							<argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
			<return>return <expr><name>con</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>,
					<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,			<comment type="block">/* typmod -1 is OK for all cases */</comment>
					<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* all cases are uncollatable types */</comment>
					<argument><expr><name>typelen</name></expr></argument>,
					<argument><expr><name>val</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>,
					<argument><expr><name>typebyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><name>con</name></expr>;</return>
</block_content>}</block></function>
</unit>
