<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/parser/parse_coerce.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_coerce.c
 *		handle type coercions/conversions for parser
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_coerce.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>		<comment type="block">/* needed for datumIsEqual() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>coerce_type_typmod</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
								<parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>, <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>hideInputCoercion</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hide_coercion_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>build_coercion_expression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									   <parameter><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl></parameter>,
									   <parameter><decl><type><name>Oid</name></type> <name>funcId</name></decl></parameter>,
									   <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
									   <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>, <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>coerce_record_to_complex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
									  <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>,
									  <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_complex_array</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>typeIsOfTypedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reltypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>reloftypeId</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * coerce_to_target_type()
 *		Convert an expression to a target type and typmod.
 *
 * This is the general-purpose entry point for arbitrary type coercion
 * operations.  Direct use of the component operations can_coerce_type,
 * coerce_type, and coerce_type_typmod should be restricted to special
 * cases (eg, when the conversion is expected to succeed).
 *
 * Returns the possibly-transformed expression tree, or NULL if the type
 * conversion is not possible.  (We do this, rather than ereport'ing directly,
 * so that callers can generate custom error messages indicating context.)
 *
 * pstate - parse state (can be NULL, see coerce_type)
 * expr - input expression tree (already transformed by transformExpr)
 * exprtype - result type of expr
 * targettype - desired result type
 * targettypmod - desired result typmod
 * ccontext, cformat - context indicators to control coercions
 * location - parse location of the coercion request, or -1 if unknown/implicit
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_target_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>exprtype</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>targettype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targettypmod</name></decl></parameter>,
					  <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>,
					  <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>origexpr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>exprtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettype</name></expr></argument>, <argument><expr><name>ccontext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the input has a CollateExpr at the top, strip it off, perform the
	 * coercion, and put a new one back on.  This is annoying since it
	 * duplicates logic in coerce_type, but if we don't do this then it's too
	 * hard to tell whether coerce_type actually changed anything, and we
	 * *must* know that to avoid possibly calling hide_coercion_node on
	 * something that wasn't generated by coerce_type.  Note that if there are
	 * multiple stacked CollateExprs, we just discard all but the topmost.
	 * Also, if the target type isn't collatable, we discard the CollateExpr.
	 */</comment>
	<expr_stmt><expr><name>origexpr</name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>,
						 <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
						 <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the target is a fixed-length type, it may need a length coercion as
	 * well as a type coercion.  If we find ourselves adding both, force the
	 * inner coercion node to implicit display form.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_type_typmod</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
								<argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
								<argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
								<argument><expr><operator>(</operator><name>result</name> <operator>!=</operator> <name>expr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>!=</operator> <name>origexpr</name> <operator>&amp;&amp;</operator> <call><name>type_is_collatable</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reinstall top CollateExpr */</comment>
		<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>coll</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>origexpr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>newcoll</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>coll</name><operator>-&gt;</operator><name>collOid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>coll</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcoll</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * coerce_type()
 *		Convert an expression to a different type.
 *
 * The caller should already have determined that the coercion is possible;
 * see can_coerce_type.
 *
 * Normally, no coercion to a typmod (length) is performed here.  The caller
 * must call coerce_type_typmod as well, if a typmod constraint is wanted.
 * (But if the target type is a domain, it may internally contain a
 * typmod constraint, which will be applied inside coerce_to_domain.)
 * In some cases pg_cast specifies a type coercion function that also
 * applies length conversion, and in those cases only, the result will
 * already be properly coerced to the specified typmod.
 *
 * pstate is only used in the case that we are able to resolve the type of
 * a previously UNKNOWN Param.  It is okay to pass pstate = NULL if the
 * caller does not want type information updated for Params.
 *
 * Note: this function must not modify the given expression tree, only add
 * decoration on top of it.  See transformSetOperationTree, for example.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>inputTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypeMod</name></decl></parameter>,
			<parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>, <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcId</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>inputTypeId</name> <operator>||</operator>
		<name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no conversion needed */</comment>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>ANYOID</name> <operator>||</operator>
		<name>targetTypeId</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
		<name>targetTypeId</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
		<name>targetTypeId</name> <operator>==</operator> <name>ANYCOMPATIBLEOID</name> <operator>||</operator>
		<name>targetTypeId</name> <operator>==</operator> <name>ANYCOMPATIBLENONARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Assume can_coerce_type verified that implicit coercion is okay.
		 *
		 * Note: by returning the unmodified node here, we are saying that
		 * it's OK to treat an UNKNOWN constant as a valid input for a
		 * function accepting one of these pseudotypes.  This should be all
		 * right, since an UNKNOWN value is still a perfectly valid Datum.
		 *
		 * NB: we do NOT want a RelabelType here: the exposed type of the
		 * function argument must be its actual type, not the polymorphic
		 * pseudotype.
		 */</comment>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>ANYARRAYOID</name> <operator>||</operator>
		<name>targetTypeId</name> <operator>==</operator> <name>ANYENUMOID</name> <operator>||</operator>
		<name>targetTypeId</name> <operator>==</operator> <name>ANYRANGEOID</name> <operator>||</operator>
		<name>targetTypeId</name> <operator>==</operator> <name>ANYCOMPATIBLEARRAYOID</name> <operator>||</operator>
		<name>targetTypeId</name> <operator>==</operator> <name>ANYCOMPATIBLERANGEOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Assume can_coerce_type verified that implicit coercion is okay.
		 *
		 * These cases are unlike the ones above because the exposed type of
		 * the argument must be an actual array, enum, or range type.  In
		 * particular the argument must *not* be an UNKNOWN constant.  If it
		 * is, we just fall through; below, we'll call the pseudotype's input
		 * function, which will produce an error.  Also, if what we have is a
		 * domain over array, enum, or range, we have to relabel it to its
		 * base type.
		 *
		 * Note: currently, we can't actually see a domain-over-enum here,
		 * since the other functions in this file will not match such a
		 * parameter to ANYENUM.  But that should get changed eventually.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeId</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>!=</operator> <name>inputTypeId</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												 <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												 <argument><expr><name>InvalidOid</name></expr></argument>,
												 <argument><expr><name>cformat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Not a domain type, so return it as-is */</comment>
			<return>return <expr><name>node</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Input is a string constant with previously undetermined type. Apply
		 * the target type's typinput function to it to produce a constant of
		 * the target type.
		 *
		 * NOTE: this case cannot be folded together with the other
		 * constant-input case, since the typinput function does not
		 * necessarily behave the same as a type conversion function. For
		 * example, int4's typinput function will reject "1.2", whereas
		 * float-to-int type conversion will round to integer.
		 *
		 * XXX if the typinput function is not immutable, we really ought to
		 * postpone evaluation of the function call until runtime. But there
		 * is no way to represent a typinput function call as an expression
		 * tree, because C-string values are not Datums. (XXX This *is*
		 * possible as of 7.3, do we want to do it?)
		 */</comment>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>newcon</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>baseTypeMod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>inputTypeMod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Type</name></type>		<name>baseType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the target type is a domain, we want to call its base type's
		 * input routine, not domain_in().  This is to avoid premature failure
		 * when the domain applies a typmod: existing input routines follow
		 * implicit-coercion semantics for length checks, which is not always
		 * what we want here.  The needed check will be applied properly
		 * inside coerce_to_domain().
		 */</comment>
		<expr_stmt><expr><name>baseTypeMod</name> <operator>=</operator> <name>targetTypeMod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For most types we pass typmod -1 to the input routine, because
		 * existing input routines follow implicit-coercion semantics for
		 * length checks, which is not always what we want here.  Any length
		 * constraint will be applied later by our caller.  An exception
		 * however is the INTERVAL type, for which we *must* pass the typmod
		 * or it won't be able to obey the bizarre SQL-spec input rules. (Ugly
		 * as sin, but so is this part of the spec...)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>==</operator> <name>INTERVALOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inputTypeMod</name> <operator>=</operator> <name>baseTypeMod</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>inputTypeMod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>baseType</name> <operator>=</operator> <call><name>typeidType</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>baseTypeId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>=</operator> <name>inputTypeMod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>=</operator> <call><name>typeTypeCollation</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <call><name>typeLen</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <call><name>typeByVal</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We use the original literal's location regardless of the position
		 * of the coercion.  This is a change from pre-9.2 behavior, meant to
		 * simplify life for pg_stat_statements.
		 */</comment>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set up to point at the constant's text if the input routine throws
		 * an error.
		 */</comment>
		<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We assume here that UNKNOWN's internal representation is the same
		 * as CSTRING.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>stringTypeDatum</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>,
												 <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>inputTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>stringTypeDatum</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>,
												 <argument><expr><name>inputTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If it's a varlena value, force it to be in non-expanded
		 * (non-toasted) format; this avoids any possible dependency on
		 * external values and improves consistency of representation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <name><name>newcon</name><operator>-&gt;</operator><name>constlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator>
				<call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RANDOMIZE_ALLOCATED_MEMORY</name></cpp:ifdef>

		<comment type="block">/*
		 * For pass-by-reference data types, repeat the conversion to see if
		 * the input function leaves any uninitialized bytes in the result. We
		 * can only detect that reliably if RANDOMIZE_ALLOCATED_MEMORY is
		 * enabled, so we don't bother testing otherwise.  The reason we don't
		 * want any instability in the input function is that comparison of
		 * Const nodes relies on bytewise comparison of the datums, so if the
		 * input function leaves garbage then subexpressions that should be
		 * identical may not get recognized as such.  See pgsql-hackers
		 * discussion of 2008-04-04.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>newcon</name><operator>-&gt;</operator><name>constbyval</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>val2</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>val2</name> <operator>=</operator> <call><name>stringTypeDatum</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>,
								   <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>inputTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>newcon</name><operator>-&gt;</operator><name>constlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>val2</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>val2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>datumIsEqual</name><argument_list>(<argument><expr><name><name>newcon</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name>val2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>newcon</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"type %s has unstable input conversion for \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>typeTypeName</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcon</name></expr>;</expr_stmt>

		<comment type="block">/* If target is a domain, apply constraints. */</comment>
		<if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>!=</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_domain</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
									  <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
									  <argument><expr><name>targetTypeId</name></expr></argument>,
									  <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>pstate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_coerce_param_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Allow the CoerceParamHook to decide what happens.  It can return a
		 * transformed node (very possibly the same Param node), or return
		 * NULL to indicate we should proceed with normal coercion.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>pstate</name><operator>-&gt;</operator><name>p_coerce_param_hook</name></name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
											 <argument><expr><name>targetTypeId</name></expr></argument>,
											 <argument><expr><name>targetTypeMod</name></expr></argument>,
											 <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we have a COLLATE clause, we have to push the coercion
		 * underneath the COLLATE; or discard the COLLATE if the target type
		 * isn't collatable.  This is really ugly, but there is little choice
		 * because the above hacks on Consts and Params wouldn't happen
		 * otherwise.  This kluge has consequences in coerce_to_target_type.
		 */</comment>
		<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>coll</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>coll</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
							 <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>targetTypeMod</name></expr></argument>,
							 <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>newcoll</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>coll</name><operator>-&gt;</operator><name>collOid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcoll</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>coll</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcoll</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pathtype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>ccontext</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>funcId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_NONE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Generate an expression tree representing run-time application
			 * of the conversion function.  If we are dealing with a domain
			 * target type, the conversion function will yield the base type,
			 * and we need to extract the correct typmod to use from the
			 * domain's typtypmod.
			 */</comment>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>baseTypeMod</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>baseTypeMod</name> <operator>=</operator> <name>targetTypeMod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>build_coercion_expression</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pathtype</name></expr></argument>, <argument><expr><name>funcId</name></expr></argument>,
											   <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
											   <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If domain, coerce to the domain type and relabel with domain
			 * type ID, hiding the previous coercion node.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>!=</operator> <name>baseTypeId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_domain</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
										  <argument><expr><name>targetTypeId</name></expr></argument>,
										  <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We don't need to do a physical conversion, but we do need to
			 * attach a RelabelType node so that the expression will be seen
			 * to have the intended type when inspected by higher-level code.
			 *
			 * Also, domains may have value restrictions beyond the base type
			 * that must be accounted for.  If the destination is a domain
			 * then we won't need a RelabelType node.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_domain</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>,
									  <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>node</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * XXX could we label result with exprTypmod(node) instead of
				 * default -1 typmod, to save a possible length-coercion
				 * later? Would work if both types have same interpretation of
				 * typmod, which is likely but not certain.
				 */</comment>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>,
												 <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												 <argument><expr><name>InvalidOid</name></expr></argument>,
												 <argument><expr><name>cformat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
		<call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Coerce a RECORD to a specific complex type */</comment>
		<return>return <expr><call><name>coerce_record_to_complex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>,
										<argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
		<call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Coerce a specific complex type to RECORD */</comment>
		<comment type="block">/* NB: we do NOT want a RelabelType here */</comment>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>&amp;&amp;</operator>
		<call><name>is_complex_array</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Coerce record[] to a specific complex array type */</comment>
		<comment type="block">/* not implemented yet ... */</comment>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>&amp;&amp;</operator>
		<call><name>is_complex_array</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Coerce a specific complex array type to record[] */</comment>
		<comment type="block">/* NB: we do NOT want a RelabelType here */</comment>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>typeInheritsFrom</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call>
		<operator>||</operator> <call><name>typeIsOfTypedTable</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Input class type is a subclass of target, so generate an
		 * appropriate runtime conversion (removing unneeded columns and
		 * possibly rearranging the ones that are wanted).
		 *
		 * We will also get here when the input is a domain over a subclass of
		 * the target type.  To keep life simple for the executor, we define
		 * ConvertRowtypeExpr as only working between regular composite types;
		 * therefore, in such cases insert a RelabelType to smash the input
		 * expression down to its base type.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeId</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>!=</operator> <name>inputTypeId</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><call><name>makeRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
											  <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>InvalidOid</name></expr></argument>,
											  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rt</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rt</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>targetTypeId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* If we get here, caller blew it */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find conversion function from %s to %s"</literal></expr></argument>,
		 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * can_coerce_type()
 *		Can input_typeids be coerced to target_typeids?
 *
 * We must be told the context (CAST construct, assignment, implicit coercion)
 * as this determines the set of available casts.
 */</comment>
<function><type><name>bool</name></type>
<name>can_coerce_type</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>input_typeids</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>target_typeids</name></decl></parameter>,
				<parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_generics</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* run through argument list... */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>inputTypeId</name> <init>= <expr><name><name>input_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>targetTypeId</name> <init>= <expr><name><name>target_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>funcId</name></decl>;</decl_stmt>

		<comment type="block">/* no problem if same type */</comment>
		<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* accept if target is ANY */</comment>
		<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>ANYOID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* accept if target is polymorphic, for now */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>have_generics</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* do more checking later */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If input is an untyped string constant, assume we can convert it to
		 * anything.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If pg_cast shows that we can coerce, accept.  This test now covers
		 * both binary-compatible and coercion-function cases.
		 */</comment>
		<expr_stmt><expr><name>pathtype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>ccontext</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>funcId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If input is RECORD and target is a composite type, assume we can
		 * coerce (may need tighter checking here)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
			<call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If input is a composite type and target is RECORD, accept
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
			<call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>					<comment type="block">/* not implemented yet */</comment>

		<comment type="block">/*
		 * If input is record[] and target is a composite array type, assume
		 * we can coerce (may need tighter checking here)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>&amp;&amp;</operator>
			<call><name>is_complex_array</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * If input is a composite array type and target is record[], accept
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>&amp;&amp;</operator>
			<call><name>is_complex_array</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If input is a class type that inherits from target, accept
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>typeInheritsFrom</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>typeIsOfTypedTable</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Else, cannot coerce at this argument position
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></for>

	<comment type="block">/* If we found any generic argument types, cross-check them */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_generics</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_generic_type_consistency</name><argument_list>(<argument><expr><name>input_typeids</name></expr></argument>, <argument><expr><name>target_typeids</name></expr></argument>,
											<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create an expression tree to represent coercion to a domain type.
 *
 * 'arg': input expression
 * 'baseTypeId': base type of domain, if known (pass InvalidOid if caller
 *		has not bothered to look this up)
 * 'baseTypeMod': base type typmod of domain, if known (pass -1 if caller
 *		has not bothered to look this up)
 * 'typeId': target type to coerce to
 * 'ccontext': context indicator to control coercions
 * 'cformat': coercion display format
 * 'location': coercion request location
 * 'hideInputCoercion': if true, hide the input coercion under this one.
 *
 * If the target type isn't a domain, the given 'arg' is returned as-is.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_domain</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>baseTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>baseTypeMod</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>,
				 <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>, <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>hideInputCoercion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Get the base type if it hasn't been supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If it isn't a domain, return the node as it was passed in */</comment>
	<if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>==</operator> <name>typeId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>arg</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Suppress display of nested coercion steps */</comment>
	<if_stmt><if>if <condition>(<expr><name>hideInputCoercion</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hide_coercion_node</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the domain applies a typmod to its base type, build the appropriate
	 * coercion step.  Mark it implicit for display purposes, because we don't
	 * want it shown separately by ruleutils.c; but the isExplicit flag passed
	 * to the conversion function depends on the manner in which the domain
	 * coercion is invoked, so that the semantics of implicit and explicit
	 * coercion differ.  (Is that really the behavior we want?)
	 *
	 * NOTE: because we apply this as part of the fixed expression structure,
	 * ALTER DOMAIN cannot alter the typtypmod.  But it's unclear that that
	 * would be safe to do anyway, without lots of knowledge about what the
	 * base type thinks the typmod means.
	 */</comment>
	<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_type_typmod</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
							 <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now build the domain coercion node.  This represents run-time checking
	 * of any constraints currently attached to the domain.  This also ensures
	 * that the expression is properly labeled as to result type.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>typeId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* currently, always -1 for domains */</comment>
	<comment type="block">/* resultcollid will be set by parse_collate.c */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * coerce_type_typmod()
 *		Force a value to a particular typmod, if meaningful and possible.
 *
 * This is applied to values that are going to be stored in a relation
 * (where we have an atttypmod for the column) as well as values being
 * explicitly CASTed (where the typmod comes from the target type spec).
 *
 * The caller must have already ensured that the value is of the correct
 * type, typically by applying coerce_type.
 *
 * ccontext may affect semantics, depending on whether the length coercion
 * function pays attention to the isExplicit flag it's passed.
 *
 * cformat determines the display properties of the generated node (if any).
 *
 * If hideInputCoercion is true *and* we generate a node, the input node is
 * forced to IMPLICIT display form, so that only the typmod coercion node will
 * be visible when displaying the expression.
 *
 * NOTE: this does not need to work on domain types, because any typmod
 * coercion for a domain is considered to be part of the type coercion
 * needed to produce the domain value in the first place.  So, no getBaseType.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>coerce_type_typmod</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
				   <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>, <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>hideInputCoercion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcId</name></decl>;</decl_stmt>

	<comment type="block">/* Skip coercion if already done */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetTypMod</name> <operator>==</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Suppress display of nested coercion steps */</comment>
	<if_stmt><if>if <condition>(<expr><name>hideInputCoercion</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hide_coercion_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A negative typmod means that no actual coercion is needed, but we still
	 * want a RelabelType to ensure that the expression exposes the intended
	 * typmod.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetTypMod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pathtype</name> <operator>=</operator> <name>COERCION_PATH_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>pathtype</name> <operator>=</operator> <call><name>find_typmod_coercion_function</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funcId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>build_coercion_expression</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pathtype</name></expr></argument>, <argument><expr><name>funcId</name></expr></argument>,
										 <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>targetTypMod</name></expr></argument>,
										 <argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We don't need to perform any actual coercion step, but we should
		 * apply a RelabelType to ensure that the expression exposes the
		 * intended typmod.
		 */</comment>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>applyRelabelType</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>targetTypMod</name></expr></argument>,
								<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a coercion node as IMPLICIT so it will never be displayed by
 * ruleutils.c.  We use this when we generate a nest of coercion nodes
 * to implement what is logically one conversion; the inner nodes are
 * forced to IMPLICIT_CAST format.  This does not change their semantics,
 * only display behavior.
 *
 * It is caller error to call this on something that doesn't have a
 * CoercionForm field.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hide_coercion_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>relabelformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>coerceformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>coerceformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>convertformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>row_format</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>coercionformat</name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * build_coercion_expression()
 *		Construct an expression tree for applying a pg_cast entry.
 *
 * This is used for both type-coercion and length-coercion operations,
 * since there is no difference in terms of the calling convention.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>build_coercion_expression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						  <parameter><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>funcId</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypMod</name></decl></parameter>,
						  <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>, <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procstruct</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>procstruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * These Asserts essentially check that function is a legal coercion
		 * function.  We can't make the seemingly obvious tests on prorettype
		 * and proargtypes[0], even in the COERCION_PATH_FUNC case, because of
		 * various binary-compatibility cases.
		 */</comment>
		<comment type="block">/* Assert(targetTypeId == procstruct-&gt;prorettype); */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>procstruct</name><operator>-&gt;</operator><name>proretset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>procstruct</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Assert(procstruct-&gt;proargtypes.values[0] == exprType(node)); */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>INT4OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>||</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>BOOLOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>==</operator> <name>COERCION_PATH_FUNC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We build an ordinary FuncExpr with special arguments */</comment>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>cons</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Pass target typmod as an int4 constant */</comment>
			<expr_stmt><expr><name>cons</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>targetTypMod</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>cons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Pass it a boolean isExplicit parameter, too */</comment>
			<expr_stmt><expr><name>cons</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>BOOLOID</name></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>ccontext</name> <operator>==</operator> <name>COERCION_EXPLICIT</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>cons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>args</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>pathtype</name> <operator>==</operator> <name>COERCION_PATH_ARRAYCOERCE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We need to build an ArrayCoerceExpr */</comment>
		<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>ctest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>sourceBaseTypeId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>sourceBaseTypeMod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>targetElementType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elemexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Look through any domain over the source array type.  Note we don't
		 * expect that the target type is a domain; it must be a plain array.
		 * (To get to a domain target type, we'll do coerce_to_domain later.)
		 */</comment>
		<expr_stmt><expr><name>sourceBaseTypeMod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sourceBaseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>sourceBaseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set up a CaseTestExpr representing one element of the source array.
		 * This is an abuse of CaseTestExpr, but it's OK as long as there
		 * can't be any CaseExpr or ArrayCoerceExpr within the completed
		 * elemexpr.
		 */</comment>
		<expr_stmt><expr><name><name>ctest</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>sourceBaseTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctest</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <name>sourceBaseTypeMod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctest</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* Assume coercions don't care */</comment>

		<comment type="block">/* And coerce it to the target element type */</comment>
		<expr_stmt><expr><name>targetElementType</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>targetElementType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>elemexpr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ctest</name></expr></argument>,
										 <argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>typeId</name></name></expr></argument>,
										 <argument><expr><name>targetElementType</name></expr></argument>,
										 <argument><expr><name>targetTypMod</name></expr></argument>,
										 <argument><expr><name>ccontext</name></expr></argument>,
										 <argument><expr><name>cformat</name></expr></argument>,
										 <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>elemexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to coerce array element type as expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>elemexpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>targetTypeId</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Label the output as having a particular element typmod only if we
		 * ended up with a per-element expression that is labeled that way.
		 */</comment>
		<expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>elemexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* resultcollid will be set by parse_collate.c */</comment>
		<expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>acoerce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>acoerce</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>pathtype</name> <operator>==</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We need to build a CoerceViaIO node */</comment>
		<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>targetTypeId</name></expr>;</expr_stmt>
		<comment type="block">/* resultcollid will be set by parse_collate.c */</comment>
		<expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>iocoerce</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported pathtype %d in build_coercion_expression"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>pathtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * coerce_record_to_complex
 *		Coerce a RECORD to a specific composite type.
 *
 * Currently we only support this for inputs that are RowExprs or whole-row
 * Vars.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>coerce_record_to_complex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
						 <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>,
						 <parameter><decl><type><name>CoercionForm</name></type> <name>cformat</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>baseTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ucolno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Since the RowExpr must be of type RECORD, we needn't worry about it
		 * containing any dropped columns.
		 */</comment>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varno</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>vlocation</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>GetNSItemByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>expandNSItemVars</name><argument_list>(<argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>, <argument><expr><name>vlocation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Look up the composite type, accounting for possibility that what we are
	 * given is a domain over composite.
	 */</comment>
	<expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process the fields */</comment>
	<expr_stmt><expr><name>newargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ucolno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>exprtype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Fill in NULLs for dropped columns in rowtype */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * can't use atttypid here, but it doesn't really matter what type
			 * the Const claims to be.
			 */</comment>
			<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>,
							  <argument><expr><call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Input has too few columns."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exprtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									  <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>,
									  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
									  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
									  <argument><expr><name>ccontext</name></expr></argument>,
									  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
									  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot cast type %s to %s in column %d."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>exprtype</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>ucolno</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ucolno</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Input has too many columns."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rowexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name>baseTypeId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>cformat</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* not needed for named target type */</comment>
	<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<comment type="block">/* If target is a domain, apply constraints */</comment>
	<if_stmt><if>if <condition>(<expr><name>baseTypeId</name> <operator>!=</operator> <name>targetTypeId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
		<return>return <expr><call><name>coerce_to_domain</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rowexpr</name></expr></argument>,
								<argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>,
								<argument><expr><name>targetTypeId</name></expr></argument>,
								<argument><expr><name>ccontext</name></expr></argument>, <argument><expr><name>cformat</name></expr></argument>, <argument><expr><name>location</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rowexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * coerce_to_boolean()
 *		Coerce an argument of a construct that requires boolean input
 *		(AND, OR, NOT, etc).  Also check that input is not a set.
 *
 * Returns the possibly-transformed node tree.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_boolean</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inputTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>,
										<argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
										<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: first %s is name of a SQL construct, eg WHERE */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must be type %s, not type %s"</literal></expr></argument>,
							<argument><expr><name>constructName</name></expr></argument>, <argument><expr><literal type="string">"boolean"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name>newnode</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg WHERE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must not return a set"</literal></expr></argument>,
						<argument><expr><name>constructName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * coerce_to_specific_type_typmod()
 *		Coerce an argument of a construct that requires a specific data type,
 *		with a specific typmod.  Also check that input is not a set.
 *
 * Returns the possibly-transformed node tree.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_specific_type_typmod</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetTypmod</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inputTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>!=</operator> <name>targetTypeId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>,
										<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>targetTypmod</name></expr></argument>,
										<argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
										<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: first %s is name of a SQL construct, eg LIMIT */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must be type %s, not type %s"</literal></expr></argument>,
							<argument><expr><name>constructName</name></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name>newnode</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg LIMIT */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must not return a set"</literal></expr></argument>,
						<argument><expr><name>constructName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * coerce_to_specific_type()
 *		Coerce an argument of a construct that requires a specific data type.
 *		Also check that input is not a set.
 *
 * Returns the possibly-transformed node tree.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_specific_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constructName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>coerce_to_specific_type_typmod</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
										  <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										  <argument><expr><name>constructName</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parser_coercion_errposition - report coercion error location, if possible
 *
 * We prefer to point at the coercion request (CAST, ::, etc) if possible;
 * but there may be no such location in the case of an implicit coercion.
 * In that case point at the input expression.
 *
 * XXX possibly this is more generally useful than coercion errors;
 * if so, should rename and place with parser_errposition.
 */</comment>
<function><type><name>int</name></type>
<name>parser_coercion_errposition</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>coerce_location</name></decl></parameter>,
							<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>input_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>coerce_location</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>coerce_location</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>input_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * select_common_type()
 *		Determine the common supertype of a list of input expressions.
 *		This is used for determining the output type of CASE, UNION,
 *		and similar constructs.
 *
 * 'exprs' is a *nonempty* list of expressions.  Note that earlier items
 * in the list will be preferred if there is doubt.
 * 'context' is a phrase to use in the error message if we fail to select
 * a usable type.  Pass NULL to have the routine return InvalidOid
 * rather than throwing an error on failure.
 * 'which_expr': if not NULL, receives a pointer to the particular input
 * expression from which the result type was taken.
 *
 * Caution: "failure" just means that there were inputs of different type
 * categories.  It is not guaranteed that all the inputs are coercible to the
 * selected type; caller must check that (see verify_common_type).
 */</comment>
<function><type><name>Oid</name></type>
<name>select_common_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				   <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>which_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>pexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TYPCATEGORY</name></type> <name>pcategory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pispreferred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>exprs</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_second_cell</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>pexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If all input types are valid and exactly the same, just pick that type.
	 * This is the only way that we will resolve the result as being a domain
	 * type; otherwise domains are smashed to their base types for comparison.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>, <argument>lc</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ntype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>nexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>!=</operator> <name>ptype</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>			<comment type="block">/* got to the end of the list? */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>which_expr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>which_expr</name> <operator>=</operator> <name>pexpr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>ptype</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Nope, so set up for the full algorithm.  Note that at this point, lc
	 * points to the first list item with type different from pexpr's; we need
	 * not re-examine any items the previous loop advanced over.
	 */</comment>
	<expr_stmt><expr><name>ptype</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>, <argument>lc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ntype</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>nexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* move on to next one if no new information... */</comment>
		<if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>!=</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator> <name>ntype</name> <operator>!=</operator> <name>ptype</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TYPCATEGORY</name></type> <name>ncategory</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>nispreferred</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>ntype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ncategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* so far, only unknowns so take anything... */</comment>
				<expr_stmt><expr><name>pexpr</name> <operator>=</operator> <name>nexpr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>ntype</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pcategory</name> <operator>=</operator> <name>ncategory</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pispreferred</name> <operator>=</operator> <name>nispreferred</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>ncategory</name> <operator>!=</operator> <name>pcategory</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * both types in different categories? then not much hope...
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/*------
				  translator: first %s is name of a SQL construct, eg CASE */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s types %s and %s cannot be matched"</literal></expr></argument>,
								<argument><expr><name>context</name></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ntype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>nexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name>pispreferred</name> <operator>&amp;&amp;</operator>
					 <call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptype</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * take new type if can coerce to it implicitly but not the
				 * other way; but if we have a preferred type, stay on it.
				 */</comment>
				<expr_stmt><expr><name>pexpr</name> <operator>=</operator> <name>nexpr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>ntype</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pcategory</name> <operator>=</operator> <name>ncategory</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pispreferred</name> <operator>=</operator> <name>nispreferred</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If all the inputs were UNKNOWN type --- ie, unknown-type literals ---
	 * then resolve as type TEXT.  This situation comes up with constructs
	 * like SELECT (CASE WHEN foo THEN 'bar' ELSE 'baz' END); SELECT 'foo'
	 * UNION SELECT 'bar'; It might seem desirable to leave the construct's
	 * output type as UNKNOWN, but that really doesn't work, because we'd
	 * probably end up needing a runtime coercion from UNKNOWN to something
	 * else, and we usually won't have it.  We need to coerce the unknown
	 * literals while they are still literals, so a decision has to be made
	 * now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>which_expr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>which_expr</name> <operator>=</operator> <name>pexpr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ptype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * select_common_type_from_oids()
 *		Determine the common supertype of an array of type OIDs.
 *
 * This is the same logic as select_common_type(), but working from
 * an array of type OIDs not a list of expressions.  As in that function,
 * earlier entries in the array have some preference over later ones.
 * On failure, return InvalidOid if noerror is true, else throw an error.
 *
 * Caution: "failure" just means that there were inputs of different type
 * categories.  It is not guaranteed that all the inputs are coercible to the
 * selected type; caller must check that (see verify_common_type_from_oids).
 *
 * Note: neither caller will pass any UNKNOWNOID entries, so the tests
 * for that in this function are dead code.  However, they don't cost much,
 * and it seems better to keep this logic as close to select_common_type()
 * as possible.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>select_common_type_from_oids</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>typeids</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noerror</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TYPCATEGORY</name></type> <name>pcategory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pispreferred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name><name>typeids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* If all input types are valid and exactly the same, pick that type. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>ptype</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ptype</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Nope, so set up for the full algorithm.  Note that at this point, we
	 * can skip array entries before "i"; they are all equal to ptype.
	 */</comment>
	<expr_stmt><expr><name>ptype</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ntype</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name><name>typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* move on to next one if no new information... */</comment>
		<if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>!=</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator> <name>ntype</name> <operator>!=</operator> <name>ptype</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TYPCATEGORY</name></type> <name>ncategory</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>nispreferred</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>ntype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ncategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* so far, only unknowns so take anything... */</comment>
				<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>ntype</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pcategory</name> <operator>=</operator> <name>ncategory</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pispreferred</name> <operator>=</operator> <name>nispreferred</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>ncategory</name> <operator>!=</operator> <name>pcategory</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * both types in different categories? then not much hope...
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>noerror</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument types %s and %s cannot be matched"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ntype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name>pispreferred</name> <operator>&amp;&amp;</operator>
					 <call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptype</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * take new type if can coerce to it implicitly but not the
				 * other way; but if we have a preferred type, stay on it.
				 */</comment>
				<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>ntype</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pcategory</name> <operator>=</operator> <name>ncategory</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pispreferred</name> <operator>=</operator> <name>nispreferred</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Like select_common_type(), choose TEXT if all inputs were UNKNOWN */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ptype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * coerce_to_common_type()
 *		Coerce an expression to the given type.
 *
 * This is used following select_common_type() to coerce the individual
 * expressions to the desired type.  'context' is a phrase to use in the
 * error message if we fail to coerce.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>coerce_to_common_type</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inputTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>inputTypeId</name> <operator>==</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no work */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>inputTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targetTypeId</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						   <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: first %s is name of a SQL construct, eg CASE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s could not convert type %s to %s"</literal></expr></argument>,
						<argument><expr><name>context</name></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputTypeId</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * verify_common_type()
 *		Verify that all input types can be coerced to a proposed common type.
 *		Return true if so, false if not all coercions are possible.
 *
 * Most callers of select_common_type() don't need to do this explicitly
 * because the checks will happen while trying to convert input expressions
 * to the right type, e.g. in coerce_to_common_type().  However, if a separate
 * check step is needed to validate the applicability of the common type, call
 * this.
 */</comment>
<function><type><name>bool</name></type>
<name>verify_common_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>common_type</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ntype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>nexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>common_type</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * verify_common_type_from_oids()
 *		As above, but work from an array of type OIDs.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>verify_common_type_from_oids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>common_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>typeids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>common_type</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_generic_type_consistency()
 *		Are the actual arguments potentially compatible with a
 *		polymorphic function?
 *
 * The argument consistency rules are:
 *
 * 1) All arguments declared ANYELEMENT must have the same datatype.
 * 2) All arguments declared ANYARRAY must have the same datatype,
 *	  which must be a varlena array type.
 * 3) All arguments declared ANYRANGE must have the same datatype,
 *	  which must be a range type.
 * 4) If there are arguments of more than one of these polymorphic types,
 *	  the array element type and/or range subtype must be the same as each
 *	  other and the same as the ANYELEMENT type.
 * 5) ANYENUM is treated the same as ANYELEMENT except that if it is used
 *	  (alone or in combination with plain ANYELEMENT), we add the extra
 *	  condition that the ANYELEMENT type must be an enum.
 * 6) ANYNONARRAY is treated the same as ANYELEMENT except that if it is used,
 *	  we add the extra condition that the ANYELEMENT type must not be an array.
 *	  (This is a no-op if used in combination with ANYARRAY or ANYENUM, but
 *	  is an extra restriction if not.)
 * 7) All arguments declared ANYCOMPATIBLE must be implicitly castable
 *	  to a common supertype (chosen as per select_common_type's rules).
 *	  ANYCOMPATIBLENONARRAY works like ANYCOMPATIBLE but also requires the
 *	  common supertype to not be an array.  If there are ANYCOMPATIBLEARRAY
 *	  or ANYCOMPATIBLERANGE arguments, their element types or subtypes are
 *	  included while making the choice of common supertype.
 * 8) The resolved type of ANYCOMPATIBLEARRAY arguments will be the array
 *	  type over the common supertype (which might not be the same array type
 *	  as any of the original arrays).
 * 9) All ANYCOMPATIBLERANGE arguments must be the exact same range type
 *	  (after domain flattening), since we have no preference rule that would
 *	  let us choose one over another.  Furthermore, that range's subtype
 *	  must exactly match the common supertype chosen by rule 7.
 *
 * Domains over arrays match ANYARRAY, and are immediately flattened to their
 * base type.  (Thus, for example, we will consider it a match if one ANYARRAY
 * argument is a domain over int4[] while another one is just int4[].)	Also
 * notice that such a domain does *not* match ANYNONARRAY.  The same goes
 * for ANYCOMPATIBLEARRAY and ANYCOMPATIBLENONARRAY.
 *
 * Similarly, domains over ranges match ANYRANGE or ANYCOMPATIBLERANGE,
 * and are immediately flattened to their base type.
 *
 * Note that domains aren't currently considered to match ANYENUM,
 * even if their base type would match.
 *
 * If we have UNKNOWN input (ie, an untyped literal) for any polymorphic
 * argument, assume it is okay.
 *
 * We do not ereport here, but just return false if a rule is violated.
 */</comment>
<function><type><name>bool</name></type>
<name>check_generic_type_consistency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>actual_arg_types</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>declared_arg_types</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elem_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>array_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>range_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anycompatible_range_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anycompatible_range_typelem</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anynonarray</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anyenum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_nonarray</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_anycompatible_args</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>anycompatible_actual_types</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Loop through the arguments to see if we have any that are polymorphic.
	 * If so, require the actual types to be consistent.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&lt;=</operator> <name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>decl_type</name> <init>= <expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>actual_type</name> <init>= <expr><name><name>actual_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
			<name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
			<name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_anynonarray</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_anyenum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>array_typeid</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>range_typeid</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>range_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLEOID</name> <operator>||</operator>
				 <name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLENONARRAYOID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLENONARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_anycompatible_nonarray</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* collect the actual types of non-unknown COMPATIBLE args */</comment>
			<expr_stmt><expr><name><name>anycompatible_actual_types</name><index>[<expr><name>n_anycompatible_args</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLEARRAYOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>elem_type</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
			<expr_stmt><expr><name>elem_type</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not an array */</comment>
			<comment type="block">/* collect the element type for common-supertype choice */</comment>
			<expr_stmt><expr><name><name>anycompatible_actual_types</name><index>[<expr><name>n_anycompatible_args</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>elem_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLERANGEOID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* All ANYCOMPATIBLERANGE arguments must be the same type */</comment>
				<if_stmt><if>if <condition>(<expr><name>anycompatible_range_typeid</name> <operator>!=</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>anycompatible_range_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>anycompatible_range_typelem</name> <operator>=</operator> <call><name>get_range_subtype</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_range_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not a range type */</comment>
				<comment type="block">/* collect the subtype for common-supertype choice */</comment>
				<expr_stmt><expr><name><name>anycompatible_actual_types</name><index>[<expr><name>n_anycompatible_args</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>anycompatible_range_typelem</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Get the element type based on the array type, if we have one */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>array_typeid</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Special case for matching ANYARRAY input to an ANYARRAY
			 * argument: allow it for now.  enforce_generic_type_consistency()
			 * might complain later, depending on the presence of other
			 * polymorphic arguments or results, but it will deliver a less
			 * surprising error message than "function does not exist".
			 *
			 * (If you think to change this, note that can_coerce_type will
			 * consider such a situation as a match, so that we might not even
			 * get here.)
			 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>array_typelem</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>array_typelem</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* should be an array, but isn't */</comment>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * if we don't have an element type yet, use the one we just
				 * got
				 */</comment>
				<expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>array_typelem</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>array_typelem</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* otherwise, they better match */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the element type based on the range type, if we have one */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>range_typelem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>range_typelem</name> <operator>=</operator> <call><name>get_range_subtype</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* should be a range, but isn't */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * if we don't have an element type yet, use the one we just got
			 */</comment>
			<expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>range_typelem</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>range_typelem</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* otherwise, they better match */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anynonarray</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* require the element type to not be an array or domain over array */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>type_is_array_domain</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_anyenum</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* require the element type to be an enum */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_enum</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check matching of ANYCOMPATIBLE-family arguments, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>n_anycompatible_args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>anycompatible_typeid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>anycompatible_typeid</name> <operator>=</operator>
			<call><name>select_common_type_from_oids</name><argument_list>(<argument><expr><name>n_anycompatible_args</name></expr></argument>,
										 <argument><expr><name>anycompatible_actual_types</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* there's definitely no common supertype */</comment>

		<comment type="block">/* We have to verify that the selected type actually works */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_common_type_from_oids</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>,
										  <argument><expr><name>n_anycompatible_args</name></expr></argument>,
										  <argument><expr><name>anycompatible_actual_types</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>have_anycompatible_nonarray</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * require the anycompatible type to not be an array or domain
			 * over array
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>type_is_array_domain</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * the anycompatible type must exactly match the range element type,
		 * if we were able to identify one
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_range_typelem</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>anycompatible_range_typelem</name> <operator>!=</operator> <name>anycompatible_typeid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Looks valid */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * enforce_generic_type_consistency()
 *		Make sure a polymorphic function is legally callable, and
 *		deduce actual argument and result types.
 *
 * If any polymorphic pseudotype is used in a function's arguments or
 * return type, we make sure the actual data types are consistent with
 * each other.  The argument consistency rules are shown above for
 * check_generic_type_consistency().
 *
 * If we have UNKNOWN input (ie, an untyped literal) for any polymorphic
 * argument, we attempt to deduce the actual type it should have.  If
 * successful, we alter that position of declared_arg_types[] so that
 * make_fn_arguments will coerce the literal to the right thing.
 *
 * If we have polymorphic arguments of the ANYCOMPATIBLE family,
 * we similarly alter declared_arg_types[] entries to show the resolved
 * common supertype, so that make_fn_arguments will coerce the actual
 * arguments to the proper type.
 *
 * Rules are applied to the function's return type (possibly altering it)
 * if it is declared as a polymorphic type and there is at least one
 * polymorphic argument type:
 *
 * 1) If return type is ANYELEMENT, and any argument is ANYELEMENT, use the
 *	  argument's actual type as the function's return type.
 * 2) If return type is ANYARRAY, and any argument is ANYARRAY, use the
 *	  argument's actual type as the function's return type.
 * 3) Similarly, if return type is ANYRANGE, and any argument is ANYRANGE,
 *	  use the argument's actual type as the function's return type.
 * 4) Otherwise, if return type is ANYELEMENT or ANYARRAY, and there is
 *	  at least one ANYELEMENT, ANYARRAY, or ANYRANGE input, deduce the
 *	  return type from those inputs, or throw error if we can't.
 * 5) Otherwise, if return type is ANYRANGE, throw error.  (We have no way to
 *	  select a specific range type if the arguments don't include ANYRANGE.)
 * 6) ANYENUM is treated the same as ANYELEMENT except that if it is used
 *	  (alone or in combination with plain ANYELEMENT), we add the extra
 *	  condition that the ANYELEMENT type must be an enum.
 * 7) ANYNONARRAY is treated the same as ANYELEMENT except that if it is used,
 *	  we add the extra condition that the ANYELEMENT type must not be an array.
 *	  (This is a no-op if used in combination with ANYARRAY or ANYENUM, but
 *	  is an extra restriction if not.)
 * 8) ANYCOMPATIBLE, ANYCOMPATIBLEARRAY, ANYCOMPATIBLENONARRAY, and
 *	  ANYCOMPATIBLERANGE are handled by resolving the common supertype
 *	  of those arguments (or their element types/subtypes, for array and range
 *	  inputs), and then coercing all those arguments to the common supertype,
 *	  or the array type over the common supertype for ANYCOMPATIBLEARRAY.
 *	  For ANYCOMPATIBLERANGE, there must be at least one non-UNKNOWN input,
 *	  all such inputs must be the same range type, and that type's subtype
 *	  must equal the common supertype.
 *
 * Domains over arrays or ranges match ANYARRAY or ANYRANGE arguments,
 * respectively, and are immediately flattened to their base type.  (In
 * particular, if the return type is also ANYARRAY or ANYRANGE, we'll set
 * it to the base type not the domain type.)  The same is true for
 * ANYCOMPATIBLEARRAY and ANYCOMPATIBLERANGE.
 *
 * When allow_poly is false, we are not expecting any of the actual_arg_types
 * to be polymorphic, and we should not return a polymorphic result type
 * either.  When allow_poly is true, it is okay to have polymorphic "actual"
 * arg types, and we can return a matching polymorphic type as the result.
 * (This case is currently used only to check compatibility of an aggregate's
 * declaration with the underlying transfn.)
 *
 * A special case is that we could see ANYARRAY as an actual_arg_type even
 * when allow_poly is false (this is possible only because pg_statistic has
 * columns shown as anyarray in the catalogs).  We allow this to match a
 * declared ANYARRAY argument, but only if there is no other polymorphic
 * argument that we would need to match it with, and no need to determine
 * the element type to infer the result type.  Note this means that functions
 * taking ANYARRAY had better behave sanely if applied to the pg_statistic
 * columns; they can't just assume that successive inputs are of the same
 * actual element type.  There is no similar logic for ANYCOMPATIBLEARRAY;
 * there isn't a need for it since there are no catalog columns of that type,
 * so we won't see it as input.  We could consider matching an actual ANYARRAY
 * input to an ANYCOMPATIBLEARRAY argument, but at present that seems useless
 * as well, since there's no value in using ANYCOMPATIBLEARRAY unless there's
 * at least one other ANYCOMPATIBLE-family argument or result.
 *
 * Also, if there are no arguments declared to be of polymorphic types,
 * we'll return the rettype unmodified even if it's polymorphic.  This should
 * never occur for user-declared functions, because CREATE FUNCTION prevents
 * it.  But it does happen for some built-in functions, such as array_in().
 */</comment>
<function><type><name>Oid</name></type>
<name>enforce_generic_type_consistency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>actual_arg_types</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>declared_arg_types</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>rettype</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>allow_poly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_poly_anycompatible</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_poly_unknowns</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elem_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>array_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>range_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anycompatible_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anycompatible_array_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anycompatible_range_typeid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>anycompatible_range_typelem</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anynonarray</name> <init>= <expr><operator>(</operator><name>rettype</name> <operator>==</operator> <name>ANYNONARRAYOID</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anyenum</name> <init>= <expr><operator>(</operator><name>rettype</name> <operator>==</operator> <name>ANYENUMOID</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_nonarray</name> <init>= <expr><operator>(</operator><name>rettype</name> <operator>==</operator> <name>ANYCOMPATIBLENONARRAYOID</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_array</name> <init>= <expr><operator>(</operator><name>rettype</name> <operator>==</operator> <name>ANYCOMPATIBLEARRAYOID</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_anycompatible_range</name> <init>= <expr><operator>(</operator><name>rettype</name> <operator>==</operator> <name>ANYCOMPATIBLERANGEOID</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_poly_args</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* this counts all family-1 arguments */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_anycompatible_args</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* this counts only non-unknowns */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>anycompatible_actual_types</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Loop through the arguments to see if we have any that are polymorphic.
	 * If so, require the actual types to be consistent.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&lt;=</operator> <name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>decl_type</name> <init>= <expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>actual_type</name> <init>= <expr><name><name>actual_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
			<name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
			<name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>n_poly_args</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_anynonarray</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_anyenum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>have_poly_unknowns</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>allow_poly</name> <operator>&amp;&amp;</operator> <name>decl_type</name> <operator>==</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no new information here */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments declared \"anyelement\" are not all alike"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>n_poly_args</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>have_poly_unknowns</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>allow_poly</name> <operator>&amp;&amp;</operator> <name>decl_type</name> <operator>==</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no new information here */</comment>
			<expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>array_typeid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments declared \"anyarray\" are not all alike"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>n_poly_args</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>have_poly_unknowns</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>allow_poly</name> <operator>&amp;&amp;</operator> <name>decl_type</name> <operator>==</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no new information here */</comment>
			<expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>actual_type</name> <operator>!=</operator> <name>range_typeid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments declared \"anyrange\" are not all alike"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>range_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLEOID</name> <operator>||</operator>
				 <name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLENONARRAYOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>have_poly_anycompatible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLENONARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_anycompatible_nonarray</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>allow_poly</name> <operator>&amp;&amp;</operator> <name>decl_type</name> <operator>==</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no new information here */</comment>
			<comment type="block">/* collect the actual types of non-unknown COMPATIBLE args */</comment>
			<expr_stmt><expr><name><name>anycompatible_actual_types</name><index>[<expr><name>n_anycompatible_args</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLEARRAYOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>anycompatible_elem_type</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>have_poly_anycompatible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_anycompatible_array</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>allow_poly</name> <operator>&amp;&amp;</operator> <name>decl_type</name> <operator>==</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no new information here */</comment>
			<expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
			<expr_stmt><expr><name>anycompatible_elem_type</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_elem_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not an array but type %s"</literal></expr></argument>,
								<argument><expr><literal type="string">"anycompatiblearray"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* collect the element type for common-supertype choice */</comment>
			<expr_stmt><expr><name><name>anycompatible_actual_types</name><index>[<expr><name>n_anycompatible_args</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>anycompatible_elem_type</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLERANGEOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>have_poly_anycompatible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_anycompatible_range</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>allow_poly</name> <operator>&amp;&amp;</operator> <name>decl_type</name> <operator>==</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no new information here */</comment>
			<expr_stmt><expr><name>actual_type</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* flatten domains */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* All ANYCOMPATIBLERANGE arguments must be the same type */</comment>
				<if_stmt><if>if <condition>(<expr><name>anycompatible_range_typeid</name> <operator>!=</operator> <name>actual_type</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments declared \"anycompatiblerange\" are not all alike"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
									   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>anycompatible_range_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>anycompatible_range_typeid</name> <operator>=</operator> <name>actual_type</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>anycompatible_range_typelem</name> <operator>=</operator> <call><name>get_range_subtype</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_range_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not a range type but type %s"</literal></expr></argument>,
									<argument><expr><literal type="string">"anycompatiblerange"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>actual_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* collect the subtype for common-supertype choice */</comment>
				<expr_stmt><expr><name><name>anycompatible_actual_types</name><index>[<expr><name>n_anycompatible_args</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>anycompatible_range_typelem</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Fast Track: if none of the arguments are polymorphic, return the
	 * unmodified rettype.  Not our job to resolve it if it's polymorphic.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n_poly_args</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>have_poly_anycompatible</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>rettype</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check matching of family-1 polymorphic arguments, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>n_poly_args</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the element type based on the array type, if we have one */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>array_typelem</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>array_typeid</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Special case for matching ANYARRAY input to an ANYARRAY
				 * argument: allow it iff no other arguments are family-1
				 * polymorphics (otherwise we couldn't be sure whether the
				 * array element type matches up) and the result type doesn't
				 * require us to infer a specific element type.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>n_poly_args</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
					<operator>(</operator><name>rettype</name> <operator>!=</operator> <name>ANYARRAYOID</name> <operator>&amp;&amp;</operator>
					 <call><name>IsPolymorphicTypeFamily1</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot determine element type of \"anyarray\" argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>array_typelem</name> <operator>=</operator> <name>ANYELEMENTOID</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>array_typelem</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not an array but type %s"</literal></expr></argument>,
									<argument><expr><literal type="string">"anyarray"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * if we don't have an element type yet, use the one we just
				 * got
				 */</comment>
				<expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>array_typelem</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>array_typelem</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* otherwise, they better match */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not consistent with argument declared %s"</literal></expr></argument>,
								<argument><expr><literal type="string">"anyarray"</literal></expr></argument>, <argument><expr><literal type="string">"anyelement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the element type based on the range type, if we have one */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>range_typelem</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>range_typelem</name> <operator>=</operator> <call><name>get_range_subtype</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typelem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not a range type but type %s"</literal></expr></argument>,
								<argument><expr><literal type="string">"anyrange"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * if we don't have an element type yet, use the one we just
				 * got
				 */</comment>
				<expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>range_typelem</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>range_typelem</name> <operator>!=</operator> <name>elem_typeid</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* otherwise, they better match */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument declared %s is not consistent with argument declared %s"</literal></expr></argument>,
								<argument><expr><literal type="string">"anyrange"</literal></expr></argument>, <argument><expr><literal type="string">"anyelement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>allow_poly</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>elem_typeid</name> <operator>=</operator> <name>ANYELEMENTOID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <name>ANYARRAYOID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>range_typeid</name> <operator>=</operator> <name>ANYRANGEOID</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Only way to get here is if all the family-1 polymorphic
				 * arguments have UNKNOWN inputs.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine polymorphic type because input has type %s"</literal></expr></argument>,
								<argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>have_anynonarray</name> <operator>&amp;&amp;</operator> <name>elem_typeid</name> <operator>!=</operator> <name>ANYELEMENTOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * require the element type to not be an array or domain over
			 * array
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>type_is_array_domain</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type matched to anynonarray is an array type: %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>have_anyenum</name> <operator>&amp;&amp;</operator> <name>elem_typeid</name> <operator>!=</operator> <name>ANYELEMENTOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* require the element type to be an enum */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_enum</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type matched to anyenum is not an enum type: %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check matching of family-2 polymorphic arguments, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_poly_anycompatible</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>n_anycompatible_args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>anycompatible_typeid</name> <operator>=</operator>
				<call><name>select_common_type_from_oids</name><argument_list>(<argument><expr><name>n_anycompatible_args</name></expr></argument>,
											 <argument><expr><name>anycompatible_actual_types</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We have to verify that the selected type actually works */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_common_type_from_oids</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>,
											  <argument><expr><name>n_anycompatible_args</name></expr></argument>,
											  <argument><expr><name>anycompatible_actual_types</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments of anycompatible family cannot be cast to a common type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>have_anycompatible_array</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>anycompatible_array_typeid</name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>have_anycompatible_range</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we can't infer a range type from the others */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine polymorphic type %s because input has type %s"</literal></expr></argument>,
									<argument><expr><literal type="string">"anycompatiblerange"</literal></expr></argument>, <argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * the anycompatible type must exactly match the range element
				 * type
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>anycompatible_range_typelem</name> <operator>!=</operator> <name>anycompatible_typeid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"anycompatiblerange type %s does not match anycompatible type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>anycompatible_range_typeid</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>have_anycompatible_nonarray</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * require the element type to not be an array or domain over
				 * array
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>type_is_array_domain</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type matched to anycompatiblenonarray is an array type: %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>allow_poly</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>anycompatible_typeid</name> <operator>=</operator> <name>ANYCOMPATIBLEOID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>anycompatible_array_typeid</name> <operator>=</operator> <name>ANYCOMPATIBLEARRAYOID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>anycompatible_range_typeid</name> <operator>=</operator> <name>ANYCOMPATIBLERANGEOID</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Only way to get here is if all the family-2 polymorphic
				 * arguments have UNKNOWN inputs.  Resolve to TEXT as
				 * select_common_type() would do.  That doesn't license us to
				 * use TEXTRANGE, though.
				 */</comment>
				<expr_stmt><expr><name>anycompatible_typeid</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>anycompatible_array_typeid</name> <operator>=</operator> <name>TEXTARRAYOID</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>have_anycompatible_range</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine polymorphic type %s because input has type %s"</literal></expr></argument>,
									<argument><expr><literal type="string">"anycompatiblerange"</literal></expr></argument>, <argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* replace family-2 polymorphic types by selected types */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>decl_type</name> <init>= <expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLEOID</name> <operator>||</operator>
				<name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLENONARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>anycompatible_typeid</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLEARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>anycompatible_array_typeid</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYCOMPATIBLERANGEOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>anycompatible_range_typeid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we had any UNKNOWN inputs for family-1 polymorphic arguments,
	 * re-scan to assign correct types to them.
	 *
	 * Note: we don't have to consider unknown inputs that were matched to
	 * family-2 polymorphic arguments, because we forcibly updated their
	 * declared_arg_types[] positions just above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_poly_unknowns</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>decl_type</name> <init>= <expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>actual_type</name> <init>= <expr><name><name>actual_arg_types</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>actual_type</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
				<name>decl_type</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
				<name>decl_type</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>elem_typeid</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
										<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>array_typeid</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>decl_type</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* we can't infer a range type from the others */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine polymorphic type %s because input has type %s"</literal></expr></argument>,
									<argument><expr><literal type="string">"anyrange"</literal></expr></argument>, <argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>declared_arg_types</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>range_typeid</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if we return ANYELEMENT use the appropriate argument type */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
		<name>rettype</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator>
		<name>rettype</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>elem_typeid</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if we return ANYARRAY use the appropriate argument type */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>array_typeid</name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elem_typeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>array_typeid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if we return ANYRANGE use the appropriate argument type */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this error is unreachable if the function signature is valid: */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine polymorphic type %s because input has type %s"</literal></expr></argument>,
							<argument><expr><literal type="string">"anyrange"</literal></expr></argument>, <argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>range_typeid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if we return ANYCOMPATIBLE use the appropriate type */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>ANYCOMPATIBLEOID</name> <operator>||</operator>
		<name>rettype</name> <operator>==</operator> <name>ANYCOMPATIBLENONARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this error is unreachable if the function signature is valid: */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not identify anycompatible type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>anycompatible_typeid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if we return ANYCOMPATIBLEARRAY use the appropriate type */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>ANYCOMPATIBLEARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this error is unreachable if the function signature is valid: */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_array_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not identify anycompatiblearray type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>anycompatible_array_typeid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if we return ANYCOMPATIBLERANGE use the appropriate argument type */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>ANYCOMPATIBLERANGEOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this error is unreachable if the function signature is valid: */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>anycompatible_range_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not identify anycompatiblerange type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>anycompatible_range_typeid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we don't return a generic type; send back the original return type */</comment>
	<return>return <expr><name>rettype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_valid_polymorphic_signature()
 *		Is a proposed function signature valid per polymorphism rules?
 *
 * Returns NULL if the signature is valid (either ret_type is not polymorphic,
 * or it can be deduced from the given declared argument types).  Otherwise,
 * returns a palloc'd, already translated errdetail string saying why not.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>check_valid_polymorphic_signature</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ret_type</name></decl></parameter>,
								  <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>declared_arg_types</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ret_type</name> <operator>==</operator> <name>ANYRANGEOID</name> <operator>||</operator> <name>ret_type</name> <operator>==</operator> <name>ANYCOMPATIBLERANGEOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * ANYRANGE requires an ANYRANGE input, else we can't tell which of
		 * several range types with the same element type to use.  Likewise
		 * for ANYCOMPATIBLERANGE.
		 */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>declared_arg_types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ret_type</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* OK */</comment>
		</block_content>}</block></for>
		<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"A result of type %s requires at least one input of type %s."</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsPolymorphicTypeFamily1</name><argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Otherwise, any family-1 type can be deduced from any other */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicTypeFamily1</name><argument_list>(<argument><expr><name><name>declared_arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* OK */</comment>
		</block_content>}</block></for>
		<comment type="block">/* Keep this list in sync with IsPolymorphicTypeFamily1! */</comment>
		<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"A result of type %s requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange."</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsPolymorphicTypeFamily2</name><argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Otherwise, any family-2 type can be deduced from any other */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicTypeFamily2</name><argument_list>(<argument><expr><name><name>declared_arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* OK */</comment>
		</block_content>}</block></for>
		<comment type="block">/* Keep this list in sync with IsPolymorphicTypeFamily2! */</comment>
		<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"A result of type %s requires at least one input of type anycompatible, anycompatiblearray, anycompatiblenonarray, or anycompatiblerange."</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>			<comment type="block">/* OK, ret_type is not polymorphic */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * check_valid_internal_signature()
 *		Is a proposed function signature valid per INTERNAL safety rules?
 *
 * Returns NULL if OK, or a suitable error message if ret_type is INTERNAL but
 * none of the declared arg types are.  (It's unsafe to create such a function
 * since it would allow invocation of INTERNAL-consuming functions directly
 * from SQL.)  It's overkill to return the error detail message, since there
 * is only one possibility, but we do it like this to keep the API similar to
 * check_valid_polymorphic_signature().
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>check_valid_internal_signature</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ret_type</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>declared_arg_types</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ret_type</name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>declared_arg_types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ret_type</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* OK */</comment>
		</block_content>}</block></for>
		<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"A result of type internal requires at least one input of type internal."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>			<comment type="block">/* OK, ret_type is not INTERNAL */</comment>
</block_content>}</block></function>


<comment type="block">/* TypeCategory()
 *		Assign a category to the specified type OID.
 *
 * NB: this must not return TYPCATEGORY_INVALID.
 */</comment>
<function><type><name>TYPCATEGORY</name></type>
<name>TypeCategory</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>typcategory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typispreferred</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typcategory</name> <operator>!=</operator> <name>TYPCATEGORY_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>TYPCATEGORY</name><operator>)</operator> <name>typcategory</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* IsPreferredType()
 *		Check if this type is a preferred type for the given category.
 *
 * If category is TYPCATEGORY_INVALID, then we'll return true for preferred
 * types of any category; otherwise, only for preferred types of that
 * category.
 */</comment>
<function><type><name>bool</name></type>
<name>IsPreferredType</name><parameter_list>(<parameter><decl><type><name>TYPCATEGORY</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>typcategory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typispreferred</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typispreferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>typcategory</name> <operator>||</operator> <name>category</name> <operator>==</operator> <name>TYPCATEGORY_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>typispreferred</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* IsBinaryCoercible()
 *		Check if srctype is binary-coercible to targettype.
 *
 * This notion allows us to cheat and directly exchange values without
 * going through the trouble of calling a conversion function.  Note that
 * in general, this should only be an implementation shortcut.  Before 7.4,
 * this was also used as a heuristic for resolving overloaded functions and
 * operators, but that's basically a bad idea.
 *
 * As of 7.3, binary coercibility isn't hardwired into the code anymore.
 * We consider two types binary-coercible if there is an implicitly
 * invokable, no-function-needed pg_cast entry.  Also, a domain is always
 * binary-coercible to its base type, though *not* vice versa (in the other
 * direction, one must apply domain constraint checks before accepting the
 * value as legitimate).  We also need to special-case various polymorphic
 * types.
 *
 * This function replaces IsBinaryCompatible(), which was an inherently
 * symmetric test.  Since the pg_cast entries aren't necessarily symmetric,
 * the order of the operands is now significant.
 */</comment>
<function><type><name>bool</name></type>
<name>IsBinaryCoercible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>srctype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targettype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_cast</name></type> <name>castForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Fast path if same type */</comment>
	<if_stmt><if>if <condition>(<expr><name>srctype</name> <operator>==</operator> <name>targettype</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Anything is coercible to ANY or ANYELEMENT or ANYCOMPATIBLE */</comment>
	<if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYOID</name> <operator>||</operator> <name>targettype</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>||</operator>
		<name>targettype</name> <operator>==</operator> <name>ANYCOMPATIBLEOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If srctype is a domain, reduce to its base type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>srctype</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Somewhat-fast path for domain -&gt; base type case */</comment>
	<if_stmt><if>if <condition>(<expr><name>srctype</name> <operator>==</operator> <name>targettype</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Also accept any array type as coercible to ANY[COMPATIBLE]ARRAY */</comment>
	<if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYARRAYOID</name> <operator>||</operator> <name>targettype</name> <operator>==</operator> <name>ANYCOMPATIBLEARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>type_is_array</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also accept any non-array type as coercible to ANY[COMPATIBLE]NONARRAY */</comment>
	<if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYNONARRAYOID</name> <operator>||</operator> <name>targettype</name> <operator>==</operator> <name>ANYCOMPATIBLENONARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_array</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also accept any enum type as coercible to ANYENUM */</comment>
	<if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYENUMOID</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>type_is_enum</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also accept any range type as coercible to ANY[COMPATIBLE]RANGE */</comment>
	<if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>ANYRANGEOID</name> <operator>||</operator> <name>targettype</name> <operator>==</operator> <name>ANYCOMPATIBLERANGEOID</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>type_is_range</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also accept any composite type as coercible to RECORD */</comment>
	<if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also accept any composite array type as coercible to RECORD[] */</comment>
	<if_stmt><if>if <condition>(<expr><name>targettype</name> <operator>==</operator> <name>RECORDARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>is_complex_array</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Else look in pg_cast */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CASTSOURCETARGET</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>srctype</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no cast */</comment>
	<expr_stmt><expr><name>castForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_cast</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>castForm</name><operator>-&gt;</operator><name>castmethod</name></name> <operator>==</operator> <name>COERCION_METHOD_BINARY</name> <operator>&amp;&amp;</operator>
			  <name><name>castForm</name><operator>-&gt;</operator><name>castcontext</name></name> <operator>==</operator> <name>COERCION_CODE_IMPLICIT</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * find_coercion_pathway
 *		Look for a coercion pathway between two types.
 *
 * Currently, this deals only with scalar-type cases; it does not consider
 * polymorphic types nor casts between composite types.  (Perhaps fold
 * those in someday?)
 *
 * ccontext determines the set of available casts.
 *
 * The possible result codes are:
 *	COERCION_PATH_NONE: failed to find any coercion pathway
 *				*funcid is set to InvalidOid
 *	COERCION_PATH_FUNC: apply the coercion function returned in *funcid
 *	COERCION_PATH_RELABELTYPE: binary-compatible cast, no function needed
 *				*funcid is set to InvalidOid
 *	COERCION_PATH_ARRAYCOERCE: need an ArrayCoerceExpr node
 *				*funcid is set to InvalidOid
 *	COERCION_PATH_COERCEVIAIO: need a CoerceViaIO node
 *				*funcid is set to InvalidOid
 *
 * Note: COERCION_PATH_RELABELTYPE does not necessarily mean that no work is
 * needed to do the coercion; if the target is a domain then we may need to
 * apply domain constraint checking.  If you want to check for a zero-effort
 * conversion then use IsBinaryCoercible().
 */</comment>
<function><type><name>CoercionPathType</name></type>
<name>find_coercion_pathway</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceTypeId</name></decl></parameter>,
					  <parameter><decl><type><name>CoercionContext</name></type> <name>ccontext</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>result</name> <init>= <expr><name>COERCION_PATH_NONE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<comment type="block">/* Perhaps the types are domains; if so, look at their base types */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sourceTypeId</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>targetTypeId</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Domains are always coercible to and from their base type */</comment>
	<if_stmt><if>if <condition>(<expr><name>sourceTypeId</name> <operator>==</operator> <name>targetTypeId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>COERCION_PATH_RELABELTYPE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Look in pg_cast */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CASTSOURCETARGET</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_cast</name></type> <name>castForm</name> <init>= <expr><operator>(</operator><name>Form_pg_cast</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CoercionContext</name></type> <name>castcontext</name></decl>;</decl_stmt>

		<comment type="block">/* convert char value for castcontext to CoercionContext enum */</comment>
		<switch>switch <condition>(<expr><name><name>castForm</name><operator>-&gt;</operator><name>castcontext</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>COERCION_CODE_IMPLICIT</name></expr>:</case>
				<expr_stmt><expr><name>castcontext</name> <operator>=</operator> <name>COERCION_IMPLICIT</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>COERCION_CODE_ASSIGNMENT</name></expr>:</case>
				<expr_stmt><expr><name>castcontext</name> <operator>=</operator> <name>COERCION_ASSIGNMENT</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>COERCION_CODE_EXPLICIT</name></expr>:</case>
				<expr_stmt><expr><name>castcontext</name> <operator>=</operator> <name>COERCION_EXPLICIT</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized castcontext: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>castForm</name><operator>-&gt;</operator><name>castcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>castcontext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* Rely on ordering of enum for correct behavior here */</comment>
		<if_stmt><if>if <condition>(<expr><name>ccontext</name> <operator>&gt;=</operator> <name>castcontext</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>castForm</name><operator>-&gt;</operator><name>castmethod</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>COERCION_METHOD_FUNCTION</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_FUNC</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name><name>castForm</name><operator>-&gt;</operator><name>castfunc</name></name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>COERCION_METHOD_INOUT</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>COERCION_METHOD_BINARY</name></expr>:</case>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized castmethod: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>castForm</name><operator>-&gt;</operator><name>castmethod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If there's no pg_cast entry, perhaps we are dealing with a pair of
		 * array types.  If so, and if their element types have a conversion
		 * pathway, report that we can coerce with an ArrayCoerceExpr.
		 *
		 * Hack: disallow coercions to oidvector and int2vector, which
		 * otherwise tend to capture coercions that should go to "real" array
		 * types.  We want those types to be considered "real" arrays for many
		 * purposes, but not this one.  (Also, ArrayCoerceExpr isn't
		 * guaranteed to produce an output that meets the restrictions of
		 * these datatypes, such as being 1-dimensional.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>!=</operator> <name>OIDVECTOROID</name> <operator>&amp;&amp;</operator> <name>targetTypeId</name> <operator>!=</operator> <name>INT2VECTOROID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>targetElem</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>sourceElem</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>targetElem</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>sourceElem</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>elempathtype</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>elemfuncid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>elempathtype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetElem</name></expr></argument>,
													 <argument><expr><name>sourceElem</name></expr></argument>,
													 <argument><expr><name>ccontext</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>elemfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>elempathtype</name> <operator>!=</operator> <name>COERCION_PATH_NONE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_ARRAYCOERCE</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we still haven't found a possibility, consider automatic casting
		 * using I/O functions.  We allow assignment casts to string types and
		 * explicit casts from string types to be handled this way. (The
		 * CoerceViaIO mechanism is a lot more general than that, but this is
		 * all we want to allow in the absence of a pg_cast entry.) It would
		 * probably be better to insist on explicit casts in both directions,
		 * but this is a compromise to preserve something of the pre-8.3
		 * behavior that many types had implicit (yipes!) casts to text.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>COERCION_PATH_NONE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ccontext</name> <operator>&gt;=</operator> <name>COERCION_ASSIGNMENT</name> <operator>&amp;&amp;</operator>
				<call><name>TypeCategory</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>ccontext</name> <operator>&gt;=</operator> <name>COERCION_EXPLICIT</name> <operator>&amp;&amp;</operator>
					 <call><name>TypeCategory</name><argument_list>(<argument><expr><name>sourceTypeId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * find_typmod_coercion_function -- does the given type need length coercion?
 *
 * If the target type possesses a pg_cast function from itself to itself,
 * it must need length coercion.
 *
 * "bpchar" (ie, char(N)) and "numeric" are examples of such types.
 *
 * If the given type is a varlena array type, we do not look for a coercion
 * function associated directly with the array type, but instead look for
 * one associated with the element type.  An ArrayCoerceExpr node must be
 * used to apply such a function.  (Note: currently, it's pointless to
 * return the funcid in this case, because it'll just get looked up again
 * in the recursive construction of the ArrayCoerceExpr's elemexpr.)
 *
 * We use the same result enum as find_coercion_pathway, but the only possible
 * result codes are:
 *	COERCION_PATH_NONE: no length coercion needed
 *	COERCION_PATH_FUNC: apply the function returned in *funcid
 *	COERCION_PATH_ARRAYCOERCE: apply the function using ArrayCoerceExpr
 */</comment>
<function><type><name>CoercionPathType</name></type>
<name>find_typmod_coercion_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Type</name></type>		<name>targetType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_FUNC</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetType</name> <operator>=</operator> <call><name>typeidType</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for a varlena array type */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typeForm</name><operator>-&gt;</operator><name>typelem</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Yes, switch our attention to the element type */</comment>
		<expr_stmt><expr><name>typeId</name> <operator>=</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_ARRAYCOERCE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look in pg_cast */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>CASTSOURCETARGET</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_cast</name></type> <name>castForm</name> <init>= <expr><operator>(</operator><name>Form_pg_cast</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name><name>castForm</name><operator>-&gt;</operator><name>castfunc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>funcid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>COERCION_PATH_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_complex_array
 *		Is this type an array of composite?
 *
 * Note: this will not return true for record[]; check for RECORDARRAYOID
 * separately if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_complex_array</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elemtype</name> <init>= <expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether reltypeId is the row type of a typed table of type
 * reloftypeId, or is a domain over such a row type.  (This is conceptually
 * similar to the subtype relationship checked by typeInheritsFrom().)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>typeIsOfTypedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reltypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>reloftypeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>typeOrDomainTypeRelid</name><argument_list>(<argument><expr><name>reltypeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>relid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>reltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>reltup</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>==</operator> <name>reloftypeId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
