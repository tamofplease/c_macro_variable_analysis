<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/parser/parse_shortestpath.c"><comment type="block">/*
 * parse_shortestpath.c
 *	  handle clauses for graph in parser
 *
 * Copyright (c) 2017 by Bitnine Global, Inc.
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_shortestpath.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ag_const.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cypher_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_shortestpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cypher_utils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_COLNAME_VIDS</name></cpp:macro>		<cpp:value>"vids"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_COLNAME_EIDS</name></cpp:macro>		<cpp:value>"eids"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_ALIASNAME_START_LEFT</name></cpp:macro>  <cpp:value>"lstart"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_ALIASNAME_START_RIGHT</name></cpp:macro> <cpp:value>"rstart"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_ALIASNAME_END_LEFT</name></cpp:macro>    <cpp:value>"lend"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_ALIASNAME_END_RIGHT</name></cpp:macro>   <cpp:value>"rend"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_ALIASNAME_OID_LEFT</name></cpp:macro>    <cpp:value>"loid"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_ALIASNAME_OID_RIGHT</name></cpp:macro>   <cpp:value>"roid"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_ALIASNAME_TID_LEFT</name></cpp:macro>    <cpp:value>"ltid"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_ALIASNAME_TID_RIGHT</name></cpp:macro>   <cpp:value>"rtid"</cpp:value></cpp:define>

<comment type="block">/* semantic checks */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkNodeForRefForDijkstra</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkNodeReferableForDijkstra</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkNodeForRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkNodeReferable</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkRelFormat</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_match</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkRelFormatForDijkstra</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* shortest path */</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>makeShortestPathQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>isexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>makeShortestPathFrom</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>,
												<parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>makeShortestpathEdgeLeftQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
														 <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>makeShortestpathEdgeRightQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
														  <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeShortestpathEdgeUnionLeft</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeShortestpathEdgeUnionRight</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeShortestpathEdgeLeft</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeShortestpathEdgeRight</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeVerticesSubLink</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeEdgesSubLink</name><parameter_list>(<parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_dijkstra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getCypherRelType</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>typname</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>typloc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeVertexIdExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* dijkstra */</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>makeDijkstraQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>is_expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>makeDijkstraFrom</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>,
											<parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>makeDijkstraEdgeQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
												 <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeDijkstraEdgeUnion</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>row_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeDijkstraEdge</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>row_name</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* parse node */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeColumnRef1</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeColumnRef</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResTarget</name> <modifier>*</modifier></type><name>makeSimpleResTarget</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResTarget</name> <modifier>*</modifier></type><name>makeResTarget</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeAArrayExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>elements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeRowExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeSubLink</name><parameter_list>(<parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformShortestPath</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>checkNodeForRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkRelFormat</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkNodeForRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeShortestPathQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformShortestPathInMatch</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>checkNodeReferable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkRelFormat</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkNodeReferable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeShortestPathQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkNodeForRefForDijkstra</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>checkNodeReferable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"property constraint is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										   <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkNodeReferableForDijkstra</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node must be a reference to a specific node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>col</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VERTEXOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable \"%s\" is not a vertex"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"property constraint is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkNodeForRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>checkNodeReferable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"property constraint is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										   <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkNodeReferable</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node must be a reference to a specific node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>col</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VERTEXOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable \"%s\" is not a vertex"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkRelFormat</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_match</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>varloc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_match</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>varloc</name> <operator>=</operator> <call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bound variable to edge not allowed in shortestpath"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>indices</name> <init>= <expr><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>lidx</name> <init>= <expr><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>lidx</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only 0 or 1 is allowed for minimal length"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>lidx</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"property constraint is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT (
 *     (
 *       SELECT array_agg(
 *           (
 *             SELECT (id, properties)::vertex
 *             FROM `get_graph_path()`.ag_vertex
 *             WHERE id = vid
 *           )
 *         )
 *       FROM unnest(vids) AS vid
 *     ),
 *     (
 *       SELECT array_agg(
 *           (
 *             SELECT (id, start, "end", properties)::edge
 *             FROM `get_graph_path()`.`typname`
 *             WHERE tableoid = rowid_tableoid(eid) AND ctid = rowid_ctid(eid)
 *           )
 *         )
 *       FROM unnest(eids) AS eid
 *     )
 *   )::graphpath AS `pathname`,
 *   (
 *     SELECT array_agg(
 *         (
 *           SELECT (id, start, "end", properties)::edge
 *           FROM `get_graph_path()`.`typname`
 *           WHERE tableoid = rowid_tableoid(eid) AND ctid = rowid_ctid(eid)
 *         )
 *       )
 *     FROM unnest(eids) AS eid
 *   ) AS `relname`
 * FROM
 * (
 *   SELECT shortestpath_graphids() as vids,
 *          shortestpath_rowids() as eids
 *   FROM `graph_path`.edge_label
 *   WHERE start = id(source)
 *     AND "end" = id(target)
 *
 *   SHORTESTPATH( id(source), id(target) )
 * )
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>makeShortestPathQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> 	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>empty_edges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherRel</name>  <modifier>*</modifier></type><name>crel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pathname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>edgename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>makeShortestPathFrom</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pathname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>( <expr><name>pathname</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>isexpr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>makeVerticesSubLink</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeEdgesSubLink</name><argument_list>(<argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>empty_edges</name> <operator>=</operator> <call><name>makeAArrayExpr</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><literal type="string">"_edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coalesced</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesced</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><name>empty_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesced</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>makeRowExpr</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>, <argument><expr><name>coalesced</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"graphpath"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cpath</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CPATH_SHORTEST_ALL</name> <operator>&amp;&amp;</operator> <name>isexpr</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>arragg</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>arragg</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"array_agg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arragg</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							 <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeEdgesSubLink</name><argument_list>(<argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>, <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edgename</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							 <argument><expr><name>edgename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT shortestpath_vids() as vids,
 *        shortestpath_eids() as eids
 * FROM `graph_path`.edge_label
 * WHERE start = id(source)
 *   AND "end" = id(target)
 *
 * SHORTESTPATH( id(source), id(target) )
 */</comment>
<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>makeShortestPathFrom</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Alias</name>	      <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name>    <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	      <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	      <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>      <modifier>*</modifier></type><name>fc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherRel</name>     <modifier>*</modifier></type><name>crel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>  	      <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>  	      <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherNode</name>    <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	      <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	      <modifier>*</modifier></type><name>vertex_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	      <modifier>*</modifier></type><name>where</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	      <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentParseState</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parentParseState</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"_d"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_locked_from_parent</name></name> <operator>=</operator> <call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>makeShortestpathEdgeLeftQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>makeShortestpathEdgeRightQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* vids */</comment>
	<expr_stmt><expr><name>fc</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"shortestpath_graphids"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fc</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
							   <argument><expr><name>fc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><literal type="string">"vids"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* eids */</comment>
	<expr_stmt><expr><name>fc</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"shortestpath_rowids"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fc</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
							   <argument><expr><name>fc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><literal type="string">"eids"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* end ID */</comment>
	<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_LEFT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_START_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_END_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathEndIdLeft</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_LEFT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_END_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_START_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathEndIdRight</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

	<comment type="block">/* minhop &amp; maxhop */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathMinhops</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathMaxhops</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Indices</name>     <modifier>*</modifier></type><name>indices</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>A_Const</name>       <modifier>*</modifier></type><name>idx</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathMaxhops</name></name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>indices</name> <operator>=</operator> <operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator><name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathMinhops</name></name> <operator>=</operator> <name><name>idx</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>( <expr><name><name>indices</name><operator>-&gt;</operator><name>uidx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator><name><name>indices</name><operator>-&gt;</operator><name>uidx</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathMaxhops</name></name> <operator>=</operator> <name><name>idx</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* limit */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathLimit</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cpath</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CPATH_SHORTEST_ALL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathLimit</name></name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* edge ID */</comment>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_OID_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathTableOidLeft</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_OID_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathTableOidRight</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_TID_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathCtidLeft</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_TID_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathCtidRight</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* WHERE */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_LEFT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_END_LEFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name>   <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_START_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_START_LEFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name>   <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_ALIASNAME_END_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vertex_id</name> <operator>=</operator> <call><name>makeVertexIdExpr</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>where</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>vertex_id</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vertex_id</name> <operator>=</operator> <call><name>makeVertexIdExpr</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>where</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>where</name></expr></argument>, <argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>vertex_id</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* qual */</comment>
	<comment type="block">/* Add Property Constraint
	 * if (cpath-&gt;qual != NULL)
	 *    where = lappend(where, cpath-&gt;qual);
	 */</comment>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shortestpath source */</comment>
	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vertex_id</name> <operator>=</operator> <call><name>makeVertexIdExpr</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathSource</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>vertex_id</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shortestpath target */</comment>
	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vertex_id</name> <operator>=</operator> <call><name>makeVertexIdExpr</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathTarget</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><name>vertex_id</name></expr></argument>,
											<argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parentParseState</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<return>return <expr><call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>makeShortestpathEdgeLeftQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherRel</name> 	   <modifier>*</modifier></type><name>crel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> 		   <modifier>*</modifier></type><name>elabel_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>		   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>		   <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>		   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getCypherRelType</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elabel_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeShortestpathEdgeUnionLeft</name><argument_list>(<argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeShortestpathEdgeLeft</name><argument_list>(<argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<return>return <expr><call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>makeShortestpathEdgeRightQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherRel</name> 	   <modifier>*</modifier></type><name>crel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> 		   <modifier>*</modifier></type><name>elabel_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>		   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>		   <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>		   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getCypherRelType</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elabel_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeShortestpathEdgeUnionRight</name><argument_list>(<argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeShortestpathEdgeRight</name><argument_list>(<argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<return>return <expr><call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT start lstart, "end" lend, ltableoid loid, lctid ltid
 * FROM (
 *   SELECT start, "end", tableoid ltableoid, ctid lctid FROM `get_graph_path()`.`elabel_name`
 *   UNION
 *   SELECT "end", start, tableoid rtableoid, ctid rctid FROM `get_graph_path()`.`elabel_name`
 * )
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeShortestpathEdgeUnionLeft</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>lsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>rsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>sub_sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>crel</name><operator>-&gt;</operator><name>only</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>lsel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rsel</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>lsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"tableoid"</literal></expr></argument>, <argument><expr><literal type="string">"ltableoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><literal type="string">"lctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"tableoid"</literal></expr></argument>, <argument><expr><literal type="string">"rtableoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><literal type="string">"rctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SETOP_UNION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>all</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>lsel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <name>rsel</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>sub_sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeSubselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub_sel</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>u</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub_sel</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>sub_sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make4</name><argument_list>(<argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>SP_ALIASNAME_START_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>SP_ALIASNAME_END_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ltableoid"</literal></expr></argument>, <argument><expr><name>SP_ALIASNAME_OID_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"lctid"</literal></expr></argument>, <argument><expr><name>SP_ALIASNAME_TID_LEFT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT start rstart, "end" rend, ltableoid roid, lctid rtid
 * FROM (
 *   SELECT start, "end", tableoid ltableoid, ctid lctid FROM `get_graph_path()`.`elabel_name`
 *   UNION
 *   SELECT "end", start, tableoid rtableoid, ctid rctid FROM `get_graph_path()`.`elabel_name`
 * )
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeShortestpathEdgeUnionRight</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>lsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>rsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>sub_sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>crel</name><operator>-&gt;</operator><name>only</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>lsel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rsel</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>lsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"tableoid"</literal></expr></argument>, <argument><expr><literal type="string">"ltableoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><literal type="string">"lctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"tableoid"</literal></expr></argument>, <argument><expr><literal type="string">"rtableoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><literal type="string">"rctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SETOP_UNION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>all</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>lsel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <name>rsel</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>sub_sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeSubselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub_sel</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>u</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub_sel</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>sub_sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make4</name><argument_list>(<argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>SP_ALIASNAME_START_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>SP_ALIASNAME_END_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ltableoid"</literal></expr></argument>, <argument><expr><name>SP_ALIASNAME_OID_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"lctid"</literal></expr></argument>, <argument><expr><name>SP_ALIASNAME_TID_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT start lstart, "end" lend, tableoid loid, ctid ltid FROM
 * ( SELECT start, "end", tableoid, ctid FROM `get_graph_path()`.`elabel_name` )
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeShortestpathEdgeLeft</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>crel</name><operator>-&gt;</operator><name>only</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make4</name><argument_list>(<argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>SP_ALIASNAME_START_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>SP_ALIASNAME_END_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"tableoid"</literal></expr></argument>, <argument><expr><name>SP_ALIASNAME_OID_LEFT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><name>SP_ALIASNAME_TID_LEFT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT start rstart, "end" rend, tableoid roid, ctid rtid FROM
 * ( SELECT start, "end", tableoid, ctid FROM `get_graph_path()`.`elabel_name` )
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeShortestpathEdgeRight</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>crel</name><operator>-&gt;</operator><name>only</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make4</name><argument_list>(<argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>SP_ALIASNAME_START_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>SP_ALIASNAME_END_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"tableoid"</literal></expr></argument>, <argument><expr><name>SP_ALIASNAME_OID_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><name>SP_ALIASNAME_TID_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT array_agg(
 *     (
 *       SELECT (id, properties)::vertex
 *       FROM `get_graph_path()`.ag_vertex
 *       WHERE id = vid
 *     )
 *   )
 * FROM unnest(vids) AS vid
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeVerticesSubLink</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>selsub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>ag_vertex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>arragg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>unnest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>vid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SubLink for `array_agg()`
	 */</comment>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>selsub</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>makeRowExpr</name><argument_list>(<argument><expr><call><name>list_make3</name><argument_list>(<argument><expr><name>id</name></expr></argument>,
									<argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><literal type="string">"vertex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>selsub</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeResTarget</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ag_vertex</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AG_VERTEX</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ag_vertex</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>selsub</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>ag_vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"vid"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>selsub</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>makeSubLink</name><argument_list>(<argument><expr><name>selsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SELECT which gets array of vertices from `vids`
	 */</comment>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>arragg</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"array_agg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeResTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arragg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>unnest</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"unnest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_COLNAME_VIDS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vid</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vid</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vid</name><operator>-&gt;</operator><name>ordinality</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vid</name><operator>-&gt;</operator><name>is_rowsfrom</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vid</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>unnest</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vid</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><literal type="string">"vid"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vid</name><operator>-&gt;</operator><name>coldeflist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeSubLink</name><argument_list>(<argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT array_agg(
 *     (
 *       SELECT (id, start, "end", properties)::edge
 *       FROM `get_graph_path()`.`typname`
 *
 *       # shortestpath()
 *       WHERE tableoid = rowid_tableoid(eid) AND ctid = rowid_ctid(eid)
 *
 *       # dijkstra()
 *       WHERE id = eid
 *     )
 *   )
 * FROM unnest(eids) AS eid
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeEdgesSubLink</name><parameter_list>(<parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_dijkstra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>selsub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherRel</name>  <modifier>*</modifier></type><name>crel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>where_args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>arragg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>unnest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>eid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SubLink for `array_agg()`
	 */</comment>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>selsub</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>makeRowExpr</name><argument_list>(<argument><expr><call><name>list_make5</name><argument_list>(<argument><expr><name>id</name></expr></argument>,
								  <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><literal type="string">"edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>selsub</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeResTarget</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getCypherRelType</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>selsub</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_dijkstra</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"eid"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>where_args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tableoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ctid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>getid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tableoid</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getid</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"rowid_tableoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"eid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>tableoid</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>getid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>where_args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ctid</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>getid</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"rowid_ctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"eid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>ctid</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>getid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>where_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>where_args</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>selsub</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>where_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeSubLink</name><argument_list>(<argument><expr><name>selsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SELECT which gets array of edges from `eids`
	 */</comment>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>arragg</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"array_agg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeResTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arragg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>unnest</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"unnest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>SP_COLNAME_EIDS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>eid</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eid</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eid</name><operator>-&gt;</operator><name>ordinality</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eid</name><operator>-&gt;</operator><name>is_rowsfrom</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eid</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>unnest</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eid</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><literal type="string">"eid"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eid</name><operator>-&gt;</operator><name>coldeflist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeSubLink</name><argument_list>(<argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>getCypherRelType</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>typname</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>typloc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>typname</name> <operator>=</operator> <name>AG_EDGE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typloc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>typloc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple types for relationship not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>typname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typloc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>typloc</name> <operator>=</operator> <call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeVertexIdExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>AG_ELEM_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeColumnRef1</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fields</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fields</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeColumnRef</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeColumnRef</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <name>fields</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cref</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ResTarget</name> <modifier>*</modifier></type>
<name>makeSimpleResTarget</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeResTarget</name><argument_list>(<argument><expr><name>cref</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ResTarget</name> <modifier>*</modifier></type>
<name>makeResTarget</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResTarget</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeAArrayExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>elements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>cast</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>elements</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>cast</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cast</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeRowExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowExpr</name>	   <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>cast</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CAST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>cast</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>row</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cast</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeSubLink</name><parameter_list>(<parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sublink</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>=</operator> <name>EXPR_SUBLINK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sublink</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformDijkstra</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>checkNodeForRefForDijkstra</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkRelFormatForDijkstra</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkNodeForRefForDijkstra</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeDijkstraQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformDijkstraInMatch</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>checkNodeReferableForDijkstra</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkRelFormatForDijkstra</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkNodeReferableForDijkstra</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeDijkstraQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkRelFormatForDijkstra</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>indices</name> <init>= <expr><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>lidx</name> <init>= <expr><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable length relationship is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>lidx</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"property constraint is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * path = DIJKSTRA((source)-[:edge_label]-&gt;(target), weight, qual, LIMIT n)
 *
 * |
 * v
 *
 * SELECT (
 *     (
 *       SELECT array_agg(
 *           (
 *             SELECT (id, properties)::vertex
 *             FROM `get_graph_path()`.ag_vertex
 *             WHERE id = vid
 *           )
 *         )
 *       FROM unnest(vids) AS vid
 *     ),
 *     (
 *       SELECT array_agg(
 *           (
 *             SELECT (id, start, "end", properties)::edge
 *             FROM `get_graph_path()`.`typname`
 *             WHERE id = eid
 *           )
 *         )
 *       FROM unnest(eids) AS eid
 *     )
 *   )::graphpath AS `pathname`,
 *   weight
 * FROM
 * (
 *   SELECT dijkstra_vids() as vids,
 *          dijkstra_eids() as eids,
 *          weight
 *   FROM `graph_path`.edge_label
 *   WHERE start = id(source) AND `qual`
 *
 *   DIJKSTRA (id(source), id(target), LIMIT n, "end", id)
 * )
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>makeDijkstraQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> 	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>empty_edges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pathname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>makeDijkstraFrom</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>makeVerticesSubLink</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeEdgesSubLink</name><argument_list>(<argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>empty_edges</name> <operator>=</operator> <call><name>makeAArrayExpr</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><literal type="string">"_edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>coalesced</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>coalesced</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><name>empty_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>coalesced</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>makeRowExpr</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>, <argument><expr><name>coalesced</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"graphpath"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_expr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>arragg</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>arragg</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"array_agg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arragg</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pathname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cpath</name><operator>-&gt;</operator><name>weight_var</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>weight_varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>weight_var</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"weight"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							 <argument><expr><name>weight_varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT dijkstra_vids() as vids,
 *        dijkstra_eids() as eids,
 *        weight
 * FROM `graph_path`.edge_label
 * WHERE start = id(source) AND `qual`
 *
 * DIJKSTRA (id(source), id(target), LIMIT n, "end", id)
 */</comment>
<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>makeDijkstraFrom</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>fc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherRel</name>  <modifier>*</modifier></type><name>crel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>wtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>  	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertex_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>where</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentParseState</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parentParseState</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"_d"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_locked_from_parent</name></name> <operator>=</operator> <call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>makeDijkstraEdgeQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* vids */</comment>
	<expr_stmt><expr><name>fc</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"dijkstra_vids"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fc</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
							   <argument><expr><name>fc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><literal type="string">"vids"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* eids */</comment>
	<expr_stmt><expr><name>fc</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"dijkstra_eids"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fc</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
							   <argument><expr><name>fc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><literal type="string">"eids"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* weight */</comment>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>,
								 <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>wtype</name> <operator>!=</operator> <name>FLOAT8OID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>weight</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>weight</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>wtype</name></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>weight</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"weight must be type %s, not type %s"</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>FLOAT8OID</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>wtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>target</name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"weight must not return a set"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><literal type="string">"weight"</literal></expr></argument>, <argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>weight_var</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>dijkstraWeight</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>dijkstraWeightOut</name></name> <operator>=</operator> <operator>(</operator><name><name>cpath</name><operator>-&gt;</operator><name>weight_var</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* end ID */</comment>
	<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_LEFT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>dijkstraEndId</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

	<comment type="block">/* edge ID */</comment>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_ELEM_ID</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>dijkstraEdgeId</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* WHERE */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_LEFT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vertex_id</name> <operator>=</operator> <call><name>makeVertexIdExpr</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>where</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>vertex_id</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* qual */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cpath</name><operator>-&gt;</operator><name>qual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>where</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>where</name></expr></argument>, <argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Dijkstra source */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathSource</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>vertex_id</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Dijkstra target */</comment>
	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeColumnRef1</name><argument_list>(<argument><expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>vertex</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vertex_id</name> <operator>=</operator> <call><name>makeVertexIdExpr</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>shortestpathTarget</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><name>vertex_id</name></expr></argument>,
											<argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Dijkstra LIMIT */</comment>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>dijkstraLimit</name></name> <operator>=</operator> <call><name>transformCypherLimit</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>,
											  <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>, <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parentParseState</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<return>return <expr><call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>makeDijkstraEdgeQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherRel</name> 	   <modifier>*</modifier></type><name>crel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> 		   <modifier>*</modifier></type><name>elabel_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>row_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>		   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>		   <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>		   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getCypherRelType</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elabel_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>row_name</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeDijkstraEdgeUnion</name><argument_list>(<argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><name>row_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeDijkstraEdge</name><argument_list>(<argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><name>row_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<return>return <expr><call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT start, "end", id, (id, _start, _end, properties)::edge AS row_name
 * FROM (
 *   SELECT start AS _start, "end" AS _end, start, "end", id, properties
 *   FROM `get_graph_path()`.`elabel_name`
 *   UNION
 *   SELECT start AS _start, "end" AS _end, end, start, id, properties
 *   FROM `get_graph_path()`.`elabel_name`
 * )
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeDijkstraEdgeUnion</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>row_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>lsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>rsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>sub_sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>lsel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><literal type="string">"_start"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><literal type="string">"_end"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rsel</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>lsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>row_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
								   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>row_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
								   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SETOP_UNION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>all</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>lsel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <name>rsel</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>sub_sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeSubselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub_sel</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>u</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub_sel</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>sub_sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make4</name><argument_list>(<argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>row_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>makeRowExpr</name><argument_list>(<argument><expr><call><name>list_make5</name><argument_list>(<argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"_start"</literal></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"_end"</literal></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><literal type="string">"edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
								  <argument><expr><call><name>makeResTarget</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>row_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT start, "end", id, (id, start, end, properties)::edge AS row_name
 * FROM `get_graph_path()`.`elabel_name`
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeDijkstraEdge</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>elabel_name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>row_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elabel_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make4</name><argument_list>(<argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>row_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>makeRowExpr</name><argument_list>(<argument><expr><call><name>list_make5</name><argument_list>(<argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>makeColumnRef1</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><literal type="string">"edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
								  <argument><expr><call><name>makeResTarget</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>row_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</return>
</block_content>}</block></function></unit>
