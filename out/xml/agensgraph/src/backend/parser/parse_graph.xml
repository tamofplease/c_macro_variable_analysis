<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/parser/parse_graph.c"><comment type="block">/*
 * parse_graph.c
 *	  handle clauses for graph in parser
 *
 * Copyright (c) 2016 by Bitnine Global, Inc.
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_graph.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ag_const.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_vertex_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_label.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/graphnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cypher_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_cypher_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_shortestpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CYPHER_SUBQUERY_ALIAS</name></cpp:macro>	<cpp:value>"_"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CYPHER_OPTMATCH_ALIAS</name></cpp:macro>	<cpp:value>"_o"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CYPHER_MERGEMATCH_ALIAS</name></cpp:macro>	<cpp:value>"_m"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CYPHER_DELETEJOIN_ALIAS</name></cpp:macro>	<cpp:value>"_d"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EDGE_UNION_START_ID</name></cpp:macro>		<cpp:value>"_start"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EDGE_UNION_END_ID</name></cpp:macro>		<cpp:value>"_end"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLE_LEFT_ALIAS</name></cpp:macro>			<cpp:value>"l"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLE_RIGHT_ALIAS</name></cpp:macro>			<cpp:value>"r"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLE_VERTEX_ALIAS</name></cpp:macro>		<cpp:value>"vtx"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLE_COLNAME_IDS</name></cpp:macro>			<cpp:value>"ids"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLE_COLNAME_EDGES</name></cpp:macro>		<cpp:value>"edges"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLE_COLNAME_VERTICES</name></cpp:macro>	<cpp:value>"vertices"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLE_COLNAME_NEXT</name></cpp:macro>		<cpp:value>"next"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLE_COLNAME_EDGE</name></cpp:macro>		<cpp:value>"edge"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VLE_COLNAME_VERTEX</name></cpp:macro>		<cpp:value>"vertex"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELETE_VERTEX_ALIAS</name></cpp:macro>		<cpp:value>"v"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELETE_EDGE_ALIAS</name></cpp:macro>		<cpp:value>"e"</cpp:value></cpp:define>

<decl_stmt><decl><type><name>bool</name></type>		<name>enable_eager</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>		<comment type="block">/* variable assigned to the node */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>labname</name></decl>;</decl_stmt>		<comment type="block">/* final label of the vertex */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prop_constr</name></decl>;</decl_stmt>	<comment type="block">/* has property constraints? */</comment>
}</block></struct></type> <name>NodeInfo</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name></decl>;</decl_stmt>			<comment type="block">/* of the RTE */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>varattno</name></decl>;</decl_stmt>		<comment type="block">/* in the target list */</comment>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_constr</name></decl>;</decl_stmt>	<comment type="block">/* property constraint of the element */</comment>
}</block></struct></type> <name>ElemQual</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
}</block></struct></type> <name>ElemQualOnly</name>;</typedef>

<typedef>typedef <type><struct>struct <name>prop_constr_context</name>
<block>{
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathelems</name></decl>;</decl_stmt>
}</block></struct></type> <name>prop_constr_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name></decl>;</decl_stmt>			<comment type="block">/* of the RTE */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>varattno</name></decl>;</decl_stmt>		<comment type="block">/* in the target list */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>labname</name></decl>;</decl_stmt>		<comment type="block">/* label of the vertex */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nullable</name></decl>;</decl_stmt>		<comment type="block">/* is this nullable? */</comment>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>			<comment type="block">/* resolved vertex */</comment>
}</block></struct></type> <name>FutureVertex</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FVR_DONT_RESOLVE</name></cpp:macro>		<cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FVR_IGNORE_NULLABLE</name></cpp:macro>		<cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FVR_PRESERVE_VAR_REF</name></cpp:macro>	<cpp:value>0x04</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>resolve_future_vertex_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_preserved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>resno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
}</block></struct></type> <name>find_target_label_context</name>;</typedef>

<comment type="block">/* projection (RETURN and WITH) */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkNameInItems</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* MATCH - OPTIONAL */</comment>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformMatchOptional</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
												  <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* MATCH - preprocessing */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hasPropConstr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>getFindPaths</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendFindPathsResult</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fplist</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>collectNodeInfo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addNodeInfo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NodeInfo</name> <modifier>*</modifier></type><name>getNodeInfo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NodeInfo</name> <modifier>*</modifier></type><name>findNodeInfo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>makeComponents</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isPathConnectedTo</name><parameter_list>(<parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>component</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>arePathsConnected</name><parameter_list>(<parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* MATCH - transform */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformComponents</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>components</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformMatchNode</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>eqoList</name></decl></parameter>,
								<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNSItem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformMatchRel</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
											 <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>eqoList</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformMatchSR</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>eqoList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>addEdgeUnion</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>edge_label</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>only</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>genEdgeUnion</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>edge_label</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>only</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setInitialVidForVLE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
								<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>vertexIsNSItem</name></decl></parameter>,
								<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>prev_crel</name></decl></parameter>,
								<parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>prev_edge</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformMatchVLE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
											 <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SelectStmt</name> <modifier>*</modifier></type><name>genVLESubselect</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>genVLELeftChild</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>genVLERightChild</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>genVertexSimple</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>genEdgeSimple</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>genVLEEdgeSubselect</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
								 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeSubselect</name> <modifier>*</modifier></type><name>genInhEdge</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>genVLEJoinExpr</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>larg</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rarg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>genQualifiedName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>genVLEQual</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>propMap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformVLEtoNSItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
												<parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>vle</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isZeroLengthVLE</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getCypherRelType</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>typname</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>typloc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>addQualRelPath</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
							<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>prev_crel</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>prev_edge</name></decl></parameter>,
							<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>addQualNodeIn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>vertexIsNSItem</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
						   <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>prev</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getEdgeColname</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prev</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isFutureVertexExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setFutureVertexExprId</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>,
								  <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>prev</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>addQualUniqueEdges</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ueids</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ueidarrs</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* MATCH - VLE */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>vtxArrConcat</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>edgeArrConcat</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* MATCH - quals */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addElemQual</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>,
						<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_constr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>adjustElemQuals</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>elem_quals</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformElemQuals</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_prop_constr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
								   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_map</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_constr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transform_prop_constr_worker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>prop_constr_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ginAvail</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>getSourceRelid</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hasGinOnProp</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* MATCH - future vertex */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addFutureVertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FutureVertex</name> <modifier>*</modifier></type><name>findFutureVertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
									  <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>adjustFutureVertices</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>future_vertices</name></decl></parameter>,
								  <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>resolve_future_vertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>resolve_future_vertex_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										   <parameter><decl><type><name>resolve_future_vertex_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resolveFutureVertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>FutureVertex</name> <modifier>*</modifier></type><name>fv</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>ignore_nullable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>makeVertexNSItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>,
											<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>removeResolvedFutureVertices</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>future_vertices</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* CREATE */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformCreatePattern</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GraphVertex</name> <modifier>*</modifier></type><name>transformCreateNode</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GraphEdge</name> <modifier>*</modifier></type><name>transformCreateRel</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeNewVertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeNewEdge</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relation</name></type> <name>openTargetLabel</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* SET/REMOVE */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformSetPropList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_remove</name></decl></parameter>,
								  <parameter><decl><type><name>CSetKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GraphSetProp</name> <modifier>*</modifier></type><name>transformSetProp</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherSetProp</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>is_remove</name></decl></parameter>,
									  <parameter><decl><type><name>CSetKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* MERGE */</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformMergeMatch</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformMergeMatchJoin</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
												   <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformNullSelect</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeMatchForMerge</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformMergeCreate</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>,
								  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>prevrte</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GraphVertex</name> <modifier>*</modifier></type><name>transformMergeNode</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>singlenode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GraphEdge</name> <modifier>*</modifier></type><name>transformMergeRel</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transformMergeOnSet</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sets</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* DELETE */</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformDeleteJoin</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transformDeleteEdges</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformDeleteJoinNSItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
													 <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>A_ArrayExpr</name> <modifier>*</modifier></type><name>verticesAppend</name><parameter_list>(<parameter><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>vertices</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>verticesConcat</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertices</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeSelectEdgesVertices</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertices</name></decl></parameter>,
									 <parameter><decl><type><name>CypherDeleteClause</name> <modifier>*</modifier></type><name>delete</name></decl></parameter>,
									 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>edges_resname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeEdgesForDetach</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeFunction</name> <modifier>*</modifier></type><name>makeUnnestVertices</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertices</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BoolExpr</name> <modifier>*</modifier></type><name>makeEdgesVertexQual</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>extractVerticesExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>,
								 <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>extractEdgesExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>,
							  <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getDeleteTargetName</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* graph write */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>findAllModifiedLabels</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>find_target_label</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>find_target_label_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									 <parameter><decl><type><name>find_target_label_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* common */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>labelExist</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>labloc</name></decl></parameter>,
					   <parameter><decl><type><name>char</name></type> <name>labkind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>throw</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vertexLabelExist</name><parameter_list>(<parameter><type><name>pstate</name></type></parameter>, <parameter><type><name>labname</name></type></parameter>, <parameter><type><name>labloc</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>labelExist(pstate, labname, labloc, LABEL_KIND_VERTEX, true)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>edgeLabelExist</name><parameter_list>(<parameter><type><name>pstate</name></type></parameter>, <parameter><type><name>labname</name></type></parameter>, <parameter><type><name>labloc</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>labelExist(pstate, labname, labloc, LABEL_KIND_EDGE, true)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>createLabelIfNotExist</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>labloc</name></decl></parameter>,
								  <parameter><decl><type><name>char</name></type> <name>labkind</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>createVertexLabelIfNotExist</name><parameter_list>(<parameter><type><name>pstate</name></type></parameter>, <parameter><type><name>labname</name></type></parameter>, <parameter><type><name>labloc</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>createLabelIfNotExist(pstate, labname, labloc, LABEL_KIND_VERTEX)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>createEdgeLabelIfNotExist</name><parameter_list>(<parameter><type><name>pstate</name></type></parameter>, <parameter><type><name>labname</name></type></parameter>, <parameter><type><name>labloc</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>createLabelIfNotExist(pstate, labname, labloc, LABEL_KIND_EDGE)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isNodeForRef</name><parameter_list>(<parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformPropMap</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
							  <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>stripNullKeys</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>properties</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_query_eager</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* transform */</comment>
<typedef>typedef <function_decl><type><name>Query</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>TransformMethod</name>) <parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformClauseBy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
											 <parameter><decl><type><name>TransformMethod</name></type> <name>transform</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>transformClauseImpl</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
											   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
											   <parameter><decl><type><name>TransformMethod</name></type> <name>transform</name></decl></parameter>,
											   <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>incrementalJoinRTEs</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
											   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
											   <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_nsitem</name></decl></parameter>,
											   <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>r_nsitem</name></decl></parameter>,
											   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>makeJoinResCols</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_rte</name></decl></parameter>,
							<parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>r_rte</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>l_colvars</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_colvars</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colnames</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colvars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>findNamespaceItemForRTE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
												   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>makeTargetListFromNSItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
									  <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>makeTargetListFromJoin</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
									<parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>makeWholeRowTarget</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
									   <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>findTarget</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resname</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* expression - type */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeVertexExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeEdgeExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
						  <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makePathVertexExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNSItem</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* expression - common */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>getColumnVar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
						  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>getSysColumnVar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
							 <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>getExprField</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeArrayExpr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typarray</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeTypedRowExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>qualAndExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* parse node */</comment>
<function_decl><type><specifier>static</specifier> <name>ResTarget</name> <modifier>*</modifier></type><name>makeSimpleResTarget</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResTarget</name> <modifier>*</modifier></type><name>makeResTarget</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>makeColumnRef</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>A_Const</name> <modifier>*</modifier></type><name>makeNullAConst</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsNullAConst</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* utils */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>repairTargetListCollations</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformCypherSubPattern</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherSubPattern</name> <modifier>*</modifier></type><name>subpat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherMatchClause</name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subpat</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CSP_FINDPATH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subpat</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>subpat</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CPATH_DIJKSTRA</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>transformDijkstra</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><call><name>transformShortestPath</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherMatchClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name><name>subpat</name><operator>-&gt;</operator><name>pattern</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>where</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>optional</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>detail</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>match</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subpat</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CSP_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>count</name><operator>-&gt;</operator><name>agg_star</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>transformTargetEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformCypherProjection</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherProjection</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherProjection</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>detail</name><operator>-&gt;</operator><name>where</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>where</name> <init>= <expr><name><name>detail</name><operator>-&gt;</operator><name>where</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CP_WITH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>where</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>where</name></name> <operator>=</operator> <name>where</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformCypherWhere</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>detail</name><operator>-&gt;</operator><name>distinct</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>detail</name><operator>-&gt;</operator><name>order</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
			 <name><name>detail</name><operator>-&gt;</operator><name>skip</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>detail</name><operator>-&gt;</operator><name>limit</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distinct</name> <init>= <expr><name><name>detail</name><operator>-&gt;</operator><name>distinct</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>order</name> <init>= <expr><name><name>detail</name><operator>-&gt;</operator><name>order</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>skip</name> <init>= <expr><name><name>detail</name><operator>-&gt;</operator><name>skip</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>limit</name> <init>= <expr><name><name>detail</name><operator>-&gt;</operator><name>limit</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * detach options so that this function passes through this if statement
		 * when the function is called again recursively
		 */</comment>
		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>distinct</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>distinct</name></name> <operator>=</operator> <name>distinct</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <name>skip</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>transformCypherOrderBy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>order</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>distinct</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* intentionally blank, do nothing */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>distinct</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <call><name>transformDistinctClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
														  <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
														  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>transformCypherLimit</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>, <argument><expr><name>EXPR_KIND_OFFSET</name></expr></argument>,
												<argument><expr><literal type="string">"SKIP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>transformCypherLimit</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>,
											   <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>transformItemList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>items</name></name></expr></argument>,
											<argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>detail</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CP_WITH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>checkNameInItems</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>items</name></name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>generateGroupClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
											   <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>detail</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CP_WITH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

		<comment type="block">/* try to resolve all target entries except vertex Var */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>qry-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>VERTEXOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>FVR_DONT_RESOLVE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													 <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>detail</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CP_RETURN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resolveItemList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parseCheckAggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>repairTargetListCollations</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to repair the collations due to the to_jsonb cast
 * after the creation of the group clause. If this function is passed a
 * NULL, it will return a NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>repairTargetListCollations</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>ls</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate through the targetList, looking for FuncExprs, skipping
	 * everything else.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>ls</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>		<modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_TargetEntry</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Once we find a FuncExpr, check to see if it is a to_jsonb
		 * cast. If it is, then we need to copy the inputcollid to the
		 * funccollid, provided the funccollid value is InvalidOid.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_FuncExpr</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name>	<modifier>*</modifier></type><name>fexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>!=</operator> <name>F_CYPHER_TO_JSONB</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
				<name><name>fexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name><name>fexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>targetList</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformCypherMatchClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherMatchClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherMatchClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * since WHERE clause is part of MATCH,
	 * transform OPTIONAL MATCH with its WHERE clause
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>detail</name><operator>-&gt;</operator><name>optional</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformMatchOptional</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* MATCH clause cannot follow OPTIONAL MATCH clause */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>cypherClauseTag</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_CypherMatchClause</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CypherMatchClause</name> <modifier>*</modifier></type><name>prev_detail</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>(</operator><name>CypherClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>prev_detail</name> <operator>=</operator> <operator>(</operator><name>CypherMatchClause</name> <operator>*</operator><operator>)</operator> <name><name>prev</name><operator>-&gt;</operator><name>detail</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>prev_detail</name><operator>-&gt;</operator><name>optional</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MATCH right after OPTIONAL MATCH is not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use a WITH clause between them"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_is_match_quals</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>detail</name><operator>-&gt;</operator><name>where</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <call><name>hasPropConstr</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_optional_match</name></name></expr> ?</condition><then> <expr><name>FVR_IGNORE_NULLABLE</name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_match_quals</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformCypherWhere</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>where</name></name></expr></argument>,
										<argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformElemQuals</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fplist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>fplist</name> <operator>=</operator> <call><name>getFindPaths</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_is_fp_processed</name></name> <operator>&amp;&amp;</operator> <name>fplist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_fp_processed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendFindPathsResult</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>fplist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>components</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_match_quals</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_fp_processed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * To do this at here is safe since it just uses transformed
				 * expression and does not look over the ancestors of `pstate`.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>collectNodeInfo</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>components</name> <operator>=</operator> <call><name>makeComponents</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformComponents</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>components</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* there is no need to resolve `qual` here */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
														 <argument><expr><name>FVR_DONT_RESOLVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformCypherCreateClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherCreateClause</name> <modifier>*</modifier></type><name>detail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>detail</name> <operator>=</operator> <operator>(</operator><name>CypherCreateClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpath</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make a CREATE clause for each path in the pattern */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherCreateClause</name> <modifier>*</modifier></type><name>newcreate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>newprev</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newcreate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherCreateClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcreate</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>,
										   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newprev</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newprev</name><operator>-&gt;</operator><name>detail</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcreate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newprev</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newprev</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_GRAPHWRITE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>=</operator> <name>GWROP_CREATE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>last</name></name> <operator>=</operator> <operator>(</operator><name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>pattern</name></name> <operator>=</operator> <call><name>transformCreatePattern</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>targets</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>nr_modify</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_nr_modify_clause</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													 <argument><expr><name>FVR_DONT_RESOLVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_eager</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformCypherDeleteClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherDeleteClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherDeleteClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<comment type="block">/* DELETE cannot be the first clause */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Merge same mode of DELETE clauses for reducing delete join */</comment>
	<while>while <condition>(<expr><call><name>cypherClauseTag</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_CypherDeleteClause</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherClause</name>	   <modifier>*</modifier></type><name>prev</name> <init>= <expr><operator>(</operator><name>CypherClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CypherDeleteClause</name> <modifier>*</modifier></type><name>prevDel</name> <init>= <expr><operator>(</operator><name>CypherDeleteClause</name> <operator>*</operator><operator>)</operator> <name><name>prev</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>prevDel</name><operator>-&gt;</operator><name>detach</name></name> <operator>==</operator> <name><name>detail</name><operator>-&gt;</operator><name>detach</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>prevDel</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>prev</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_GRAPHWRITE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>=</operator> <name>GWROP_DELETE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>last</name></name> <operator>=</operator> <operator>(</operator><name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>detach</name></name> <operator>=</operator> <name><name>detail</name><operator>-&gt;</operator><name>detach</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClauseBy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>, <argument><expr><name>transformDeleteJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>exprs</name></name> <operator>=</operator> <call><name>extractVerticesExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
										   <argument><expr><name>EXPR_KIND_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>nr_modify</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_nr_modify_clause</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * The edges of the vertices to remove are used only for removal,
	 * not for the next clause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>detail</name><operator>-&gt;</operator><name>detach</name></name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_delete_edges_resname</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>		<modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>gde</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GraphDelElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* This assumes the edge array always comes last. */</comment>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>gde</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_delete_edges_resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gde</name><operator>-&gt;</operator><name>elem</name></name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>, <argument><expr><name>EXPR_KIND_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add expression for deleting edges related target vertices. */</comment>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>gde</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_delete_edges_resname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_delete_edges_resname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>qry-&gt;graph.exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>gde</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>gde</name><operator>-&gt;</operator><name>elem</name></name> <operator>=</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>gde</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>,
										  <argument><expr><name>FVR_PRESERVE_VAR_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													 <argument><expr><name>FVR_DONT_RESOLVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_eager</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>findAllModifiedLabels</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformCypherSetClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherSetClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherSetClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<comment type="block">/* SET/REMOVE cannot be the first clause */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CSET_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_GRAPHWRITE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>=</operator> <name>GWROP_SET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>last</name></name> <operator>=</operator> <operator>(</operator><name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>sets</name></name> <operator>=</operator> <call><name>transformSetPropList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>is_remove</name></name></expr></argument>,
										   <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>qry-&gt;graph.sets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphSetProp</name> <modifier>*</modifier></type><name>gsp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>gsp</name><operator>-&gt;</operator><name>elem</name></name> <operator>=</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>gsp</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>,
										  <argument><expr><name>FVR_PRESERVE_VAR_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gsp</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>gsp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										  <argument><expr><name>FVR_PRESERVE_VAR_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>nr_modify</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_nr_modify_clause</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													 <argument><expr><name>FVR_DONT_RESOLVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>qry-&gt;graph.sets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphSetProp</name> <modifier>*</modifier></type><name>gsp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>gsp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>assign_query_eager</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>findAllModifiedLabels</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformCypherMergeClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherMergeClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherMergeClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>prev_rte</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MERGE can have only one path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_GRAPHWRITE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>=</operator> <name>GWROP_MERGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>last</name></name> <operator>=</operator> <operator>(</operator><name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClauseBy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>, <argument><expr><name>transformMergeMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make an expression list to create the MERGE path.
	 * We assume that the previous clause is the first RTE of MERGE MATCH.
	 */</comment>
	<expr_stmt><expr><name>prev_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>pattern</name></name> <operator>=</operator> <call><name>transformMergeCreate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>,
											  <argument><expr><name>prev_rte</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>targets</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>sets</name></name> <operator>=</operator> <call><name>transformMergeOnSet</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>sets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>nr_modify</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_nr_modify_clause</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													 <argument><expr><name>FVR_DONT_RESOLVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_eager</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>findAllModifiedLabels</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformCypherLoadClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherLoadClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherLoadClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><name><name>detail</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>findTarget</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeWholeRowTarget</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Query</name> <modifier>*</modifier></type>
<name>transformCypherUnwindClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherUnwindClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherUnwindClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>targetloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>unwind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseExprKind</name></type> <name>sv_expr_kind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>funcexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get all the target variables from the previous clause and add them to
	 * this query as target variables so that next clauses can access them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>detail</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetloc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the name (e.g. "n" in "UNWNID v AS n") is the same with the name of
	 * targets from the previous clause, throw an error.
	 *
	 * e.g. MATCH (n)-[]-&gt;(m) UNWIND n.a AS m ...
	 *                     ^                ^
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>findTarget</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>targetloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Only jsonb array works. It throws an error for all other types.
		 * This is the best because we don't know the actual value in the jsonb
		 * value at this point.
		 */</comment>
		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <literal type="string">"jsonb_array_elements"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>type_is_array</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <literal type="string">"unnest"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expression must be jsonb or array, but %s"</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>targetloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>unwind</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The logic here is the same with the one in transformTargetEntry().
	 * We cannot use this function because we already transformed the target
	 * expression above to get the type of it.
	 */</comment>
	<expr_stmt><expr><name>sv_expr_kind</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_SELECT_TARGET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_srf</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcexpr</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>unwind</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>last_srf</name></expr></argument>, <argument><expr><name>unwind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>sv_expr_kind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>funcexpr</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* check whether resulting columns have a name or not */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkNameInItems</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<macro><name>forboth</name><argument_list>(<argument>li</argument>, <argument>items</argument>, <argument>lt</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResTarget</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expression in WITH must be aliased (use AS)"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* See transformFromClauseItem() */</comment>
<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformMatchOptional</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherMatchClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherMatchClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_nsitem</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>r_alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prevclause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>l_alias</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * To return NULL if OPTIONAL MATCH is the first clause and there is
		 * no result that matches the pattern.
		 */</comment>

		<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>l_alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_SUBQUERY_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>l_nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>l_alias</name></expr></argument>,
												 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l_nsitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>l_nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Transform RIGHT. Prevent `clause` from being transformed infinitely.
	 * `p_cols_visible` of `l_rte` must be set to allow `r_rte` to see columns
	 * of `l_rte` by their name.
	 */</comment>

	<expr_stmt><expr><name>prevclause</name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>optional</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_optional_match</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>r_alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_OPTMATCH_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r_nsitem</name> <operator>=</operator> <call><name>transformClauseImpl</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>, <argument><expr><name>transformStmt</name></expr></argument>,
								   <argument><expr><name>r_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_is_optional_match</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>detail</name><operator>-&gt;</operator><name>optional</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prevclause</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_SUBQUERY_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>incrementalJoinRTEs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>JOIN_LEFT</name></expr></argument>, <argument><expr><name>l_nsitem</name></expr></argument>, <argument><expr><name>r_nsitem</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
							   <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hasPropConstr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lp</argument>, <argument>pattern</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>p-&gt;chain</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>CypherNode</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name> <init>= <expr><operator>(</operator><name>CypherNode</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name> <init>= <expr><operator>(</operator><name>CypherRel</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>CypherRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>getFindPaths</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fplist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lp</argument>, <argument>pattern</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>CPATH_NORMAL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fplist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fplist</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>fplist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendFindPathsResult</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fplist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>fplist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CypherRel</name>  <modifier>*</modifier></type><name>crel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pathname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>edgename</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>weightvar</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CPATH_DIJKSTRA</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>transformDijkstraInMatch</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>transformShortestPathInMatch</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pathname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pathname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>,
													   <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
								 <argument><expr><name>pathname</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CPATH_DIJKSTRA</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>weightvar</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>weight_var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>weightvar</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														   <argument><expr><name>nsitem</name></expr></argument>,
														   <argument><expr><name>weightvar</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
									 <argument><expr><name>weightvar</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>edgename</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														   <argument><expr><name>nsitem</name></expr></argument>,
														   <argument><expr><name>edgename</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
									 <argument><expr><name>edgename</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>collectNodeInfo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lp</argument>, <argument>pattern</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>p-&gt;chain</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>cnode</name></expr></argument>, <argument><expr><name>CypherNode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>addNodeInfo</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>addNodeInfo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>labname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeInfo</name>   <modifier>*</modifier></type><name>ni</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ni</name> <operator>=</operator> <call><name>findNodeInfo</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ni</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ni</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ni</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ni</name><operator>-&gt;</operator><name>varname</name></name> <operator>=</operator> <name>varname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ni</name><operator>-&gt;</operator><name>labname</name></name> <operator>=</operator> <name>labname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ni</name><operator>-&gt;</operator><name>prop_constr</name></name> <operator>=</operator> <operator>(</operator><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_node_info_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_node_info_list</name></name></expr></argument>, <argument><expr><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ni</name><operator>-&gt;</operator><name>labname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ni</name><operator>-&gt;</operator><name>labname</name></name> <operator>=</operator> <name>labname</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>labname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>ni</name><operator>-&gt;</operator><name>labname</name></name></expr></argument>, <argument><expr><name>labname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>varloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label conflict on node \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>ni</name><operator>-&gt;</operator><name>prop_constr</name></name> <operator>=</operator> <operator>(</operator><name><name>ni</name><operator>-&gt;</operator><name>prop_constr</name></name> <operator>||</operator> <operator>(</operator><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NodeInfo</name> <modifier>*</modifier></type>
<name>getNodeInfo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeInfo</name> <modifier>*</modifier></type><name>ni</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ni</name> <operator>=</operator> <call><name>findNodeInfo</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ni</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NodeInfo</name> <modifier>*</modifier></type>
<name>findNodeInfo</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>pstate-&gt;p_node_info_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NodeInfo</name> <modifier>*</modifier></type><name>ni</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ni</name><operator>-&gt;</operator><name>varname</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ni</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* make connected components */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>makeComponents</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>components</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lp</argument>, <argument>pattern</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>repr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

		<comment type="block">/* find the first connected component */</comment>
		<expr_stmt><expr><name>repr</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>components</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>isPathConnectedTo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>repr</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * if there is no matched connected component,
		 * make a new connected component which is a list of CypherPath's
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>repr</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>components</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* find other connected components and merge them to `repr` */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>components</argument>, <argument>lnext(components, lc)</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>isPathConnectedTo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>list_concat</name><argument_list>(<argument><expr><name>repr</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>components</name> <operator>=</operator> <call><name>foreach_delete_current</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* add the path to `repr` */</comment>
		<expr_stmt><expr><name>repr</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>repr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>components</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>components</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isPathConnectedTo</name><parameter_list>(<parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>component</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lp</argument>, <argument>component</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>arePathsConnected</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arePathsConnected</name><parameter_list>(<parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le1</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le1</argument>, <argument>path1-&gt;chain</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode1</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le2</name></decl>;</decl_stmt>

		<comment type="block">/* node variables are the only concern */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>cnode1</name></expr></argument>, <argument><expr><name>CypherNode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>varname1</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode1</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* treat it as a unique node */</comment>
		<if_stmt><if>if <condition>(<expr><name>varname1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>le2</argument>, <argument>path2-&gt;chain</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode2</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname2</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>cnode2</name></expr></argument>, <argument><expr><name>CypherNode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>varname2</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode2</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>varname2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>varname1</name></expr></argument>, <argument><expr><name>varname2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformComponents</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>components</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eqoList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>leqo</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>components</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ueids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ueidarrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lp</argument>, <argument>c</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pathname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>pathloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>out</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>vertex_is_nsitem</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CypherRel</name>  <modifier>*</modifier></type><name>prev_crel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>prev_edge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>pvs</name> <init>= <expr><call><name>makeArrayExpr</name><argument_list>(<argument><expr><name>VERTEXARRAYOID</name></expr></argument>, <argument><expr><name>VERTEXOID</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>pes</name> <init>= <expr><call><name>makeArrayExpr</name><argument_list>(<argument><expr><name>EDGEARRAYOID</name></expr></argument>, <argument><expr><name>EDGEOID</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>out</name> <operator>=</operator> <operator>(</operator><name>pathname</name> <operator>!=</operator> <name>NULL</name>              <operator>||</operator>
				   <name><name>p</name><operator>-&gt;</operator><name>kind</name></name>  <operator>==</operator> <name>CPATH_SHORTEST</name>    <operator>||</operator>
				   <name><name>p</name><operator>-&gt;</operator><name>kind</name></name>  <operator>==</operator> <name>CPATH_SHORTEST_ALL</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pathloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>te</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>pathname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>pathloc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pathloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>edge_nsitem</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>cnode</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* `cnode` is the first node in the path */</comment>
				<if_stmt><if>if <condition>(<expr><name>prev_crel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>zero</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* vertex only path */</comment>
					<if_stmt><if>if <condition>(<expr><name>le</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>transformMatchNode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cnode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
													<argument><expr><name>targetList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqoList</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>vertex_is_nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * if `crel` is zero-length VLE, get RTE of `cnode`
					 * because `crel` needs `id` column of the RTE
					 */</comment>
					<expr_stmt><expr><name>zero</name> <operator>=</operator> <call><name>isZeroLengthVLE</name><argument_list>(<argument><expr><name>crel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>transformMatchNode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cnode</name></expr></argument>,
												<argument><expr><operator>(</operator><name>zero</name> <operator>||</operator> <name>out</name><operator>)</operator></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>eqoList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vertex_is_nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>CPATH_NORMAL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>setInitialVidForVLE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>,
										<argument><expr><name>vertex_is_nsitem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>edge_nsitem</name> <operator>=</operator> <call><name>transformMatchRel</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>eqoList</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>addQualNodeIn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>,
										 <argument><expr><name>vertex_is_nsitem</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>edge_nsitem</name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>transformMatchNode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cnode</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>eqoList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vertex_is_nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>addQualNodeIn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>,
										 <argument><expr><name>vertex_is_nsitem</name></expr></argument>, <argument><expr><name>prev_crel</name></expr></argument>,
										 <argument><expr><name>prev_edge</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* end of the path */</comment>
					<if_stmt><if>if <condition>(<expr><name>le</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>crel</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>setInitialVidForVLE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>, <argument><expr><name>vertex_is_nsitem</name></expr></argument>,
										<argument><expr><name>prev_crel</name></expr></argument>, <argument><expr><name>prev_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>edge_nsitem</name> <operator>=</operator> <call><name>transformMatchRel</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>eqoList</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>addQualRelPath</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>prev_crel</name></expr></argument>, <argument><expr><name>prev_edge</name></expr></argument>,
										  <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>edge_nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* uniqueness */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>eid</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>eid</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>edge_nsitem</name></expr></argument>,
									   <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ueids</name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(<argument><expr><name>ueids</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>eidarr</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>eidarr</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>edge_nsitem</name></expr></argument>,
										  <argument><expr><name>VLE_COLNAME_IDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ueidarrs</name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(<argument><expr><name>ueidarrs</name></expr></argument>, <argument><expr><name>eidarr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vertex</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Starting vertex of ZeroLengthVLE is excluded from
					 * the graph path.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isZeroLengthVLE</name><argument_list>(<argument><expr><name>crel</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>pvs</name> <operator>=</operator> <call><name>vtxArrConcat</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pvs</name></expr></argument>,
										   <argument><expr><call><name>makePathVertexExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>,
															  <argument><expr><name>vertex_is_nsitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>pes</name> <operator>=</operator> <call><name>edgeArrConcat</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pes</name></expr></argument>,
											<argument><expr><call><name>makeEdgeExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>,
														 <argument><expr><name>edge_nsitem</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>pvs</name> <operator>=</operator> <call><name>vtxArrConcat</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pvs</name></expr></argument>,
										   <argument><expr><call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														<argument><expr><name>edge_nsitem</name></expr></argument>,
														<argument><expr><name>VLE_COLNAME_VERTICES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>pes</name> <operator>=</operator> <call><name>edgeArrConcat</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pes</name></expr></argument>,
											<argument><expr><call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														 <argument><expr><name>edge_nsitem</name></expr></argument>,
														 <argument><expr><name>VLE_COLNAME_EDGES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>prev_crel</name> <operator>=</operator> <name>crel</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>prev_edge</name> <operator>=</operator> <name>edge_nsitem</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>out</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CPATH_NORMAL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>graphpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vertex</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pvs</name> <operator>=</operator> <call><name>vtxArrConcat</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pvs</name></expr></argument>,
								   <argument><expr><call><name>makePathVertexExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>,
													  <argument><expr><name>vertex_is_nsitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>graphpath</name> <operator>=</operator> <call><name>makeTypedRowExpr</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>pvs</name></expr></argument>, <argument><expr><name>pes</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>GRAPHPATHOID</name></expr></argument>, <argument><expr><name>pathloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>,
									  <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>graphpath</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
													  <argument><expr><name>pathname</name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>addQualUniqueEdges</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>ueids</name></expr></argument>, <argument><expr><name>ueidarrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Process all ElemQualOnly's at here because there are places that assume
	 * resjunk columns come after non-junk columns.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>leqo</argument>, <argument>eqoList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ElemQualOnly</name> <modifier>*</modifier></type><name>eqo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>leqo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><name><name>eqo</name><operator>-&gt;</operator><name>te</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addElemQual</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name><name>eqo</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformMatchNode</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>eqoList</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNSItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeInfo</name>   <modifier>*</modifier></type><name>ni</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>labname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>labloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prop_constr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>isNSItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * If a vertex with the same variable is already in the target list,
	 * - the vertex is from the previous clause or
	 * - a node with the same variable in the pattern are already processed,
	 * so skip `cnode`.
	 */</comment>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VERTEXOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>addElemQual</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>scanNameSpaceForRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nsitem</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * `te` can be from the previous clause or the pattern.
			 * If it is from the pattern, it should be an actual vertex or
			 * a future vertex
			 */</comment>

			<comment type="block">/*
			 * if the variable is from the previous clause, it should not
			 * have a label constraint
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label on variable from previous clauses is not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												   <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>te</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* previously returned RTE_RELATION by this function */</comment>
			<expr_stmt><expr><operator>*</operator><name>isNSItem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nsitem</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * try to find the variable when this pattern is within an OPTIONAL MATCH
	 * or a sub-SELECT
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>te</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>varname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>col</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FutureVertex</name> <modifier>*</modifier></type><name>fv</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>col</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VERTEXOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>col</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
								 <argument><expr><name>varname</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>addElemQual</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* `col` can be a future vertex */</comment>
			<expr_stmt><expr><name>fv</name> <operator>=</operator> <call><name>findFutureVertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>col</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>col</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
								  <argument><expr><name><name>col</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>fv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>addFutureVertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name><name>fv</name><operator>-&gt;</operator><name>labname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>te</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>labname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>labloc</name> <operator>=</operator> <call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prop_constr</name> <operator>=</operator> <operator>(</operator><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ni</name> <operator>=</operator> <call><name>getNodeInfo</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ni</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>labname</name> <operator>=</operator> <name><name>ni</name><operator>-&gt;</operator><name>labname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>labloc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>prop_constr</name> <operator>=</operator> <name><name>ni</name><operator>-&gt;</operator><name>prop_constr</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>labname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>labname</name> <operator>=</operator> <name>AG_VERTEX</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vertexLabelExist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labname</name></expr></argument>, <argument><expr><name>labloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If `cnode` has a label constraint or a property constraint, return RTE.
	 *
	 * If `cnode` is in a path, return RTE because the path must consist of
	 * valid vertices.
	 * If there is no previous relationship of `cnode` in the path and
	 * the next relationship of `cnode` is zero-length, return RTE
	 * because the relationship needs starting point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>labname</name></expr></argument>, <argument><expr><name>AG_VERTEX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>prop_constr</name> <operator>||</operator> <name>force</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>labname</name></expr></argument>,
						 <argument><expr><name>labloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <operator>!</operator><name><name>cnode</name><operator>-&gt;</operator><name>only</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set `ihn` to true because we should scan all derived tables */</comment>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>prop_constr</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>resjunk</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>resno</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If `varname` is NULL, this target has to be ignored when
			 * `RETURN *`.
			 */</comment>
			<expr_stmt><expr><name>resjunk</name> <operator>=</operator> <operator>(</operator><name>varname</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>resno</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>resjunk</name></expr> ?</condition><then> <expr><name>InvalidAttrNumber</name></expr> </then><else>: <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVertexExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														 <argument><expr><name>nsitem</name></expr></argument>,
														 <argument><expr><name>varloc</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name></expr></argument>,
								 <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
								 <argument><expr><name>resjunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>resjunk</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ElemQualOnly</name> <modifier>*</modifier></type><name>eqo</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>eqo</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>eqo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>eqo</name><operator>-&gt;</operator><name>te</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>eqo</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>=</operator> <name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>eqoList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>eqoList</name></expr></argument>, <argument><expr><name>eqo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>addElemQual</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* return RTE to help the caller can access columns directly */</comment>
		<expr_stmt><expr><operator>*</operator><name>isNSItem</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nsitem</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* this node is just a placeholder for relationships */</comment>
	<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * `cnode` is assigned to the variable `varname` but there is a chance to
	 * omit the RTE for `cnode` if no expression uses properties of `cnode`.
	 * So, return a (invalid) future vertex at here for later use.
	 */</comment>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>GRAPHIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>makeTypedRowExpr</name><argument_list>(<argument><expr><call><name>list_make3</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VERTEXOID</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><name>varname</name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* there is no need to addElemQual() here */</comment>
	<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>addFutureVertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name>labname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>te</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformMatchRel</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>eqoList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<comment type="block">/* all relationships must be unique */</comment>
	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>te</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>varname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>getCypherRelType</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><name>AG_EDGE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>edgeLabelExist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>typname</name></expr></argument>, <argument><expr><name>typloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>transformMatchSR</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>eqoList</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>transformMatchVLE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>pathout</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformMatchSR</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>eqoList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getCypherRelType</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addEdgeUnion</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>typname</name></expr></argument>, <argument><expr><name><name>crel</name><operator>-&gt;</operator><name>only</name></name></expr></argument>, <argument><expr><name>typloc</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typname</name></expr></argument>, <argument><expr><name>typloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <operator>!</operator><name><name>crel</name><operator>-&gt;</operator><name>only</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>resjunk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>resno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>resjunk</name> <operator>=</operator> <operator>(</operator><name>varname</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>resno</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>resjunk</name></expr> ?</condition><then> <expr><name>InvalidAttrNumber</name></expr> </then><else>: <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeEdgeExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>,
												   <argument><expr><name>varloc</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name></expr></argument>,
							 <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
							 <argument><expr><name>resjunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>resjunk</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ElemQualOnly</name> <modifier>*</modifier></type><name>eqo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>eqo</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>eqo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>eqo</name><operator>-&gt;</operator><name>te</name></name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>eqo</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>=</operator> <name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>eqoList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>eqoList</name></expr></argument>, <argument><expr><name>eqo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>addElemQual</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>nsitem</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>addEdgeUnion</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>edge_label</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>only</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>,
			 <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>u</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>alias</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>genEdgeUnion</name><argument_list>(<argument><expr><name>edge_label</name></expr></argument>, <argument><expr><name>only</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<return>return <expr><call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SELECT id, start, "end", properties, ctid, start AS _start, "end" AS _end
 * FROM `get_graph_path()`.`edge_label`
 * UNION ALL
 * SELECT id, start, "end", properties, ctid, "end" AS _start, start AS _end
 * FROM `get_graph_path()`.`edge_label`
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>genEdgeUnion</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>edge_label</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>only</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>lsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>rsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>u</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>edge_label</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <operator>!</operator><name>only</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>lsel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make5</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rsel</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>lsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>,
												   <argument><expr><name>EDGE_UNION_START_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>,
												   <argument><expr><name>EDGE_UNION_END_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>,
												   <argument><expr><name>EDGE_UNION_START_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							   <argument><expr><call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>,
												   <argument><expr><name>EDGE_UNION_END_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SETOP_UNION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>all</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>lsel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <name>rsel</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>u</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setInitialVidForVLE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>vertexIsNSItem</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>prev_crel</name></decl></parameter>,
					<parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>prev_edge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

	<comment type="block">/* nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vertex</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>isFutureVertexExpr</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prev_crel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_vid</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_nsitem</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>getEdgeColname</name><argument_list>(<argument><expr><name>prev_crel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(
					<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>prev_edge</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_vid</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cref</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_nsitem</name></name> <operator>=</operator> <name>prev_edge</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vertexIsNSItem</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(
				<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_vid</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cref</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_nsitem</name></name> <operator>=</operator> <name>nsitem</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>vid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* vertex or future vertex */</comment>

		<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>vid</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>AG_ELEM_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_vid</name></name> <operator>=</operator> <name>vid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_nsitem</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformMatchVLE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>out</name> <init>= <expr><operator>(</operator><name>varname</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>pathout</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>genVLESubselect</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>pathout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasOptUnique</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformVLEtoNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sel</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>resjunk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>resno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>resjunk</name> <operator>=</operator> <operator>(</operator><name>varname</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>resno</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>resjunk</name></expr> ?</condition><then> <expr><name>InvalidAttrNumber</name></expr> </then><else>: <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>VLE_COLNAME_EDGES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name></expr></argument>,
							 <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
							 <argument><expr><name>resjunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pathout</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>VLE_COLNAME_VERTICES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
							 <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
							 <argument><expr><call><name>genUniqueName</name><argument_list>()</argument_list></call></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>nsitem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CYPHER_REL_DIR_NONE
 *
 *     SELECT l._start, l._end, l.ids, l.edges, l.vertices,
 *            r.next, r.id, r.edge, r.vertex
 *     FROM `genVLELeftChild()` VLE JOIN LATERAL `genVLERightChild()` ON TRUE
 *
 * CYPHER_REL_DIR_LEFT
 *
 *     SELECT l.end, l.start, l.ids, l.edges, l.vertices,
 *            r.next, r.id, r.edge, r.vertex
 *     FROM `genVLELeftChild()` VLE JOIN LATERAL `genVLERightChild()` ON TRUE
 *
 * CYPHER_REL_DIR_RIGHT
 *
 *     SELECT l.start, l.end, l.ids, l.edges, l.vertices,
 *            r.next, r.id, r.edge, r.vertex
 *     FROM `genVLELeftChild()` VLE JOIN LATERAL `genVLERightChild()` ON TRUE
 *
 * NOTE: If the order of the result targets is changed,
 *       `XXX_VARNO` macro definitions in nodeNestloopVle.c
 *       must be synchronized with the changed order.
 */</comment>
<function><type><specifier>static</specifier> <name>SelectStmt</name> <modifier>*</modifier></type>
<name>genVLESubselect</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prev_colname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prev_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curr_colname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> 	   <modifier>*</modifier></type><name>curr_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ids_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>ids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>next_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>id_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> 	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>join</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prev_colname</name> <operator>=</operator> <call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>, <argument><expr><name>prev_colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>prev_col</name></expr></argument>, <argument><expr><name>prev_colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>curr_colname</name> <operator>=</operator> <call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curr_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>, <argument><expr><name>curr_colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curr</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>curr_col</name></expr></argument>, <argument><expr><name>curr_colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ids_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>, <argument><expr><name>VLE_COLNAME_IDS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>ids_col</name></expr></argument>, <argument><expr><name>VLE_COLNAME_IDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edges_col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>edges_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>,
												   <argument><expr><name>VLE_COLNAME_EDGES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>edges_col</name></expr></argument>, <argument><expr><name>VLE_COLNAME_EDGES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pathout</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertices_col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vertices_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>,
													  <argument><expr><name>VLE_COLNAME_VERTICES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>vertices_col</name></expr></argument>, <argument><expr><name>VLE_COLNAME_VERTICES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>next_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>,
											  <argument><expr><name>VLE_COLNAME_NEXT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>next_col</name></expr></argument>, <argument><expr><name>VLE_COLNAME_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>id_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>id_col</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>edge_col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>edge_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>,
												  <argument><expr><name>VLE_COLNAME_EDGE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>edge_col</name></expr></argument>, <argument><expr><name>VLE_COLNAME_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pathout</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>vertex_col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vertex_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>,
													<argument><expr><name>VLE_COLNAME_VERTEX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>vertex_col</name></expr></argument>, <argument><expr><name>VLE_COLNAME_VERTEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>genVLELeftChild</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>pathout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>genVLERightChild</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>pathout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>join</name> <operator>=</operator> <call><name>genVLEJoinExpr</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CYPHER_REL_DIR_NONE
 *
 *     SELECT _start, _end, ARRAY[id] AS ids,
 *            ARRAY[(id, start, "end", properties, ctid)::edge] AS edges
 *            ARRAY[NULL::vertex] AS vertices
 *     FROM &lt;edge label with additional _start and _end columns&gt; AS l
 *     WHERE &lt;outer vid&gt; = _start AND l.properties @&gt; ...)
 *
 * CYPHER_REL_DIR_LEFT
 *
 *     SELECT "end", start, ARRAY[id] AS ids,
 *            ARRAY[(id, start, "end", properties, ctid)::edge] AS edges
 *            ARRAY[NULL::vertex] AS vertices
 *     FROM &lt;edge label (and its children)&gt; AS l
 *     WHERE &lt;outer vid&gt; = "end" AND l.properties @&gt; ...)
 *
 * CYPHER_REL_DIR_RIGHT
 *
 *     SELECT start, "end", ARRAY[id] AS ids,
 *            ARRAY[(id, start, "end", properties, ctid)::edge] AS edges
 *            ARRAY[NULL::vertex] AS vertices
 *     FROM &lt;edge label (and its children)&gt; AS l
 *     WHERE &lt;outer vid&gt; = start AND l.properties @&gt; ...)
 *
 * If `isZeroLengthVLE(crel)`, then
 *
 *     CYPHER_REL_DIR_NONE
 *
 *         VALUES (&lt;outer vid&gt;, &lt;outer vid&gt;, ARRAY[]::_graphid,
 *                 ARRAY[]::_edge, ARRAY[]::_vertex)
 *         AS l(_start, _end, ids, edges, vertices)
 *
 *     CYPHER_REL_DIR_LEFT
 *
 *         VALUES (&lt;outer vid&gt;, &lt;outer vid&gt;, ARRAY[]::_graphid,
 *                 ARRAY[]::_edge, ARRAY[]::_vertices)
 *         AS l("end", start, ids, edges, vertices)
 *
 *     CYPHER_REL_DIR_RIGHT
 *
 *         VALUES (&lt;outer vid&gt;, &lt;outer vid&gt;, ARRAY[]::_graphid,
 *                 ARRAY[]::_edge, ARRAY[]::_vertices)
 *         AS l(start, "end", ids, edges, vertices)
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>genVLELeftChild</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>idarr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>edgearr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * `vid` is NULL only if
	 * (there is no previous edge of the vertex in the path
	 *  and the vertex is transformed first time in the pattern)
	 * and `crel` is not zero-length
	 */</comment>
	<expr_stmt><expr><name>vid</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_vid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isZeroLengthVLE</name><argument_list>(<argument><expr><name>crel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>ids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vid</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>idarr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>idarr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ids</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>idarr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ids</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"_graphid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ids</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>vid</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>VLE_COLNAME_IDS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeCast</name> <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>edgearr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edgearr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edges</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>edgearr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edges</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"_edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edges</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>VLE_COLNAME_EDGES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>pathout</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeCast</name>  <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>vtxarr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>vtxarr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vtxarr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vertices</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator> <name>vtxarr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vertices</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"_vertex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vertices</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>VLE_COLNAME_VERTICES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>valuesLists</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prev_colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prev_col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>cast</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>ids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>where_args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>prev_colname</name> <operator>=</operator> <call><name>genQualifiedName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><name>prev_colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>prev_col</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>curr</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idarr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>idarr</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>idarr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cast</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>idarr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"_graphid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cast</name></expr></argument>, <argument><expr><name>VLE_COLNAME_IDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>genVLEEdgeSubselect</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>edgearr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edgearr</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>genEdgeSimple</name><argument_list>(<argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edgearr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cast</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>edgearr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"_edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cast</name></expr></argument>, <argument><expr><name>VLE_COLNAME_EDGES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>pathout</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cast</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator> <call><name>makeNullAConst</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"_vertex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cast</name></expr></argument>, <argument><expr><name>VLE_COLNAME_VERTICES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>vid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>vidcond</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>vidcond</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>prev_col</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>where_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>where_args</name></expr></argument>, <argument><expr><name>vidcond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* TODO: cannot see properties of future vertices */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>where_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>where_args</name></expr></argument>, <argument><expr><call><name>genVLEQual</name><argument_list>(<argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>,
														<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>where_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeSubselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>, <argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CYPHER_REL_DIR_NONE
 *
 *     SELECT r._end AS next, r.id,
 *            (r.id, r.start, r."end", r.properties, r.ctid)::edge AS edge,
 *            (vtx.id, vtx.properties, vtx.ctid)::vertex AS vertex
 *     FROM &lt;edge label with additional _start and _end columns&gt; AS r,
 *          &lt;all vertex label&gt; AS vtx
 *     WHERE l._end = r._start AND l._end = vtx.id AND r.properties @&gt; ...)
 *
 * CYPHER_REL_DIR_LEFT
 *
 *     SELECT r.start AS next, r.id,
 *            (r.id, r.start, r."end", r.properties, r.ctid)::edge AS edge,
 *            (vtx.id, vtx.properties, vtx.ctid)::vertex AS vertex
 *     FROM &lt;edge label (and its children)&gt; AS r,
 *          &lt;all vertex label&gt; AS vtx
 *     WHERE l.start = r.end AND l.start = vtx.id AND r.properties @&gt; ...)
 *
 * CYPHER_REL_DIR_RIGHT
 *
 *     SELECT r."end" AS next, r.id,
 *            (r.id, r.start, r."end", r.properties, r.ctid)::edge AS edge,
 *            (vtx.id, vtx.properties, vtx.ctid)::vertex AS vertex
 *     FROM &lt;edge label (and its children)&gt; AS r,
 *          &lt;all vertex label&gt; AS vtx
 *     WHERE l.end = r.start AND l.end = vtx.id AND r.properties @&gt; ...)
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>genVLERightChild</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pathout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>colref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>from</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>joinqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>where_args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>colref</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>,
											<argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>colref</name></expr></argument>, <argument><expr><name>VLE_COLNAME_NEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>colref</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><name>colref</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><call><name>genEdgeSimple</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VLE_COLNAME_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><call><name>genVLEEdgeSubselect</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_LEFT_ALIAS</name></expr></argument>,
									<argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>curr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>,
									<argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>joinqual</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prev</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>curr</name></expr></argument>,
								<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>where_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>where_args</name></expr></argument>, <argument><expr><name>joinqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>where_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>where_args</name></expr></argument>, <argument><expr><call><name>genVLEQual</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>,
													<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pathout</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>vtx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>vtxid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vtx</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AG_VERTEX</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vtx</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>VLE_VERTEX_ALIAS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>vtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><call><name>genVertexSimple</name><argument_list>(<argument><expr><name>VLE_VERTEX_ALIAS</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>VLE_COLNAME_VERTEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>vtxid</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vtxid</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>genQualifiedName</name><argument_list>(<argument><expr><name>VLE_VERTEX_ALIAS</name></expr></argument>, <argument><expr><name>AG_ELEM_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vtxid</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>joinqual</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>,
									<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>vtxid</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>curr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>where_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>where_args</name></expr></argument>, <argument><expr><name>joinqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>where_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeSubselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>VLE_RIGHT_ALIAS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>genVertexSimple</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowExpr</name>	   <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>row</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"vertex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vertex</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>genEdgeSimple</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowExpr</name>	   <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>AG_START_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>AG_END_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make5</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>row</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>edge</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>genVLEEdgeSubselect</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getCypherRelType</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>

		<comment type="block">/* id, start, "end", properties, ctid, _start, _end */</comment>
		<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeSubselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <call><name>genEdgeUnion</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><name><name>crel</name><operator>-&gt;</operator><name>only</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>edge</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <operator>!</operator><name><name>crel</name><operator>-&gt;</operator><name>only</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>aliasname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>RowShareLock</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>parserOpenTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* id, start, "end", properties, ctid */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>crel</name><operator>-&gt;</operator><name>only</name></name> <operator>&amp;&amp;</operator> <call><name>has_subclass</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>genInhEdge</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>edge</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>edge</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>edge</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>genVLEJoinExpr</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>larg</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rarg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>trueconst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>truecond</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>indices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>minHops</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxHops</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>trueconst</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trueconst</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trueconst</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <literal type="string">"t"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trueconst</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>truecond</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>truecond</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>trueconst</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>truecond</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(
			<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>, <argument><expr><literal type="string">"bool"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>truecond</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>indices</name> <operator>=</operator> <operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minHops</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name><operator>)</operator><operator>-&gt;</operator><name><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>indices</name><operator>-&gt;</operator><name>uidx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxHops</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name><name>indices</name><operator>-&gt;</operator><name>uidx</name></name><operator>)</operator><operator>-&gt;</operator><name><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_VLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>larg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <name>rarg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>truecond</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>minHops</name></name> <operator>=</operator> <name>minHops</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>maxHops</name></name> <operator>=</operator> <name>maxHops</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>genQualifiedName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>name1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>name2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>name1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>name2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>genVLEQual</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>propMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>prop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherGenericExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>propcond</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prop</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>genQualifiedName</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prop</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherGenericExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>propMap</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>propcond</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"@&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prop</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>,
								<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>propcond</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * UNION ALL the relation whose OID is `parentoid` and its child relations.
 *
 * SELECT id, start, "end", properties, ctid FROM `r`
 * UNION ALL
 * SELECT id, start, "end", properties, ctid FROM edge
 * ...
 */</comment>
<function><type><specifier>static</specifier> <name>RangeSubselect</name> <modifier>*</modifier></type>
<name>genInhEdge</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>lsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_START_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_END_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>makeSimpleResTarget</name><argument_list>(<argument><expr><literal type="string">"ctid"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make5</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsel</name> <operator>=</operator> <name>sel</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>parentoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>childrv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>rsel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>u</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>childrv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrv</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rsel</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>rsel</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rsel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>childrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>SETOP_UNION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>all</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>lsel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <name>rsel</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>lsel</name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeSubselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>lsel</name></expr>;</expr_stmt>

	<return>return <expr><name>sub</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformVLEtoNSItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>vle</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>vle_initial_nsitem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make the RTE temporarily visible */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_nsitem</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>vle_initial_nsitem</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_vle_initial_nsitem</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vle_initial_nsitem</name><operator>-&gt;</operator><name>p_rel_visible</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>vle</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>vle_initial_nsitem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>vle_initial_nsitem</name><operator>-&gt;</operator><name>p_rel_visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>isVLE</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nsitem</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isZeroLengthVLE</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>indices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>lidx</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>crel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>indices</name> <operator>=</operator> <operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lidx</name> <operator>=</operator> <operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name><name>lidx</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>getCypherRelType</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>typname</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>typloc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>typname</name> <operator>=</operator> <name>AG_EDGE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typloc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>typloc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple types for relationship not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>typname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typloc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>typloc</name> <operator>=</operator> <call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>addQualRelPath</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>prev_crel</name></decl></parameter>,
			   <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>prev_edge</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
			   <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prev_vid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * NOTE: If `crel` is VLE and a node between `prev_crel` and `crel` is
	 *       either a placeholder or a new future vertex,
	 *       the initial vid of `crel` is `prev_vid` already.
	 *       Currently, just add kind of duplicate qual anyway.
	 */</comment>

	<expr_stmt><expr><name>prev_vid</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>prev_edge</name></expr></argument>, <argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>prev_crel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vid</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>prev_vid</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>addQualNodeIn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>vertexIsNSItem</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vid</name></decl>;</decl_stmt>

	<comment type="block">/* `vertex` is just a placeholder for relationships */</comment>
	<if_stmt><if>if <condition>(<expr><name>vertex</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>qual</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isFutureVertexExpr</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setFutureVertexExprId</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>vertex</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>qual</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* already done in transformMatchVLE() */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>prev</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>qual</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vertexIsNSItem</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>getExprField</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>AG_ELEM_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>vid</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>id</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getEdgeColname</name><parameter_list>(<parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>EDGE_UNION_END_ID</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_LEFT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>AG_START_ID</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>AG_END_ID</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>EDGE_UNION_START_ID</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_LEFT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>AG_END_ID</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>AG_START_ID</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isFutureVertexExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>vertex</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>row</name> <operator>=</operator> <operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

	<comment type="block">/* a Const node representing a NULL */</comment>
	<return>return <expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>row</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setFutureVertexExprId</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertex</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>,
					  <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowExpr</name>	   <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>row</name> <operator>=</operator> <operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>vid</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><call><name>getEdgeColname</name><argument_list>(<argument><expr><name>crel</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>vid</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>row</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>vtxArrConcat</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>		<name>elemtype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>!=</operator> <name>VERTEXOID</name> <operator>&amp;&amp;</operator> <name>elemtype</name> <operator>!=</operator> <name>VERTEXARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expression must be a vertex, but %s"</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>array</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>makeArrayExpr</name><argument_list>(<argument><expr><name>VERTEXARRAYOID</name></expr></argument>, <argument><expr><name>VERTEXOID</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VERTEXARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expression must be an array of vertex, but %s"</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"||"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>array</name></expr></argument>,
							<argument><expr><name>elem</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>edgeArrConcat</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>		<name>elemtype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>!=</operator> <name>EDGEOID</name> <operator>&amp;&amp;</operator> <name>elemtype</name> <operator>!=</operator> <name>EDGEARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expression must be an edge, but %s"</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elemtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>array</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>makeArrayExpr</name><argument_list>(<argument><expr><name>EDGEARRAYOID</name></expr></argument>, <argument><expr><name>EDGEOID</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EDGEARRAYOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expression must be an array of edge, but %s"</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"||"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>array</name></expr></argument>,
							<argument><expr><name>elem</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>addQualUniqueEdges</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ueids</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ueidarrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>arrpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lea1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>arroverlap</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>arrpos</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"array_position"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le1</argument>, <argument>ueids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>eid1</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le2</name></decl>;</decl_stmt>

		<macro><name>for_each_cell</name><argument_list>(<argument>le2</argument>, <argument>ueids</argument>, <argument>lnext(ueids, le1)</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>eid2</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>ne</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ne</name> <operator>=</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>eid1</name></expr></argument>, <argument><expr><name>eid2</name></expr></argument>,
						 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>foreach</name><argument_list>(<argument>lea1</argument>, <argument>ueidarrs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>eidarr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lea1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>dupcond</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>arrpos</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
									<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>eidarr</name></expr></argument>, <argument><expr><name>eid1</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>arrpos</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>dupcond</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dupcond</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dupcond</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dupcond</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dupcond</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>dupcond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><name>arroverlap</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"arrayoverlap"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lea1</argument>, <argument>ueidarrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>eidarr1</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lea1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lea2</name></decl>;</decl_stmt>

		<macro><name>for_each_cell</name><argument_list>(<argument>lea2</argument>, <argument>ueidarrs</argument>, <argument>lnext(ueidarrs, lea1)</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>eidarr2</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lea2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>funcexpr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>dupcond</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>funcexpr</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>arroverlap</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
										 <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>eidarr1</name></expr></argument>, <argument><expr><name>eidarr2</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>arroverlap</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>dupcond</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>dupcond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>addElemQual</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_constr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ElemQual</name> <modifier>*</modifier></type><name>eq</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>prop_constr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>eq</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>eq</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eq</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eq</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>varattno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eq</name><operator>-&gt;</operator><name>prop_constr</name></name> <operator>=</operator> <name>prop_constr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_elem_quals</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_elem_quals</name></name></expr></argument>, <argument><expr><name>eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjustElemQuals</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>elem_quals</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>elem_quals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ElemQual</name> <modifier>*</modifier></type><name>eq</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>eq</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>nsitem</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformElemQuals</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>pstate-&gt;p_elem_quals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ElemQual</name>   <modifier>*</modifier></type><name>eq</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_cyphermap</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>eq</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* don't use make_var() because `te` can be resjunk */</comment>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>eq</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>eq</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>eq</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>collid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<comment type="block">/* skip markVarForSelectPriv() because `rte` is RTE_SUBQUERY */</comment>

		<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>getExprField</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>is_cyphermap</name> <operator>=</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>eq</name><operator>-&gt;</operator><name>prop_constr</name></name></expr></argument>, <argument><expr><name>CypherMapExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_cyphermap</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transform_prop_constr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>,
										 <argument><expr><name><name>eq</name><operator>-&gt;</operator><name>prop_constr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>is_cyphermap</name> <operator>&amp;&amp;</operator> <call><name>ginAvail</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>eq</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>eq</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
			<operator>!</operator><name>is_cyphermap</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_constr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>prop_constr</name> <operator>=</operator> <call><name>transformPropMap</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>eq</name><operator>-&gt;</operator><name>prop_constr</name></name></expr></argument>,
										   <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"@&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>prop_constr</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_elem_quals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transform_prop_constr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_map</name></decl></parameter>,
					  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_constr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>prop_constr_context</name></type> <name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>prop_map</name></name> <operator>=</operator> <name>prop_map</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pathelems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>transform_prop_constr_worker</name><argument_list>(<argument><expr><name>prop_constr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ctx</name><operator>.</operator><name>qual</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>transform_prop_constr_worker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>prop_constr_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><name>CypherMapExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>le</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>pathelem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pathelem</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							 <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pathelems</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pathelems</name></name></expr></argument>, <argument><expr><name>pathelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CypherMapExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>transform_prop_constr_worker</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>rvaltype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>rvalloc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lval</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeJsonbFuncAccessor</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pathelems</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rvaltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rvalloc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>rval</name></expr></argument>, <argument><expr><name>rvaltype</name></expr></argument>, <argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expression must be of type jsonb but %s"</literal></expr></argument>,
									   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rvaltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>rvalloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>make_op</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>pathelems</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pathelems</name></name></expr></argument>,
										  <argument><expr><call><name>list_tail</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pathelems</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ginAvail</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inhoids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>getSourceRelid</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_subclass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>hasGinOnProp</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>inhoids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>li</argument>, <argument>inhoids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>inhoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>hasGinOnProp</name><argument_list>(<argument><expr><name>inhoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>getSourceRelid</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FutureVertex</name> <modifier>*</modifier></type><name>fv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the given Var refers to a future vertex, there is no actual RTE for
	 * it. So, find the Var from the list of future vertices first.
	 */</comment>
	<expr_stmt><expr><name>fv</name> <operator>=</operator> <call><name>findFutureVertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fv</name><operator>-&gt;</operator><name>labname</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rtable</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
				<comment type="block">/* already locked */</comment>
				<return>return <expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</return>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>VERTEXOID</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>EDGEOID</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* In RowExpr case, `(id, ...)` is assumed */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>rtable</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>varno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>varattno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
			</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>varattno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
				<comment type="line">// XXX: Do we need type check?</comment>

				<expr_stmt><expr><name>varno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>varattno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
			</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>
				<return>return <expr><name>InvalidOid</name></expr>;</return>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid RTEKind %d"</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* See get_relation_info() */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hasGinOnProp</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>li</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indcheckxmin</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>TransactionIdPrecedes</name><argument_list>(
					<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_indextuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>TransactionXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>GIN_AM_OID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>addFutureVertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FutureVertex</name> <modifier>*</modifier></type><name>fv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fv</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>fv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fv</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fv</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>varattno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fv</name><operator>-&gt;</operator><name>labname</name></name> <operator>=</operator> <name>labname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fv</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_is_optional_match</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fv</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_future_vertices</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_future_vertices</name></name></expr></argument>, <argument><expr><name>fv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FutureVertex</name> <modifier>*</modifier></type>
<name>findFutureVertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>sublevels_up</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>pstate-&gt;p_future_vertices</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FutureVertex</name> <modifier>*</modifier></type><name>fv</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fv</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>varno</name> <operator>&amp;&amp;</operator> <name><name>fv</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>varattno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>fv</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>adjustFutureVertices</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>future_vertices</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>future_vertices</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FutureVertex</name> <modifier>*</modifier></type><name>fv</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

		<comment type="block">/* set `varno` of new future vertex to its `rtindex` */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fv</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fv</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>nsitem</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>nsitem-&gt;p_rte-&gt;subquery-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VERTEXOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * skip all forms of vertex (e.g. `(id, properties)::vertex`)
			 * except variables of vertex
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>fv</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>fv</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
				<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fv</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>nsitem</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * `te-&gt;resno` should always be equal to the item's
				 * ordinal position (counting from 1)
				 */</comment>
				<expr_stmt><expr><name><name>fv</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>future_vertices</name> <operator>=</operator> <call><name>foreach_delete_current</name><argument_list>(<argument><expr><name>future_vertices</name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>future_vertices</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>resolve_future_vertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>resolve_future_vertex_context</name></type> <name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>resolve_future_vertex_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>resolve_future_vertex_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>resolve_future_vertex_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>agglevelsup</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>agglevelsup</name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>la</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex_mutator</name><argument_list>(
					<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
					<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>la</argument>, <argument>agg-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex_mutator</name><argument_list>(
							<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>arg</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
							<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<return>return <expr><name>node</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>agglevelsup</name> <operator>&gt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* fall-through */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OID_VERTEX_EQ_OP</name></expr>:</case>
			<case>case <expr><name>OID_VERTEX_NE_OP</name></expr>:</case>
			<case>case <expr><name>OID_VERTEX_LT_OP</name></expr>:</case>
			<case>case <expr><name>OID_VERTEX_GT_OP</name></expr>:</case>
			<case>case <expr><name>OID_VERTEX_LE_OP</name></expr>:</case>
			<case>case <expr><name>OID_VERTEX_GE_OP</name></expr>:</case>
				<comment type="block">/* comparing only `id`s is enough */</comment>
				<return>return <expr><name>node</name></expr>;</return>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* fall-through */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>&amp;&amp;</operator>
				<call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>VERTEXOID</name> <operator>&amp;&amp;</operator>
				<name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name> <operator>==</operator> <name>Anum_ag_vertex_id</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* fall-through */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FutureVertex</name> <modifier>*</modifier></type><name>fv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>newvar</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VERTEXOID</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>fv</name> <operator>=</operator> <call><name>findFutureVertex</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fv</name><operator>-&gt;</operator><name>expr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FVR_DONT_RESOLVE</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>resolveFutureVertex</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>fv</name></expr></argument>,
								<argument><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FVR_IGNORE_NULLABLE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>fv</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FVR_PRESERVE_VAR_REF</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* XXX: is this OK? */</comment>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>fv</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>fv</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
									 <argument><expr><name>resolve_future_vertex_mutator</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>resolve_future_vertex_mutator</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>resolveFutureVertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>FutureVertex</name> <modifier>*</modifier></type><name>fv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_nullable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>fv_nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>fv_te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>fv_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>fv_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>sel_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>fv</name><operator>-&gt;</operator><name>expr</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fv_nsitem</name> <operator>=</operator> <call><name>GetNSItemByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fv</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fv_nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fv_te</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>fv_nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							 <argument><expr><name><name>fv</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fv_te</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fv_var</name> <operator>=</operator> <call><name>make_var</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>fv_nsitem</name></expr></argument>, <argument><expr><name><name>fv</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fv_id</name> <operator>=</operator> <call><name>getExprField</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fv_var</name></expr></argument>, <argument><expr><name>AG_ELEM_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * `p_cols_visible` of previous RTE must be set to allow `rte` to see
	 * columns of the previous RTE by their name
	 */</comment>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>makeVertexNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fv_te</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name><name>fv</name><operator>-&gt;</operator><name>labname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sel_id</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>AG_ELEM_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sel_id</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>vertex</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>sel_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fv_id</name></expr></argument>, <argument><expr><name>id</name></expr></argument>,
							<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ignore_nullable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name> <operator>=</operator> <call><name>qualAndExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinType</name></type>	<name>jointype</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>fv</name><operator>-&gt;</operator><name>nullable</name></name></expr> ?</condition><then> <expr><name>JOIN_LEFT</name></expr> </then><else>: <expr><name>JOIN_INNER</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>l_jt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>l_rtindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>l_rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_nsitem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>l_jt</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>l_jt</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>l_rtindex</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>l_jt</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>l_jt</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>l_rtindex</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>l_jt</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>l_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>l_rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_SUBQUERY_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>l_nsitem</name> <operator>=</operator> <call><name>findNamespaceItemForRTE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>incrementalJoinRTEs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>l_nsitem</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* modify `fv-&gt;expr` to the actual vertex */</comment>
	<expr_stmt><expr><name><name>fv</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>makeVertexNSItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parentParseState</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentParseState</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parentParseState</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_locked_from_parent</name></name> <operator>=</operator> <call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>labname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVertexExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												 <argument><expr><name>nsitem</name></expr></argument>,
												 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parentParseState</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<return>return <expr><call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>parentParseState</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>removeResolvedFutureVertices</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>future_vertices</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>future_vertices</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FutureVertex</name> <modifier>*</modifier></type><name>fv</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fv</name><operator>-&gt;</operator><name>expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>future_vertices</name> <operator>=</operator> <call><name>foreach_delete_current</name><argument_list>(<argument><expr><name>future_vertices</name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>future_vertices</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformCreatePattern</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>graphPattern</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pathname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pathloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gchain</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphPath</name>  <modifier>*</modifier></type><name>gpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pathloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>cpath-&gt;chain</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>CypherNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name> <init>= <expr><operator>(</operator><name>CypherNode</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>gvertex</name> <operator>=</operator> <call><name>transformCreateNode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cnode</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gvertex</name><operator>-&gt;</operator><name>create</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there must be at least one relationship"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												   <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>gchain</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gchain</name></expr></argument>, <argument><expr><name>gvertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherRel</name>  <modifier>*</modifier></type><name>crel</name> <init>= <expr><operator>(</operator><name>CypherRel</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GraphEdge</name>  <modifier>*</modifier></type><name>gedge</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>CypherRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gedge</name> <operator>=</operator> <call><name>transformCreateRel</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gchain</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gchain</name></expr></argument>, <argument><expr><name>gedge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>pathname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>dummy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>GRAPHPATHOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							 <argument><expr><name>pathname</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>gpath</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GraphPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pathname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>gpath</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>gpath</name><operator>-&gt;</operator><name>chain</name></name> <operator>=</operator> <name>gchain</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>graphPattern</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>graphPattern</name></expr></argument>, <argument><expr><name>gpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>graphPattern</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GraphVertex</name> <modifier>*</modifier></type>
<name>transformCreateNode</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>create</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name>	<modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphVertex</name>	<modifier>*</modifier></type><name>gvertex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VERTEXOID</name> <operator>||</operator> <operator>!</operator><call><name>isNodeForRef</name><argument_list>(<argument><expr><name>cnode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>create</name> <operator>=</operator> <operator>(</operator><name>te</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>create</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>labname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> 	<name>relation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertex</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>labname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>labname</name> <operator>=</operator> <name>AG_VERTEX</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>labloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>labname</name></expr></argument>, <argument><expr><name>AG_VERTEX</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specifying default label is not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>createVertexLabelIfNotExist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labname</name></expr></argument>, <argument><expr><name>labloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* lock the relation of the label and return it */</comment>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>openTargetLabel</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make vertex expression for result plan */</comment>
		<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>makeNewVertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* keep the lock */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							 <argument><expr><operator>(</operator><ternary><condition><expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">"?column?"</literal></expr> </then><else>: <expr><name>varname</name></expr></else></ternary><operator>)</operator></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name> <operator>=</operator>
				<call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>gvertex</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GraphVertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gvertex</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gvertex</name><operator>-&gt;</operator><name>create</name></name> <operator>=</operator> <name>create</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gvertex</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

	<return>return <expr><name>gvertex</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GraphEdge</name> <modifier>*</modifier></type>
<name>transformCreateRel</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> 	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphEdge</name>  <modifier>*</modifier></type><name>gedge</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only directed relationships are allowed in CREATE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only one relationship type is allowed for CREATE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable length relationship is not allowed for CREATE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * All relationships must be unique and we cannot reference an edge
	 * from the previous clause in CREATE clause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><name>AG_EDGE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create edge on default label"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>createEdgeLabelIfNotExist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>typname</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>openTargetLabel</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>makeNewEdge</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>edge</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						 <argument><expr><operator>(</operator><ternary><condition><expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">"?column?"</literal></expr> </then><else>: <expr><name>varname</name></expr></else></ternary><operator>)</operator></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name> <operator>=</operator>
			<call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>gedge</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GraphEdge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CYPHER_REL_DIR_LEFT</name></expr>:</case>
			<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>GRAPH_EDGE_DIR_LEFT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CYPHER_REL_DIR_RIGHT</name></expr>:</case>
			<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>GRAPH_EDGE_DIR_RIGHT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CYPHER_REL_DIR_NONE</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"invalid direction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

	<return>return <expr><name>gedge</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeNewVertex</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>id_attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prop_map_attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map_default</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id_attnum</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>id_attnum</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>id_attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prop_map_attnum</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>prop_map_attnum</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map_default</name> <operator>=</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>prop_map_attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prop_map</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>prop_map_default</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesce</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformPropMap</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>EXPR_KIND_INSERT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the evaluated value of the user-supplied expression is NULL,
		 * use the default properties.
		 */</comment>
		<expr_stmt><expr><name>coalesce</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>prop_map_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>coalesce</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>makeTypedRowExpr</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VERTEXOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeNewEdge</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>id_attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prop_map_attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map_default</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id_attnum</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>id_attnum</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>id_attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>GRAPHIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>GRAPHIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prop_map_attnum</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>prop_map_attnum</name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map_default</name> <operator>=</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>prop_map_attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prop_map</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>prop_map_default</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesce</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformPropMap</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>EXPR_KIND_INSERT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>coalesce</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>prop_map_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>coalesce</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>makeTypedRowExpr</name><argument_list>(<argument><expr><call><name>list_make4</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>EDGEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>openTargetLabel</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>labname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>labname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>parserOpenTable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>relation</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformSetPropList</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_remove</name></decl></parameter>, <parameter><decl><type><name>CSetKind</name></type> <name>kind</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gsplist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>li</argument>, <argument>items</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherSetProp</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>gsplist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gsplist</name></expr></argument>, <argument><expr><call><name>transformSetProp</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>is_remove</name></expr></argument>,
													<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>gsplist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GraphSetProp</name> <modifier>*</modifier></type>
<name>transformSetProp</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherSetProp</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_remove</name></decl></parameter>,
				 <parameter><decl><type><name>CSetKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphSetProp</name> <modifier>*</modifier></type><name>gsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>exprtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GSPKind</name></type>		<name>gspkind</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>transformCypherMapForSet</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>prop</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathelems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pathelems</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>makeArrayExpr</name><argument_list>(<argument><expr><name>TEXTARRAYOID</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><name>pathelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the original property map of the element.
	 */</comment>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transform the assigned property to get `expr` (RHS of the SET clause
	 * item). `sp-&gt;expr` can be a null constant if this `sp` is for REMOVE.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_UPDATE_SOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>exprtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>, <argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
					   <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expression must be of type jsonb but %s"</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>exprtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * make the modified property map
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition>	<comment type="block">/* LHS is the property map itself */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsNullAConst</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set property map to NULL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"use {} instead of NULL to remove all properties"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>add</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>concat</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>concat</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"jsonb_concat"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>concat</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
										 <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>concat</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* just overwrite the property map */</comment>
			<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else				<comment type="block">/* LHS is a property in the property map */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>delete</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>del_prop</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>add</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"+= operator on a property is not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>delete</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"jsonb_delete_path"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>del_prop</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>delete</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
									 <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>delete</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsNullAConst</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>allow_null_properties</name> <operator>||</operator> <name>is_remove</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* SET a.b.c = NULL */</comment>
			<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <name>del_prop</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else							<comment type="block">/* SET a.b.c = expr */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>set_prop</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesce</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * UNKNOWNOID 'null' will be passed to jsonb_in()
			 * when ParseFuncOrColumn()
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsNullAConst</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>UNKNOWNOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,
										  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>set</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"jsonb_set"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>set_prop</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
										 <argument><expr><call><name>list_make3</name><argument_list>(<argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>set</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The right operand can be null. In this case,
			 * it behaves like REMOVE clause.
			 */</comment>
			<expr_stmt><expr><name>coalesce</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>set_prop</name></expr></argument>, <argument><expr><name>del_prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>coalesce</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * set the modified property map
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_null_properties</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>stripNullKeys</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CSET_NORMAL</name></expr>:</case>
			<expr_stmt><expr><name>gspkind</name> <operator>=</operator> <name>GSP_NORMAL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CSET_ON_CREATE</name></expr>:</case>
			<expr_stmt><expr><name>gspkind</name> <operator>=</operator> <name>GSP_ON_CREATE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CSET_ON_MATCH</name></expr>:</case>
			<expr_stmt><expr><name>gspkind</name> <operator>=</operator> <name>GSP_ON_MATCH</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected CSetKind %d"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>gsp</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GraphSetProp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gsp</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>gspkind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gsp</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>varname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gsp</name><operator>-&gt;</operator><name>elem</name></name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gsp</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>prop_map</name></expr>;</expr_stmt>

	<return>return <expr><name>gsp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformMergeMatch</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>CypherClause</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformMergeMatchJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* See transformMatchOptional() */</comment>
<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformMergeMatchJoin</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherMergeClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherMergeClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prevclause</name> <init>= <expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_nsitem</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>r_alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>prevclause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>l_nsitem</name> <operator>=</operator> <call><name>transformNullSelect</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>l_nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>prevclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>r_alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_MERGEMATCH_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r_nsitem</name> <operator>=</operator> <call><name>transformClauseImpl</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeMatchForMerge</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>transformStmt</name></expr></argument>, <argument><expr><name>r_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_SUBQUERY_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>incrementalJoinRTEs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>JOIN_CYPHER_MERGE</name></expr></argument>, <argument><expr><name>l_nsitem</name></expr></argument>, <argument><expr><name>r_nsitem</name></expr></argument>,
							   <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformNullSelect</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>nullres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nullres</name> <operator>=</operator> <call><name>makeResTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeNullAConst</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>nullres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_SUBQUERY_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nsitem</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeMatchForMerge</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherMatchClause</name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherMatchClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>where</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>optional</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CypherClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>detail</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>match</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformMergeCreate</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>prevrte</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prevtlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>singlenode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gchain</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphPath</name>  <modifier>*</modifier></type><name>gpath</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>prevrte</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>prevrte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the target list of the RTE of the previous clause
	 * to check duplicate variables.
	 */</comment>
	<expr_stmt><expr><name>prevtlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>prevrte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>singlenode</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>path-&gt;chain</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>CypherNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name> <init>= <expr><operator>(</operator><name>CypherNode</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>gvertex</name> <operator>=</operator> <call><name>transformMergeNode</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cnode</name></expr></argument>, <argument><expr><name>singlenode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prevtlist</name></expr></argument>,
										 <argument><expr><name>resultList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gchain</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gchain</name></expr></argument>, <argument><expr><name>gvertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherRel</name>  <modifier>*</modifier></type><name>crel</name> <init>= <expr><operator>(</operator><name>CypherRel</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GraphEdge</name>  <modifier>*</modifier></type><name>gedge</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>CypherRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gedge</name> <operator>=</operator> <call><name>transformMergeRel</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>crel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prevtlist</name></expr></argument>, <argument><expr><name>resultList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gchain</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gchain</name></expr></argument>, <argument><expr><name>gedge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>gpath</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GraphPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gpath</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gpath</name><operator>-&gt;</operator><name>chain</name></name> <operator>=</operator> <name>gchain</name></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>gpath</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* See transformCreateNode() */</comment>
<function><type><specifier>static</specifier> <name>GraphVertex</name> <modifier>*</modifier></type>
<name>transformMergeNode</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>singlenode</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>labname</name> <init>= <expr><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> 	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>resno</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphVertex</name>	<modifier>*</modifier></type><name>gvertex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VERTEXOID</name> <operator>||</operator> <operator>!</operator><call><name>isNodeForRef</name><argument_list>(<argument><expr><name>cnode</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <name>singlenode</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>labname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>labname</name> <operator>=</operator> <name>AG_VERTEX</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>labloc</name> <init>= <expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>labname</name></expr></argument>, <argument><expr><name>AG_VERTEX</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specifying default label is not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>createVertexLabelIfNotExist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labname</name></expr></argument>, <argument><expr><name>labloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>openTargetLabel</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vertex</name> <operator>=</operator> <call><name>makeNewVertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>vertex</name></expr></argument>,
						 <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
						 <argument><expr><operator>(</operator><ternary><condition><expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">"?column?"</literal></expr> </then><else>: <expr><name>varname</name></expr></else></ternary><operator>)</operator></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name> <operator>=</operator>
			<call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>findTarget</name><argument_list>(<argument><expr><name>resultList</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>resno</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>gvertex</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GraphVertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gvertex</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>resno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gvertex</name><operator>-&gt;</operator><name>create</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gvertex</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gvertex</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>vertex</name></expr>;</expr_stmt>

	<return>return <expr><name>gvertex</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* See transformCreateRel() */</comment>
<function><type><specifier>static</specifier> <name>GraphEdge</name> <modifier>*</modifier></type>
<name>transformMergeRel</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> 	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name>	<modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>resno</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GraphEdge</name>  <modifier>*</modifier></type><name>gedge</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only one relationship type is allowed for MERGE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable length relationship is not allowed for MERGE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>getCypherName</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><name>AG_EDGE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create edge on default label"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>createEdgeLabelIfNotExist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>typname</name></expr></argument>, <argument><expr><call><name>getCypherNameLoc</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>openTargetLabel</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>getCypherName</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>crel</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>makeNewEdge</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>crel</name><operator>-&gt;</operator><name>prop_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>edge</name></expr></argument>,
						 <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
						 <argument><expr><operator>(</operator><ternary><condition><expr><name>varname</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">"?column?"</literal></expr> </then><else>: <expr><name>varname</name></expr></else></ternary><operator>)</operator></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name> <operator>=</operator>
			<call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_labels</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>findTarget</name><argument_list>(<argument><expr><name>resultList</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>resno</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>gedge</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GraphEdge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CYPHER_REL_DIR_LEFT</name></expr>:</case>
			<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>GRAPH_EDGE_DIR_LEFT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CYPHER_REL_DIR_RIGHT</name></expr>:</case>
		<case>case <expr><name>CYPHER_REL_DIR_NONE</name></expr>:</case>
			<comment type="block">/*
			 * According to the TCK of openCypher,
			 * use outgoing direction if direction is unspecified.
			 */</comment>
			<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>GRAPH_EDGE_DIR_RIGHT</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"invalid direction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>resno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gedge</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>edge</name></expr>;</expr_stmt>

	<return>return <expr><name>gedge</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformMergeOnSet</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l_oncreate</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l_onmatch</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CypherSetClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>detail</name><operator>-&gt;</operator><name>is_remove</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>detail</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CSET_ON_CREATE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>l_oncreate</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>l_oncreate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>detail</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CSET_ON_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>l_onmatch</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>l_onmatch</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>l_oncreate</name> <operator>=</operator> <call><name>transformSetPropList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>CSET_ON_CREATE</name></expr></argument>,
									  <argument><expr><name>l_oncreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>l_onmatch</name> <operator>=</operator> <call><name>transformSetPropList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>CSET_ON_MATCH</name></expr></argument>,
									 <argument><expr><name>l_onmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>l_onmatch</name></expr></argument>, <argument><expr><name>l_oncreate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformDeleteJoin</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>CypherClause</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformDeleteJoinNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected rtekind(%d) in DELETE"</literal></expr></argument>, <argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>transformDeleteEdges</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherClause</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>CypherClause</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CypherDeleteClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherDeleteClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>edges</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>extractEdgesExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>edges</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>,
									 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>qry</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_GRAPHWRITE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>=</operator> <name>GWROP_DELETE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>last</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>detach</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>eager</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromNSItem</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>exprs</name></name> <operator>=</operator> <name>edges</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>nr_modify</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_nr_modify_clause</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													 <argument><expr><name>FVR_DONT_RESOLVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolved_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasGraphwriteClause</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>findAllModifiedLabels</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* See transformMatchOptional() */</comment>
<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformDeleteJoinNSItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherClause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CypherDeleteClause</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><operator>(</operator><name>CypherDeleteClause</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>detail</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>vertices_var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertices_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>exprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>edges_resname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>sel_ag_edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>r_alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>r_qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>r_nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>join_nsitem</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since targets of a DELETE clause refers the result of the previous
	 * clause, it must be transformed first.
	 */</comment>
	<expr_stmt><expr><name>l_nsitem</name> <operator>=</operator> <call><name>transformClauseBy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>, <argument><expr><name>transformDeleteEdges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* FIXME: `detail-&gt;exprs` is transformed twice */</comment>
	<expr_stmt><expr><name>exprs</name> <operator>=</operator> <call><name>transformCypherExprList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>detail</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>le</argument>, <argument>exprs</argument>, <argument>lp</argument>, <argument>detail-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>pexpr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>vartype</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>pexpr</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only direct variable reference is supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>vartype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>vartype</name> <operator>==</operator> <name>VERTEXOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>vertices_var</name> <operator>=</operator> <call><name>verticesAppend</name><argument_list>(<argument><expr><name>vertices_var</name></expr></argument>, <argument><expr><name>pexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>vartype</name> <operator>==</operator> <name>EDGEOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* do nothing */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>vartype</name> <operator>==</operator> <name>GRAPHPATHOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"nodes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>pexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>vertices_nodes</name> <operator>=</operator> <call><name>verticesConcat</name><argument_list>(<argument><expr><name>vertices_nodes</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node, relationship, or path is expected"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * TODO: `expr` must contain one of the target variables
		 *		 and it mustn't contain aggregate and SubLink's.
		 */</comment>
	</block_content>}</block>

	<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>verticesConcat</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>vertices_var</name></expr></argument>, <argument><expr><name>vertices_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>vertices</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>l_nsitem</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sel_ag_edge</name> <operator>=</operator> <call><name>makeSelectEdgesVertices</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>, <argument><expr><name>detail</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edges_resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r_alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_DELETEJOIN_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>r_qry</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><name>sel_ag_edge</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><call><name>isLockedRefname</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>r_alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>r_qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 'edge' variable is only used to determine if there is an edge
	 * connected to the vertex.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>detail</name><operator>-&gt;</operator><name>detach</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>r_qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>r_qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>r_nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r_qry</name></expr></argument>, <argument><expr><name>r_alias</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>join_nsitem</name> <operator>=</operator> <call><name>incrementalJoinRTEs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>JOIN_CYPHER_DELETE</name></expr></argument>, <argument><expr><name>l_nsitem</name></expr></argument>, <argument><expr><name>r_nsitem</name></expr></argument>,
									  <argument><expr><name>qual</name></expr></argument>,
									  <argument><expr><call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_SUBQUERY_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_delete_edges_resname</name></name> <operator>=</operator> <name>edges_resname</name></expr>;</expr_stmt>
	<return>return <expr><name>join_nsitem</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>A_ArrayExpr</name> <modifier>*</modifier></type>
<name>verticesAppend</name><parameter_list>(<parameter><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>vertices</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>vertices</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>vertices</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vertices</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vertices</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>vertices</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>vertices</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>vertices</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>verticesConcat</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertices</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>arrcat</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>vertices</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>expr</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>vertices</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>arrcat</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"array_cat"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arrcat</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * if DETACH
 *
 *     SELECT array_agg((id, start, edge, NULL, ctid)::edge) AS &lt;unique-name&gt;
 *     FROM ag_edge AS e, unnest(vertices) AS v
 *     WHERE e.start = v.id OR e.end = v.id
 *
 * else
 *
 *     SELECT NULL::edge
 *     FROM ag_edge AS e, unnest(vertices) AS v
 *     WHERE e.start = v.id OR e.end = v.id
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeSelectEdgesVertices</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertices</name></decl></parameter>, <parameter><decl><type><name>CypherDeleteClause</name> <modifier>*</modifier></type><name>delete</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>edges_resname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>ag_edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>unnest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>sel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>vertices</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>delete</name><operator>-&gt;</operator><name>detach</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>edges_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>edges_col</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeEdgesForDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edges_name</name> <operator>=</operator> <call><name>genUniqueName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetlist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeResTarget</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><name>edges_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* add delete target */</comment>
		<expr_stmt><expr><name>edges_col</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>edges_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>delete</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>delete</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>edges_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>edges_resname</name> <operator>=</operator> <name>edges_name</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>nulledge</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nulledge</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulledge</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeNullAConst</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulledge</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulledge</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>targetlist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeResTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nulledge</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ag_edge</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AG_EDGE</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ag_edge</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ag_edge</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>DELETE_EDGE_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>unnest</name> <operator>=</operator> <call><name>makeUnnestVertices</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>targetlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>ag_edge</name></expr></argument>, <argument><expr><name>unnest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sel</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeEdgesVertexQual</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* array_agg((id, start, end, NULL, ctid)::edge) */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeEdgesForDetach</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowExpr</name>	   <modifier>*</modifier></type><name>edgerow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>edges</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>DELETE_EDGE_ALIAS</name></expr></argument>, <argument><expr><name>AG_ELEM_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>DELETE_EDGE_ALIAS</name></expr></argument>, <argument><expr><name>AG_START_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>DELETE_EDGE_ALIAS</name></expr></argument>, <argument><expr><name>AG_END_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>makeNullAConst</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>DELETE_EDGE_ALIAS</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edgerow</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edgerow</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make5</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edgerow</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edgerow</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edgerow</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edgerow</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>edgerow</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><literal type="string">"edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"array_agg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>edges</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RangeFunction</name> <modifier>*</modifier></type>
<name>makeUnnestVertices</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>vertices</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>unnest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>rf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>unnest</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"unnest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>vertices</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rf</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>ordinality</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>is_rowsfrom</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>unnest</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>DELETE_VERTEX_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>coldeflist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><name>rf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* e.start = v.id OR e.end = v.id */</comment>
<function><type><specifier>static</specifier> <name>BoolExpr</name> <modifier>*</modifier></type>
<name>makeEdgesVertexQual</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>vid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>eq_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>eq_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>or_expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>DELETE_EDGE_ALIAS</name></expr></argument>, <argument><expr><name>AG_START_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>DELETE_EDGE_ALIAS</name></expr></argument>, <argument><expr><name>AG_END_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vid</name> <operator>=</operator> <call><name>makeColumnRef</name><argument_list>(<argument><expr><call><name>genQualifiedName</name><argument_list>(<argument><expr><name>DELETE_VERTEX_ALIAS</name></expr></argument>, <argument><expr><name>AG_ELEM_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>eq_start</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>eq_end</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>or_expr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>or_expr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>=</operator> <name>OR_EXPR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>or_expr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>eq_start</name></expr></argument>, <argument><expr><name>eq_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>or_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>or_expr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>extractVerticesExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>exprlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>   <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>EDGEOID</name></expr>:</case>
			<case>case <expr><name>EDGEARRAYOID</name></expr>:</case>
				<continue>continue;</continue>

			<case>case <expr><name>GRAPHPATHOID</name></expr>:</case>
				<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>getExprField</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></argument>, <argument><expr><name>AG_PATH_VERTICES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no break */</comment>
			<case>case <expr><name>VERTEXOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>gde</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GraphDelElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>gde</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <call><name>getDeleteTargetName</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>gde</name><operator>-&gt;</operator><name>elem</name></name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>gde</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node, relationship, or path is expected"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>extractEdgesExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>exprlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>   <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>VERTEXOID</name></expr>:</case>
				<continue>continue;</continue>

			<case>case <expr><name>GRAPHPATHOID</name></expr>:</case>
				<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>getExprField</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></argument>, <argument><expr><name>AG_PATH_EDGES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no break */</comment>
			<case>case <expr><name>EDGEOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>gde</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GraphDelElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>gde</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <call><name>getDeleteTargetName</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>gde</name><operator>-&gt;</operator><name>elem</name></name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>gde</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node, relationship, or path is expected"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getDeleteTargetName</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only direct variable reference is supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cr</name> <operator>=</operator> <operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid delete target name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>findAllModifiedLabels</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>label_oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* DELETE */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>exprs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qry-&gt;graph.exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>gde</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>label_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>label_oids</name></expr></argument>,
									 <argument><expr><call><name>find_target_label</name><argument_list>(<argument><expr><name><name>gde</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* SET and MERGE ON SET */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>sets</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qry-&gt;graph.sets</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GraphSetProp</name> <modifier>*</modifier></type><name>gsp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>label_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>label_oids</name></expr></argument>,
									 <argument><expr><call><name>find_target_label</name><argument_list>(<argument><expr><name><name>gsp</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>label_oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_oids</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>targets</name></name> <operator>=</operator> <call><name>list_union_oid</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>targets</name></name></expr></argument>, <argument><expr><name>child_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>targets</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>find_target_label</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>find_target_label_context</name></type> <name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>qry</name></name> <operator>=</operator> <name>qry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>in_preserved</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>resno</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>find_target_label_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot find target label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>relid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ctx</name><operator>.</operator><name>relid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_target_label_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>find_target_label_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>qry</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * NOTE: This is related to how `ModifyGraph` does SET, and
		 *       `FVR_PRESERVE_VAR_REF` flag. We need to fix this.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>==</operator> <name>GWROP_SET</name> <operator>||</operator>
			 <name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>==</operator> <name>GWROP_DELETE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>in_preserved</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>in_preserved</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>find_target_label_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>in_preserved</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid varno %u"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* whole-row Var */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subqry</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>subqry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>qry</name></name> <operator>=</operator> <name>subqry</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>find_target_label_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>qry</name></name> <operator>=</operator> <name>qry</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>joinvar</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
				<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid varattno %hd"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>joinvar</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>find_target_label_walker</name><argument_list>(<argument><expr><name>joinvar</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected retkind(%d) in find_target_label_walker()"</literal></expr></argument>,
				 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For a CREATE clause, `transformCypherCreateClause()` does not create
	 * RTE's for target labels. So, look through `qry-&gt;graph.pattern` to get
	 * the relid of the target label.
	 *
	 * This code assumes that `RowExpr` appears only as root of the expression
	 * in `TargetEntry` when `wrietOp` is `GWROP_CREATE`. This assumption is OK
	 * because users cannot make `RowExpr` in Cypher.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>==</operator> <name>GWROP_CREATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GraphPath</name>  <modifier>*</modifier></type><name>gpath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>pattern</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>gpath</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>gpath-&gt;chain</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>GraphVertex</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GraphVertex</name> <modifier>*</modifier></type><name>gvertex</name> <init>= <expr><operator>(</operator><name>GraphVertex</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>gvertex</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>resno</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>gvertex</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>GraphEdge</name>  <modifier>*</modifier></type><name>gedge</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>GraphEdge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>gedge</name> <operator>=</operator> <operator>(</operator><name>GraphEdge</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>gedge</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>resno</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>gedge</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It is difficult to find a label for graph elements in a graph path,
	 * so all labels of that type are treated as result labels.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FieldSelect</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>		<name>graph_oid</name> <init>= <expr><call><name>get_graph_path_oid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fs</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GRAPHPATHOID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>VERTEXARRAYOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>get_laboid_relid</name><argument_list>(<argument><expr><call><name>get_labname_laboid</name><argument_list>(<argument><expr><name>AG_VERTEX</name></expr></argument>,
																 <argument><expr><name>graph_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EDGEARRAYOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>get_laboid_relid</name><argument_list>(<argument><expr><call><name>get_labname_laboid</name><argument_list>(<argument><expr><name>AG_EDGE</name></expr></argument>,
																 <argument><expr><name>graph_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid fieldnum %s : %hd"</literal></expr></argument>,
									   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fs</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>fieldnum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>find_target_label_walker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>labelExist</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>labloc</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>labkind</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>throw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>graphid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>elemstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_ag_label</name></type> <name>labtup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>graphid</name> <operator>=</operator> <call><name>get_graph_path_oid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>LABELNAMEGRAPH</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>labname</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>graphid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>throw</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>labkind</name> <operator>==</operator> <name>LABEL_KIND_VERTEX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>elemstr</name> <operator>=</operator> <literal type="string">"vertex"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>elemstr</name> <operator>=</operator> <literal type="string">"edge"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s label \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>elemstr</name></expr></argument>, <argument><expr><name>labname</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>labtup</name> <operator>=</operator> <operator>(</operator><name>Form_ag_label</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>labtup</name><operator>-&gt;</operator><name>labkind</name></name> <operator>!=</operator> <name>labkind</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>labtup</name><operator>-&gt;</operator><name>labkind</name></name> <operator>==</operator> <name>LABEL_KIND_VERTEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elemstr</name> <operator>=</operator> <literal type="string">"vertex"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>elemstr</name> <operator>=</operator> <literal type="string">"edge"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label \"%s\" is %s label"</literal></expr></argument>, <argument><expr><name>labname</name></expr></argument>, <argument><expr><name>elemstr</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>createLabelIfNotExist</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>labname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>labloc</name></decl></parameter>,
					  <parameter><decl><type><name>char</name></type> <name>labkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>keyword</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sqlcmd</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>labelExist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>labname</name></expr></argument>, <argument><expr><name>labloc</name></expr></argument>, <argument><expr><name>labkind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>labkind</name> <operator>==</operator> <name>LABEL_KIND_VERTEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyword</name> <operator>=</operator> <literal type="string">"VLABEL"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyword</name> <operator>=</operator> <literal type="string">"ELABEL"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sqlcmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlcmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"CREATE %s \"%s\""</literal></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>labname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_exec</name><argument_list>(<argument><expr><name>sqlcmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isNodeForRef</name><parameter_list>(<parameter><decl><type><name>CypherNode</name> <modifier>*</modifier></type><name>cnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>getCypherName</name><argument_list>(<argument><expr><name><name>cnode</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>cnode</name><operator>-&gt;</operator><name>prop_map</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformPropMap</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>transformCypherExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>coerce_expr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>prop_map</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						   <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>exprKind</name> <operator>==</operator> <name>EXPR_KIND_INSERT_TARGET</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>allow_null_properties</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>stripNullKeys</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>resolve_future_vertex</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>stripNullKeys</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>properties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>strip</name></decl>;</decl_stmt>

	<comment type="block">/* keys with NULL value is not allowed */</comment>
	<expr_stmt><expr><name>strip</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"jsonb_strip_nulls"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>strip</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>strip</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>assign_query_eager_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>nxtQry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>eager</name></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_GRAPHWRITE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Clauses whose CID is incremented should be run as eager. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>sets</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
				<name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>exprs</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
				<name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>==</operator> <name>GWROP_MERGE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>eager</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>nxtQry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>==</operator> <name>GWROP_MERGE</name> <operator>&amp;&amp;</operator>
					 <operator>(</operator><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>==</operator> <name>GWROP_CREATE</name> <operator>||</operator>
					  <name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>writeOp</name></name> <operator>==</operator> <name>GWROP_MERGE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>eager</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>eager</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>eager</name></name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator>
				<name>enable_eager</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"eagerness plan is not allowed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>range_table_walker</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
								  <argument><expr><name>assign_query_eager_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>nxtQry</name></expr></argument>,
								  <argument><expr><name>QTW_IGNORE_CTE_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_query_eager</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>range_table_walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
							  <argument><expr><name>assign_query_eager_walker</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>query</name></expr></argument>,
							  <argument><expr><name>QTW_IGNORE_CTE_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>last</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>sets</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
		 <name><name>query</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>exprs</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>eager</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>graph</name><operator>.</operator><name>eager</name></name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator>
		<name>enable_eager</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"eagerness plan is not allowed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>transformClauseBy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>transformStmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformClauseBy</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>TransformMethod</name></type> <name>transform</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAliasNoDup</name><argument_list>(<argument><expr><name>CYPHER_SUBQUERY_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>transformClauseImpl</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>transform</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToJoinlist</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nsitem</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>transformClauseImpl</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
					<parameter><decl><type><name>TransformMethod</name></type> <name>transform</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>childParseState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>future_vertices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>CypherClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>childParseState</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childParseState</name><operator>-&gt;</operator><name>p_is_match_quals</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_is_match_quals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childParseState</name><operator>-&gt;</operator><name>p_is_fp_processed</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_is_fp_processed</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childParseState</name><operator>-&gt;</operator><name>p_is_optional_match</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_is_optional_match</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>transform</name><argument_list>(<argument><expr><name>childParseState</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_elem_quals</name></name> <operator>=</operator> <name><name>childParseState</name><operator>-&gt;</operator><name>p_elem_quals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>future_vertices</name> <operator>=</operator> <name><name>childParseState</name><operator>-&gt;</operator><name>p_future_vertices</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>childParseState</name><operator>-&gt;</operator><name>p_nr_modify_clause</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_nr_modify_clause</name></name> <operator>=</operator> <name><name>childParseState</name><operator>-&gt;</operator><name>p_nr_modify_clause</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_delete_edges_resname</name></name> <operator>=</operator> <name><name>childParseState</name><operator>-&gt;</operator><name>p_delete_edges_resname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name> <operator>=</operator> <name><name>childParseState</name><operator>-&gt;</operator><name>p_hasGraphwriteClause</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>childParseState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
		 <name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_GRAPHWRITE</name><operator>)</operator> <operator>||</operator>
		<name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected command in previous clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>,
										   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>adjustElemQuals</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_elem_quals</name></name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>future_vertices</name> <operator>=</operator> <call><name>removeResolvedFutureVertices</name><argument_list>(<argument><expr><name>future_vertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>future_vertices</name> <operator>=</operator> <call><name>adjustFutureVertices</name><argument_list>(<argument><expr><name>future_vertices</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_future_vertices</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_future_vertices</name></name></expr></argument>,
											<argument><expr><name>future_vertices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nsitem</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>incrementalJoinRTEs</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					<parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_nsitem</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>r_nsitem</name></decl></parameter>,
					<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>l_jt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>r_rtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceColumn</name> <modifier>*</modifier></type><name>res_nscolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>res_colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res_colvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l_colnos</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_colnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>l_nsitem</name><operator>-&gt;</operator><name>p_cols_visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* find JOIN-subtree of `l_rte` */</comment>
	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>pstate-&gt;p_joinlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>jt</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jt</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jt</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>jt</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jt</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rtindex</name> <operator>==</operator> <name><name>l_nsitem</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>l_jt</name> <operator>=</operator> <name>jt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>l_jt</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>makeExtraFromNSItem</name><argument_list>(<argument><expr><name>r_nsitem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_rtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>l_jt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r_rtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>makeJoinResCols</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l_nsitem</name></expr></argument>, <argument><expr><name>r_nsitem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_colnos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_colnos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res_colnames</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>res_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res_nscolumns</name> <operator>=</operator> <operator>(</operator><name>ParseNamespaceColumn</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>l_colnos</name></expr></argument>)</argument_list></call> <operator>+</operator>
													  <call><name>list_length</name><argument_list>(<argument><expr><name>r_colnos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>*</operator>
													 <sizeof>sizeof<argument_list>(<argument><expr><name>ParseNamespaceColumn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									   <argument><expr><name>res_colnames</name></expr></argument>,
									   <argument><expr><name>res_nscolumns</name></expr></argument>,
									   <argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
									   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>res_colvars</name></expr></argument>,
									   <argument><expr><name>l_colnos</name></expr></argument>,
									   <argument><expr><name>r_colnos</name></expr></argument>,
									   <argument><expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name><name>nsitem</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>l_jt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>makeExtraFromNSItem</name><argument_list>(<argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>r_nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nsitem</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>makeJoinResCols</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_rte</name></decl></parameter>,
				<parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>r_rte</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>l_colvars</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_colvars</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colnames</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>l_colnames</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_colnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>r_lname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_lvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>colvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name><name>l_rte</name><operator>-&gt;</operator><name>p_rte</name></name></expr></argument>, <argument><expr><name><name>l_rte</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_colnames</name></expr></argument>,
			  <argument><expr><name>l_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name><name>r_rte</name><operator>-&gt;</operator><name>p_rte</name></name></expr></argument>, <argument><expr><name><name>r_rte</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_colnames</name></expr></argument>,
			  <argument><expr><name>r_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="line">//	*l_colvars = expandNSItemVars(l_rte, 0, -1, &amp;l_colnames);</comment>
<comment type="line">//	*r_colvars = expandNSItemVars(r_rte, 0, -1, &amp;r_colnames);</comment>

	<expr_stmt><expr><operator>*</operator><name>res_colnames</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>res_colnames</name></expr></argument>, <argument><expr><name>l_colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>res_colvars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>res_colvars</name></expr></argument>, <argument><expr><operator>*</operator><name>l_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>r_lname</argument>, <argument>r_colnames</argument>, <argument>r_lvar</argument>, <argument>*r_colvars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>r_colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>r_lname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lvar</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>forboth</name><argument_list>(<argument>lname</argument>, <argument>*res_colnames</argument>, <argument>lvar</argument>, <argument>*res_colvars</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>r_colname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>r_lname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colvars</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>r_lvar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>r_var</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>r_lvar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>vartype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>r_vartype</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>vartype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r_vartype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>vartype</name> <operator>!=</operator> <name>r_vartype</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable type mismatch"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>vartype</name> <operator>!=</operator> <name>VERTEXOID</name> <operator>&amp;&amp;</operator> <name>vartype</name> <operator>!=</operator> <name>EDGEOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node or relationship is expected"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>res_colnames</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>res_colnames</name></expr></argument>, <argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>res_colvars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>res_colvars</name></expr></argument>, <argument><expr><name>colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type>
<name>findNamespaceItemForRTE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lni</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lni</argument>, <argument>pstate-&gt;p_namespace</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lni</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name> <operator>==</operator> <name>rte</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>nsitem</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>makeTargetListFromNSItem</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varattno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>varattno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>nsitem-&gt;p_rte-&gt;subquery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varattno</name> <operator>==</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* no transform here, just use `te-&gt;expr` */</comment>
		<expr_stmt><expr><name>varnode</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>,
						  <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>resname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>varnode</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							  <argument><expr><name>resname</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>varattno</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>targetlist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>makeTargetListFromJoin</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>lt</argument>, <argument>rte-&gt;joinaliasvars</argument>, <argument>ln</argument>, <argument>rte-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>varnode</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
							  <argument><expr><name>resname</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>targetlist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>makeWholeRowTarget</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>varnode</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>varnode</name> <operator>=</operator> <call><name>makeWholeRowVar</name><argument_list>(<argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></argument>, <argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rtindex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>varnode</name></expr></argument>, <argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>varnode</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
						   <argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>findTarget</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>resname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>resname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>te</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeVertexExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>getSysColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeTypedRowExpr</name><argument_list>(<argument><expr><call><name>list_make3</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VERTEXOID</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeEdgeExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CypherRel</name> <modifier>*</modifier></type><name>crel</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prop_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>AG_ELEM_LOCAL_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>AG_START_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>AG_END_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prop_map</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>AG_ELEM_PROP_MAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>crel</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>getColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>getSysColumnVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>makeTypedRowExpr</name><argument_list>(<argument><expr><call><name>list_make5</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>prop_map</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>EDGEOID</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makePathVertexExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNSItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>isNSItem</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>makeVertexExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>obj</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>VERTEXOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>getColumnVar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attrno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lcn</argument>, <argument>rte-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * NOTE: no ambiguous reference check here
			 *       since all column names in `rte` are unique
			 */</comment>

			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>make_var</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>attrno</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* require read access to the column */</comment>
			<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>attrno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column \"%s\" not found (internal error)"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>getSysColumnVar</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
				<parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attnum</name> <operator>&lt;=</operator> <name>SelfItemPointerAttributeNumber</name> <operator>&amp;&amp;</operator>
			  <name>attnum</name> <operator>&gt;=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>make_var</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>getExprField</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typoid</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_copy</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fselect</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name> <operator>=</operator> <name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fselect</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeArrayExpr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typarray</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator> <name>typarray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name>typoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>elems</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeTypedRowExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name>typoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CAST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>row</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>qualAndExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>expr</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>qual</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>bexpr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bexpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>AND_EXPR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>bexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>bexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>qual</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ResTarget</name> <modifier>*</modifier></type>
<name>makeSimpleResTarget</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>makeResTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cref</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ResTarget</name> <modifier>*</modifier></type>
<name>makeResTarget</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResTarget</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeColumnRef</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <name>fields</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>A_Const</name> <modifier>*</modifier></type>
<name>makeNullAConst</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>nullconst</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nullconst</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nullconst</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Null</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nullconst</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>nullconst</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsNullAConst</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_Null</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
