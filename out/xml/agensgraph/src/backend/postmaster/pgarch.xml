<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/postmaster/pgarch.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pgarch.c
 *
 *	PostgreSQL WAL archiver
 *
 *	All functions relating to archiver are included here
 *
 *	- All functions executed by archiver process
 *
 *	- archiver is forked from postmaster, and the two
 *	processes then communicate using signals. All functions
 *	executed by postmaster are included in this file.
 *
 *	Initial author: Simon Riggs		simon@2ndquadrant.com
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/postmaster/pgarch.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fork_process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/interrupt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/pgarch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>


<comment type="block">/* ----------
 * Timer definitions.
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGARCH_AUTOWAKE_INTERVAL</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define> <comment type="block">/* How often to force a poll of the
									 * archive status directory; in seconds. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGARCH_RESTART_INTERVAL</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>	<comment type="block">/* How often to attempt to restart a
									 * failed archiver; in seconds. */</comment>

<comment type="block">/*
 * Maximum number of retries allowed when attempting to archive a WAL
 * file.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_ARCHIVE_RETRIES</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/*
 * Maximum number of retries allowed when attempting to remove an
 * orphan archive status file.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_ORPHAN_CLEANUP_RETRIES</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>


<comment type="block">/* ----------
 * Local data
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>last_pgarch_start_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>last_sigterm_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flags set by interrupt handlers for later service in the main loop.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>wakened</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>ready_to_stop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Local function forward declarations
 * ----------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>pgarch_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>NON_EXEC_STATIC</name> <name>void</name></type> <name>PgArchiverMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgarch_waken</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgarch_waken_stop</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgarch_MainLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgarch_ArchiverCopyLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgarch_archiveXlog</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgarch_readyXlog</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgarch_archiveDone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ------------------------------------------------------------
 * Public functions called from postmaster follow
 * ------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * pgarch_start
 *
 *	Called from postmaster at startup or after an existing archiver
 *	died.  Attempt to fire up a fresh archiver process.
 *
 *	Returns PID of child process, or 0 if fail.
 *
 *	Note: if fail, we will be called again from the postmaster main loop.
 */</comment>
<function><type><name>int</name></type>
<name>pgarch_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>time_t</name></type>		<name>curtime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pgArchPid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do nothing if no archiver needed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogArchivingActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do nothing if too soon since last archiver start.  This is a safety
	 * valve to protect against continuous respawn attempts if the archiver is
	 * dying immediately at launch. Note that since we will be re-called from
	 * the postmaster main loop, we will get another chance later.
	 */</comment>
	<expr_stmt><expr><name>curtime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>curtime</name> <operator>-</operator> <name>last_pgarch_start_time</name><operator>)</operator> <operator>&lt;</operator>
		<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>PGARCH_RESTART_INTERVAL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>last_pgarch_start_time</name> <operator>=</operator> <name>curtime</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<switch>switch <condition>(<expr><operator>(</operator><name>pgArchPid</name> <operator>=</operator> <call><name>pgarch_forkexec</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<switch>switch <condition>(<expr><operator>(</operator><name>pgArchPid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork archiver: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* in postmaster child ... */</comment>
			<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close the postmaster's sockets */</comment>
			<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Drop our connection to postmaster's shared memory, as well */</comment>
			<expr_stmt><expr><call><name>dsm_detach_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PGSharedMemoryDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PgArchiverMain</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<default>default:</default>
			<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>pgArchPid</name></expr>;</return>
	</block_content>}</block></switch></block_content></block></switch>

	<comment type="block">/* shouldn't get here */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------
 * Local functions called by archiver follow
 * ------------------------------------------------------------
 */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 * pgarch_forkexec() -
 *
 * Format up the arglist for, then fork and exec, archive process
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>pgarch_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forkarch"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* filled in by postmaster_forkexec */</comment>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>


<comment type="block">/*
 * PgArchiverMain
 *
 *	The argc/argv parameters are valid only in EXEC_BACKEND case.  However,
 *	since we don't use 'em, it hardly matters...
 */</comment>
<function><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>PgArchiverMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Ignore all signals usually bound to some action in the postmaster,
	 * except for SIGHUP, SIGTERM, SIGUSR1, SIGUSR2, and SIGQUIT.
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>SignalHandlerForConfigReload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>SignalHandlerForShutdownRequest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>SignalHandlerForCrashExit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>pgarch_waken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>pgarch_waken_stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Reset some signals that are accepted by postmaster but not here */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyBackendType</name> <operator>=</operator> <name>B_ARCHIVER</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgarch_MainLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR1 signal handler for archiver process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgarch_waken</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set flag that there is work to be done */</comment>
	<expr_stmt><expr><name>wakened</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR2 signal handler for archiver process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgarch_waken_stop</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set flag to do a final cycle and shut down afterwards */</comment>
	<expr_stmt><expr><name>ready_to_stop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgarch_MainLoop
 *
 * Main loop for archiver
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgarch_MainLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>last_copy_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>time_to_stop</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We run the copy loop immediately upon entry, in case there are
	 * unarchived files left over from a previous database run (or maybe the
	 * archiver died unexpectedly).  After that we wait for a signal or
	 * timeout before doing more.
	 */</comment>
	<expr_stmt><expr><name>wakened</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * There shouldn't be anything for the archiver to do except to wait for a
	 * signal ... however, the archiver exists to protect our data, so she
	 * wakes up occasionally to allow herself to be proactive.
	 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* When we get SIGUSR2, we do one more archive cycle, then exit */</comment>
		<expr_stmt><expr><name>time_to_stop</name> <operator>=</operator> <name>ready_to_stop</name></expr>;</expr_stmt>

		<comment type="block">/* Check for config update */</comment>
		<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we've gotten SIGTERM, we normally just sit and do nothing until
		 * SIGUSR2 arrives.  However, that means a random SIGTERM would
		 * disable archiving indefinitely, which doesn't seem like a good
		 * idea.  If more than 60 seconds pass since SIGTERM, exit anyway, so
		 * that the postmaster can start a new archiver if needed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ShutdownRequestPending</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>time_t</name></type>		<name>curtime</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>last_sigterm_time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>last_sigterm_time</name> <operator>=</operator> <name>curtime</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>curtime</name> <operator>-</operator> <name>last_sigterm_time</name><operator>)</operator> <operator>&gt;=</operator>
					 <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <literal type="number">60</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Do what we're here for */</comment>
		<if_stmt><if>if <condition>(<expr><name>wakened</name> <operator>||</operator> <name>time_to_stop</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>wakened</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgarch_ArchiverCopyLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_copy_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Sleep until a signal is received, or until a poll is forced by
		 * PGARCH_AUTOWAKE_INTERVAL having passed since last_copy_time, or
		 * until postmaster dies.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>time_to_stop</name></expr>)</condition>		<comment type="block">/* Don't wait during last iteration */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>curtime</name> <init>= <expr><operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>timeout</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>PGARCH_AUTOWAKE_INTERVAL</name> <operator>-</operator> <operator>(</operator><name>curtime</name> <operator>-</operator> <name>last_copy_time</name><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
							   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
							   <argument><expr><name>timeout</name> <operator>*</operator> <literal type="number">1000L</literal></expr></argument>,
							   <argument><expr><name>WAIT_EVENT_ARCHIVER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>wakened</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>time_to_stop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>wakened</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The archiver quits either when the postmaster dies (not expected)
		 * or after completing one more archiving cycle after receiving
		 * SIGUSR2.
		 */</comment>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>time_to_stop</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/*
 * pgarch_ArchiverCopyLoop
 *
 * Archives all outstanding xlogs then returns
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgarch_ArchiverCopyLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlog</name><index>[<expr><name>MAX_XFN_CHARS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * loop through all xlogs with archive_status of .ready and archive
	 * them...mostly we expect this to be a single file, though it is possible
	 * some backend will add files onto the list of those that need archiving
	 * while we are still copying earlier archives
	 */</comment>
	<while>while <condition>(<expr><call><name>pgarch_readyXlog</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>failures</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>failures_orphan</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>pathname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Do not initiate any more archive commands after receiving
			 * SIGTERM, nor after the postmaster has died unexpectedly. The
			 * first condition is to try to keep from having init SIGKILL the
			 * command, and the second is to avoid conflicts with another
			 * archiver spawned by a newer postmaster.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ShutdownRequestPending</name> <operator>||</operator> <operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check for config update.  This is so that we'll adopt a new
			 * setting for archive_command as soon as possible, even if there
			 * is a backlog of files to be archived.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* can't do anything if no command ... */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogArchiveCommandSet</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"archive_mode enabled, yet archive_command is not set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Since archive status files are not removed in a durable manner,
			 * a system crash could leave behind .ready files for WAL segments
			 * that have already been recycled or removed.  In this case,
			 * simply remove the orphan status file and move on.  unlink() is
			 * used here as even on subsequent crashes the same orphan files
			 * would get removed, so there is no need to worry about
			 * durability.
			 */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogready</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>xlogready</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>xlogready</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removed orphan archive status file \"%s\""</literal></expr></argument>,
									<argument><expr><name>xlogready</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* leave loop and move to the next status file */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>++</operator><name>failures_orphan</name> <operator>&gt;=</operator> <name>NUM_ORPHAN_CLEANUP_RETRIES</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removal of orphan archive status file \"%s\" failed too many times, will try again later"</literal></expr></argument>,
									<argument><expr><name>xlogready</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* give up cleanup of orphan status files */</comment>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* wait a bit before retrying */</comment>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pgarch_archiveXlog</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* successful */</comment>
				<expr_stmt><expr><call><name>pgarch_archiveDone</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Tell the collector about the WAL file that we successfully
				 * archived
				 */</comment>
				<expr_stmt><expr><call><name>pgstat_send_archiver</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>			<comment type="block">/* out of inner retry loop */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Tell the collector about the WAL file that we failed to
				 * archive
				 */</comment>
				<expr_stmt><expr><call><name>pgstat_send_archiver</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>++</operator><name>failures</name> <operator>&gt;=</operator> <name>NUM_ARCHIVE_RETRIES</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"archiving write-ahead log file \"%s\" failed too many times, will try again later"</literal></expr></argument>,
									<argument><expr><name>xlog</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return;</return>		<comment type="block">/* give up archiving for now */</comment>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* wait a bit before retrying */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * pgarch_archiveXlog
 *
 * Invokes system(3) to copy one archive file to wherever it should go
 *
 * Returns true if successful
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgarch_archiveXlog</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogarchcmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pathname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>activitymsg</name><index>[<expr><name>MAXFNAMELEN</name> <operator>+</operator> <literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * construct the command to be executed
	 */</comment>
	<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>xlogarchcmd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>xlogarchcmd</name> <operator>+</operator> <name>MAXPGPATH</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>XLogArchiveCommand</name></expr>;</init> <condition><expr><operator>*</operator><name>sp</name></expr>;</condition> <incr><expr><name>sp</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sp</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'p'</literal></expr>:</case>
					<comment type="block">/* %p: relative path of source file */</comment>
					<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>endp</name> <operator>-</operator> <name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>make_native_path</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'f'</literal></expr>:</case>
					<comment type="block">/* %f: filename of source file */</comment>
					<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>endp</name> <operator>-</operator> <name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'%'</literal></expr>:</case>
					<comment type="block">/* convert %% to a single % */</comment>
					<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* otherwise treat the % as not special */</comment>
					<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>dp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"executing archive command \"%s\""</literal></expr></argument>,
							 <argument><expr><name>xlogarchcmd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report archive activity in PS display */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"archiving %s"</literal></expr></argument>, <argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>xlogarchcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If either the shell itself, or a called command, died on a signal,
		 * abort the archiver.  We do this because system() ignores SIGINT and
		 * SIGQUIT while waiting; so a signal is very likely something that
		 * should have interrupted us too.  Also die if the shell got a hard
		 * "command not found" type of error.  If we overreact it's no big
		 * deal, the postmaster will just start the archiver again.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>lev</name> <init>= <expr><ternary><condition><expr><call><name>wait_result_is_any_signal</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>FATAL</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>lev</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"archive command failed with exit code %d"</literal></expr></argument>,
							<argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The failed archive command was: %s"</literal></expr></argument>,
							   <argument><expr><name>xlogarchcmd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>lev</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"archive command was terminated by exception 0x%X"</literal></expr></argument>,
							<argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"See C include file \"ntstatus.h\" for a description of the hexadecimal value."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The failed archive command was: %s"</literal></expr></argument>,
							   <argument><expr><name>xlogarchcmd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>lev</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"archive command was terminated by signal %d: %s"</literal></expr></argument>,
							<argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pg_strsignal</name><argument_list>(<argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The failed archive command was: %s"</literal></expr></argument>,
							   <argument><expr><name>xlogarchcmd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>lev</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"archive command exited with unrecognized status %d"</literal></expr></argument>,
							<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The failed archive command was: %s"</literal></expr></argument>,
							   <argument><expr><name>xlogarchcmd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"failed on %s"</literal></expr></argument>, <argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"archived write-ahead log file \"%s\""</literal></expr></argument>, <argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"last was %s"</literal></expr></argument>, <argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgarch_readyXlog
 *
 * Return name of the oldest xlog file that has not yet been archived.
 * No notification is set that file archiving is now in progress, so
 * this would need to be extended if multiple concurrent archival
 * tasks were created. If a failure occurs, we will completely
 * re-copy the file at the next available opportunity.
 *
 * It is important that we return the oldest, so that we archive xlogs
 * in order that they were written, for two reasons:
 * 1) to maintain the sequential chain of xlogs required for recovery
 * 2) because the oldest ones will sooner become candidates for
 * recycling at time of checkpoint
 *
 * NOTE: the "oldest" comparison will consider any .history file to be older
 * than any other file except another .history file.  Segments on a timeline
 * with a smaller ID will be older than all segments on a timeline with a
 * larger ID; the net result being that past timelines are given higher
 * priority for archiving.  This seems okay, or at least not obviously worth
 * changing.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgarch_readyXlog</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * open xlog status directory and read through list of xlogs that have the
	 * .ready suffix, looking for earliest file. It is possible to optimise
	 * this code, though only a single file is expected on the vast majority
	 * of calls, so....
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>XLogArchiveStatusDir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>rldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>rlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>historyFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>XLogArchiveStatusDir</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/archive_status"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rldir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>XLogArchiveStatusDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>rlde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>rldir</name></expr></argument>, <argument><expr><name>XLogArchiveStatusDir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>basenamelen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>rlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>basename</name><index>[<expr><name>MAX_XFN_CHARS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ishistory</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore entries with unexpected number of characters */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>basenamelen</name> <argument_list type="generic">&lt; <argument><expr><name>MIN_XFN_CHARS</name> <operator>||</operator>
			<name>basenamelen</name></expr></argument> &gt;</argument_list></name> <name>MAX_XFN_CHARS</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Ignore entries with unexpected characters */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name><name>rlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>VALID_XFN_CHARS</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>basenamelen</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Ignore anything not suffixed with .ready */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rlde</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>basenamelen</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Truncate off the .ready */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>basename</name></expr></argument>, <argument><expr><name><name>rlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>basenamelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>basename</name><index>[<expr><name>basenamelen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* Is this a history file? */</comment>
		<expr_stmt><expr><name>ishistory</name> <operator>=</operator> <call><name>IsTLHistoryFileName</name><argument_list>(<argument><expr><name>basename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Consume the file to archive.  History files have the highest
		 * priority.  If this is the first file or the first history file
		 * ever, copy it.  In the presence of a history file already chosen as
		 * target, ignore all other files except history files which have been
		 * generated for an older timeline than what is already chosen as
		 * target to archive.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <operator>(</operator><name>ishistory</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>historyFound</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>historyFound</name> <operator>=</operator> <name>ishistory</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ishistory</name> <operator>||</operator> <operator>!</operator><name>historyFound</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>basename</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>rldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgarch_archiveDone
 *
 * Emit notification that an xlog file has been successfully archived.
 * We do this by renaming the status file from NNN.ready to NNN.done.
 * Eventually, a checkpoint process will notice this and delete both the
 * NNN.done file and the xlog file itself.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgarch_archiveDone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>rlogready</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>rlogdone</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>rlogready</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>rlogdone</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>durable_rename</name><argument_list>(<argument><expr><name>rlogready</name></expr></argument>, <argument><expr><name>rlogdone</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
