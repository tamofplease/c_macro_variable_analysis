<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/nodes/tidbitmap.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tidbitmap.c
 *	  PostgreSQL tuple-id (TID) bitmap package
 *
 * This module provides bitmap data structures that are spiritually
 * similar to Bitmapsets, but are specially adapted to store sets of
 * tuple identifiers (TIDs), or ItemPointers.  In particular, the division
 * of an ItemPointer into BlockNumber and OffsetNumber is catered for.
 * Also, since we wish to be able to store very large tuple sets in
 * memory with this data structure, we support "lossy" storage, in which
 * we no longer remember individual tuple offsets on a page but only the
 * fact that a particular page needs to be visited.
 *
 * The "lossy" storage uses one bit per disk page, so at the standard 8K
 * BLCKSZ, we can represent all pages in 64Gb of disk space in about 1Mb
 * of memory.  People pushing around tables of that size should have a
 * couple of Mb to spare, so we don't worry about providing a second level
 * of lossiness.  In theory we could fall back to page ranges at some
 * point, but for now that seems useless complexity.
 *
 * We also support the notion of candidate matches, or rechecking.  This
 * means we know that a search need visit only some tuples on a page,
 * but we are not certain that all of those tuples are real matches.
 * So the eventual heap scan must recheck the quals for these tuples only,
 * rather than rechecking the quals for all tuples on the page as in the
 * lossy-bitmap case.  Rechecking can be specified when TIDs are inserted
 * into a bitmap, and it can also happen internally when we AND a lossy
 * and a non-lossy page.
 *
 *
 * Copyright (c) 2003-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/nodes/tidbitmap.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/bitmapset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/tidbitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dsa.h"</cpp:file></cpp:include>

<comment type="block">/*
 * The maximum number of tuples per page is not large (typically 256 with
 * 8K pages, or 1024 with 32K pages).  So there's not much point in making
 * the per-page bitmaps variable size.  We just legislate that the size
 * is this:
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TUPLES_PER_PAGE</name></cpp:macro>  <cpp:value>MaxHeapTuplesPerPage</cpp:value></cpp:define>

<comment type="block">/*
 * When we have to switch over to lossy storage, we use a data structure
 * with one bit per page, where all pages having the same number DIV
 * PAGES_PER_CHUNK are aggregated into one chunk.  When a chunk is present
 * and has the bit set for a given page, there must not be a per-page entry
 * for that page in the page table.
 *
 * We actually store both exact pages and lossy chunks in the same hash
 * table, using identical data structures.  (This is because the memory
 * management for hashtables doesn't easily/efficiently allow space to be
 * transferred easily from one hashtable to another.)  Therefore it's best
 * if PAGES_PER_CHUNK is the same as MAX_TUPLES_PER_PAGE, or at least not
 * too different.  But we also want PAGES_PER_CHUNK to be a power of 2 to
 * avoid expensive integer remainder operations.  So, define it like this:
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGES_PER_CHUNK</name></cpp:macro>  <cpp:value>(BLCKSZ / 32)</cpp:value></cpp:define>

<comment type="block">/* We use BITS_PER_BITMAPWORD and typedef bitmapword from nodes/bitmapset.h */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORDNUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((x) / BITS_PER_BITMAPWORD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITNUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((x) % BITS_PER_BITMAPWORD)</cpp:value></cpp:define>

<comment type="block">/* number of active words for an exact page: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORDS_PER_PAGE</name></cpp:macro>	<cpp:value>((MAX_TUPLES_PER_PAGE - 1) / BITS_PER_BITMAPWORD + 1)</cpp:value></cpp:define>
<comment type="block">/* number of active words for a lossy chunk: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORDS_PER_CHUNK</name></cpp:macro>  <cpp:value>((PAGES_PER_CHUNK - 1) / BITS_PER_BITMAPWORD + 1)</cpp:value></cpp:define>

<comment type="block">/*
 * The hashtable entries are represented by this data structure.  For
 * an exact page, blockno is the page number and bit k of the bitmap
 * represents tuple offset k+1.  For a lossy chunk, blockno is the first
 * page in the chunk (this must be a multiple of PAGES_PER_CHUNK) and
 * bit k represents page blockno+k.  Note that it is not possible to
 * have exact storage for the first page of a chunk if we are using
 * lossy storage for any page in the chunk's range, since the same
 * hashtable entry has to serve both purposes.
 *
 * recheck is used only on exact pages --- it indicates that although
 * only the stated tuples need be checked, the full index qual condition
 * must be checked for each (ie, these are candidate matches).
 */</comment>
<typedef>typedef <type><struct>struct <name>PagetableEntry</name>
<block>{
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl>;</decl_stmt>		<comment type="block">/* page number (hashtable key) */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>status</name></decl>;</decl_stmt>			<comment type="block">/* hash entry status */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ischunk</name></decl>;</decl_stmt>		<comment type="block">/* T = lossy storage, F = exact */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recheck</name></decl>;</decl_stmt>		<comment type="block">/* should the tuples be rechecked? */</comment>
	<decl_stmt><decl><type><name>bitmapword</name></type>	<name><name>words</name><index>[<expr><call><name>Max</name><argument_list>(<argument><expr><name>WORDS_PER_PAGE</name></expr></argument>, <argument><expr><name>WORDS_PER_CHUNK</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>PagetableEntry</name>;</typedef>

<comment type="block">/*
 * Holds array of pagetable entries.
 */</comment>
<typedef>typedef <type><struct>struct <name>PTEntryArray</name>
<block>{
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>refcount</name></decl>;</decl_stmt>	<comment type="block">/* no. of iterator attached */</comment>
	<decl_stmt><decl><type><name>PagetableEntry</name></type> <name><name>ptentry</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>PTEntryArray</name>;</typedef>

<comment type="block">/*
 * We want to avoid the overhead of creating the hashtable, which is
 * comparatively large, when not necessary. Particularly when we are using a
 * bitmap scan on the inside of a nestloop join: a bitmap may well live only
 * long enough to accumulate one entry in such cases.  We therefore avoid
 * creating an actual hashtable until we need two pagetable entries.  When
 * just one pagetable entry is needed, we store it in a fixed field of
 * TIDBitMap.  (NOTE: we don't get rid of the hashtable if the bitmap later
 * shrinks down to zero or one page again.  So, status can be TBM_HASH even
 * when nentries is zero or one.)
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>TBM_EMPTY</name></decl>,					<comment type="block">/* no hashtable, nentries == 0 */</comment>
	<decl><name>TBM_ONE_PAGE</name></decl>,				<comment type="block">/* entry1 contains the single entry */</comment>
	<decl><name>TBM_HASH</name></decl>					<comment type="block">/* pagetable is valid, entry1 is not */</comment>
}</block></enum></type> <name>TBMStatus</name>;</typedef>

<comment type="block">/*
 * Current iterating state of the TBM.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>TBM_NOT_ITERATING</name></decl>,			<comment type="block">/* not yet converted to page and chunk array */</comment>
	<decl><name>TBM_ITERATING_PRIVATE</name></decl>,		<comment type="block">/* converted to local page and chunk array */</comment>
	<decl><name>TBM_ITERATING_SHARED</name></decl>		<comment type="block">/* converted to shared page and chunk array */</comment>
}</block></enum></type> <name>TBMIteratingState</name>;</typedef>

<comment type="block">/*
 * Here is the representation for a whole TIDBitMap:
 */</comment>
<struct>struct <name>TIDBitmap</name>
<block>{
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>type</name></decl>;</decl_stmt>			<comment type="block">/* to make it a valid Node */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl>;</decl_stmt>			<comment type="block">/* memory context containing me */</comment>
	<decl_stmt><decl><type><name>TBMStatus</name></type>	<name>status</name></decl>;</decl_stmt>			<comment type="block">/* see codes above */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>pagetable_hash</name></name> <modifier>*</modifier></type><name>pagetable</name></decl>;</decl_stmt>	<comment type="block">/* hash table of PagetableEntry's */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nentries</name></decl>;</decl_stmt>		<comment type="block">/* number of entries in pagetable */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxentries</name></decl>;</decl_stmt>		<comment type="block">/* limit on same to meet maxbytes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>			<comment type="block">/* number of exact entries in pagetable */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchunks</name></decl>;</decl_stmt>		<comment type="block">/* number of lossy entries in pagetable */</comment>
	<decl_stmt><decl><type><name>TBMIteratingState</name></type> <name>iterating</name></decl>;</decl_stmt>	<comment type="block">/* tbm_begin_iterate called? */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>lossify_start</name></decl>;</decl_stmt>	<comment type="block">/* offset to start lossifying hashtable at */</comment>
	<decl_stmt><decl><type><name>PagetableEntry</name></type> <name>entry1</name></decl>;</decl_stmt>		<comment type="block">/* used when status == TBM_ONE_PAGE */</comment>
	<comment type="block">/* these are valid when iterating is true: */</comment>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>spages</name></decl>;</decl_stmt>	<comment type="block">/* sorted exact-page list, or NULL */</comment>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>schunks</name></decl>;</decl_stmt>	<comment type="block">/* sorted lossy-chunk list, or NULL */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dsapagetable</name></decl>;</decl_stmt>	<comment type="block">/* dsa_pointer to the element array */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dsapagetableold</name></decl>;</decl_stmt>	<comment type="block">/* dsa_pointer to the old element array */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>ptpages</name></decl>;</decl_stmt>		<comment type="block">/* dsa_pointer to the page array */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>ptchunks</name></decl>;</decl_stmt>		<comment type="block">/* dsa_pointer to the chunk array */</comment>
	<decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>dsa</name></decl>;</decl_stmt>			<comment type="block">/* reference to per-query dsa area */</comment>
}</block>;</struct>

<comment type="block">/*
 * When iterating over a bitmap in sorted order, a TBMIterator is used to
 * track our progress.  There can be several iterators scanning the same
 * bitmap concurrently.  Note that the bitmap becomes read-only as soon as
 * any iterator is created.
 */</comment>
<struct>struct <name>TBMIterator</name>
<block>{
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name></decl>;</decl_stmt>			<comment type="block">/* TIDBitmap we're iterating over */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>spageptr</name></decl>;</decl_stmt>		<comment type="block">/* next spages index */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkptr</name></decl>;</decl_stmt>		<comment type="block">/* next schunks index */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name></decl>;</decl_stmt>		<comment type="block">/* next bit to check in current schunk */</comment>
	<decl_stmt><decl><type><name>TBMIterateResult</name></type> <name>output</name></decl>;</decl_stmt>	<comment type="block">/* MUST BE LAST (because variable-size) */</comment>
}</block>;</struct>

<comment type="block">/*
 * Holds the shared members of the iterator so that multiple processes
 * can jointly iterate.
 */</comment>
<typedef>typedef <type><struct>struct <name>TBMSharedIteratorState</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nentries</name></decl>;</decl_stmt>		<comment type="block">/* number of entries in pagetable */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxentries</name></decl>;</decl_stmt>		<comment type="block">/* limit on same to meet maxbytes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>			<comment type="block">/* number of exact entries in pagetable */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchunks</name></decl>;</decl_stmt>		<comment type="block">/* number of lossy entries in pagetable */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>pagetable</name></decl>;</decl_stmt>		<comment type="block">/* dsa pointers to head of pagetable data */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>spages</name></decl>;</decl_stmt>			<comment type="block">/* dsa pointer to page array */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>schunks</name></decl>;</decl_stmt>		<comment type="block">/* dsa pointer to chunk array */</comment>
	<decl_stmt><decl><type><name>LWLock</name></type>		<name>lock</name></decl>;</decl_stmt>			<comment type="block">/* lock to protect below members */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>spageptr</name></decl>;</decl_stmt>		<comment type="block">/* next spages index */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkptr</name></decl>;</decl_stmt>		<comment type="block">/* next schunks index */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name></decl>;</decl_stmt>		<comment type="block">/* next bit to check in current schunk */</comment>
}</block></struct></type> <name>TBMSharedIteratorState</name>;</typedef>

<comment type="block">/*
 * pagetable iteration array.
 */</comment>
<typedef>typedef <type><struct>struct <name>PTIterationArray</name>
<block>{
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>refcount</name></decl>;</decl_stmt>	<comment type="block">/* no. of iterator attached */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>index</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* index array */</comment>
}</block></struct></type> <name>PTIterationArray</name>;</typedef>

<comment type="block">/*
 * same as TBMIterator, but it is used for joint iteration, therefore this
 * also holds a reference to the shared state.
 */</comment>
<struct>struct <name>TBMSharedIterator</name>
<block>{
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>	<comment type="block">/* shared state */</comment>
	<decl_stmt><decl><type><name>PTEntryArray</name> <modifier>*</modifier></type><name>ptbase</name></decl>;</decl_stmt>		<comment type="block">/* pagetable element array */</comment>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptpages</name></decl>;</decl_stmt>	<comment type="block">/* sorted exact page index list */</comment>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptchunks</name></decl>;</decl_stmt> <comment type="block">/* sorted lossy page index list */</comment>
	<decl_stmt><decl><type><name>TBMIterateResult</name></type> <name>output</name></decl>;</decl_stmt>	<comment type="block">/* MUST BE LAST (because variable-size) */</comment>
}</block>;</struct>

<comment type="block">/* Local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_union_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>bpage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tbm_intersect_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>apage</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>tbm_find_pageentry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>,
												<parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>tbm_get_pageentry</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tbm_page_is_lossy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_mark_page_lossy</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_lossify</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>tbm_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>tbm_shared_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>,
								  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* define hashtable mapping block numbers to PagetableEntry's */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_USE_NONDEFAULT_ALLOCATOR</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_PREFIX</name></cpp:macro> <cpp:value>pagetable</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_ELEMENT_TYPE</name></cpp:macro> <cpp:value>PagetableEntry</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_KEY_TYPE</name></cpp:macro> <cpp:value>BlockNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_KEY</name></cpp:macro> <cpp:value>blockno</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_HASH_KEY</name><parameter_list>(<parameter><type><name>tb</name></type></parameter>, <parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>murmurhash32(key)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_EQUAL</name><parameter_list>(<parameter><type><name>tb</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a == b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_SCOPE</name></cpp:macro> <cpp:value>static inline</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_DEFINE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_DECLARE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/simplehash.h"</cpp:file></cpp:include>


<comment type="block">/*
 * tbm_create - create an initially-empty bitmap
 *
 * The bitmap will live in the memory context that is CurrentMemoryContext
 * at the time of this call.  It will be limited to (approximately) maxbytes
 * total memory consumption.  If the DSA passed to this function is not NULL
 * then the memory for storing elements of the underlying page table will
 * be allocated from the DSA.
 */</comment>
<function><type><name>TIDBitmap</name> <modifier>*</modifier></type>
<name>tbm_create</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>maxbytes</name></decl></parameter>, <parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name></decl>;</decl_stmt>

	<comment type="block">/* Create the TIDBitmap struct and zero all its fields */</comment>
	<expr_stmt><expr><name>tbm</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TIDBitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>mcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TBM_EMPTY</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>tbm_calculate_entries</name><argument_list>(<argument><expr><name>maxbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>lossify_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name> <operator>=</operator> <name>dsa</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>

	<return>return <expr><name>tbm</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Actually create the hashtable.  Since this is a moderately expensive
 * proposition, we don't do it until we have to.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_create_pagetable</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name> <operator>=</operator> <call><name>pagetable_create</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If entry1 is valid, push it into the hashtable */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>oldstatus</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_insert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>,
								<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name><operator>.</operator><name>blockno</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldstatus</name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>oldstatus</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TBM_HASH</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_free - free a TIDBitmap
 */</comment>
<function><type><name>void</name></type>
<name>tbm_free</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pagetable_destroy</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_free_shared_area - free shared state
 *
 * Free shared iterator state, Also free shared pagetable and iterator arrays
 * memory if they are not referred by any of the shared iterator i.e recount
 * is becomes 0.
 */</comment>
<function><type><name>void</name></type>
<name>tbm_free_shared_area</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>istate</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTEntryArray</name> <modifier>*</modifier></type><name>ptbase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptchunks</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptbase</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptpages</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptpages</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptchunks</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptchunks</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_add_tuples - add some tuple IDs to a TIDBitmap
 *
 * If recheck is true, then the recheck flag will be set in the
 * TBMIterateResult when any of these tuples are reported out.
 */</comment>
<function><type><name>void</name></type>
<name>tbm_add_tuples</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ItemPointer</name></type> <name>tids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntids</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>currblk</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* only valid when currblk is valid */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_NOT_ITERATING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tids</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tids</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>,
					<decl><type ref="prev"/><name>bitnum</name></decl>;</decl_stmt>

		<comment type="block">/* safety check to ensure we don't overrun bit array bounds */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>off</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>off</name></expr></argument> &gt;</argument_list></name> <name>MAX_TUPLES_PER_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuple offset out of range: %u"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Look up target page unless we already did.  This saves cycles when
		 * the input includes consecutive tuples on the same page, which is
		 * common enough to justify an extra test here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>blk</name> <operator>!=</operator> <name>currblk</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>tbm_page_is_lossy</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* remember page is lossy */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>tbm_get_pageentry</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>currblk</name> <operator>=</operator> <name>blk</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* whole page is already marked */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The page is a lossy chunk header, set bit for itself */</comment>
			<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <name>bitnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Page is exact, so set bit for individual tuple */</comment>
			<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>recheck</name></name> <operator>|=</operator> <name>recheck</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tbm_lossify</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Page could have been converted to lossy, so force new lookup */</comment>
			<expr_stmt><expr><name>currblk</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_add_page - add a whole page to a TIDBitmap
 *
 * This causes the whole page to be reported (with the recheck flag)
 * when the TIDBitmap is scanned.
 */</comment>
<function><type><name>void</name></type>
<name>tbm_add_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Enter the page in the bitmap, or mark it lossy if already present */</comment>
	<expr_stmt><expr><call><name>tbm_mark_page_lossy</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If we went over the memory limit, lossify some more pages */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_lossify</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_union - set union
 *
 * a is modified in-place, b is not changed
 */</comment>
<function><type><name>void</name></type>
<name>tbm_union</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>iterating</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Nothing to do if b is empty */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Scan through chunks and pages in b, merge into a */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_union_page</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>entry1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>bpage</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pagetable_start_iterate</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>bpage</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tbm_union_page</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Process one page of b during a union op */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_union_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>bpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>apage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bpage</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Scan b's chunk, mark each indicated page lossy in a */</comment>
		<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_CHUNK</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>bpage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>pg</name> <operator>=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <operator>(</operator><name>wordnum</name> <operator>*</operator> <name>BITS_PER_BITMAPWORD</name><operator>)</operator></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>tbm_mark_page_lossy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>pg</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>w</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>tbm_page_is_lossy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>bpage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* page is already lossy in a, nothing to do */</comment>
		<return>return;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>apage</name> <operator>=</operator> <call><name>tbm_get_pageentry</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>bpage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>apage</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The page is a lossy chunk header, set bit for itself */</comment>
			<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Both pages are exact, merge at the bit level */</comment>
			<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_PAGE</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>|=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>recheck</name></name> <operator>|=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>recheck</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <name><name>a</name><operator>-&gt;</operator><name>maxentries</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_lossify</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_intersect - set intersection
 *
 * a is modified in-place, b is not changed
 */</comment>
<function><type><name>void</name></type>
<name>tbm_intersect</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>iterating</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Nothing to do if a is empty */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Scan through chunks and pages in a, try to match to b */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>tbm_intersect_page</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>entry1</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Page is now empty, remove it from a */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>entry1</name><operator>.</operator><name>ischunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>npages</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TBM_EMPTY</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>apage</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pagetable_start_iterate</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>apage</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>tbm_intersect_page</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>apage</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Page or chunk is now empty, remove it from a */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>apage</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nchunks</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>npages</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name><operator>--</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pagetable_delete</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name><name>apage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process one page of a during an intersection op
 *
 * Returns true if apage is now empty and should be deleted from a
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tbm_intersect_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>apage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>bpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>apage</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Scan each bit in chunk, try to clear */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>candelete</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_CHUNK</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bitmapword</name></type>	<name>neww</name> <init>= <expr><name>w</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>bitnum</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>pg</name> <operator>=</operator> <name><name>apage</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <operator>(</operator><name>wordnum</name> <operator>*</operator> <name>BITS_PER_BITMAPWORD</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tbm_page_is_lossy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<call><name>tbm_find_pageentry</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Page is not in b at all, lose lossy bit */</comment>
							<expr_stmt><expr><name>neww</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>pg</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>bitnum</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>w</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>=</operator> <name>neww</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>neww</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>candelete</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><name>candelete</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>tbm_page_is_lossy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>apage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Some of the tuples in 'a' might not satisfy the quals for 'b', but
		 * because the page 'b' is lossy, we don't know which ones. Therefore
		 * we mark 'a' as requiring rechecks, to indicate that at most those
		 * tuples set in 'a' are matches.
		 */</comment>
		<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>candelete</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>bpage</name> <operator>=</operator> <call><name>tbm_find_pageentry</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>apage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bpage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Both pages are exact, merge at the bit level */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>bpage</name><operator>-&gt;</operator><name>ischunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_PAGE</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>candelete</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>recheck</name></name> <operator>|=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>recheck</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* If there is no matching b page, we can just delete the a page */</comment>
		<return>return <expr><name>candelete</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_is_empty - is a TIDBitmap completely empty?
 */</comment>
<function><type><name>bool</name></type>
<name>tbm_is_empty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_begin_iterate - prepare to iterate through a TIDBitmap
 *
 * The TBMIterator struct is created in the caller's memory context.
 * For a clean shutdown of the iteration, call tbm_end_iterate; but it's
 * okay to just allow the memory context to be released, too.  It is caller's
 * responsibility not to touch the TBMIterator anymore once the TIDBitmap
 * is freed.
 *
 * NB: after this is called, it is no longer allowed to modify the contents
 * of the bitmap.  However, you can call this multiple times to scan the
 * contents repeatedly, including parallel scans.
 */</comment>
<function><type><name>TBMIterator</name> <modifier>*</modifier></type>
<name>tbm_begin_iterate</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>!=</operator> <name>TBM_ITERATING_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the TBMIterator struct, with enough trailing space to serve the
	 * needs of the TBMIterateResult sub-struct.
	 */</comment>
	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <operator>(</operator><name>TBMIterator</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TBMIterator</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
									  <name>MAX_TUPLES_PER_PAGE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>tbm</name></name> <operator>=</operator> <name>tbm</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize iteration pointers.
	 */</comment>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have a hashtable, create and fill the sorted page lists, unless
	 * we already did that for a previous iterator.  Note that the lists are
	 * attached to the bitmap not the iterator, so they can be used by more
	 * than one iterator.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name> <operator>&amp;&amp;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_NOT_ITERATING</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nchunks</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name> <operator>&amp;&amp;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name> <operator>=</operator> <operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>,
								   <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name> <operator>&amp;&amp;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name> <operator>=</operator> <operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>,
								   <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>npages</name> <operator>=</operator> <name>nchunks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pagetable_start_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>page</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name><index>[<expr><name>nchunks</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name><index>[<expr><name>npages</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>==</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nchunks</name> <operator>==</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>npages</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>, <argument><expr><name>npages</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>tbm_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nchunks</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>, <argument><expr><name>nchunks</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>tbm_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>=</operator> <name>TBM_ITERATING_PRIVATE</name></expr>;</expr_stmt>

	<return>return <expr><name>iterator</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_prepare_shared_iterate - prepare shared iteration state for a TIDBitmap.
 *
 * The necessary shared state will be allocated from the DSA passed to
 * tbm_create, so that multiple processes can attach to it and iterate jointly.
 *
 * This will convert the pagetable hash into page and chunk array of the index
 * into pagetable array.
 */</comment>
<function><type><name>dsa_pointer</name></type>
<name>tbm_prepare_shared_iterate</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>istate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTEntryArray</name> <modifier>*</modifier></type><name>ptbase</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptpages</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptchunks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>!=</operator> <name>TBM_ITERATING_PRIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate TBMSharedIteratorState from DSA to hold the shared members and
	 * lock, this will also be used by multiple worker for shared iterate.
	 */</comment>
	<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TBMSharedIteratorState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>istate</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're not already iterating, create and fill the sorted page lists.
	 * (If we are, the sorted page lists are already stored in the TIDBitmap,
	 * and we can just reuse them.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_NOT_ITERATING</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nchunks</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Allocate the page and chunk array memory from the DSA to share
		 * across multiple processes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PTIterationArray</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
										<name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptpages</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptpages</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PTIterationArray</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
										 <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptchunks</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptchunks</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If TBM status is TBM_HASH then iterate over the pagetable and
		 * convert it to page and chunk arrays.  But if it's in the
		 * TBM_ONE_PAGE mode then directly allocate the space for one entry
		 * from the DSA.
		 */</comment>
		<expr_stmt><expr><name>npages</name> <operator>=</operator> <name>nchunks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pagetable_start_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>page</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>page</name> <operator>-</operator> <name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>ptchunks</name><operator>-&gt;</operator><name>index</name><index>[<expr><name>nchunks</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>ptpages</name><operator>-&gt;</operator><name>index</name><index>[<expr><name>npages</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>==</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nchunks</name> <operator>==</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In one page mode allocate the space for one pagetable entry,
			 * initialize it, and directly store its index (i.e. 0) in the
			 * page array.
			 */</comment>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PTEntryArray</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
											 <sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptpages</name><operator>-&gt;</operator><name>index</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ptbase</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptbase</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>npages</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>ptpages</name><operator>-&gt;</operator><name>index</name></name><operator>)</operator></expr></argument>, <argument><expr><name>npages</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					  <argument><expr><name>tbm_shared_comparator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nchunks</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>ptchunks</name><operator>-&gt;</operator><name>index</name></name><operator>)</operator></expr></argument>, <argument><expr><name>nchunks</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					  <argument><expr><name>tbm_shared_comparator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Store the TBM members in the shared state so that we can share them
	 * across multiple processes.
	 */</comment>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>nentries</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>npages</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptpages</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptchunks</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For every shared iterator, referring to pagetable and iterator array,
	 * increase the refcount by 1 so that while freeing the shared iterator we
	 * don't free pagetable and iterator array until its refcount becomes 0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptbase</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptbase</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptpages</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptpages</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptchunks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptchunks</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize the iterator lock */</comment>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_SHARED_TIDBITMAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the shared iterator state */</comment>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>=</operator> <name>TBM_ITERATING_SHARED</name></expr>;</expr_stmt>

	<return>return <expr><name>dp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_extract_page_tuple - extract the tuple offsets from a page
 *
 * The extracted offsets are stored into TBMIterateResult.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>tbm_extract_page_tuple</name><parameter_list>(<parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_PAGE</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>off</name> <init>= <expr><name>wordnum</name> <operator>*</operator> <name>BITS_PER_BITMAPWORD</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name>ntuples</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name><operator>)</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>w</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>ntuples</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	tbm_advance_schunkbit - Advance the schunkbit
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>tbm_advance_schunkbit</name><parameter_list>(<parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>schunkbitp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name> <init>= <expr><operator>*</operator><name>schunkbitp</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>schunkbit</name> <operator>&lt;</operator> <name>PAGES_PER_CHUNK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name> <init>= <expr><call><name>WORDNUM</name><argument_list>(<argument><expr><name>schunkbit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bitnum</name> <init>= <expr><call><name>BITNUM</name><argument_list>(<argument><expr><name>schunkbit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>schunkbit</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>schunkbitp</name> <operator>=</operator> <name>schunkbit</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_iterate - scan through next page of a TIDBitmap
 *
 * Returns a TBMIterateResult representing one page, or NULL if there are
 * no more pages to scan.  Pages are guaranteed to be delivered in numerical
 * order.  If result-&gt;ntuples &lt; 0, then the bitmap is "lossy" and failed to
 * remember the exact tuples to look at on this page --- the caller must
 * examine all tuples on the page and check if they meet the intended
 * condition.  If result-&gt;recheck is true, only the indicated tuples need
 * be examined, but the condition must be rechecked anyway.  (For ease of
 * testing, recheck is always set true when ntuples &lt; 0.)
 */</comment>
<function><type><name>TBMIterateResult</name> <modifier>*</modifier></type>
<name>tbm_iterate</name><parameter_list>(<parameter><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>tbm</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>iterator</name><operator>-&gt;</operator><name>output</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_ITERATING_PRIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If lossy chunk pages remain, make sure we've advanced schunkptr/
	 * schunkbit to the next set bit.
	 */</comment>
	<while>while <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>&lt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name><index>[<expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>tbm_advance_schunkbit</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schunkbit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>schunkbit</name> <operator>&lt;</operator> <name>PAGES_PER_CHUNK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <name>schunkbit</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* advance to next chunk */</comment>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If both chunk and per-page data remain, must output the numerically
	 * earlier page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>&lt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name><index>[<expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>chunk_blockno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>chunk_blockno</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>&gt;=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name> <operator>||</operator>
			<name>chunk_blockno</name> <operator>&lt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>spages</name><index>[<expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name></expr>]</index></name><operator>-&gt;</operator><name>blockno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Return a lossy page indicator from the chunk */</comment>
			<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>chunk_blockno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name><operator>++</operator></expr>;</expr_stmt>
			<return>return <expr><name>output</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>&lt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name></decl>;</decl_stmt>

		<comment type="block">/* In TBM_ONE_PAGE state, we don't allocate an spages[] array */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>spages</name><index>[<expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* scan bitmap to extract individual offset numbers */</comment>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <call><name>tbm_extract_page_tuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>blockno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name>ntuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>recheck</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name>output</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Nothing more in the bitmap */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	tbm_shared_iterate - scan through next page of a TIDBitmap
 *
 *	As above, but this will iterate using an iterator which is shared
 *	across multiple processes.  We need to acquire the iterator LWLock,
 *	before accessing the shared members.
 */</comment>
<function><type><name>TBMIterateResult</name> <modifier>*</modifier></type>
<name>tbm_shared_iterate</name><parameter_list>(<parameter><decl><type><name>TBMSharedIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>output</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>istate</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>ptbase</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>idxpages</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>idxchunks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>ptbase</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>ptpages</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idxpages</name> <operator>=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>ptpages</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>ptchunks</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idxchunks</name> <operator>=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>ptchunks</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Acquire the LWLock before accessing the shared members */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If lossy chunk pages remain, make sure we've advanced schunkptr/
	 * schunkbit to the next set bit.
	 */</comment>
	<while>while <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>&amp;</operator><name><name>ptbase</name><index>[<expr><name><name>idxchunks</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>tbm_advance_schunkbit</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schunkbit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>schunkbit</name> <operator>&lt;</operator> <name>PAGES_PER_CHUNK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <name>schunkbit</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* advance to next chunk */</comment>
		<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If both chunk and per-page data remain, must output the numerically
	 * earlier page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>&amp;</operator><name><name>ptbase</name><index>[<expr><name><name>idxchunks</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>chunk_blockno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>chunk_blockno</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>&gt;=</operator> <name><name>istate</name><operator>-&gt;</operator><name>npages</name></name> <operator>||</operator>
			<name>chunk_blockno</name> <operator>&lt;</operator> <name><name>ptbase</name><index>[<expr><name><name>idxpages</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>blockno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Return a lossy page indicator from the chunk */</comment>
			<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>chunk_blockno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>output</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>npages</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name> <init>= <expr><operator>&amp;</operator><name><name>ptbase</name><index>[<expr><name><name>idxpages</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name></decl>;</decl_stmt>

		<comment type="block">/* scan bitmap to extract individual offset numbers */</comment>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <call><name>tbm_extract_page_tuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>blockno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name>ntuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>recheck</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>output</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing more in the bitmap */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_end_iterate - finish an iteration over a TIDBitmap
 *
 * Currently this is just a pfree, but it might do more someday.  (For
 * instance, it could be useful to count open iterators and allow the
 * bitmap to return to read/write status when there are no more iterators.)
 */</comment>
<function><type><name>void</name></type>
<name>tbm_end_iterate</name><parameter_list>(<parameter><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_end_shared_iterate - finish a shared iteration over a TIDBitmap
 *
 * This doesn't free any of the shared state associated with the iterator,
 * just our backend-private state.
 */</comment>
<function><type><name>void</name></type>
<name>tbm_end_shared_iterate</name><parameter_list>(<parameter><decl><type><name>TBMSharedIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_find_pageentry - find a PagetableEntry for the pageno
 *
 * Returns NULL if there is no non-lossy entry for the pageno.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type>
<name>tbm_find_pageentry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* in case pagetable doesn't exist */</comment>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>!=</operator> <name>pageno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>page</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_lookup</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* don't want a lossy chunk header */</comment>
	<return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_get_pageentry - find or create a PagetableEntry for the pageno
 *
 * If new, the entry is marked as an exact (non-chunk) entry.
 *
 * This may cause the table to exceed the desired memory size.  It is
 * up to the caller to call tbm_lossify() at the next safe point if so.
 */</comment>
<function><type><specifier>static</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type>
<name>tbm_get_pageentry</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_EMPTY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use the fixed slot */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TBM_ONE_PAGE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>==</operator> <name>pageno</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>page</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Time to switch from one page to a hashtable */</comment>
			<expr_stmt><expr><call><name>tbm_create_pagetable</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Look up or create an entry */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_insert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Initialize it if not present before */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>oldstatus</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>oldstatus</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
		<comment type="block">/* must count it too */</comment>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_page_is_lossy - is the page marked as lossily stored?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tbm_page_is_lossy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>chunk_pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitno</name></decl>;</decl_stmt>

	<comment type="block">/* we can skip the lookup if there are no lossy chunks */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bitno</name> <operator>=</operator> <name>pageno</name> <operator>%</operator> <name>PAGES_PER_CHUNK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk_pageno</name> <operator>=</operator> <name>pageno</name> <operator>-</operator> <name>bitno</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_lookup</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>chunk_pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>page</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name> <init>= <expr><call><name>WORDNUM</name><argument_list>(<argument><expr><name>bitno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bitnum</name> <init>= <expr><call><name>BITNUM</name><argument_list>(<argument><expr><name>bitno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_mark_page_lossy - mark the page number as lossily stored
 *
 * This may cause the table to exceed the desired memory size.  It is
 * up to the caller to call tbm_lossify() at the next safe point if so.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_mark_page_lossy</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>chunk_pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitnum</name></decl>;</decl_stmt>

	<comment type="block">/* We force the bitmap into hashtable mode whenever it's lossy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>TBM_HASH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_create_pagetable</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bitno</name> <operator>=</operator> <name>pageno</name> <operator>%</operator> <name>PAGES_PER_CHUNK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk_pageno</name> <operator>=</operator> <name>pageno</name> <operator>-</operator> <name>bitno</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove any extant non-lossy entry for the page.  If the page is its own
	 * chunk header, however, we skip this and handle the case below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bitno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pagetable_delete</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* It was present, so adjust counts */</comment>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name><operator>--</operator></expr>;</expr_stmt>		<comment type="block">/* assume it must have been non-lossy */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Look up or create entry for chunk-header page */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_insert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>chunk_pageno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize it if not present before */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>oldstatus</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>oldstatus</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>chunk_pageno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* must count it too */</comment>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>oldstatus</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* chunk header page was formerly non-lossy, make it lossy */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>oldstatus</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>chunk_pageno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* we assume it had some tuple bit(s) set, so mark it lossy */</comment>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* adjust counts */</comment>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now set the original target page's bit */</comment>
	<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>bitno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>bitno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_lossify - lose some information to get back under the memory limit
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_lossify</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * XXX Really stupid implementation: this just lossifies pages in
	 * essentially random order.  We should be paying some attention to the
	 * number of bits set in each page, instead.
	 *
	 * Since we are called as soon as nentries exceeds maxentries, we should
	 * push nentries down to significantly less than maxentries, or else we'll
	 * just end up doing this again very soon.  We shoot for maxentries/2.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_NOT_ITERATING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pagetable_start_iterate_at</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>lossify_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>page</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* already a chunk header */</comment>

		<comment type="block">/*
		 * If the page would become a chunk header, we won't save anything by
		 * converting it to lossy, so skip it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>%</operator> <name>PAGES_PER_CHUNK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* This does the dirty work ... */</comment>
		<expr_stmt><expr><call><name>tbm_mark_page_lossy</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&lt;=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have made enough room. Remember where to start lossifying
			 * next round, so we evenly iterate over the hashtable.
			 */</comment>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>lossify_start</name></name> <operator>=</operator> <name><name>i</name><operator>.</operator><name>cur</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Note: tbm_mark_page_lossy may have inserted a lossy chunk into the
		 * hashtable and may have deleted the non-lossy chunk.  We can
		 * continue the same hash table scan, since failure to visit one
		 * element or visiting the newly inserted element, isn't fatal.
		 */</comment>
	</block_content>}</block></while>

	<comment type="block">/*
	 * With a big bitmap and small work_mem, it's possible that we cannot get
	 * under maxentries.  Again, if that happens, we'd end up uselessly
	 * calling tbm_lossify over and over.  To prevent this from becoming a
	 * performance sink, force maxentries up to at least double the current
	 * number of entries.  (In essence, we're admitting inability to fit
	 * within work_mem when we do this.)  Note that this test will not fire if
	 * we broke out of the loop early; and if we didn't, the current number of
	 * entries is simply not reducible any further.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>, <argument><expr><operator>(</operator><name>INT_MAX</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator to handle PagetableEntry pointers.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tbm_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>l</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>PagetableEntry</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>left</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>blockno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>r</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>PagetableEntry</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>right</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>blockno</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * As above, but this will get index into PagetableEntry array.  Therefore,
 * it needs to get actual PagetableEntry using the index before comparing the
 * blockno.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tbm_shared_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>lpage</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><index>[<expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>left</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>rpage</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><index>[<expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>right</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lpage</name><operator>-&gt;</operator><name>blockno</name></name> <operator>&lt;</operator> <name><name>rpage</name><operator>-&gt;</operator><name>blockno</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>lpage</name><operator>-&gt;</operator><name>blockno</name></name> <operator>&gt;</operator> <name><name>rpage</name><operator>-&gt;</operator><name>blockno</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	tbm_attach_shared_iterate
 *
 *	Allocate a backend-private iterator and attach the shared iterator state
 *	to it so that multiple processed can iterate jointly.
 *
 *	We also converts the DSA pointers to local pointers and store them into
 *	our private iterator.
 */</comment>
<function><type><name>TBMSharedIterator</name> <modifier>*</modifier></type>
<name>tbm_attach_shared_iterate</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TBMSharedIterator</name> <modifier>*</modifier></type><name>iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>istate</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create the TBMSharedIterator struct, with enough trailing space to
	 * serve the needs of the TBMIterateResult sub-struct.
	 */</comment>
	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <operator>(</operator><name>TBMSharedIterator</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TBMSharedIterator</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
											 <name>MAX_TUPLES_PER_PAGE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>istate</name> <operator>=</operator> <operator>(</operator><name>TBMSharedIteratorState</name> <operator>*</operator><operator>)</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>istate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ptbase</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>npages</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ptpages</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ptchunks</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>iterator</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pagetable_allocate
 *
 * Callback function for allocating the memory for hashtable elements.
 * Allocate memory for hashtable elements, using DSA if available.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type>
<name>pagetable_allocate</name><parameter_list>(<parameter><decl><type><name>pagetable_hash</name> <modifier>*</modifier></type><name>pagetable</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name> <init>= <expr><operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <name><name>pagetable</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTEntryArray</name> <modifier>*</modifier></type><name>ptbase</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>MemoryContextAllocExtended</name><argument_list>(<argument><expr><name><name>pagetable</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
										  <argument><expr><name>MCXT_ALLOC_HUGE</name> <operator>|</operator> <name>MCXT_ALLOC_ZERO</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Save the dsapagetable reference in dsapagetableold before allocating
	 * new memory so that pagetable_free can free the old entry.
	 */</comment>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name> <operator>=</operator> <call><name>dsa_allocate_extended</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>,
											  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PTEntryArray</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size</name></expr></argument>,
											  <argument><expr><name>DSA_ALLOC_HUGE</name> <operator>|</operator> <name>DSA_ALLOC_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pagetable_free
 *
 * Callback function for freeing hash table elements.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>pagetable_free</name><parameter_list>(<parameter><decl><type><name>pagetable_hash</name> <modifier>*</modifier></type><name>pagetable</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name> <init>= <expr><operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <name><name>pagetable</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* pfree the input pointer if DSA is not available */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_calculate_entries
 *
 * Estimate number of hashtable entries we can have within maxbytes.
 */</comment>
<function><type><name>long</name></type>
<name>tbm_calculate_entries</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>maxbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>nbuckets</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Estimate number of hashtable entries we can have within maxbytes. This
	 * estimates the hash cost as sizeof(PagetableEntry), which is good enough
	 * for our purpose.  Also count an extra Pointer per entry for the arrays
	 * created during iteration readout.
	 */</comment>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <name>maxbytes</name> <operator>/</operator>
		<operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pointer</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pointer</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>, <argument><expr><name>INT_MAX</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* safety limit */</comment>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sanity limit */</comment>

	<return>return <expr><name>nbuckets</name></expr>;</return>
</block_content>}</block></function>
</unit>
