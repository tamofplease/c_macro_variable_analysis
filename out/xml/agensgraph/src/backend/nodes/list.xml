<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/nodes/list.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * list.c
 *	  implementation for PostgreSQL generic list package
 *
 * See comments in pg_list.h.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/nodes/list.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bitutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * The previous List implementation, since it used a separate palloc chunk
 * for each cons cell, had the property that adding or deleting list cells
 * did not move the storage of other existing cells in the list.  Quite a
 * bit of existing code depended on that, by retaining ListCell pointers
 * across such operations on a list.  There is no such guarantee in this
 * implementation, so instead we have debugging support that is meant to
 * help flush out now-broken assumptions.  Defining DEBUG_LIST_MEMORY_USAGE
 * while building this file causes the List operations to forcibly move
 * all cells in a list whenever a cell is added or deleted.  In combination
 * with MEMORY_CONTEXT_CHECKING and/or Valgrind, this can usually expose
 * broken code.  It's a bit expensive though, as there's many more palloc
 * cycles and a lot more data-copying than in a default build.
 *
 * By default, we enable this when building for Valgrind.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_VALGRIND</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_LIST_MEMORY_USAGE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Overhead for the fixed part of a List header, measured in ListCells */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST_HEADER_OVERHEAD</name></cpp:macro>  \
	<cpp:value>((int) ((offsetof(List, initial_elements) - 1) / sizeof(ListCell) + 1))</cpp:value></cpp:define>

<comment type="block">/*
 * Macros to simplify writing assertions about the type of a list; a
 * NIL list is considered to be an empty list of any type.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsPointerList</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((l) == NIL || IsA((l), List))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsIntegerList</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((l) == NIL || IsA((l), IntList))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsOidList</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>((l) == NIL || IsA((l), OidList))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block">/*
 * Check that the specified List is valid (so far as we can tell).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_list_invariants</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <name><name>list</name><operator>-&gt;</operator><name>max_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_List</name> <operator>||</operator>
		   <name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_IntList</name> <operator>||</operator>
		   <name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_OidList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_list_invariants</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ASSERT_CHECKING */</comment>

<comment type="block">/*
 * Return a freshly allocated List with room for at least min_size cells.
 *
 * Since empty non-NIL lists are invalid, new_list() sets the initial length
 * to min_size, effectively marking that number of cells as valid; the caller
 * is responsible for filling in their data.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>new_list</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>min_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We allocate all the requested cells, and possibly some more, as part of
	 * the same palloc request as the List header.  This is a big win for the
	 * typical case of short fixed-length lists.  It can lose if we allocate a
	 * moderately long list and then it gets extended; we'll be wasting more
	 * initial_elements[] space than if we'd made the header small.  However,
	 * rounding up the request as we do in the normal code path provides some
	 * defense against small extensions.
	 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG_LIST_MEMORY_USAGE</name></cpp:ifndef>

	<comment type="block">/*
	 * Normally, we set up a list with some extra cells, to allow it to grow
	 * without a repalloc.  Prefer cell counts chosen to make the total
	 * allocation a power-of-2, since palloc would round it up to that anyway.
	 * (That stops being true for very large allocations, but very long lists
	 * are infrequent, so it doesn't seem worth special logic for such cases.)
	 *
	 * The minimum allocation is 8 ListCell units, providing either 4 or 5
	 * available ListCells depending on the machine's word width.  Counting
	 * palloc's overhead, this uses the same amount of space as a one-cell
	 * list did in the old implementation, and less space for any longer list.
	 *
	 * We needn't worry about integer overflow; no caller passes min_size
	 * that's more than twice the size of an existing list, so the size limits
	 * within palloc will ensure that we don't overflow here.
	 */</comment>
	<expr_stmt><expr><name>max_size</name> <operator>=</operator> <call><name>pg_nextpower2_32</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>min_size</name> <operator>+</operator> <name>LIST_HEADER_OVERHEAD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_size</name> <operator>-=</operator> <name>LIST_HEADER_OVERHEAD</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * For debugging, don't allow any extra space.  This forces any cell
	 * addition to go through enlarge_list() and thus move the existing data.
	 */</comment>
	<expr_stmt><expr><name>max_size</name> <operator>=</operator> <name>min_size</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>newlist</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>initial_elements</name></expr></argument>)</argument_list></call> <operator>+</operator>
							  <name>max_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>min_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>max_length</name></name> <operator>=</operator> <name>max_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name><name>newlist</name><operator>-&gt;</operator><name>initial_elements</name></name></expr>;</expr_stmt>

	<return>return <expr><name>newlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Enlarge an existing non-NIL List to have room for at least min_size cells.
 *
 * This does *not* update list-&gt;length, as some callers would find that
 * inconvenient.  (list-&gt;length had better be the correct number of existing
 * valid cells, though.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>enlarge_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_max_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>min_size</name> <operator>&gt;</operator> <name><name>list</name><operator>-&gt;</operator><name>max_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else we shouldn't be here */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG_LIST_MEMORY_USAGE</name></cpp:ifndef>

	<comment type="block">/*
	 * As above, we prefer power-of-two total allocations; but here we need
	 * not account for list header overhead.
	 */</comment>

	<comment type="block">/* clamp the minimum value to 16, a semi-arbitrary small power of 2 */</comment>
	<expr_stmt><expr><name>new_max_len</name> <operator>=</operator> <call><name>pg_nextpower2_32</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>min_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* As above, don't allocate anything extra */</comment>
	<expr_stmt><expr><name>new_max_len</name> <operator>=</operator> <name>min_size</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>==</operator> <name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Replace original in-line allocation with a separate palloc block.
		 * Ensure it is in the same memory context as the List header.  (The
		 * previous List implementation did not offer any guarantees about
		 * keeping all list cells in the same context, but it seems reasonable
		 * to create such a guarantee now.)
		 */</comment>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <operator>(</operator><name>ListCell</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>new_max_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr></argument>,
			   <argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must not move the list header, so it's unsafe to try to reclaim
		 * the initial_elements[] space via repalloc.  In debugging builds,
		 * however, we can clear that space and/or mark it inaccessible.
		 * (wipe_mem includes VALGRIND_MAKE_MEM_NOACCESS.)
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CLOBBER_FREED_MEMORY</name></cpp:ifdef>
		<expr_stmt><expr><call><name>wipe_mem</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr></argument>,
				 <argument><expr><name><name>list</name><operator>-&gt;</operator><name>max_length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr></argument>,
								   <argument><expr><name><name>list</name><operator>-&gt;</operator><name>max_length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG_LIST_MEMORY_USAGE</name></cpp:ifndef>
		<comment type="block">/* Normally, let repalloc deal with enlargement */</comment>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <operator>(</operator><name>ListCell</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>,
											   <argument><expr><name>new_max_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/*
		 * repalloc() might enlarge the space in-place, which we don't want
		 * for debugging purposes, so forcibly move the data somewhere else.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>newelements</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newelements</name> <operator>=</operator> <operator>(</operator><name>ListCell</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>new_max_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newelements</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>,
			   <argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>newelements</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>max_length</name></name> <operator>=</operator> <name>new_max_len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convenience functions to construct short Lists from given values.
 * (These are normally invoked via the list_makeN macros.)
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_make1_impl</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>new_list</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>datum1</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_make2_impl</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum1</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>new_list</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>datum1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum2</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_make3_impl</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum1</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum2</name></decl></parameter>,
				<parameter><decl><type><name>ListCell</name></type> <name>datum3</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>new_list</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>datum1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>datum3</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_make4_impl</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum1</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum2</name></decl></parameter>,
				<parameter><decl><type><name>ListCell</name></type> <name>datum3</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum4</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>new_list</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>datum1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>datum3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>datum4</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_make5_impl</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum1</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum2</name></decl></parameter>,
				<parameter><decl><type><name>ListCell</name></type> <name>datum3</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum4</name></decl></parameter>, <parameter><decl><type><name>ListCell</name></type> <name>datum5</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>new_list</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>datum1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>datum3</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>datum4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>datum5</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make room for a new head cell in the given (non-NIL) list.
 *
 * The data in the new head cell is undefined; the caller should be
 * sure to fill it in
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>new_head_cell</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Enlarge array if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <name><name>list</name><operator>-&gt;</operator><name>max_length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>enlarge_list</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Now shove the existing data over */</comment>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
			<argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make room for a new tail cell in the given (non-NIL) list.
 *
 * The data in the new tail cell is undefined; the caller should be
 * sure to fill it in
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>new_tail_cell</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Enlarge array if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <name><name>list</name><operator>-&gt;</operator><name>max_length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>enlarge_list</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append a pointer to the list. A pointer to the modified list is
 * returned. Note that this function may or may not destructively
 * modify the list; callers should always use this function's return
 * value, rather than continuing to use the pointer passed as the
 * first argument.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lappend</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name>T_List</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>new_tail_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_tail</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append an integer to the specified list. See lappend()
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lappend_int</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name>T_IntList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>new_tail_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><call><name>list_tail</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append an OID to the specified list. See lappend()
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lappend_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name>T_OidList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>new_tail_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><call><name>list_tail</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make room for a new cell at position 'pos' (measured from 0).
 * The data in the cell is left undefined, and must be filled in by the
 * caller. 'list' is assumed to be non-NIL, and 'pos' must be a valid
 * list position, ie, 0 &lt;= pos &lt;= list's length.
 * Returns address of the new cell.
 */</comment>
<function><type><specifier>static</specifier> <name>ListCell</name> <modifier>*</modifier></type>
<name>insert_new_cell</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;=</operator> <name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Enlarge array if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <name><name>list</name><operator>-&gt;</operator><name>max_length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>enlarge_list</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Now shove the existing data over */</comment>
	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>,
				<argument><expr><operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>pos</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert the given datum at position 'pos' (measured from 0) in the list.
 * 'pos' must be valid, ie, 0 &lt;= pos &lt;= list's length.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_insert_nth</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pos</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>insert_new_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_insert_nth_int</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pos</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><call><name>insert_new_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_insert_nth_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pos</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><call><name>insert_new_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepend a new element to the list. A pointer to the modified list
 * is returned. Note that this function may or may not destructively
 * modify the list; callers should always use this function's return
 * value, rather than continuing to use the pointer passed as the
 * second argument.
 *
 * Caution: before Postgres 8.0, the original List was unmodified and
 * could be considered to retain its separate identity.  This is no longer
 * the case.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lcons</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name>T_List</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>new_head_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepend an integer to the list. See lcons()
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lcons_int</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name>T_IntList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>new_head_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepend an OID to the list. See lcons()
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lcons_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name>T_OidList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>new_head_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Concatenate list2 to the end of list1, and return list1.
 *
 * This is equivalent to lappend'ing each element of list2, in order, to list1.
 * list1 is destructively changed, list2 is not.  (However, in the case of
 * pointer lists, list1 and list2 will point to the same structures.)
 *
 * Callers should be sure to use the return value as the new pointer to the
 * concatenated list: the 'list1' input pointer may or may not be the same
 * as the returned pointer.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_concat</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>list1</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>list2</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>list1</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list1</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>list2</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_len</name> <operator>=</operator> <name><name>list1</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <name><name>list2</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
	<comment type="block">/* Enlarge array if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_len</name> <operator>&gt;</operator> <name><name>list1</name><operator>-&gt;</operator><name>max_length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>enlarge_list</name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Even if list1 == list2, using memcpy should be safe here */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list1</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name><name>list1</name><operator>-&gt;</operator><name>length</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list2</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
		   <argument><expr><name><name>list2</name><operator>-&gt;</operator><name>length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list1</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>new_len</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Form a new list by concatenating the elements of list1 and list2.
 *
 * Neither input list is modified.  (However, if they are pointer lists,
 * the output list will point to the same structures.)
 *
 * This is equivalent to, but more efficient than,
 * list_concat(list_copy(list1), list2).
 * Note that some pre-v13 code might list_copy list2 as well, but that's
 * pointless now.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_concat_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>list1</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>list2</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list1</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>list2</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_len</name> <operator>=</operator> <name><name>list1</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <name><name>list2</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name><name>list1</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name><name>list1</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>,
		   <argument><expr><name><name>list1</name><operator>-&gt;</operator><name>length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>elements</name></name> <operator>+</operator> <name><name>list1</name><operator>-&gt;</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>list2</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>,
		   <argument><expr><name><name>list2</name><operator>-&gt;</operator><name>length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Truncate 'list' to contain no more than 'new_size' elements. This
 * modifies the list in-place! Despite this, callers should use the
 * pointer returned by this function to refer to the newly truncated
 * list -- it may or may not be the same as the pointer that was
 * passed.
 *
 * Note that any cells removed by list_truncate() are NOT pfree'd.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_truncate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>new_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* truncate to zero length */</comment>

	<comment type="block">/* If asked to effectively extend the list, do nothing */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>new_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: unlike the individual-list-cell deletion functions, we don't move
	 * the list cells to new storage, even in DEBUG_LIST_MEMORY_USAGE mode.
	 * This is because none of them can move in this operation, so just like
	 * in the old cons-cell-based implementation, this function doesn't
	 * invalidate any pointers to cells of the list.  This is also the reason
	 * for not wiping the memory of the deleted cells: the old code didn't
	 * free them either.  Perhaps later we'll tighten this up.
	 */</comment>

	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true iff 'datum' is a member of the list. Equality is
 * determined via equal(), so callers should ensure that they pass a
 * Node as 'datum'.
 */</comment>
<function><type><name>bool</name></type>
<name>list_member</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true iff 'datum' is a member of the list. Equality is
 * determined by using simple pointer comparison.
 */</comment>
<function><type><name>bool</name></type>
<name>list_member_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>datum</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true iff the integer 'datum' is a member of the list.
 */</comment>
<function><type><name>bool</name></type>
<name>list_member_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>datum</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true iff the OID 'datum' is a member of the list.
 */</comment>
<function><type><name>bool</name></type>
<name>list_member_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>datum</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete the n'th cell (counting from 0) in list.
 *
 * The List is pfree'd if this was the last member.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_delete_nth_cell</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're about to delete the last node from the list, free the whole
	 * list instead and return NIL, which is the only valid representation of
	 * a zero-length list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we normally just collapse out the removed element.  But for
	 * debugging purposes, move the whole list contents someplace else.
	 *
	 * (Note that we *must* keep the contents in the same memory context.)
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG_LIST_MEMORY_USAGE</name></cpp:ifndef>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
			<argument><expr><operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>n</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>newelems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newmaxlen</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newelems</name> <operator>=</operator> <operator>(</operator><name>ListCell</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>newmaxlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newelems</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newelems</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
			   <argument><expr><operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>n</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>!=</operator> <name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * As in enlarge_list(), clear the initial_elements[] space and/or
			 * mark it inaccessible.
			 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CLOBBER_FREED_MEMORY</name></cpp:ifdef>
			<expr_stmt><expr><call><name>wipe_mem</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr></argument>,
					 <argument><expr><name><name>list</name><operator>-&gt;</operator><name>max_length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr></argument>,
									   <argument><expr><name><name>list</name><operator>-&gt;</operator><name>max_length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>newelems</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>max_length</name></name> <operator>=</operator> <name>newmaxlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete 'cell' from 'list'.
 *
 * The List is pfree'd if this was the last member.  However, we do not
 * touch any data the cell might've been pointing to.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_delete_cell</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>list_delete_nth_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cell</name> <operator>-</operator> <name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete the first cell in list that matches datum, if any.
 * Equality is determined via equal().
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_delete</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>list_delete_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Didn't find a match: return the list unmodified */</comment>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* As above, but use simple pointer equality */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_delete_ptr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>datum</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>list_delete_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Didn't find a match: return the list unmodified */</comment>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* As above, but for integers */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_delete_int</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>datum</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>list_delete_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Didn't find a match: return the list unmodified */</comment>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* As above, but for OIDs */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_delete_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>datum</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>list_delete_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Didn't find a match: return the list unmodified */</comment>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete the first element of the list.
 *
 * This is useful to replace the Lisp-y code "list = lnext(list);" in cases
 * where the intent is to alter the list rather than just traverse it.
 * Beware that the list is modified, whereas the Lisp-y coding leaves
 * the original list head intact in case there's another pointer to it.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_delete_first</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* would an error be better? */</comment>

	<return>return <expr><call><name>list_delete_nth_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete the last element of the list.
 *
 * This is the opposite of list_delete_first(), but is noticeably cheaper
 * with a long list, since no data need be moved.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_delete_last</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* would an error be better? */</comment>

	<comment type="block">/* list_truncate won't free list if it goes to empty, but this should */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>list_truncate</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete the first N cells of the list.
 *
 * The List is pfree'd if the request causes all cells to be deleted.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_delete_first_n</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No-op request? */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>list</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Delete whole list? */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we normally just collapse out the removed elements.  But for
	 * debugging purposes, move the whole list contents someplace else.
	 *
	 * (Note that we *must* keep the contents in the same memory context.)
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG_LIST_MEMORY_USAGE</name></cpp:ifndef>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,
			<argument><expr><operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>n</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>newelems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newmaxlen</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>n</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newelems</name> <operator>=</operator> <operator>(</operator><name>ListCell</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>newmaxlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newelems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>newmaxlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>!=</operator> <name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * As in enlarge_list(), clear the initial_elements[] space and/or
			 * mark it inaccessible.
			 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CLOBBER_FREED_MEMORY</name></cpp:ifdef>
			<expr_stmt><expr><call><name>wipe_mem</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr></argument>,
					 <argument><expr><name><name>list</name><operator>-&gt;</operator><name>max_length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr></argument>,
									   <argument><expr><name><name>list</name><operator>-&gt;</operator><name>max_length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>newelems</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>max_length</name></name> <operator>=</operator> <name>newmaxlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>newmaxlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate the union of two lists. This is calculated by copying
 * list1 via list_copy(), then adding to it all the members of list2
 * that aren't already in list1.
 *
 * Whether an element is already a member of the list is determined
 * via equal().
 *
 * The returned list is newly-allocated, although the content of the
 * cells is the same (i.e. any pointed-to objects are not copied).
 *
 * NB: this function will NOT remove any duplicates that are present
 * in list1 (so it only performs a "union" if list1 is known unique to
 * start with).  Also, if you are about to write "x = list_union(x, y)"
 * you probably want to use list_concat_unique() instead to avoid wasting
 * the storage of the old x list.
 *
 * This function could probably be implemented a lot faster if it is a
 * performance bottleneck.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_union</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list2</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_union() determines duplicates via simple
 * pointer comparison.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_union_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list2</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_union() operates upon lists of integers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_union_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list2</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_union() operates upon lists of OIDs.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_union_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list2</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a list that contains all the cells that are in both list1 and
 * list2.  The returned list is freshly allocated via palloc(), but the
 * cells themselves point to the same objects as the cells of the
 * input lists.
 *
 * Duplicate entries in list1 will not be suppressed, so it's only a true
 * "intersection" if list1 is known unique beforehand.
 *
 * This variant works on lists of pointers, and determines list
 * membership via equal().  Note that the list1 member will be pointed
 * to in the result.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_intersection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>list1</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name>list2</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list1</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * As list_intersection but operates on lists of integers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_intersection_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>list1</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name>list2</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list1</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a list that contains all the cells in list1 that are not in
 * list2. The returned list is freshly allocated via palloc(), but the
 * cells themselves point to the same objects as the cells of the
 * input lists.
 *
 * This variant works on lists of pointers, and determines list
 * membership via equal()
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_difference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list2</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list1</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_difference() determines list membership via
 * simple pointer equality.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_difference_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list2</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list1</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_difference() operates upon lists of integers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_difference_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list2</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list1</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_difference() operates upon lists of OIDs.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_difference_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list2</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list1</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append datum to list, but only if it isn't already in the list.
 *
 * Whether an element is already a member of the list is determined
 * via equal().
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_append_unique</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>list</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>lappend</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_append_unique() determines list membership via
 * simple pointer equality.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_append_unique_ptr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>list</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>lappend</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_append_unique() operates upon lists of integers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_append_unique_int</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>list</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_append_unique() operates upon lists of OIDs.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_append_unique_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>list</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>lappend_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append to list1 each member of list2 that isn't already in list1.
 *
 * Whether an element is already a member of the list is determined
 * via equal().
 *
 * This is almost the same functionality as list_union(), but list1 is
 * modified in-place rather than being copied. However, callers of this
 * function may have strict ordering expectations -- i.e. that the relative
 * order of those list2 elements that are not duplicates is preserved.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_concat_unique</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list2</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>list1</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_concat_unique() determines list membership via
 * simple pointer equality.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_concat_unique_ptr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list2</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>list1</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_concat_unique() operates upon lists of integers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_concat_unique_int</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsIntegerList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list2</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>list1</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This variant of list_concat_unique() operates upon lists of OIDs.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_concat_unique_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list2</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>list1</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>list1</name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove adjacent duplicates in a list of OIDs.
 *
 * It is caller's responsibility to have sorted the list to bring duplicates
 * together, perhaps via list_sort(list, list_oid_cmp).
 */</comment>
<function><type><name>void</name></type>
<name>list_deduplicate_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsOidList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>elements</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>elements</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oid_value</name> <operator>!=</operator> <name><name>elements</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>oid_value</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>elements</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name><operator>.</operator><name>oid_value</name> <operator>=</operator> <name><name>elements</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>oid_value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free all storage in a list, and optionally the pointed-to elements
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>list_free_private</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>deep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>deep</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name> <operator>!=</operator> <name><name>list</name><operator>-&gt;</operator><name>initial_elements</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free all the cells of the list, as well as the list itself. Any
 * objects that are pointed-to by the cells of the list are NOT
 * free'd.
 *
 * On return, the argument to this function has been freed, so the
 * caller would be wise to set it to NIL for safety's sake.
 */</comment>
<function><type><name>void</name></type>
<name>list_free</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>list_free_private</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free all the cells of the list, the list itself, and all the
 * objects pointed-to by the cells of the list (each element in the
 * list must contain a pointer to a palloc()'d region of memory!)
 *
 * On return, the argument to this function has been freed, so the
 * caller would be wise to set it to NIL for safety's sake.
 */</comment>
<function><type><name>void</name></type>
<name>list_free_deep</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * A "deep" free operation only makes sense on a list of pointers.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free_private</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a shallow copy of the specified list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>oldlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newlist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name><name>oldlist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>oldlist</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newlist</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name><name>oldlist</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>,
		   <argument><expr><name><name>newlist</name><operator>-&gt;</operator><name>length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a shallow copy of the specified list, without the first N elements.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_copy_tail</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>oldlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nskip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newlist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nskip</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nskip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>				<comment type="block">/* would it be better to elog? */</comment>

	<if_stmt><if>if <condition>(<expr><name>oldlist</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name>nskip</name> <operator>&gt;=</operator> <name><name>oldlist</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name><name>oldlist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>oldlist</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>nskip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newlist</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldlist</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>nskip</name></expr>]</index></name></expr></argument>,
		   <argument><expr><name><name>newlist</name><operator>-&gt;</operator><name>length</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a deep copy of the specified list.
 *
 * The list elements are copied via copyObject(), so that this function's
 * idea of a "deep" copy is considerably deeper than what list_free_deep()
 * means by the same word.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>list_copy_deep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>oldlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newlist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* This is only sensible for pointer Lists */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>oldlist</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name><name>oldlist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>oldlist</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newlist</name><operator>-&gt;</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newlist</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator>
			<call><name>copyObjectImpl</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldlist</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort a list according to the specified comparator function.
 *
 * The list is sorted in-place.
 *
 * The comparator function is declared to receive arguments of type
 * const ListCell *; this allows it to use lfirst() and variants
 * without casting its arguments.  Otherwise it behaves the same as
 * the comparator function for standard qsort().
 *
 * Like qsort(), this provides no guarantees about sort stability
 * for equal keys.
 */</comment>
<function><type><name>void</name></type>
<name>list_sort</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>list_sort_comparator</name></type> <name>cmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>qsort_comparator</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing to do if there's less than two elements */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>qsort_comparator</name><operator>)</operator> <name>cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * list_sort comparator for sorting a list into ascending OID order.
 */</comment>
<function><type><name>int</name></type>
<name>list_oid_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>v1</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>v2</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>&lt;</operator> <name>v2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>&gt;</operator> <name>v2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
