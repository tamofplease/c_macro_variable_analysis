<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/nodes/bitmapset.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * bitmapset.c
 *	  PostgreSQL generic bitmap set package
 *
 * A bitmap set can represent any set of nonnegative integers, although
 * it is mainly intended for sets where the maximum value is not large,
 * say at most a few hundred.  By convention, a NULL pointer is always
 * accepted by all operations to represent the empty set.  (But beware
 * that this is not the only representation of the empty set.  Use
 * bms_is_empty() in preference to testing for NULL.)
 *
 *
 * Copyright (c) 2003-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/nodes/bitmapset.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/bitmapset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bitutils.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORDNUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((x) / BITS_PER_BITMAPWORD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITNUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((x) % BITS_PER_BITMAPWORD)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITMAPSET_SIZE</name><parameter_list>(<parameter><type><name>nwords</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>(offsetof(Bitmapset, words) + (nwords) * sizeof(bitmapword))</cpp:value></cpp:define>

<comment type="block">/*----------
 * This is a well-known cute trick for isolating the rightmost one-bit
 * in a word.  It assumes two's complement arithmetic.  Consider any
 * nonzero value, and focus attention on the rightmost one.  The value is
 * then something like
 *				xxxxxx10000
 * where x's are unspecified bits.  The two's complement negative is formed
 * by inverting all the bits and adding one.  Inversion gives
 *				yyyyyy01111
 * where each y is the inverse of the corresponding x.  Incrementing gives
 *				yyyyyy10000
 * and then ANDing with the original value gives
 *				00000010000
 * This works for all cases except original value = zero, where of course
 * we get zero.
 *----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHTMOST_ONE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((signedbitmapword) (x) &amp; -((signedbitmapword) (x)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_MULTIPLE_ONES</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((bitmapword) RIGHTMOST_ONE(x) != (x))</cpp:value></cpp:define>

<comment type="block">/* Select appropriate bit-twiddling functions for bitmap word size */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BITS_PER_BITMAPWORD</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bmw_leftmost_one_pos</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>pg_leftmost_one_pos32(w)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bmw_rightmost_one_pos</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>pg_rightmost_one_pos32(w)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bmw_popcount</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro>				<cpp:value>pg_popcount32(w)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>BITS_PER_BITMAPWORD</name> <operator>==</operator> <literal type="number">64</literal></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bmw_leftmost_one_pos</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>pg_leftmost_one_pos64(w)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bmw_rightmost_one_pos</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>pg_rightmost_one_pos64(w)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bmw_popcount</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro>				<cpp:value>pg_popcount64(w)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"invalid BITS_PER_BITMAPWORD"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * bms_copy - make a palloc'd copy of a bitmapset
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>BITMAPSET_SIZE</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_equal - are two bitmapsets equal?
 *
 * This is logical not physical equality; in particular, a NULL pointer will
 * be reported as equal to a palloc'd value containing no members.
 */</comment>
<function><type><name>bool</name></type>
<name>bms_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>shorter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>longer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>shortlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>longlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Identify shorter and longer input */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&lt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shorter</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>longer</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>shorter</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>longer</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* And process */</comment>
	<expr_stmt><expr><name>shortlen</name> <operator>=</operator> <name><name>shorter</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shortlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>shorter</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>longer</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>longlen</name> <operator>=</operator> <name><name>longer</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>longlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>longer</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_compare - qsort-style comparator for bitmapsets
 *
 * This guarantees to report values as equal iff bms_equal would say they are
 * equal.  Otherwise, the highest-numbered bit that is set in one value but
 * not the other determines the result.  (This rule means that, for example,
 * {6} is greater than {5}, which seems plausible.)
 */</comment>
<function><type><name>int</name></type>
<name>bms_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>shortlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Handle cases where one input is longer than the other */</comment>
	<expr_stmt><expr><name>shortlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>shortlen</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>shortlen</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Process words in common */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>shortlen</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>aw</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>bw</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>aw</name> <operator>!=</operator> <name>bw</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><operator>(</operator><name>aw</name> <operator>&gt;</operator> <name>bw</name><operator>)</operator></expr> ?</condition><then> <expr><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_make_singleton - build a bitmapset containing a single member
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_make_singleton</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>,
				<decl><type ref="prev"/><name>bitnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"negative bitmapset member not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>BITMAPSET_SIZE</name><argument_list>(<argument><expr><name>wordnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <name>wordnum</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_free - free a bitmapset
 *
 * Same as pfree except for allowing NULL input
 */</comment>
<function><type><name>void</name></type>
<name>bms_free</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>a</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * These operations all make a freshly palloc'd result,
 * leaving their inputs untouched
 */</comment>


<comment type="block">/*
 * bms_union - set union
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_union</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>otherlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Identify shorter and longer input; copy the longer one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&lt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>other</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>other</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* And union the shorter input into the result */</comment>
	<expr_stmt><expr><name>otherlen</name> <operator>=</operator> <name><name>other</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>otherlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>other</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_intersect - set intersection
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_intersect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resultlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Identify shorter and longer input; copy the shorter one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&lt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>other</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>other</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* And intersect the longer input with the result */</comment>
	<expr_stmt><expr><name>resultlen</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>resultlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;=</operator> <name><name>other</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_difference - set difference (ie, A without members of B)
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_difference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>shortlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Copy the left input */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And remove b's bits from result */</comment>
	<expr_stmt><expr><name>shortlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shortlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_is_subset - is A a subset of B?
 */</comment>
<function><type><name>bool</name></type>
<name>bms_is_subset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>shortlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>longlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* empty set is a subset of anything */</comment>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Check common words */</comment>
	<expr_stmt><expr><name>shortlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shortlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Check extra words */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>longlen</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>longlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_subset_compare - compare A and B for equality/subset relationships
 *
 * This is more efficient than testing bms_is_subset in both directions.
 */</comment>
<function><type><name>BMS_Comparison</name></type>
<name>bms_subset_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMS_Comparison</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>shortlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>longlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>BMS_EQUAL</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><ternary><condition><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>BMS_EQUAL</name></expr> </then><else>: <expr><name>BMS_SUBSET1</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>BMS_EQUAL</name></expr> </then><else>: <expr><name>BMS_SUBSET2</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Check common words */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>BMS_EQUAL</name></expr>;</expr_stmt>			<comment type="block">/* status so far */</comment>
	<expr_stmt><expr><name>shortlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shortlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>aword</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>bword</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aword</name> <operator>&amp;</operator> <operator>~</operator><name>bword</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* a is not a subset of b */</comment>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BMS_SUBSET1</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>BMS_DIFFERENT</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>BMS_SUBSET2</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bword</name> <operator>&amp;</operator> <operator>~</operator><name>aword</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* b is not a subset of a */</comment>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BMS_SUBSET2</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>BMS_DIFFERENT</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>BMS_SUBSET1</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Check extra words */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>longlen</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>longlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* a is not a subset of b */</comment>
				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BMS_SUBSET1</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>BMS_DIFFERENT</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>BMS_SUBSET2</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>longlen</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>longlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* b is not a subset of a */</comment>
				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>BMS_SUBSET2</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>BMS_DIFFERENT</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>BMS_SUBSET1</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_is_member - is X a member of A?
 */</comment>
<function><type><name>bool</name></type>
<name>bms_is_member</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>,
				<decl><type ref="prev"/><name>bitnum</name></decl>;</decl_stmt>

	<comment type="block">/* XXX better to just return false for x&lt;0 ? */</comment>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"negative bitmapset member not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>wordnum</name> <operator>&gt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_member_index
 *		determine 0-based index of member x in the bitmap
 *
 * Returns (-1) when x is not a member.
 */</comment>
<function><type><name>int</name></type>
<name>bms_member_index</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bitmapword</name></type>	<name>mask</name></decl>;</decl_stmt>

	<comment type="block">/* return -1 if not a member of the bitmap */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* count bits in preceding words */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>wordnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* No need to count the bits in a zero word */</comment>
		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>bmw_popcount</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now add bits of the last word, but only those before the item. We can
	 * do that by applying a mask and then using popcount again. To get
	 * 0-based index, we want to count only preceding bits, not the item
	 * itself, so we subtract 1.
	 */</comment>
	<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>bmw_popcount</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_overlap - do sets overlap (ie, have a nonempty intersection)?
 */</comment>
<function><type><name>bool</name></type>
<name>bms_overlap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>shortlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Check words in common */</comment>
	<expr_stmt><expr><name>shortlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shortlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_overlap_list - does a set overlap an integer list?
 */</comment>
<function><type><name>bool</name></type>
<name>bms_overlap_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>,
				<decl><type ref="prev"/><name>bitnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>b</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>b</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>x</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"negative bitmapset member not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>wordnum</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_nonempty_difference - do sets have a nonempty difference?
 */</comment>
<function><type><name>bool</name></type>
<name>bms_nonempty_difference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>shortlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Check words in common */</comment>
	<expr_stmt><expr><name>shortlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shortlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Check extra words in a */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_singleton_member - return the sole integer member of set
 *
 * Raises error if |a| is not 1.
 */</comment>
<function><type><name>int</name></type>
<name>bms_singleton_member</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bitmapset is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nwords</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>HAS_MULTIPLE_ONES</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bitmapset has multiple members"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>wordnum</name> <operator>*</operator> <name>BITS_PER_BITMAPWORD</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>bmw_rightmost_one_pos</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bitmapset is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_get_singleton_member
 *
 * Test whether the given set is a singleton.
 * If so, set *member to the value of its sole member, and return true.
 * If not, return false, without changing *member.
 *
 * This is more convenient and faster than calling bms_membership() and then
 * bms_singleton_member(), if we don't care about distinguishing empty sets
 * from multiple-member sets.
 */</comment>
<function><type><name>bool</name></type>
<name>bms_get_singleton_member</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>member</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nwords</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>HAS_MULTIPLE_ONES</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>wordnum</name> <operator>*</operator> <name>BITS_PER_BITMAPWORD</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>bmw_rightmost_one_pos</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>member</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_num_members - count members of set
 */</comment>
<function><type><name>int</name></type>
<name>bms_num_members</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nwords</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* No need to count the bits in a zero word */</comment>
		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>bmw_popcount</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_membership - does a set have zero, one, or multiple members?
 *
 * This is faster than making an exact count with bms_num_members().
 */</comment>
<function><type><name>BMS_Membership</name></type>
<name>bms_membership</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMS_Membership</name></type> <name>result</name> <init>= <expr><name>BMS_EMPTY_SET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>BMS_EMPTY_SET</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nwords</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>BMS_EMPTY_SET</name> <operator>||</operator> <call><name>HAS_MULTIPLE_ONES</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>BMS_MULTIPLE</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>BMS_SINGLETON</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_is_empty - is a set empty?
 *
 * This is even faster than bms_membership().
 */</comment>
<function><type><name>bool</name></type>
<name>bms_is_empty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nwords</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * These operations all "recycle" their non-const inputs, ie, either
 * return the modified input or pfree it if it can't hold the result.
 *
 * These should generally be used in the style
 *
 *		foo = bms_add_member(foo, x);
 */</comment>


<comment type="block">/*
 * bms_add_member - add a specified member to set
 *
 * Input set is modified or recycled!
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_add_member</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>,
				<decl><type ref="prev"/><name>bitnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"negative bitmapset member not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* enlarge the set if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name>wordnum</name> <operator>&gt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>oldnwords</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>BITMAPSET_SIZE</name><argument_list>(<argument><expr><name>wordnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <name>wordnum</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<comment type="block">/* zero out the enlarged portion */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>oldnwords</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_del_member - remove a specified member from set
 *
 * No error if x is not currently a member of set
 *
 * Input set is modified in-place!
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_del_member</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>,
				<decl><type ref="prev"/><name>bitnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"negative bitmapset member not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>wordnum</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_add_members - like bms_union, but left input is recycled
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_add_members</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>otherlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Identify shorter and longer input; copy the longer one if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>other</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>other</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* And union the shorter input into the result */</comment>
	<expr_stmt><expr><name>otherlen</name> <operator>=</operator> <name><name>other</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>otherlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>other</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>a</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_add_range
 *		Add members in the range of 'lower' to 'upper' to the set.
 *
 * Note this could also be done by calling bms_add_member in a loop, however,
 * using this function will be faster when the range is large as we work at
 * the bitmapword level rather than at bit level.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_add_range</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>upper</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lwordnum</name></decl>,
				<decl><type ref="prev"/><name>lbitnum</name></decl>,
				<decl><type ref="prev"/><name>uwordnum</name></decl>,
				<decl><type ref="prev"/><name>ushiftbits</name></decl>,
				<decl><type ref="prev"/><name>wordnum</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing if nothing is called for, without further checking */</comment>
	<if_stmt><if>if <condition>(<expr><name>upper</name> <operator>&lt;</operator> <name>lower</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>lower</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"negative bitmapset member not allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>uwordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>BITMAPSET_SIZE</name><argument_list>(<argument><expr><name>uwordnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <name>uwordnum</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>uwordnum</name> <operator>&gt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>oldnwords</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* ensure we have enough words to store the upper bit */</comment>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>BITMAPSET_SIZE</name><argument_list>(<argument><expr><name>uwordnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <name>uwordnum</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<comment type="block">/* zero out the enlarged portion */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>oldnwords</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <name>lwordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>lower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lbitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>lower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ushiftbits</name> <operator>=</operator> <name>BITS_PER_BITMAPWORD</name> <operator>-</operator> <operator>(</operator><call><name>BITNUM</name><argument_list>(<argument><expr><name>upper</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Special case when lwordnum is the same as uwordnum we must perform the
	 * upper and lower masking on the word.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lwordnum</name> <operator>==</operator> <name>uwordnum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>lwordnum</name></expr>]</index></name> <operator>|=</operator> <operator>~</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>lbitnum</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator>
			<operator>&amp;</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>ushiftbits</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* turn on lbitnum and all bits left of it */</comment>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name><operator>++</operator></expr>]</index></name> <operator>|=</operator> <operator>~</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>lbitnum</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* turn on all bits for any intermediate words */</comment>
		<while>while <condition>(<expr><name>wordnum</name> <operator>&lt;</operator> <name>uwordnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* turn on upper's bit and all bits right of it. */</comment>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>uwordnum</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>ushiftbits</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_int_members - like bms_intersect, but left input is recycled
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_int_members</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>shortlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Intersect b into a; we need never copy */</comment>
	<expr_stmt><expr><name>shortlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shortlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;=</operator> <name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_del_members - like bms_difference, but left input is recycled
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_del_members</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>shortlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Remove b's bits from a; we need never copy */</comment>
	<expr_stmt><expr><name>shortlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shortlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name><name>b</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_join - like bms_union, but *both* inputs are recycled
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>bms_join</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>otherlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Handle cases where either input is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>b</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Identify shorter and longer input; use longer one as result */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>nwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>other</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>other</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* And union the shorter input into the result */</comment>
	<expr_stmt><expr><name>otherlen</name> <operator>=</operator> <name><name>other</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>otherlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>other</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>other</name> <operator>!=</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* pure paranoia */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_first_member - find and remove first member of a set
 *
 * Returns -1 if set is empty.  NB: set is destructively modified!
 *
 * This is intended as support for iterating through the members of a set.
 * The typical pattern is
 *
 *			while ((x = bms_first_member(inputset)) &gt;= 0)
 *				process member x;
 *
 * CAUTION: this destroys the content of "inputset".  If the set must
 * not be modified, use bms_next_member instead.
 */</comment>
<function><type><name>int</name></type>
<name>bms_first_member</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nwords</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>RIGHTMOST_ONE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>w</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>wordnum</name> <operator>*</operator> <name>BITS_PER_BITMAPWORD</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>bmw_rightmost_one_pos</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_next_member - find next member of a set
 *
 * Returns smallest member greater than "prevbit", or -2 if there is none.
 * "prevbit" must NOT be less than -1, or the behavior is unpredictable.
 *
 * This is intended as support for iterating through the members of a set.
 * The typical pattern is
 *
 *			x = -1;
 *			while ((x = bms_next_member(inputset, x)) &gt;= 0)
 *				process member x;
 *
 * Notice that when there are no more members, we return -2, not -1 as you
 * might expect.  The rationale for that is to allow distinguishing the
 * loop-not-started state (x == -1) from the loop-completed state (x == -2).
 * It makes no difference in simple loop usage, but complex iteration logic
 * might need such an ability.
 */</comment>
<function><type><name>int</name></type>
<name>bms_next_member</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prevbit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bitmapword</name></type>	<name>mask</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nwords</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prevbit</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator> <operator>&lt;&lt;</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>prevbit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>prevbit</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ignore bits before prevbit */</comment>
		<expr_stmt><expr><name>w</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>wordnum</name> <operator>*</operator> <name>BITS_PER_BITMAPWORD</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>bmw_rightmost_one_pos</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* in subsequent words, consider all bits */</comment>
		<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_prev_member - find prev member of a set
 *
 * Returns largest member less than "prevbit", or -2 if there is none.
 * "prevbit" must NOT be more than one above the highest possible bit that can
 * be set at the Bitmapset at its current size.
 *
 * To ease finding the highest set bit for the initial loop, the special
 * prevbit value of -1 can be passed to have the function find the highest
 * valued member in the set.
 *
 * This is intended as support for iterating through the members of a set in
 * reverse.  The typical pattern is
 *
 *			x = -1;
 *			while ((x = bms_prev_member(inputset, x)) &gt;= 0)
 *				process member x;
 *
 * Notice that when there are no more members, we return -2, not -1 as you
 * might expect.  The rationale for that is to allow distinguishing the
 * loop-not-started state (x == -1) from the loop-completed state (x == -2).
 * It makes no difference in simple loop usage, but complex iteration logic
 * might need such an ability.
 */</comment>

<function><type><name>int</name></type>
<name>bms_prev_member</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prevbit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ushiftbits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bitmapword</name></type>	<name>mask</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If set is NULL or if there are no more bits to the right then we've
	 * nothing to do.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>prevbit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* transform -1 to the highest possible bit we could have set */</comment>
	<if_stmt><if>if <condition>(<expr><name>prevbit</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prevbit</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name> <operator>*</operator> <name>BITS_PER_BITMAPWORD</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>prevbit</name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>ushiftbits</name> <operator>=</operator> <name>BITS_PER_BITMAPWORD</name> <operator>-</operator> <operator>(</operator><call><name>BITNUM</name><argument_list>(<argument><expr><name>prevbit</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>ushiftbits</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>prevbit</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>wordnum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>wordnum</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* mask out bits left of prevbit */</comment>
		<expr_stmt><expr><name>w</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>wordnum</name> <operator>*</operator> <name>BITS_PER_BITMAPWORD</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>bmw_leftmost_one_pos</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* in subsequent words, consider all bits */</comment>
		<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><name>bitmapword</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bms_hash_value - compute a hash key for a Bitmapset
 *
 * Note: we must ensure that any two bitmapsets that are bms_equal() will
 * hash to the same value; in practice this means that trailing all-zero
 * words must not affect the result.  Hence we strip those before applying
 * hash_any().
 */</comment>
<function><type><name>uint32</name></type>
<name>bms_hash_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lastword</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* All empty sets hash to 0 */</comment>
	<for>for <control>(<init><expr><name>lastword</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</init> <condition><expr><operator>--</operator><name>lastword</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>lastword</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>lastword</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* All empty sets hash to 0 */</comment>
	<return>return <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>words</name></name></expr></argument>,
								   <argument><expr><operator>(</operator><name>lastword</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bitmapword</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bitmap_hash - hash function for keys that are (pointers to) Bitmapsets
 *
 * Note: don't forget to specify bitmap_match as the match function!
 */</comment>
<function><type><name>uint32</name></type>
<name>bitmap_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>bms_hash_value</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Bitmapset</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>key</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bitmap_match - match function to use with bitmap_hash
 */</comment>
<function><type><name>int</name></type>
<name>bitmap_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Bitmapset</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>key1</name><operator>)</operator></expr></argument>,
					  <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Bitmapset</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>key2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
