<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/nodes/nodeFuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeFuncs.c
 *		Various general-purpose manipulations of Node trees
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/nodes/nodeFuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/graphnodes.h"</cpp:file></cpp:include>

<comment type="block">/* Ignore deprecated-non-prototype warnings. */</comment>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>clang</name> <name>diagnostic</name> <name>push</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>clang</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wdeprecated-non-prototype"</cpp:literal></cpp:pragma>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>expression_returns_set_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>leftmostLoc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>loc1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>loc2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>fix_opfuncids_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>planstate_walk_subplans</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plans</name></decl></parameter>, <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
									<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>planstate_walk_members</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>planstates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nplans</name></decl></parameter>,
								   <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	exprType -
 *	  returns the Oid of the type of the expression's result.
 */</comment>
<function><type><name>Oid</name></type>
<name>exprType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>type</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>vartype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>consttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Param</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>paramtype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Aggref</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>aggtype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>wintype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* slice and/or store operations yield the container type */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>sbsref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name> <operator>||</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refcontainertype</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refelemtype</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>funcresulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opresulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opresulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opresulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>SubLink</name> <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SubLink</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
					<name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* get the type of the subselect's first target column */</comment>
					<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qtree</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>qtree</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qtree</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot get type for untransformed sublink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>tent</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>qtree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_promoted_array_type</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
											<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* MULTIEXPR is always considered to return RECORD */</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* for all other sublink types, result is boolean */</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
					<name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* get the type of the subselect's first target column */</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>firstColType</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_promoted_array_type</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
											<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* MULTIEXPR is always considered to return RECORD */</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* for all other subplan types, result is boolean */</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* subplans should all return the same thing */</comment>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>casetype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CaseTestExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>typeId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>array_typeid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>row_typeid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>coalescetype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>minmaxtype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>type</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>op</name> <operator>==</operator> <name>IS_DOCUMENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>op</name> <operator>==</operator> <name>IS_XMLSERIALIZE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <name>XMLOID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttype</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoerceToDomainValue</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>typeId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SetToDefault</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>typeId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>NextValueExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>typeId</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>InferenceElem</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>InferenceElem</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>phexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherTypeCast</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CypherTypeCast</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>type</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompVar</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherAccessExpr</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>type</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	exprTypmod -
 *	  returns the type-specific modifier of the expression's result type,
 *	  if it can be determined.  In many cases, it can't and we return -1.
 */</comment>
<function><type><name>int32</name></type>
<name>exprTypmod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>vartypmod</name></expr>;</return>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>consttypmod</name></expr>;</return>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Param</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>paramtypmod</name></expr>;</return>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<comment type="block">/* typmod is the same for container or element */</comment>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>reftypmod</name></expr>;</return>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32</name></type>		<name>coercedTypmod</name></decl>;</decl_stmt>

				<comment type="block">/* Be smart about length-coercion functions... */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>exprIsLengthCoercion</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coercedTypmod</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>coercedTypmod</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<return>return <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Result is either first argument or NULL, so we can report
				 * first argument's typmod if known.
				 */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>NullIfExpr</name> <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>nexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>SubLink</name> <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SubLink</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
					<name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* get the typmod of the subselect's first target column */</comment>
					<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qtree</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>qtree</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qtree</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot get type for untransformed sublink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>tent</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>qtree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</return>
					<comment type="block">/* note we don't need to care if it's an array */</comment>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* otherwise, result is RECORD or BOOLEAN, typmod is -1 */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
					<name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* get the typmod of the subselect's first target column */</comment>
					<comment type="block">/* note we don't need to care if it's an array */</comment>
					<return>return <expr><name><name>subplan</name><operator>-&gt;</operator><name>firstColTypmod</name></name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* otherwise, result is RECORD or BOOLEAN, typmod is -1 */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* subplans should all return the same thing */</comment>
				<return>return <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttypmod</name></expr>;</return>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttypmod</name></expr>;</return>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttypmod</name></expr>;</return>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<return>return <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If all the alternatives agree on type/typmod, return that
				 * typmod, else use -1
				 */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>CaseExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>casetype</name> <init>= <expr><name><name>cexpr</name><operator>-&gt;</operator><name>casetype</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>casetype</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no point in trying harder */</comment>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>cexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>w</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>casetype</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>typmod</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
				<return>return <expr><name>typmod</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CaseTestExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>typeMod</name></expr>;</return>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If all the elements agree on type/typmod, return that
				 * typmod, else use -1
				 */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>ArrayExpr</name> <modifier>*</modifier></type><name>arrayexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>commontype</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no point in trying harder */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>multidims</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>commontype</name> <operator>=</operator> <name><name>arrayexpr</name><operator>-&gt;</operator><name>array_typeid</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>commontype</name> <operator>=</operator> <name><name>arrayexpr</name><operator>-&gt;</operator><name>element_typeid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<macro><name>foreach</name><argument_list>(<argument>elem</argument>, <argument>arrayexpr-&gt;elements</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>commontype</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>typmod</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
				<return>return <expr><name>typmod</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If all the alternatives agree on type/typmod, return that
				 * typmod, else use -1
				 */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>CoalesceExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>coalescetype</name> <init>= <expr><name><name>cexpr</name><operator>-&gt;</operator><name>coalescetype</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>coalescetype</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no point in trying harder */</comment>
				<macro><name>for_each_from</name><argument_list>(<argument>arg</argument>, <argument>cexpr-&gt;args</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>coalescetype</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>typmod</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
				<return>return <expr><name>typmod</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If all the alternatives agree on type/typmod, return that
				 * typmod, else use -1
				 */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>MinMaxExpr</name> <modifier>*</modifier></type><name>mexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>minmaxtype</name> <init>= <expr><name><name>mexpr</name><operator>-&gt;</operator><name>minmaxtype</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>mexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>minmaxtype</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>mexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no point in trying harder */</comment>
				<macro><name>for_each_from</name><argument_list>(<argument>arg</argument>, <argument>mexpr-&gt;args</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>minmaxtype</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>typmod</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
				<return>return <expr><name>typmod</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>typmod</name></expr>;</return>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttypmod</name></expr>;</return>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoerceToDomainValue</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>typeMod</name></expr>;</return>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SetToDefault</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>typeMod</name></expr>;</return>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
			<return>return <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>phexpr</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CypherTypeCast</name></expr>:</case>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>T_CypherListCompExpr</name></expr>:</case>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>T_CypherListCompVar</name></expr>:</case>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>T_CypherAccessExpr</name></expr>:</case>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exprIsLengthCoercion
 *		Detect whether an expression tree is an application of a datatype's
 *		typmod-coercion function.  Optionally extract the result's typmod.
 *
 * If coercedTypmod is not NULL, the typmod is stored there if the expression
 * is a length-coercion function, else -1 is stored there.
 *
 * Note that a combined type-and-length coercion will be treated as a
 * length coercion by this routine.
 */</comment>
<function><type><name>bool</name></type>
<name>exprIsLengthCoercion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>coercedTypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>coercedTypmod</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>coercedTypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* default result on failure */</comment>

	<comment type="block">/*
	 * Scalar-type length coercions are FuncExprs, array-type length coercions
	 * are ArrayCoerceExprs
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>FuncExpr</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>second_arg</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If it didn't come from a coercion context, reject.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>!=</operator> <name>COERCE_EXPLICIT_CAST</name> <operator>&amp;&amp;</operator>
			<name><name>func</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it's not a two-argument or three-argument function with the
		 * second argument being an int4 constant, it can't have been created
		 * from a length coercion (it must be a type coercion, instead).
		 */</comment>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>nargs</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>nargs</name></expr></argument> &gt;</argument_list></name> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>second_arg</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>second_arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>second_arg</name><operator>-&gt;</operator><name>consttype</name></name> <operator>!=</operator> <name>INT4OID</name> <operator>||</operator>
			<name><name>second_arg</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK, it is indeed a length-coercion function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>coercedTypmod</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>coercedTypmod</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>second_arg</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* It's not a length coercion unless there's a nondefault typmod */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK, it is indeed a length-coercion expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>coercedTypmod</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>coercedTypmod</name> <operator>=</operator> <name><name>acoerce</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * applyRelabelType
 *		Add a RelabelType node if needed to make the expression expose
 *		the specified type, typmod, and collation.
 *
 * This is primarily intended to be used during planning.  Therefore, it must
 * maintain the post-eval_const_expressions invariants that there are not
 * adjacent RelabelTypes, and that the tree is fully const-folded (hence,
 * we mustn't return a RelabelType atop a Const).  If we do find a Const,
 * we'll modify it in-place if "overwrite_ok" is true; that should only be
 * passed as true if caller knows the Const is newly generated.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>applyRelabelType</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>rtypmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rcollid</name></decl></parameter>,
				 <parameter><decl><type><name>CoercionForm</name></type> <name>rformat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rlocation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>overwrite_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we find stacked RelabelTypes (eg, from foo::int::oid) we can discard
	 * all but the top one, and must do so to ensure that semantically
	 * equivalent expressions are equal().
	 */</comment>
	<while>while <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Modify the Const directly to preserve const-flatness. */</comment>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>overwrite_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>rtype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>=</operator> <name>rtypmod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>=</operator> <name>rcollid</name></expr>;</expr_stmt>
		<comment type="block">/* We keep the Const's original location. */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>con</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rtype</name> <operator>&amp;&amp;</operator>
			 <call><name>exprTypmod</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rtypmod</name> <operator>&amp;&amp;</operator>
			 <call><name>exprCollation</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rcollid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Sometimes we find a nest of relabels that net out to nothing. */</comment>
		<return>return <expr><name>arg</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Nope, gotta have a RelabelType. */</comment>
		<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>newrelabel</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>rtype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name>rtypmod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name>rcollid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>=</operator> <name>rformat</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrelabel</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>rlocation</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newrelabel</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * relabel_to_typmod
 *		Add a RelabelType node that changes just the typmod of the expression.
 *
 * Convenience function for a common usage of applyRelabelType.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>relabel_to_typmod</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>applyRelabelType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * strip_implicit_coercions: remove implicit coercions at top level of tree
 *
 * This doesn't modify or copy the input expression tree, just return a
 * pointer to a suitable place within it.
 *
 * Note: there isn't any useful thing we can do with a RowExpr here, so
 * just return it unchanged, even if it's marked as an implicit coercion.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>strip_implicit_coercions</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * expression_returns_set
 *	  Test whether an expression returns a set result.
 *
 * Because we use expression_tree_walker(), this can also be applied to
 * whole targetlists; it'll produce true if any one of the tlist items
 * returns a set.
 */</comment>
<function><type><name>bool</name></type>
<name>expression_returns_set</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>expression_returns_set_walker</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>expression_returns_set_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>funcretset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* else fall through to check args */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* else fall through to check args */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If you add any more cases that return sets, also fix
	 * expression_returns_set_rows() in clauses.c and IS_SRF_CALL() in
	 * tlist.c.
	 */</comment>

	<comment type="block">/* Avoid recursion for some cases that parser checks not to return a set */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>expression_returns_set_walker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	exprCollation -
 *	  returns the Oid of the collation of the expression's result.
 *
 * Note: expression nodes that can invoke functions generally have an
 * "inputcollid" field, which is what the function should use as collation.
 * That is the resolved common collation of the node's inputs.  It is often
 * but not always the same as the result collation; in particular, if the
 * function produces a non-collatable result type from collatable inputs
 * or vice versa, the two are different.
 */</comment>
<function><type><name>Oid</name></type>
<name>exprCollation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>coll</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>constcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Param</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>paramcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Aggref</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>aggcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>wincollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>refcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>funccollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>SubLink</name> <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SubLink</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
					<name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* get the collation of subselect's first target column */</comment>
					<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qtree</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>qtree</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qtree</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot get collation for untransformed sublink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>tent</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>qtree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* collation doesn't change if it's converted to array */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* otherwise, result is RECORD or BOOLEAN */</comment>
					<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
					<name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* get the collation of subselect's first target column */</comment>
					<expr_stmt><expr><name>coll</name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>firstColCollation</name></name></expr>;</expr_stmt>
					<comment type="block">/* collation doesn't change if it's converted to array */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* otherwise, result is RECORD or BOOLEAN */</comment>
					<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* subplans should all return the same thing */</comment>
				<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always composite */</comment>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always composite */</comment>
			<break>break;</break>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>collOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>casecollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CaseTestExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>array_collid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always composite */</comment>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>coalescecollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>minmaxcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<comment type="block">/* Returns either NAME or a non-collatable type */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>NAMEOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>C_COLLATION_OID</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>

			<comment type="block">/*
			 * XMLSERIALIZE returns text from non-collatable inputs, so its
			 * collation is always default.  The other cases return boolean or
			 * XML, which are non-collatable.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>op</name> <operator>==</operator> <name>IS_XMLSERIALIZE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoerceToDomainValue</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SetToDefault</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* result is always an integer type */</comment>
			<break>break;</break>
		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>InferenceElem</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>phexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherTypeCast</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompVar</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherAccessExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>coll</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	exprInputCollation -
 *	  returns the Oid of the collation a function should use, if available.
 *
 * Result is InvalidOid if the node type doesn't store this information.
 */</comment>
<function><type><name>Oid</name></type>
<name>exprInputCollation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>coll</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Aggref</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>coll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>coll</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	exprSetCollation -
 *	  Assign collation information to an expression tree node.
 *
 * Note: since this is only used during parse analysis, we don't need to
 * worry about subplans or PlaceHolderVars.
 */</comment>
<function><type><name>void</name></type>
<name>exprSetCollation</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>constcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>paramcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>aggcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>wincollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>refcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>funccollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>collation</name> <operator>==</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>opcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
					<name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* get the collation of subselect's first target column */</comment>
					<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qtree</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>qtree</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qtree</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot set collation for untransformed sublink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>tent</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>qtree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>collation</name> <operator>==</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* otherwise, result is RECORD or BOOLEAN */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ASSERT_CHECKING */</comment>
			<break>break;</break>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always composite */</comment>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always composite */</comment>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>casecollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>array_collid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always composite */</comment>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>coalescecollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>minmaxcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>==</operator> <name>NAMEOID</name><operator>)</operator></expr> ?</condition><then>
				   <expr><operator>(</operator><name>collation</name> <operator>==</operator> <name>C_COLLATION_OID</name><operator>)</operator></expr> </then><else>:
				   <expr><operator>(</operator><name>collation</name> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>op</name> <operator>==</operator> <name>IS_XMLSERIALIZE</name><operator>)</operator></expr> ?</condition><then>
				   <expr><operator>(</operator><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name><operator>)</operator></expr> </then><else>:
				   <expr><operator>(</operator><name>collation</name> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>resultcollid</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>CoerceToDomainValue</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>collation</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>SetToDefault</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>collation</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always boolean */</comment>
			<break>break;</break>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* result is always an integer
											 * type */</comment>
			<break>break;</break>
		<case>case <expr><name>T_CypherTypeCast</name></expr>:</case>
			<comment type="block">/* XXX: Don't care for now */</comment>
			<break>break;</break>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompVar</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherAccessExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	exprSetInputCollation -
 *	  Assign input-collation information to an expression tree node.
 *
 * This is a no-op for node types that don't store their input collation.
 * Note we omit RowCompareExpr, which needs special treatment since it
 * contains multiple input collation OIDs.
 */</comment>
<function><type><name>void</name></type>
<name>exprSetInputCollation</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name> <operator>=</operator> <name>inputcollation</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 *	exprLocation -
 *	  returns the parse location of an expression tree, for error reports
 *
 * -1 is returned if the location can't be determined.
 *
 * For expressions larger than a single token, the intent here is to
 * return the location of the expression's leftmost token, not necessarily
 * the topmost Node's location field.  For example, an OpExpr's location
 * field will point at the operator name, but if it is not a prefix operator
 * then we should return the location of the left-hand operand instead.
 * The reason is that we want to reference the entire expression not just
 * that operator, and pointing to its start seems to be the most natural way.
 *
 * The location is not perfect --- for example, since the grammar doesn't
 * explicitly represent parentheses in the parsetree, given something that
 * had been written "(a + b) * c" we are going to point at "a" not "(".
 * But it should be plenty good enough for error reporting purposes.
 *
 * You might think that this code is overly general, for instance why check
 * the operands of a FuncExpr node, when the function name can be expected
 * to be to the left of them?  There are a couple of reasons.  The grammar
 * sometimes builds expressions that aren't quite what the user wrote;
 * for instance x IS NOT BETWEEN ... becomes a NOT-expression whose keyword
 * pointer is to the right of its leftmost argument.  Also, nodes that were
 * inserted implicitly by parse analysis (such as FuncExprs for implicit
 * coercions) will have location -1, and so we can have odd combinations of
 * known and unknown locations in a tree.
 */</comment>
<function><type><name>int</name></type>
<name>exprLocation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>loc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_RangeVar</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>RangeVar</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TableFunc</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>TableFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Param</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<comment type="block">/* function name should always be the first thing */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Aggref</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<comment type="block">/* function name should always be the first thing */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<comment type="block">/* just use container argument's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>refexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>FuncExpr</name> <modifier>*</modifier></type><name>fexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* consider both function name and leftmost arg */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>NamedArgExpr</name> <modifier>*</modifier></type><name>na</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* consider both argument name and value */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>na</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>na</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>	<comment type="block">/* struct-equivalent to OpExpr */</comment>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>		<comment type="block">/* struct-equivalent to OpExpr */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>OpExpr</name> <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* consider both operator name and leftmost arg */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saopexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* consider both operator name and leftmost arg */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>saopexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>BoolExpr</name> <modifier>*</modifier></type><name>bexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Same as above, to handle either NOT or AND/OR.  We can't
				 * special-case NOT because of the way that it's used for
				 * things like IS NOT BETWEEN.
				 */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>bexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>bexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>SubLink</name> <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SubLink</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* check the testexpr, if any, and the operator/keyword */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<comment type="block">/* just use argument's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<comment type="block">/* just use argument's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>RelabelType</name> <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Much as above */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>rexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>CoerceViaIO</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Much as above */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Much as above */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Much as above */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<comment type="block">/* just use argument's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<comment type="block">/* CASE keyword should always be the first thing */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CaseWhen</name></expr>:</case>
			<comment type="block">/* WHEN keyword should always be the first thing */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CaseWhen</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<comment type="block">/* the location points at ARRAY or [, which must be leftmost */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<comment type="block">/* the location points at ROW or (, which must be leftmost */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<comment type="block">/* just use leftmost argument's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>largs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<comment type="block">/* COALESCE keyword should always be the first thing */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<comment type="block">/* GREATEST/LEAST keyword should always be the first thing */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<comment type="block">/* function keyword should always be the first thing */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>XmlExpr</name> <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* consider both function name and leftmost arg */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>NullTest</name> <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>NullTest</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Much as above */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>nexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>BooleanTest</name> <modifier>*</modifier></type><name>bexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Much as above */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>bexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>bexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>CoerceToDomain</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Much as above */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CoerceToDomainValue</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SetToDefault</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TargetEntry</name></expr>:</case>
			<comment type="block">/* just use argument's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IntoClause</name></expr>:</case>
			<comment type="block">/* use the contained RangeVar's location --- close enough */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>IntoClause</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_List</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* report location of first list member that has a location */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* just to suppress compiler warning */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(const List *) expr</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_Expr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>A_Expr</name> <modifier>*</modifier></type><name>aexpr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* use leftmost of operator or left operand (if any) */</comment>
				<comment type="block">/* we assume right operand can't be to left of operator */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ColumnRef</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ParamRef</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ParamRef</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_A_Const</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>A_Const</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncCall</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>FuncCall</name> <modifier>*</modifier></type><name>fc</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>FuncCall</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* consider both function name and leftmost arg */</comment>
				<comment type="block">/* (we assume any ORDER BY nodes must be to right of name) */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>fc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
			<comment type="block">/* the location points at ARRAY or [, which must be leftmost */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>A_ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ResTarget</name></expr>:</case>
			<comment type="block">/* we need not examine the contained expression (if any) */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ResTarget</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MultiAssignRef</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>MultiAssignRef</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TypeCast</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>TypeCast</name> <modifier>*</modifier></type><name>tc</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * This could represent CAST(), ::, or TypeName 'literal', so
				 * any of the components might be leftmost.
				 */</comment>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><name><name>tc</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><name><name>tc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CollateClause</name></expr>:</case>
			<comment type="block">/* just use argument's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CollateClause</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortBy</name></expr>:</case>
			<comment type="block">/* just use argument's location (ignore operator, if any) */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>SortBy</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowDef</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>WindowDef</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeTableSample</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>RangeTableSample</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TypeName</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>TypeName</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ColumnDef</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Constraint</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Constraint</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FunctionParameter</name></expr>:</case>
			<comment type="block">/* just use typename's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>FunctionParameter</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>argType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_XmlSerialize</name></expr>:</case>
			<comment type="block">/* XMLSERIALIZE keyword should always be the first thing */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>XmlSerialize</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GroupingSet</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>GroupingSet</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WithClause</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>WithClause</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_InferClause</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>InferClause</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OnConflictClause</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>OnConflictClause</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
			<comment type="block">/* just use argument's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>phexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<comment type="block">/* just use nested expr's location */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>InferenceElem</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionElem</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PartitionElem</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionSpec</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PartitionSpec</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionBoundSpec</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PartitionBoundSpec</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionRangeDatum</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PartitionRangeDatum</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherTypeCast</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>CypherTypeCast</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>CypherMapExpr</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CypherMapExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>CypherListExpr</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>CypherListExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>leftmostLoc</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
								  <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cl</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompExpr</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CypherListCompExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompVar</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CypherListCompVar</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CypherAccessExpr</name></expr>:</case>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CypherAccessExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* for any other node type it's just unknown... */</comment>
			<expr_stmt><expr><name>loc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>loc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * leftmostLoc - support for exprLocation
 *
 * Take the minimum of two parse location values, but ignore unknowns
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>leftmostLoc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>loc1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>loc2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>loc1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>loc2</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>loc2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>loc1</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>Min</name><argument_list>(<argument><expr><name>loc1</name></expr></argument>, <argument><expr><name>loc2</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * fix_opfuncids
 *	  Calculate opfuncid field from opno for each OpExpr node in given tree.
 *	  The given tree can be anything expression_tree_walker handles.
 *
 * The argument is modified in-place.  (This is OK since we'd want the
 * same change for any node, even if it gets visited more than once due to
 * shared structure.)
 */</comment>
<function><type><name>void</name></type>
<name>fix_opfuncids</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This tree walk requires no special setup, so away we go... */</comment>
	<expr_stmt><expr><call><name>fix_opfuncids_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fix_opfuncids_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* rely on struct equivalence */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* rely on struct equivalence */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_sa_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fix_opfuncids_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_opfuncid
 *		Set the opfuncid (procedure OID) in an OpExpr node,
 *		if it hasn't been set already.
 *
 * Because of struct equivalence, this can also be used for
 * DistinctExpr and NullIfExpr nodes.
 */</comment>
<function><type><name>void</name></type>
<name>set_opfuncid</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_sa_opfuncid
 *		As above, for ScalarArrayOpExpr nodes.
 */</comment>
<function><type><name>void</name></type>
<name>set_sa_opfuncid</name><parameter_list>(<parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>opexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	check_functions_in_node -
 *	  apply checker() to each function OID contained in given expression node
 *
 * Returns true if the checker() function does; for nodes representing more
 * than one function call, returns true if the checker() function does so
 * for any of those functions.  Returns false if node does not invoke any
 * SQL-visible function.  Caller must not pass node == NULL.
 *
 * This function examines only the given node; it does not recurse into any
 * sub-expressions.  Callers typically prefer to keep control of the recursion
 * for themselves, in case additional checks should be made, or because they
 * have special rules about which parts of the tree need to be visited.
 *
 * Note: we ignore MinMaxExpr, SQLValueFunction, XmlExpr, CoerceToDomain,
 * and NextValueExpr nodes, because they do not contain SQL function OIDs.
 * However, they can invoke SQL-visible functions, so callers should take
 * thought about how to treat them.
 */</comment>
<function><type><name>bool</name></type>
<name>check_functions_in_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>check_function_callback</name></type> <name>checker</name></decl></parameter>,
						<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>checker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>checker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>checker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>	<comment type="block">/* struct-equivalent to OpExpr */</comment>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>		<comment type="block">/* struct-equivalent to OpExpr */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Set opfuncid if it wasn't set already */</comment>
				<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>checker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>set_sa_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>checker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>iofunc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

				<comment type="block">/* check the result type's input function */</comment>
				<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>checker</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* check the input type's output function */</comment>
				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>checker</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>opid</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>opid</argument>, <argument>rcexpr-&gt;opnos</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>opfuncid</name> <init>= <expr><call><name>get_opcode</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>checker</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Standard expression-tree walking support
 *
 * We used to have near-duplicate code in many different routines that
 * understood how to recurse through an expression node tree.  That was
 * a pain to maintain, and we frequently had bugs due to some particular
 * routine neglecting to support a particular node type.  In most cases,
 * these routines only actually care about certain node types, and don't
 * care about other types except insofar as they have to recurse through
 * non-primitive node types.  Therefore, we now provide generic tree-walking
 * logic to consolidate the redundant "boilerplate" code.  There are
 * two versions: expression_tree_walker() and expression_tree_mutator().
 */</comment>

<comment type="block">/*
 * expression_tree_walker() is designed to support routines that traverse
 * a tree in a read-only fashion (although it will also work for routines
 * that modify nodes in-place but never add/delete/replace nodes).
 * A walker routine should look like this:
 *
 * bool my_walker (Node *node, my_struct *context)
 * {
 *		if (node == NULL)
 *			return false;
 *		// check for nodes that special work is required for, eg:
 *		if (IsA(node, Var))
 *		{
 *			... do special actions for Var nodes
 *		}
 *		else if (IsA(node, ...))
 *		{
 *			... do special actions for other node types
 *		}
 *		// for any node type not specially processed, do:
 *		return expression_tree_walker(node, my_walker, (void *) context);
 * }
 *
 * The "context" argument points to a struct that holds whatever context
 * information the walker routine needs --- it can be used to return data
 * gathered by the walker, too.  This argument is not touched by
 * expression_tree_walker, but it is passed down to recursive sub-invocations
 * of my_walker.  The tree walk is started from a setup routine that
 * fills in the appropriate context struct, calls my_walker with the top-level
 * node of the tree, and then examines the results.
 *
 * The walker routine should return "false" to continue the tree walk, or
 * "true" to abort the walk and immediately return "true" to the top-level
 * caller.  This can be used to short-circuit the traversal if the walker
 * has found what it came for.  "false" is returned to the top-level caller
 * iff no invocation of the walker returned "true".
 *
 * The node types handled by expression_tree_walker include all those
 * normally found in target lists and qualifier clauses during the planning
 * stage.  In particular, it handles List nodes since a cnf-ified qual clause
 * will have List structure at the top level, and it handles TargetEntry nodes
 * so that a scan of a target list can be handled without additional code.
 * Also, RangeTblRef, FromExpr, JoinExpr, and SetOperationStmt nodes are
 * handled, so that query jointrees and setOperation trees can be processed
 * without additional code.
 *
 * expression_tree_walker will handle SubLink nodes by recursing normally
 * into the "testexpr" subtree (which is an expression belonging to the outer
 * plan).  It will also call the walker on the sub-Query node; however, when
 * expression_tree_walker itself is called on a Query node, it does nothing
 * and returns "false".  The net effect is that unless the walker does
 * something special at a Query node, sub-selects will not be visited during
 * an expression tree walk. This is exactly the behavior wanted in many cases
 * --- and for those walkers that do want to recurse into sub-selects, special
 * behavior is typically needed anyway at the entry to a sub-select (such as
 * incrementing a depth counter). A walker that wants to examine sub-selects
 * should include code along the lines of:
 *
 *		if (IsA(node, Query))
 *		{
 *			adjust context for subquery;
 *			result = query_tree_walker((Query *) node, my_walker, context,
 *									   0); // adjust flags as needed
 *			restore context if needed;
 *			return result;
 *		}
 *
 * query_tree_walker is a convenience routine (see below) that calls the
 * walker on all the expression subtrees of the given Query node.
 *
 * expression_tree_walker will handle SubPlan nodes by recursing normally
 * into the "testexpr" and the "args" list (which are expressions belonging to
 * the outer plan).  It will not touch the completed subplan, however.  Since
 * there is no link to the original Query, it is not possible to recurse into
 * subselects of an already-planned expression tree.  This is OK for current
 * uses, but may need to be revisited in future.
 */</comment>

<function><type><name>bool</name></type>
<name>expression_tree_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					   <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
					   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The walker has already visited the current node, and so we need only
	 * recurse into any sub-nodes it has.
	 *
	 * We assume that the walker is not interested in List nodes per se, so
	 * when we expect a List we just recurse directly to self without
	 * bothering to call the walker.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
		<case>case <expr><name>T_Const</name></expr>:</case>
		<case>case <expr><name>T_Param</name></expr>:</case>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
		<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
		<case>case <expr><name>T_SortGroupClause</name></expr>:</case>
			<comment type="block">/* primitive node types with no expression subnodes */</comment>
			<break>break;</break>
		<case>case <expr><name>T_WithCheckOption</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>WithCheckOption</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>qual</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* recurse directly on List */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grouping</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>grouping</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* recurse directly on List */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* recurse directly for upper/lower container index lists */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* walker must see the refexpr and refassgnexpr, however */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>	<comment type="block">/* struct-equivalent to OpExpr */</comment>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>		<comment type="block">/* struct-equivalent to OpExpr */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Also invoke the walker on the sublink's Query node, so it
				 * can recurse into the sub-query if it wants to.
				 */</comment>
				<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* recurse into the testexpr, but not into the Plan */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* also examine args list */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>subplans</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* we assume walker doesn't care about CaseWhens, either */</comment>
				<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>caseexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>elements</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<comment type="block">/* Assume colnames isn't interesting */</comment>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* we assume walker doesn't care about arg_names */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_TargetEntry</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<comment type="block">/* Do nothing with a sub-Query, per discussion above */</comment>
			<break>break;</break>
		<case>case <expr><name>T_WindowClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Invoke the walker on the CTE's Query node, so it can
				 * recurse into the sub-query if it wants to.
				 */</comment>
				<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_List</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>(List *) node</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>from</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>onconflict</name> <init>= <expr><operator>(</operator><name>OnConflictExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>onconflict</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>onconflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>onconflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>onconflict</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_PartitionPruneStepOp</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>opstep</name> <init>= <expr><operator>(</operator><name>PartitionPruneStepOp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>opstep</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_PartitionPruneStepCombine</name></expr>:</case>
			<comment type="block">/* no expression subnodes */</comment>
			<break>break;</break>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>join</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * alias clause, using list are deemed uninteresting.
				 */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setop</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>setop</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>setop</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* groupClauses are deemed uninteresting */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IndexClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>iclause</name> <init>= <expr><operator>(</operator><name>IndexClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>iclause</name><operator>-&gt;</operator><name>rinfo</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>iclause</name><operator>-&gt;</operator><name>indexquals</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>InferenceElem</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_AppendRelInfo</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_PlaceHolderInfo</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>ph_var</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_TableSampleClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name> <init>= <expr><operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tsc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tsc</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TableFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>tf</name> <init>= <expr><operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>ns_uris</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>colexprs</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>coldefexprs</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherTypeCast</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherTypeCast</name> <modifier>*</modifier></type><name>tc</name> <init>= <expr><operator>(</operator><name>CypherTypeCast</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><name>CypherMapExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><name>CypherListExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cl</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>,
										   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherListCompExpr</name> <modifier>*</modifier></type><name>clc</name> <init>= <expr><operator>(</operator><name>CypherListCompExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>clc</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>clc</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>clc</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompVar</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>T_CypherAccessExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherAccessExpr</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>CypherAccessExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>a-&gt;path</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>CypherIndices</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>CypherIndices</name> <modifier>*</modifier></type><name>cind</name> <init>= <expr><operator>(</operator><name>CypherIndices</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>cind</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>cind</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * query_tree_walker --- initiate a walk of a Query's expressions
 *
 * This routine exists just to reduce the number of places that need to know
 * where all the expression subtrees of a Query are.  Note it can be used
 * for starting a walk at top level of a Query regardless of whether the
 * walker intends to descend into subqueries.  It is also useful for
 * descending into subqueries within a walker.
 *
 * Some callers want to suppress visitation of certain items in the sub-Query,
 * typically because they need to process them specially, or don't actually
 * want to recurse into subqueries.  This is supported by the flags argument,
 * which is the bitwise OR of flag values to add or suppress visitation of
 * indicated items.  (More flag bits may be added as needed.)
 */</comment>
<function><type><name>bool</name></type>
<name>query_tree_walker</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
				  <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't walk any utilityStmt here. However, we can't easily assert
	 * that it is absent, since there are at least two code paths by which
	 * action statements from CREATE RULE end up here, and NOTIFY is allowed
	 * in a rule action.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>dijkstraEndId</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>dijkstraEdgeId</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>dijkstraLimit</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathEndIdLeft</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathEndIdRight</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathTableOidLeft</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathTableOidRight</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathCtidLeft</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathCtidRight</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathSource</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathTarget</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Most callers aren't interested in SortGroupClause nodes since those
	 * don't contain actual expressions. However they do contain OIDs which
	 * may be needed by dependency walkers etc.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_EXAMINE_SORTGROUP</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * But we need to walk the expressions under WindowClause nodes even
		 * if we're not interested in SortGroupClause nodes.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;windowClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * groupingSets and rowMarks are not walked:
	 *
	 * groupingSets contain only ressortgrouprefs (integers) which are
	 * meaningless without the corresponding groupClause or tlist.
	 * Accordingly, any walker that needs to care about them needs to handle
	 * them itself in its Query processing.
	 *
	 * rowMarks is not walked because it contains only rangetable indexes (and
	 * flags etc.) and therefore should be handled at Query level similarly.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_IGNORE_CTE_SUBQUERIES</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_IGNORE_RANGE_TABLE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>range_table_walker</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * range_table_walker is just the part of query_tree_walker that scans
 * a query's rangetable.  This is split out since it can be useful on
 * its own.
 */</comment>
<function><type><name>bool</name></type>
<name>range_table_walker</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>,
				   <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
				   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rt</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>range_table_entry_walker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Some callers even want to scan the expressions in individual RTEs.
 */</comment>
<function><type><name>bool</name></type>
<name>range_table_entry_walker</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						 <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
						 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Walkers might need to examine the RTE node itself either before or
	 * after visiting its contents (or, conceivably, both).  Note that if you
	 * specify neither flag, the walker won't be called on the RTE at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>QTW_EXAMINE_RTES_BEFORE</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_IGNORE_RT_SUBQUERIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_IGNORE_JOINALIASES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
		<case>case <expr><name>RTE_RESULT</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>QTW_EXAMINE_RTES_AFTER</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * expression_tree_mutator() is designed to support routines that make a
 * modified copy of an expression tree, with some nodes being added,
 * removed, or replaced by new subtrees.  The original tree is (normally)
 * not changed.  Each recursion level is responsible for returning a copy of
 * (or appropriately modified substitute for) the subtree it is handed.
 * A mutator routine should look like this:
 *
 * Node * my_mutator (Node *node, my_struct *context)
 * {
 *		if (node == NULL)
 *			return NULL;
 *		// check for nodes that special work is required for, eg:
 *		if (IsA(node, Var))
 *		{
 *			... create and return modified copy of Var node
 *		}
 *		else if (IsA(node, ...))
 *		{
 *			... do special transformations of other node types
 *		}
 *		// for any node type not specially processed, do:
 *		return expression_tree_mutator(node, my_mutator, (void *) context);
 * }
 *
 * The "context" argument points to a struct that holds whatever context
 * information the mutator routine needs --- it can be used to return extra
 * data gathered by the mutator, too.  This argument is not touched by
 * expression_tree_mutator, but it is passed down to recursive sub-invocations
 * of my_mutator.  The tree walk is started from a setup routine that
 * fills in the appropriate context struct, calls my_mutator with the
 * top-level node of the tree, and does any required post-processing.
 *
 * Each level of recursion must return an appropriately modified Node.
 * If expression_tree_mutator() is called, it will make an exact copy
 * of the given Node, but invoke my_mutator() to copy the sub-node(s)
 * of that Node.  In this way, my_mutator() has full control over the
 * copying process but need not directly deal with expression trees
 * that it has no interest in.
 *
 * Just as for expression_tree_walker, the node types handled by
 * expression_tree_mutator include all those normally found in target lists
 * and qualifier clauses during the planning stage.
 *
 * expression_tree_mutator will handle SubLink nodes by recursing normally
 * into the "testexpr" subtree (which is an expression belonging to the outer
 * plan).  It will also call the mutator on the sub-Query node; however, when
 * expression_tree_mutator itself is called on a Query node, it does nothing
 * and returns the unmodified Query node.  The net effect is that unless the
 * mutator does something special at a Query node, sub-selects will not be
 * visited or modified; the original sub-select will be linked to by the new
 * SubLink node.  Mutators that want to descend into sub-selects will usually
 * do so by recognizing Query nodes and calling query_tree_mutator (below).
 *
 * expression_tree_mutator will handle a SubPlan node by recursing into the
 * "testexpr" and the "args" list (which belong to the outer plan), but it
 * will simply copy the link to the inner plan, since that's typically what
 * expression tree mutators want.  A mutator that wants to modify the subplan
 * can force appropriate behavior by recognizing SubPlan expression nodes
 * and doing the right thing.
 */</comment>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>expression_tree_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						<parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
						<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The mutator has already decided not to modify the current node, but we
	 * must call the mutator for any sub-nodes.
	 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLATCOPY</name><parameter_list>(<parameter><type><name>newnode</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>nodetype</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>( (newnode) = (nodetype *) palloc(sizeof(nodetype)), \
	  memcpy((newnode), (node), sizeof(nodetype)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKFLATCOPY</name><parameter_list>(<parameter><type><name>newnode</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>nodetype</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>( AssertMacro(IsA((node), nodetype)), \
	  (newnode) = (nodetype *) palloc(sizeof(nodetype)), \
	  memcpy((newnode), (node), sizeof(nodetype)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTATE</name><parameter_list>(<parameter><type><name>newfield</name></type></parameter>, <parameter><type><name>oldfield</name></type></parameter>, <parameter><type><name>fieldtype</name></type></parameter>)</parameter_list></cpp:macro>  \
		<cpp:value>( (newfield) = (fieldtype) mutator((Node *) (oldfield), context) )</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Primitive node types with no expression subnodes.  Var and
			 * Const are frequent enough to deserve special cases, the others
			 * we just use copyObject for.
			 */</comment>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>oldnode</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>oldnode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* XXX we don't bother with datumCopy; should we? */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
		<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
		<case>case <expr><name>T_SortGroupClause</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_WithCheckOption</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><operator>(</operator><name>WithCheckOption</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>wco</name></expr></argument>, <argument><expr><name>WithCheckOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* assume mutation doesn't change types of arguments */</comment>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grouping</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>grouping</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>grouping</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We assume here that mutating the arguments does not change
				 * the semantics, i.e. that the arguments are not mutated in a
				 * way that makes them semantically different from their
				 * previously matching expressions in the GROUP BY clause.
				 *
				 * If a mutator somehow wanted to do this, it would have to
				 * handle the refs and cols lists itself as appropriate.
				 */</comment>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>refs</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>grouping</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>cols</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>grouping</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>wfunc</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>sbsref</name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>, <argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>,
					   <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>, <argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>,
					   <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>,
					   <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>, <argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>,
					   <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>nexpr</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>nexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullIfExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>NullIfExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Also invoke the mutator on the sublink's Query node, so it
				 * can recurse into the sub-query if it wants to.
				 */</comment>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* transform testexpr */</comment>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* transform args list (params to be passed to subplan) */</comment>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* but not the sub-Plan itself, which is referenced as-is */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name> <init>= <expr><operator>(</operator><name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>asplan</name></expr></argument>, <argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>fselect</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>fstore</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>fieldnums</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>fieldnums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>relabel</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>relabel</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>relabel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>iocoerce</name></expr></argument>, <argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>acoerce</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>, <argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>convexpr</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>convexpr</name></expr></argument>, <argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>convexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>collate</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>collate</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>collate</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>caseexpr</name></expr></argument>, <argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CaseWhen</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>casewhen</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>casewhen</name></expr></argument>, <argument><expr><name>CaseWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>casewhen</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>casewhen</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrayexpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>arrayexpr</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>rowexpr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Assume colnames needn't be duplicated */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>rcexpr</name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>, <argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>, <argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesceexpr</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>coalesceexpr</name></expr></argument>, <argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>coalesceexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>minmaxexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>minmaxexpr</name></expr></argument>, <argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>xexpr</name></expr></argument>, <argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>, <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* assume mutator does not care about arg_names */</comment>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>ntest</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>btest</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>ctest</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>ctest</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TargetEntry</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetentry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>targetentry</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>targetentry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<comment type="block">/* Do nothing with a sub-Query, per discussion above */</comment>
			<return>return <expr><name>node</name></expr>;</return>
		<case>case <expr><name>T_WindowClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>wc</name></expr></argument>, <argument><expr><name>WindowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>cte</name></expr></argument>, <argument><expr><name>CommonTableExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Also invoke the mutator on the CTE's Query node, so it can
				 * recurse into the sub-query if it wants to.
				 */</comment>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_List</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * We assume the mutator isn't interested in the list nodes
				 * per se, so just invoke it on each list element. NOTE: this
				 * would fail badly on a list with integer elements!
				 */</comment>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resultlist</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>resultlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>(List *) node</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name>resultlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultlist</name></expr></argument>,
										 <argument><expr><call><name>mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>resultlist</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>from</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnConflictExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>, <argument><expr><name>OnConflictExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_PartitionPruneStepOp</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>opstep</name> <init>= <expr><operator>(</operator><name>PartitionPruneStepOp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>opstep</name></expr></argument>, <argument><expr><name>PartitionPruneStepOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_PartitionPruneStepCombine</name></expr>:</case>
			<comment type="block">/* no expression sub-nodes */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>join</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>join</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We do not mutate alias or using by default */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setop</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>setop</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name><name>setop</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name><name>setop</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We do not mutate groupClauses by default */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IndexClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>iclause</name> <init>= <expr><operator>(</operator><name>IndexClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>iclause</name></expr></argument>, <argument><expr><name>IndexClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>rinfo</name></name></expr></argument>, <argument><expr><name><name>iclause</name><operator>-&gt;</operator><name>rinfo</name></name></expr></argument>, <argument><expr><name>RestrictInfo</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>indexquals</name></name></expr></argument>, <argument><expr><name><name>iclause</name><operator>-&gt;</operator><name>indexquals</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Assume we need not copy the relids bitmapset */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>inferenceelemdexpr</name> <init>= <expr><operator>(</operator><name>InferenceElem</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>inferenceelemdexpr</name></expr></argument>, <argument><expr><name>InferenceElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_AppendRelInfo</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>, <argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Assume nothing need be done with parent_colnos[] */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_PlaceHolderInfo</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>phinfo</name></expr></argument>, <argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>ph_var</name></name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_var</name></name></expr></argument>, <argument><expr><name>PlaceHolderVar</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Assume we need not copy the relids bitmapsets */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>rtfunc</name></expr></argument>, <argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Assume we need not copy the coldef info lists */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TableSampleClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name> <init>= <expr><operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>tsc</name></expr></argument>, <argument><expr><name>TableSampleClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>tsc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name><name>tsc</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TableFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>tf</name> <init>= <expr><operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>tf</name></expr></argument>, <argument><expr><name>TableFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>ns_uris</name></name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>ns_uris</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>colexprs</name></name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>colexprs</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>coldefexprs</name></name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>coldefexprs</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherTypeCast</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherTypeCast</name> <modifier>*</modifier></type><name>tc</name> <init>= <expr><operator>(</operator><name>CypherTypeCast</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CypherTypeCast</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>CypherTypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><name>CypherMapExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>CypherMapExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><name>CypherListExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>, <argument><expr><name>CypherListExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherListCompExpr</name> <modifier>*</modifier></type><name>clc</name> <init>= <expr><operator>(</operator><name>CypherListCompExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CypherListCompExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>clc</name></expr></argument>, <argument><expr><name>CypherListCompExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name><name>clc</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>Expr</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name><name>clc</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name>Expr</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name><name>clc</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name>Expr</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListCompVar</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherListCompVar</name> <modifier>*</modifier></type><name>clcv</name> <init>= <expr><operator>(</operator><name>CypherListCompVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CypherListCompVar</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>clcv</name></expr></argument>, <argument><expr><name>CypherListCompVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherAccessExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherAccessExpr</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>CypherAccessExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CypherAccessExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>CypherAccessExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherIndices</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherIndices</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><operator>(</operator><name>CypherIndices</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CypherIndices</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>CypherIndices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>, <argument><expr><name><name>i</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name><name>i</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GraphDelElem</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><operator>(</operator><name>GraphDelElem</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>GraphDelElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name><name>i</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name>Node</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<comment type="block">/* can't get here, but keep compiler happy */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * query_tree_mutator --- initiate modification of a Query's expressions
 *
 * This routine exists just to reduce the number of places that need to know
 * where all the expression subtrees of a Query are.  Note it can be used
 * for starting a walk at top level of a Query regardless of whether the
 * mutator intends to descend into subqueries.  It is also useful for
 * descending into subqueries within a mutator.
 *
 * Some callers want to suppress mutating of certain items in the Query,
 * typically because they need to process them specially, or don't actually
 * want to recurse into subqueries.  This is supported by the flags argument,
 * which is the bitwise OR of flag values to suppress mutating of
 * indicated items.  (More flag bits may be added as needed.)
 *
 * Normally the Query node itself is copied, but some callers want it to be
 * modified in-place; they must pass QTW_DONT_COPY_QUERY in flags.  All
 * modified substructure is safely copied in any case.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>query_tree_mutator</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
				   <parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
				   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_DONT_COPY_QUERY</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>newquery</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newquery</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <name>newquery</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>, <argument><expr><name>OnConflictExpr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>FromExpr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>dijkstraEndId</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>dijkstraEndId</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>dijkstraEdgeId</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>dijkstraEdgeId</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>dijkstraLimit</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>dijkstraLimit</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathEndIdLeft</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathEndIdLeft</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathEndIdRight</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathEndIdRight</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathTableOidLeft</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathTableOidLeft</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathTableOidRight</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathTableOidRight</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathCtidLeft</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathCtidLeft</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathCtidRight</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathCtidRight</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathSource</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathSource</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathTarget</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>shortestpathTarget</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Most callers aren't interested in SortGroupClause nodes since those
	 * don't contain actual expressions. However they do contain OIDs, which
	 * may be of interest to some mutators.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_EXAMINE_SORTGROUP</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * But we need to mutate the expressions under WindowClause nodes even
		 * if we're not interested in SortGroupClause nodes.
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resultlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>resultlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>query-&gt;windowClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>wc</name></expr></argument>, <argument><expr><name>WindowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>resultlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultlist</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name>resultlist</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * groupingSets and rowMarks are not mutated:
	 *
	 * groupingSets contain only ressortgroup refs (integers) which are
	 * meaningless without the groupClause or tlist. Accordingly, any mutator
	 * that needs to care about them needs to handle them itself in its Query
	 * processing.
	 *
	 * rowMarks contains only rangetable indexes (and flags etc.) and
	 * therefore should be handled at Query level similarly.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_IGNORE_CTE_SUBQUERIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* else copy CTE list as-is */</comment>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>range_table_mutator</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
										<argument><expr><name>mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * range_table_mutator is just the part of query_tree_mutator that processes
 * a query's rangetable.  This is split out since it can be useful on
 * its own.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>range_table_mutator</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>,
					<parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
					<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newrt</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rt</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newrte</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newrte</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>,
					   <argument><expr><name>TableSampleClause</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* we don't bother to copy eref, aliases, etc; OK? */</comment>
				<break>break;</break>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_IGNORE_RT_SUBQUERIES</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>CHECKFLATCOPY</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>Query</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* else, copy RT subqueries as-is */</comment>
					<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_JOIN</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QTW_IGNORE_JOINALIASES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* else, copy join aliases as-is */</comment>
					<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name>TableFunc</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>
			<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<case>case <expr><name>RTE_RESULT</name></expr>:</case>
				<comment type="block">/* nothing to do */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newrt</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newrt</name></expr></argument>, <argument><expr><name>newrte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>newrt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * query_or_expression_tree_walker --- hybrid form
 *
 * This routine will invoke query_tree_walker if called on a Query node,
 * else will invoke the walker directly.  This is a useful way of starting
 * the recursion when the walker's normal change of state is not appropriate
 * for the outermost Query node.
 */</comment>
<function><type><name>bool</name></type>
<name>query_or_expression_tree_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								<parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
								<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								 <argument><expr><name>walker</name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>,
								 <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * query_or_expression_tree_mutator --- hybrid form
 *
 * This routine will invoke query_tree_mutator if called on a Query node,
 * else will invoke the mutator directly.  This is a useful way of starting
 * the recursion when the mutator's normal change of state is not appropriate
 * for the outermost Query node.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>query_or_expression_tree_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								 <parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
								 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
										   <argument><expr><name>mutator</name></expr></argument>,
										   <argument><expr><name>context</name></expr></argument>,
										   <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * raw_expression_tree_walker --- walk raw parse trees
 *
 * This has exactly the same API as expression_tree_walker, but instead of
 * walking post-analysis parse trees, it knows how to walk the node types
 * found in raw grammar output.  (There is not currently any need for a
 * combined walker, so we keep them separate in the name of efficiency.)
 * Unlike expression_tree_walker, there is no special rule about query
 * boundaries: we descend to everything that's possibly interesting.
 *
 * Currently, the node type coverage here extends only to DML statements
 * (SELECT/INSERT/UPDATE/DELETE) and nodes that can appear in them, because
 * this is used mainly during analysis of CTEs, and only DML statements can
 * appear in CTEs.
 */</comment>
<function><type><name>bool</name></type>
<name>raw_expression_tree_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
						   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The walker has already visited the current node, and so we need only
	 * recurse into any sub-nodes it has.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
		<case>case <expr><name>T_Integer</name></expr>:</case>
		<case>case <expr><name>T_Float</name></expr>:</case>
		<case>case <expr><name>T_String</name></expr>:</case>
		<case>case <expr><name>T_BitString</name></expr>:</case>
		<case>case <expr><name>T_Null</name></expr>:</case>
		<case>case <expr><name>T_ParamRef</name></expr>:</case>
		<case>case <expr><name>T_A_Const</name></expr>:</case>
		<case>case <expr><name>T_A_Star</name></expr>:</case>
			<comment type="block">/* primitive node types with no subnodes */</comment>
			<break>break;</break>
		<case>case <expr><name>T_Alias</name></expr>:</case>
			<comment type="block">/* we assume the colnames list isn't interesting */</comment>
			<break>break;</break>
		<case>case <expr><name>T_RangeVar</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>alias</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* we assume the operName is not interesting */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* we assume walker doesn't care about CaseWhens, either */</comment>
				<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>caseexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<comment type="block">/* Assume colnames isn't interesting */</comment>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* we assume walker doesn't care about arg_names */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>join</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>join</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* using list is deemed uninteresting */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IntoClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name> <init>= <expr><operator>(</operator><name>IntoClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* colNames, options are deemed uninteresting */</comment>
				<comment type="block">/* viewQuery should be null in raw parsetree, but check it */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_List</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>(List *) node</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>InsertStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>selectStmt</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DeleteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DeleteStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>UpdateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>UpdateStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>havingClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>valuesLists</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_Expr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* operator name is deemed uninteresting */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ColumnRef</name></expr>:</case>
			<comment type="block">/* we assume the fields contain nothing interesting */</comment>
			<break>break;</break>
		<case>case <expr><name>T_FuncCall</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>fcall</name> <init>= <expr><operator>(</operator><name>FuncCall</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>fcall</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>fcall</name><operator>-&gt;</operator><name>agg_order</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>fcall</name><operator>-&gt;</operator><name>agg_filter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>fcall</name><operator>-&gt;</operator><name>over</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* function name is deemed uninteresting */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_A_Indices</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>indices</name> <init>= <expr><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>indices</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_Indirection</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>indir</name> <init>= <expr><operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>indir</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>indir</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>A_ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>elements</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_ResTarget</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>ResTarget</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rt</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rt</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_MultiAssignRef</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MultiAssignRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>source</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_TypeCast</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>tc</name> <init>= <expr><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CollateClause</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CollateClause</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_SortBy</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SortBy</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_WindowDef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowDef</name>  <modifier>*</modifier></type><name>wd</name> <init>= <expr><operator>(</operator><name>WindowDef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wd</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wd</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wd</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>wd</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeSubselect</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><operator>(</operator><name>RangeSubselect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rs</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rs</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>rf</name> <init>= <expr><operator>(</operator><name>RangeFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rf</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rf</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rf</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeTableSample</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTableSample</name> <modifier>*</modifier></type><name>rts</name> <init>= <expr><operator>(</operator><name>RangeTableSample</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* method name is deemed uninteresting */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rts</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeTableFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTableFunc</name> <modifier>*</modifier></type><name>rtf</name> <init>= <expr><operator>(</operator><name>RangeTableFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeTableFuncCol</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTableFuncCol</name> <modifier>*</modifier></type><name>rtfc</name> <init>= <expr><operator>(</operator><name>RangeTableFuncCol</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rtfc</name><operator>-&gt;</operator><name>colexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>rtfc</name><operator>-&gt;</operator><name>coldefexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TypeName</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>tn</name> <init>= <expr><operator>(</operator><name>TypeName</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>tn</name><operator>-&gt;</operator><name>typmods</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>tn</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* type name itself is deemed uninteresting */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ColumnDef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>coldef</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>collClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* for now, constraints are ignored */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IndexElem</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>indelem</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>indelem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* collation and opclass names are deemed uninteresting */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingSet</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>content</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_LockingClause</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>lockedRels</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_XmlSerialize</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlSerialize</name> <modifier>*</modifier></type><name>xs</name> <init>= <expr><operator>(</operator><name>XmlSerialize</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>xs</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>xs</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WithClause</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>WithClause</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>ctes</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_InferClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>InferClause</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>InferClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexElems</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OnConflictClause</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OnConflictClause</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>OnConflictClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>infer</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
			<return>return <expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>ctequery</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CypherListComp</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherListComp</name> <modifier>*</modifier></type><name>clc</name> <init>= <expr><operator>(</operator><name>CypherListComp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>clc</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>clc</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>clc</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherGenericExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherGenericExpr</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><operator>(</operator><name>CypherGenericExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><name>CypherMapExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><name>CypherListExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GraphDelElem</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GraphDelElem</name> <modifier>*</modifier></type><name>graphDelElem</name> <init>= <expr><operator>(</operator><name>GraphDelElem</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>graphDelElem</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * planstate_tree_walker --- walk plan state trees
 *
 * The walker has already visited the current node, and so we need only
 * recurse into any sub-nodes it has.
 */</comment>
<function><type><name>bool</name></type>
<name>planstate_tree_walker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
					  <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex plan trees */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initPlan-s */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>planstate_walk_subplans</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* lefttree */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* righttree */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* special child plans */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>planstate_walk_members</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>mt_plans</name></expr></argument>,
									   <argument><expr><operator>(</operator><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>mt_nplans</name></expr></argument>,
									   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Append</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>planstate_walk_members</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>appendplans</name></expr></argument>,
									   <argument><expr><operator>(</operator><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>as_nplans</name></expr></argument>,
									   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>planstate_walk_members</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>mergeplans</name></expr></argument>,
									   <argument><expr><operator>(</operator><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>ms_nplans</name></expr></argument>,
									   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>planstate_walk_members</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>,
									   <argument><expr><operator>(</operator><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>nplans</name></expr></argument>,
									   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>planstate_walk_members</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>,
									   <argument><expr><operator>(</operator><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>nplans</name></expr></argument>,
									   <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((CustomScanState *) planstate)-&gt;custom_ps</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* subPlan-s */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>planstate_walk_subplans</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>subPlan</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Walk a list of SubPlans (or initPlans, which also use SubPlan nodes).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>planstate_walk_subplans</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plans</name></decl></parameter>,
						<parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
						<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SubPlanState</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>sps</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Walk the constituent plans of a ModifyTable, Append, MergeAppend,
 * BitmapAnd, or BitmapOr node.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>planstate_walk_members</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>planstates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nplans</name></decl></parameter>,
					   <parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nplans</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>walker</name><argument_list>(<argument><expr><name><name>planstates</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * raw_expression_tree_mutator --- make a modified copy of raw parse trees
 *
 * This has exactly the same API as expression_tree_mutator, but instead of
 * walking post-analysis parse trees, it knows how to walk the node types
 * found in raw grammar output.
 *
 * used on agensgraph.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>raw_expression_tree_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							<parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
							<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The mutator has already decided not to modify the current node, but we
	 * must call the mutator for any sub-nodes.
	 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLATCOPY</name><parameter_list>(<parameter><type><name>newnode</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>nodetype</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>( (newnode) = (nodetype *) palloc(sizeof(nodetype)), \
	  memcpy((newnode), (node), sizeof(nodetype)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKFLATCOPY</name><parameter_list>(<parameter><type><name>newnode</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>nodetype</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>( AssertMacro(IsA((node), nodetype)), \
	  (newnode) = (nodetype *) palloc(sizeof(nodetype)), \
	  memcpy((newnode), (node), sizeof(nodetype)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTATE</name><parameter_list>(<parameter><type><name>newfield</name></type></parameter>, <parameter><type><name>oldfield</name></type></parameter>, <parameter><type><name>fieldtype</name></type></parameter>)</parameter_list></cpp:macro>  \
		<cpp:value>( (newfield) = (fieldtype) mutator((Node *) (oldfield), context) )</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
		<case>case <expr><name>T_Integer</name></expr>:</case>
		<case>case <expr><name>T_Float</name></expr>:</case>
		<case>case <expr><name>T_String</name></expr>:</case>
		<case>case <expr><name>T_BitString</name></expr>:</case>
		<case>case <expr><name>T_Null</name></expr>:</case>
		<case>case <expr><name>T_ParamRef</name></expr>:</case>
		<case>case <expr><name>T_A_Const</name></expr>:</case>
		<case>case <expr><name>T_A_Star</name></expr>:</case>
		<case>case <expr><name>T_Alias</name></expr>:</case>
			<comment type="block">/* primitive node types with no subnodes */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
			<break>break;</break>

			<comment type="block">/* we assume the colnames list isn't interesting */</comment>
			<break>break;</break>
		<case>case <expr><name>T_RangeVar</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>Alias</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>groupfn</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>groupfn</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>groupfn</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Also invoke the mutator on the sublink's Query node, so it
			 * can recurse into the sub-query if it wants to.
			 */</comment>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>caseexpr</name></expr></argument>, <argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name><name>caseexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>rowexpr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Assume colnames needn't be duplicated */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesceexpr</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>coalesceexpr</name></expr></argument>, <argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>coalesceexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>minmaxexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>minmaxexpr</name></expr></argument>, <argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>xexpr</name></expr></argument>, <argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>, <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* assume mutator does not care about arg_names */</comment>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>ntest</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>btest</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>join</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>join</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name><name>join</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We do not mutate alias or using by default */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IntoClause</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name> <init>= <expr><operator>(</operator><name>IntoClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>IntoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>into</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>RangeVar</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>viewQuery</name></name></expr></argument>, <argument><expr><name><name>into</name><operator>-&gt;</operator><name>viewQuery</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_List</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * We assume the mutator isn't interested in the list nodes
			 * per se, so just invoke it on each list element. NOTE: this
			 * would fail badly on a list with integer elements!
			 */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resultlist</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>resultlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>(List *) node</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>resultlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultlist</name></expr></argument>,
									 <argument><expr><call><name>mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>resultlist</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>InsertStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>InsertStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>RangeVar</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>selectStmt</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>selectStmt</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>onConflictClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>onConflictClause</name></name></expr></argument>,
				   <argument><expr><name>OnConflictClause</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name>WithClause</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DeleteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DeleteStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DeleteStmt</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>DeleteStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>RangeVar</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name>WithClause</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>UpdateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>UpdateStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UpdateStmt</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>UpdateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>RangeVar</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name>WithClause</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>intoClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name></expr></argument>, <argument><expr><name>IntoClause</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>havingClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>havingClause</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>valuesLists</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>valuesLists</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>lockingClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lockingClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>withClause</name></name></expr></argument>, <argument><expr><name>WithClause</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>SelectStmt</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>SelectStmt</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_Expr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_Expr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>A_Expr</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ColumnRef</name></expr>:</case>
			<comment type="block">/* we assume the fields contain nothing interesting */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnRef</name>   <modifier>*</modifier></type><name>colref</name> <init>= <expr><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnRef</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>colref</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><name><name>colref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FuncCall</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>fcall</name> <init>= <expr><operator>(</operator><name>FuncCall</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>fcall</name></expr></argument>, <argument><expr><name>FuncCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>fcall</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>nexpr</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>nexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_Indices</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>indices</name> <init>= <expr><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>A_Indices</name>  <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>indices</name></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>, <argument><expr><name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name><name>indices</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_Indirection</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>indir</name> <init>= <expr><operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>indir</name></expr></argument>, <argument><expr><name>A_Indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>indir</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>, <argument><expr><name><name>indir</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>arrexpr</name> <init>= <expr><operator>(</operator><name>A_ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>arrexpr</name></expr></argument>, <argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ResTarget</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>ResTarget</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>, <argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>, <argument><expr><name><name>rt</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>rt</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_MultiAssignRef</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiAssignRef</name>  <modifier>*</modifier></type><name>msref</name> <init>= <expr><operator>(</operator><name>MultiAssignRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MultiAssignRef</name>  <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>msref</name></expr></argument>, <argument><expr><name>MultiAssignRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name><name>msref</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TypeCast</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>tc</name> <init>= <expr><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name><name>tc</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>TypeName</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CollateClause</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CollateClause</name> <modifier>*</modifier></type><name>collate</name> <init>= <expr><operator>(</operator><name>CollateClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CollateClause</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>collate</name></expr></argument>, <argument><expr><name>CollateClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>collate</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SortBy</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortBy</name> <modifier>*</modifier></type><name>sortby</name> <init>= <expr><operator>(</operator><name>SortBy</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SortBy</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>sortby</name></expr></argument>, <argument><expr><name>SortBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name><name>sortby</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowDef</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowDef</name>  <modifier>*</modifier></type><name>wd</name> <init>= <expr><operator>(</operator><name>WindowDef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WindowDef</name>  <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>wd</name></expr></argument>, <argument><expr><name>WindowDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>, <argument><expr><name><name>wd</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name><name>wd</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name><name>wd</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name><name>wd</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeSubselect</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><operator>(</operator><name>RangeSubselect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeSubselect</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name>RangeSubselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name><name>rs</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name><name>rs</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>Alias</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeFunction</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>rf</name> <init>= <expr><operator>(</operator><name>RangeFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>, <argument><expr><name>RangeFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>Alias</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RangeTableSample</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTableSample</name> <modifier>*</modifier></type><name>rts</name> <init>= <expr><operator>(</operator><name>RangeTableSample</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTableSample</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>rts</name></expr></argument>, <argument><expr><name>RangeTableSample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>rts</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>rts</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name><name>rts</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* method name is deemed uninteresting */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>

		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TypeName</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>tn</name> <init>= <expr><operator>(</operator><name>TypeName</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>, <argument><expr><name>TypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>typmods</name></name></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>typmods</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* type name itself is deemed uninteresting */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ColumnDef</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>coldef</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>coldef</name></expr></argument>, <argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>TypeName</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>raw_default</name></name></expr></argument>, <argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>collClause</name></name></expr></argument>, <argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>collClause</name></name></expr></argument>,
				   <argument><expr><name>CollateClause</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GroupingSet</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupingSet</name>   <modifier>*</modifier></type><name>groupset</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GroupingSet</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>groupset</name></expr></argument>, <argument><expr><name>GroupingSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>content</name></name></expr></argument>, <argument><expr><name><name>groupset</name><operator>-&gt;</operator><name>content</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_LockingClause</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LockingClause</name>   <modifier>*</modifier></type><name>locing</name> <init>= <expr><operator>(</operator><name>LockingClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LockingClause</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>locing</name></expr></argument>, <argument><expr><name>LockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>lockedRels</name></name></expr></argument>, <argument><expr><name><name>locing</name><operator>-&gt;</operator><name>lockedRels</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_XmlSerialize</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XmlSerialize</name> <modifier>*</modifier></type><name>xs</name> <init>= <expr><operator>(</operator><name>XmlSerialize</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XmlSerialize</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>xs</name></expr></argument>, <argument><expr><name>XmlSerialize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>xs</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name><name>xs</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>TypeName</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WithClause</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WithClause</name>   <modifier>*</modifier></type><name>with</name> <init>= <expr><operator>(</operator><name>WithClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WithClause</name>   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>with</name></expr></argument>, <argument><expr><name>WithClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>ctes</name></name></expr></argument>, <argument><expr><name><name>with</name><operator>-&gt;</operator><name>ctes</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_InferClause</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>InferClause</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>InferClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>InferClause</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>InferClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>indexElems</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexElems</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OnConflictClause</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OnConflictClause</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>OnConflictClause</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OnConflictClause</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>OnConflictClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>infer</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>infer</name></name></expr></argument>, <argument><expr><name>InferClause</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>cte</name></expr></argument>, <argument><expr><name>CommonTableExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Also invoke the mutator on the CTE's Query node, so it can
			 * recurse into the sub-query if it wants to.
			 */</comment>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListComp</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherListComp</name> <modifier>*</modifier></type><name>clc</name> <init>= <expr><operator>(</operator><name>CypherListComp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CypherListComp</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>clc</name></expr></argument>, <argument><expr><name>CypherListComp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name><name>clc</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name><name>clc</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name><name>clc</name><operator>-&gt;</operator><name>elem</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherGenericExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherGenericExpr</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><operator>(</operator><name>CypherGenericExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CypherGenericExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>CypherGenericExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherMapExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><name>CypherMapExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CypherMapExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>CypherMapExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CypherListExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><name>CypherListExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CypherListExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>, <argument><expr><name>CypherListExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<comment type="block">/* can't get here, but keep compiler happy */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>clang</name> <name>diagnostic</name> <name>pop</name></cpp:pragma>
</unit>
