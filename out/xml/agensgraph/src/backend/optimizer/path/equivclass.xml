<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/optimizer/path/equivclass.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * equivclass.c
 *	  Routines for managing EquivalenceClasses
 *
 * See src/backend/optimizer/README for discussion of EquivalenceClasses.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/path/equivclass.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/appendinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<comment type="block">/* source-code-compatibility hacks for pull_varnos() API change */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pull_varnos</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pull_varnos_new(a,b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>make_restrictinfo</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>make_restrictinfo_new(a,b,c,d,e,f,g,h,i)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type><name>add_eq_member</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
										<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>is_child</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datatype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_exprlist_member</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_base_implied_equalities_const</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
												   <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_base_implied_equalities_no_const</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
													  <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_base_implied_equalities_broken</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
													<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_join_implied_equalities_normal</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
													 <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
													 <parameter><decl><type><name>Relids</name></type> <name>join_relids</name></decl></parameter>,
													 <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
													 <parameter><decl><type><name>Relids</name></type> <name>inner_relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_join_implied_equalities_broken</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
													 <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
													 <parameter><decl><type><name>Relids</name></type> <name>nominal_join_relids</name></decl></parameter>,
													 <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
													 <parameter><decl><type><name>Relids</name></type> <name>nominal_inner_relids</name></decl></parameter>,
													 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>select_equality_operator</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name></type> <name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>righttype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RestrictInfo</name> <modifier>*</modifier></type><name>create_join_clause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
										<parameter><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>leftem</name></decl></parameter>,
										<parameter><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>rightem</name></decl></parameter>,
										<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>parent_ec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>reconsider_outer_join_clause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										 <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>outer_on_left</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>reconsider_full_join_clause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>get_eclass_indexes_for_relids</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
												<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>get_common_eclass_indexes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids1</name></decl></parameter>,
											<parameter><decl><type><name>Relids</name></type> <name>relids2</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * process_equivalence
 *	  The given clause has a mergejoinable operator and can be applied without
 *	  any delay by an outer join, so its two sides can be considered equal
 *	  anywhere they are both computable; moreover that equality can be
 *	  extended transitively.  Record this knowledge in the EquivalenceClass
 *	  data structure, if applicable.  Returns true if successful, false if not
 *	  (in which case caller should treat the clause as ordinary, not an
 *	  equivalence).
 *
 * In some cases, although we cannot convert a clause into EquivalenceClass
 * knowledge, we can still modify it to a more useful form than the original.
 * Then, *p_restrictinfo will be replaced by a new RestrictInfo, which is what
 * the caller should use for further processing.
 *
 * If below_outer_join is true, then the clause was found below the nullable
 * side of an outer join, so its sides might validly be both NULL rather than
 * strictly equal.  We can still deduce equalities in such cases, but we take
 * care to mark an EquivalenceClass if it came from any such clauses.  Also,
 * we have to check that both sides are either pseudo-constants or strict
 * functions of Vars, else they might not both go to NULL above the outer
 * join.  (This is the main reason why we need a failure return.  It's more
 * convenient to check this case here than at the call sites...)
 *
 * We also reject proposed equivalence clauses if they contain leaky functions
 * and have security_level above zero.  The EC evaluation rules require us to
 * apply certain tests at certain joining levels, and we can't tolerate
 * delaying any test on security_level grounds.  By rejecting candidate clauses
 * that might require security delays, we ensure it's safe to apply an EC
 * clause as soon as it's supposed to be applied.
 *
 * On success return, we have also initialized the clause's left_ec/right_ec
 * fields to point to the EquivalenceClass representing it.  This saves lookup
 * effort later.
 *
 * Note: constructing merged EquivalenceClasses is a standard UNION-FIND
 * problem, for which there exist better data structures than simple lists.
 * If this code ever proves to be a bottleneck then it could be sped up ---
 * but for now, simple is beautiful.
 *
 * Note: this is only called during planner startup, not during GEQO
 * exploration, so we need not worry about whether we're in the right
 * memory context.
 */</comment>
<function><type><name>bool</name></type>
<name>process_equivalence</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_restrictinfo</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>below_outer_join</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>*</operator><name>p_restrictinfo</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>,
				<decl><type ref="prev"/><name>collation</name></decl>,
				<decl><type ref="prev"/><name>item1_type</name></decl>,
				<decl><type ref="prev"/><name>item2_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>item1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>item2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>item1_relids</name></decl>,
				<decl><type ref="prev"/><name>item2_relids</name></decl>,
				<decl><type ref="prev"/><name>item1_nullable_relids</name></decl>,
				<decl><type ref="prev"/><name>item2_nullable_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opfamilies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ec2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>em2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<comment type="block">/* Should not already be marked as having generated an eclass */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reject if it is potentially postponable by security considerations */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>leakproof</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Extract info from given clause */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>item1</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item2</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item1_relids</name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>item2_relids</name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure both input expressions expose the desired collation (their types
	 * should be OK already); see comments for canonicalize_ec_expression.
	 */</comment>
	<expr_stmt><expr><name>item1</name> <operator>=</operator> <call><name>canonicalize_ec_expression</name><argument_list>(<argument><expr><name>item1</name></expr></argument>,
									   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>item1</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item2</name> <operator>=</operator> <call><name>canonicalize_ec_expression</name><argument_list>(<argument><expr><name>item2</name></expr></argument>,
									   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>item2</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clauses of the form X=X cannot be translated into EquivalenceClasses.
	 * We'd either end up with a single-entry EC, losing the knowledge that
	 * the clause was present at all, or else make an EC with duplicate
	 * entries, causing other issues.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>item1</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the operator is strict, then the clause can be treated as just
		 * "X IS NOT NULL".  (Since we know we are considering a top-level
		 * qual, we can ignore the difference between FALSE and NULL results.)
		 * It's worth making the conversion because we'll typically get a much
		 * better selectivity estimate than we would for X=X.
		 *
		 * If the operator is not strict, we can't be sure what it will do
		 * with NULLs, so don't attempt to optimize it.
		 */</comment>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>func_strict</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opfuncid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>item1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* correct even if composite arg */</comment>
			<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>p_restrictinfo</name> <operator>=</operator>
				<call><name>make_restrictinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>ntest</name></expr></argument>,
								  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>is_pushed_down</name></name></expr></argument>,
								  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outerjoin_delayed</name></name></expr></argument>,
								  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr></argument>,
								  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outer_relids</name></name></expr></argument>,
								  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If below outer join, check for strictness, else reject.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>below_outer_join</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>item1_relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>contain_nonstrict_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>item1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* LHS is non-strict but not constant */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>item2_relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>contain_nonstrict_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>item2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* RHS is non-strict but not constant */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Calculate nullable-relid sets for each side of the clause */</comment>
	<expr_stmt><expr><name>item1_nullable_relids</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name>item1_relids</name></expr></argument>,
										  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item2_nullable_relids</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name>item2_relids</name></expr></argument>,
										  <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use the declared input types of the operator, not exprType() of the
	 * inputs, as the nominal datatypes for opfamily lookup.  This presumes
	 * that btree operators are always registered with amoplefttype and
	 * amoprighttype equal to their declared input types.  We will need this
	 * info anyway to build EquivalenceMember nodes, and by extracting it now
	 * we can use type comparisons to short-circuit some equal() tests.
	 */</comment>
	<expr_stmt><expr><call><name>op_input_types</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>item1_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>item2_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opfamilies</name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sweep through the existing EquivalenceClasses looking for matches to
	 * item1 and item2.  These are the possible outcomes:
	 *
	 * 1. We find both in the same EC.  The equivalence is already known, so
	 * there's nothing to do.
	 *
	 * 2. We find both in different ECs.  Merge the two ECs together.
	 *
	 * 3. We find just one.  Add the other to its EC.
	 *
	 * 4. We find neither.  Make a new, two-entry EC.
	 *
	 * Note: since all ECs are built through this process or the similar
	 * search in get_eclass_for_sort_expr(), it's impossible that we'd match
	 * an item in more than one existing nonvolatile EC.  So it's okay to stop
	 * at the first match.
	 */</comment>
	<expr_stmt><expr><name>ec1</name> <operator>=</operator> <name>ec2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>em1</name> <operator>=</operator> <name>em2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>root-&gt;eq_classes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* Never match to a volatile EC */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The collation has to match; check this first since it's cheaper
		 * than the opfamily comparison.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>!=</operator> <name><name>cur_ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * A "match" requires matching sets of btree opfamilies.  Use of
		 * equal() for this test has implications discussed in the comments
		 * for get_mergejoin_opfamilies().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>, <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>cur_ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no children yet */</comment>

			<comment type="block">/*
			 * If below an outer join, don't match constants: they're not as
			 * constant as they look.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>below_outer_join</name> <operator>||</operator> <name><name>cur_ec</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
				<name><name>cur_em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec1</name> <operator>&amp;&amp;</operator>
				<name>item1_type</name> <operator>==</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name>item1</name></expr></argument>, <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ec1</name> <operator>=</operator> <name>cur_ec</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>em1</name> <operator>=</operator> <name>cur_em</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ec2</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec2</name> <operator>&amp;&amp;</operator>
				<name>item2_type</name> <operator>==</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name>item2</name></expr></argument>, <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ec2</name> <operator>=</operator> <name>cur_ec</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>em2</name> <operator>=</operator> <name>cur_em</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ec1</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>ec1</name> <operator>&amp;&amp;</operator> <name>ec2</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Sweep finished, what did we find? */</comment>

	<if_stmt><if>if <condition>(<expr><name>ec1</name> <operator>&amp;&amp;</operator> <name>ec2</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If case 1, nothing to do, except add to sources */</comment>
		<if_stmt><if>if <condition>(<expr><name>ec1</name> <operator>==</operator> <name>ec2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_sources</name></name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>|=</operator> <name>below_outer_join</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_min_security</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>,
									   <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_max_security</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_max_security</name></name></expr></argument>,
									   <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* mark the RI as associated with this eclass */</comment>
			<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>=</operator> <name>ec1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>=</operator> <name>ec1</name></expr>;</expr_stmt>
			<comment type="block">/* mark the RI as usable with this pair of EMs */</comment>
			<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>em1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>em2</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Case 2: need to merge ec1 and ec2.  This should never happen after
		 * the ECs have reached canonical state; otherwise, pathkeys could be
		 * rendered non-canonical by the merge, and relation eclass indexes
		 * would get broken by removal of an eq_classes list entry.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>ec_merging_done</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too late to merge equivalence classes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We add ec2's items to ec1, then set ec2's ec_merged link to point
		 * to ec1 and remove ec2 from the eq_classes list.  We cannot simply
		 * delete ec2 because that could leave dangling pointers in existing
		 * PathKeys.  We leave it behind with a link so that the merged EC can
		 * be found.
		 */</comment>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>, <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_sources</name></name></expr></argument>, <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_sources</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_derives</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_derives</name></name></expr></argument>, <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_derives</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_relids</name></name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>|=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>ec_has_const</name></name></expr>;</expr_stmt>
		<comment type="block">/* can't need to set has_volatile */</comment>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>|=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_min_security</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>,
								   <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_max_security</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_max_security</name></name></expr></argument>,
								   <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_max_security</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_merged</name></name> <operator>=</operator> <name>ec1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>ec2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* just to avoid debugging confusion w/ dangling pointers: */</comment>
		<expr_stmt><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_derives</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_sources</name></name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>|=</operator> <name>below_outer_join</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_min_security</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>,
								   <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_max_security</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_max_security</name></name></expr></argument>,
								   <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* mark the RI as associated with this eclass */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>=</operator> <name>ec1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>=</operator> <name>ec1</name></expr>;</expr_stmt>
		<comment type="block">/* mark the RI as usable with this pair of EMs */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>em1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>em2</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ec1</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Case 3: add item2 to ec1 */</comment>
		<expr_stmt><expr><name>em2</name> <operator>=</operator> <call><name>add_eq_member</name><argument_list>(<argument><expr><name>ec1</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>, <argument><expr><name>item2_relids</name></expr></argument>, <argument><expr><name>item2_nullable_relids</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>item2_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_sources</name></name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>|=</operator> <name>below_outer_join</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_min_security</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>,
								   <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_max_security</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>ec_max_security</name></name></expr></argument>,
								   <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* mark the RI as associated with this eclass */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>=</operator> <name>ec1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>=</operator> <name>ec1</name></expr>;</expr_stmt>
		<comment type="block">/* mark the RI as usable with this pair of EMs */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>em1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>em2</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ec2</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Case 3: add item1 to ec2 */</comment>
		<expr_stmt><expr><name>em1</name> <operator>=</operator> <call><name>add_eq_member</name><argument_list>(<argument><expr><name>ec2</name></expr></argument>, <argument><expr><name>item1</name></expr></argument>, <argument><expr><name>item1_relids</name></expr></argument>, <argument><expr><name>item1_nullable_relids</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>item1_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_sources</name></name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>|=</operator> <name>below_outer_join</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_min_security</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>,
								   <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_max_security</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>ec_max_security</name></name></expr></argument>,
								   <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* mark the RI as associated with this eclass */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>=</operator> <name>ec2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>=</operator> <name>ec2</name></expr>;</expr_stmt>
		<comment type="block">/* mark the RI as usable with this pair of EMs */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>em1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>em2</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Case 4: make a new, two-entry EC */</comment>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>EquivalenceClass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name> <operator>=</operator> <name>opfamilies</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_derives</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>=</operator> <name>below_outer_join</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_min_security</name></name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_max_security</name></name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_merged</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>em1</name> <operator>=</operator> <call><name>add_eq_member</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>item1</name></expr></argument>, <argument><expr><name>item1_relids</name></expr></argument>, <argument><expr><name>item1_nullable_relids</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>item1_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>em2</name> <operator>=</operator> <call><name>add_eq_member</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>, <argument><expr><name>item2_relids</name></expr></argument>, <argument><expr><name>item2_nullable_relids</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>item2_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* mark the RI as associated with this eclass */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>
		<comment type="block">/* mark the RI as usable with this pair of EMs */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>em1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>em2</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * canonicalize_ec_expression
 *
 * This function ensures that the expression exposes the expected type and
 * collation, so that it will be equal() to other equivalence-class expressions
 * that it ought to be equal() to.
 *
 * The rule for datatypes is that the exposed type should match what it would
 * be for an input to an operator of the EC's opfamilies; which is usually
 * the declared input type of the operator, but in the case of polymorphic
 * operators no relabeling is wanted (compare the behavior of parse_coerce.c).
 * Expressions coming in from quals will generally have the right type
 * already, but expressions coming from indexkeys may not (because they are
 * represented without any explicit relabel in pg_index), and the same problem
 * occurs for sort expressions (because the parser is likewise cavalier about
 * putting relabels on them).  Such cases will be binary-compatible with the
 * real operators, so adding a RelabelType is sufficient.
 *
 * Also, the expression's exposed collation must match the EC's collation.
 * This is important because in comparisons like "foo &lt; bar COLLATE baz",
 * only one of the expressions has the correct exposed collation as we receive
 * it from the parser.  Forcing both of them to have it ensures that all
 * variant spellings of such a construct behave the same.  Again, we can
 * stick on a RelabelType to force the right exposed collation.  (It might
 * work to not label the collation at all in EC members, but this is risky
 * since some parts of the system expect exprCollation() to deliver the
 * right answer for a sort key.)
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>canonicalize_ec_expression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>req_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>req_collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>expr_type</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For a polymorphic-input-type opclass, just keep the same exposed type.
	 * RECORD opclasses work like polymorphic-type ones for this purpose.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>req_type</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>req_type</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>req_type</name> <operator>=</operator> <name>expr_type</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No work if the expression exposes the right type/collation already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expr_type</name> <operator>!=</operator> <name>req_type</name> <operator>||</operator>
		<call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>req_collation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we have to change the type of the expression, set typmod to -1,
		 * since the new type may not have the same typmod interpretation.
		 * When we only have to change collation, preserve the exposed typmod.
		 */</comment>
		<decl_stmt><decl><type><name>int32</name></type>		<name>req_typmod</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>expr_type</name> <operator>!=</operator> <name>req_type</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>req_typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>req_typmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Use applyRelabelType so that we preserve const-flatness.  This is
		 * important since eval_const_expressions has already been applied.
		 */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>applyRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
										 <argument><expr><name>req_type</name></expr></argument>, <argument><expr><name>req_typmod</name></expr></argument>, <argument><expr><name>req_collation</name></expr></argument>,
										 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_eq_member - build a new EquivalenceMember and add it to an EC
 */</comment>
<function><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type>
<name>add_eq_member</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
			  <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_child</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datatype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>EquivalenceMember</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name> <operator>=</operator> <name>relids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name> <operator>=</operator> <name>nullable_relids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>=</operator> <name>is_child</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name> <operator>=</operator> <name>datatype</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No Vars, assume it's a pseudoconstant.  This is correct for entries
		 * generated from process_equivalence(), because a WHERE clause can't
		 * contain aggregates or SRFs, and non-volatility was checked before
		 * process_equivalence() ever got called.  But
		 * get_eclass_for_sort_expr() has to work harder.  We put the tests
		 * there not here to save cycles in the equivalence case.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* it can't affect ec_relids */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_child</name></expr>)</condition>			<comment type="block">/* child members don't add to ec_relids */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>em</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_eclass_for_sort_expr
 *	  Given an expression and opfamily/collation info, find an existing
 *	  equivalence class it is a member of; if none, optionally build a new
 *	  single-member EquivalenceClass for it.
 *
 * expr is the expression, and nullable_relids is the set of base relids
 * that are potentially nullable below it.  We actually only care about
 * the set of such relids that are used in the expression; but for caller
 * convenience, we perform that intersection step here.  The caller need
 * only be sure that nullable_relids doesn't omit any nullable rels that
 * might appear in the expr.
 *
 * sortref is the SortGroupRef of the originating SortGroupClause, if any,
 * or zero if not.  (It should never be zero if the expression is volatile!)
 *
 * If rel is not NULL, it identifies a specific relation we're considering
 * a path for, and indicates that child EC members for that relation can be
 * considered.  Otherwise child members are ignored.  (Note: since child EC
 * members aren't guaranteed unique, a non-NULL value means that there could
 * be more than one EC that matches the expression; if so it's order-dependent
 * which one you get.  This is annoying but it only happens in corner cases,
 * so for now we live with just reporting the first match.  See also
 * generate_implied_equalities_for_column and match_pathkeys_to_index.)
 *
 * If create_it is true, we'll build a new EquivalenceClass when there is no
 * match.  If create_it is false, we just return NULL when no match.
 *
 * This can be used safely both before and after EquivalenceClass merging;
 * since it never causes merging it does not invalidate any existing ECs
 * or PathKeys.  However, ECs added after path generation has begun are
 * of limited usefulness, so usually it's best to create them beforehand.
 *
 * Note: opfamilies must be chosen consistently with the way
 * process_equivalence() would do; that is, generated from a mergejoinable
 * equality operator.  Else we might fail to detect valid equivalences,
 * generating poor (but not incorrect) plans.
 */</comment>
<function><type><name>EquivalenceClass</name> <modifier>*</modifier></type>
<name>get_eclass_for_sort_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilies</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>opcintype</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
						 <parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>create_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>expr_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>newec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>newem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure the expression exposes the correct type and collation.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>canonicalize_ec_expression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan through the existing EquivalenceClasses for a match
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>root-&gt;eq_classes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Never match to a volatile EC, except when we are looking at another
		 * reference to the same volatile SortGroupClause.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>sortref</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>sortref</name> <operator>!=</operator> <name><name>cur_ec</name><operator>-&gt;</operator><name>ec_sortref</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>!=</operator> <name><name>cur_ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>, <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>cur_ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Ignore child members unless they match the request.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If below an outer join, don't match constants: they're not as
			 * constant as they look.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>&amp;&amp;</operator>
				<name><name>cur_em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>opcintype</name> <operator>==</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>cur_ec</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* Match! */</comment>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/* No match; does caller want a NULL result? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>create_it</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * OK, build a new single-member EC
	 *
	 * Here, we must be sure that we construct the EC in the right context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>EquivalenceClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_derives</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>=</operator> <call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_broken</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>=</operator> <name>sortref</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_min_security</name></name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_max_security</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_merged</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>&amp;&amp;</operator> <name>sortref</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"volatile EquivalenceClass has no sortref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the precise set of nullable relids appearing in the expression.
	 */</comment>
	<expr_stmt><expr><name>expr_relids</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullable_relids</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name>nullable_relids</name></expr></argument>, <argument><expr><name>expr_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newem</name> <operator>=</operator> <call><name>add_eq_member</name><argument_list>(<argument><expr><name>newec</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expr_relids</name></expr></argument>,
						  <argument><expr><name>nullable_relids</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * add_eq_member doesn't check for volatile functions, set-returning
	 * functions, aggregates, or window functions, but such could appear in
	 * sort expressions; so we have to check whether its const-marking was
	 * correct.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_const</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>||</operator>
			<call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>contain_agg_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>contain_window_function</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newem</name><operator>-&gt;</operator><name>em_is_const</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>newec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If EC merging is already complete, we have to mop up by adding the new
	 * EC to the eclass_indexes of the relation(s) mentioned in it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>ec_merging_done</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ec_index</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>||</operator>
				   <name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_DEADREL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>,
												 <argument><expr><name>ec_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_ec_member_matching_expr
 *		Locate an EquivalenceClass member matching the given expr, if any;
 *		return NULL if no match.
 *
 * "Matching" is defined as "equal after stripping RelabelTypes".
 * This is used for identifying sort expressions, and we need to allow
 * binary-compatible relabeling for some cases involving binary-compatible
 * sort operators.
 *
 * Child EC members are ignored unless they belong to given 'relids'.
 */</comment>
<function><type><name>EquivalenceMember</name> <modifier>*</modifier></type>
<name>find_ec_member_matching_expr</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
							 <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
							 <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* We ignore binary-compatible relabeling on both ends */</comment>
	<while>while <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>emexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We shouldn't be trying to sort by an equivalence class that
		 * contains a constant, so no need to consider such cases any further.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore child members unless they belong to the requested rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Match if same expression (after stripping relabel).
		 */</comment>
		<expr_stmt><expr><name>emexpr</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>emexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>emexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>emexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>emexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>emexpr</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>em</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_computable_ec_member
 *		Locate an EquivalenceClass member that can be computed from the
 *		expressions appearing in "exprs"; return NULL if no match.
 *
 * "exprs" can be either a list of bare expression trees, or a list of
 * TargetEntry nodes.  Either way, it should contain Vars and possibly
 * Aggrefs and WindowFuncs, which are matched to the corresponding elements
 * of the EquivalenceClass's expressions.
 *
 * Unlike find_ec_member_matching_expr, there's no special provision here
 * for binary-compatible relabeling.  This is intentional: if we have to
 * compute an expression in this way, setrefs.c is going to insist on exact
 * matches of Vars to the source tlist.
 *
 * Child EC members are ignored unless they belong to given 'relids'.
 * Also, non-parallel-safe expressions are ignored if 'require_parallel_safe'.
 *
 * Note: some callers pass root == NULL for notational reasons.  This is OK
 * when require_parallel_safe is false.
 */</comment>
<function><type><name>EquivalenceMember</name> <modifier>*</modifier></type>
<name>find_computable_ec_member</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>,
						  <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>require_parallel_safe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>exprvars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We shouldn't be trying to sort by an equivalence class that
		 * contains a constant, so no need to consider such cases any further.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore child members unless they belong to the requested rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Match if all Vars and quasi-Vars are available in "exprs".
		 */</comment>
		<expr_stmt><expr><name>exprvars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
								   <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
								   <name>PVC_INCLUDE_WINDOWFUNCS</name> <operator>|</operator>
								   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>exprvars</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_exprlist_member</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>exprvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lc2</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* we hit a non-available Var */</comment>

		<comment type="block">/*
		 * If requested, reject expressions that are not parallel-safe.  We
		 * check this last because it's a rather expensive test.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>require_parallel_safe</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<return>return <expr><name>em</name></expr>;</return>				<comment type="block">/* found usable expression */</comment>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_exprlist_member
 *	  Subroutine for find_computable_ec_member: is "node" in "exprs"?
 *
 * Per the requirements of that function, "exprs" might or might not have
 * TargetEntry superstructure.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_exprlist_member</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find an equivalence class member expression, all of whose Vars, come from
 * the indicated relation.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>find_em_expr_for_rel</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc_em</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc_em</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_em</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there is more than one equivalence member whose Vars are
			 * taken entirely from this relation, we'll be content to choose
			 * any one of those.
			 */</comment>
			<return>return <expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* We didn't find any suitable equivalence class expression */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find an equivalence class member expression that can be used to build
 * a sort node using the provided relation; return NULL if no candidate.
 *
 * To succeed, we must find an EC member that prepare_sort_from_pathkeys knows
 * how to sort on, given the rel's reltarget as input.  There are also a few
 * additional constraints based on the fact that the desired sort will be done
 * within the scan/join part of the plan.  Also, non-parallel-safe expressions
 * are ignored if 'require_parallel_safe'.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>find_em_expr_usable_for_sorting_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>require_parallel_safe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reject volatile ECs immediately; such sorts must always be postponed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Try to find an EM directly matching some reltarget member.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>targetexpr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_ec_member_matching_expr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>targetexpr</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>em</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Reject expressions involving set-returning functions, as those
		 * can't be computed early either.  (Note: this test and the following
		 * one are effectively checking properties of targetexpr, so there's
		 * no point in asking whether some other EC member would be better.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If requested, reject expressions that are not parallel-safe.  We
		 * check this last because it's a rather expensive test.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>require_parallel_safe</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<return>return <expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</return>
	</block_content>}</block>

	<comment type="block">/*
	 * Try to find a expression computable from the reltarget.
	 */</comment>
	<expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_computable_ec_member</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
								   <argument><expr><name>require_parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>em</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Reject expressions involving set-returning functions, as those can't be
	 * computed early either.  (There's no point in looking for another EC
	 * member in this case; since SRFs can't appear in WHERE, they cannot
	 * belong to multi-member ECs.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_base_implied_equalities
 *	  Generate any restriction clauses that we can deduce from equivalence
 *	  classes.
 *
 * When an EC contains pseudoconstants, our strategy is to generate
 * "member = const1" clauses where const1 is the first constant member, for
 * every other member (including other constants).  If we are able to do this
 * then we don't need any "var = var" comparisons because we've successfully
 * constrained all the vars at their points of creation.  If we fail to
 * generate any of these clauses due to lack of cross-type operators, we fall
 * back to the "ec_broken" strategy described below.  (XXX if there are
 * multiple constants of different types, it's possible that we might succeed
 * in forming all the required clauses if we started from a different const
 * member; but this seems a sufficiently hokey corner case to not be worth
 * spending lots of cycles on.)
 *
 * For ECs that contain no pseudoconstants, we generate derived clauses
 * "member1 = member2" for each pair of members belonging to the same base
 * relation (actually, if there are more than two for the same base relation,
 * we only need enough clauses to link each to each other).  This provides
 * the base case for the recursion: each row emitted by a base relation scan
 * will constrain all computable members of the EC to be equal.  As each
 * join path is formed, we'll add additional derived clauses on-the-fly
 * to maintain this invariant (see generate_join_implied_equalities).
 *
 * If the opfamilies used by the EC do not provide complete sets of cross-type
 * equality operators, it is possible that we will fail to generate a clause
 * that must be generated to maintain the invariant.  (An example: given
 * "WHERE a.x = b.y AND b.y = a.z", the scheme breaks down if we cannot
 * generate "a.x = a.z" as a restriction clause for A.)  In this case we mark
 * the EC "ec_broken" and fall back to regurgitating its original source
 * RestrictInfos at appropriate times.  We do not try to retract any derived
 * clauses already generated from the broken EC, so the resulting plan could
 * be poor due to bad selectivity estimates caused by redundant clauses.  But
 * the correct solution to that is to fix the opfamilies ...
 *
 * Equality clauses derived by this function are passed off to
 * process_implied_equality (in plan/initsplan.c) to be inserted into the
 * restrictinfo datastructures.  Note that this must be called after initial
 * scanning of the quals and before Path construction begins.
 *
 * We make no attempt to avoid generating duplicate RestrictInfos here: we
 * don't search ec_sources for matches, nor put the created RestrictInfos
 * into ec_derives.  Doing so would require some slightly ugly changes in
 * initsplan.c's API, and there's no real advantage, because the clauses
 * generated here can't duplicate anything we will generate for joins anyway.
 */</comment>
<function><type><name>void</name></type>
<name>generate_base_implied_equalities</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ec_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * At this point, we're done absorbing knowledge of equivalences in the
	 * query, so no further EC merging should happen, and ECs remaining in the
	 * eq_classes list can be considered canonical.  (But note that it's still
	 * possible for new single-member ECs to be added through
	 * get_eclass_for_sort_expr().)
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>ec_merging_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ec_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;eq_classes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>can_generate_joinclause</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_merged</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else shouldn't be in list */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* not yet anyway... */</comment>

		<comment type="block">/*
		 * Generate implied equalities that are restriction clauses.
		 * Single-member ECs won't generate any deductions, either here or at
		 * the join level.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_const</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>generate_base_implied_equalities_const</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>generate_base_implied_equalities_no_const</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Recover if we failed to generate required derived clauses */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>generate_base_implied_equalities_broken</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Detect whether this EC might generate join clauses */</comment>
			<expr_stmt><expr><name>can_generate_joinclause</name> <operator>=</operator>
				<operator>(</operator><call><name>bms_membership</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BMS_MULTIPLE</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Mark the base rels cited in each eclass (which should all exist by
		 * now) with the eq_classes indexes of all eclasses mentioning them.
		 * This will let us avoid searching in subsequent lookups.  While
		 * we're at it, we can mark base rels that have pending eclass joins;
		 * this is a cheap version of has_relevant_eclass_joinclause().
		 */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>,
												 <argument><expr><name>ec_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>can_generate_joinclause</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><name>ec_index</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * generate_base_implied_equalities when EC contains pseudoconstant(s)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_base_implied_equalities_const</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									   <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>const_em</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In the trivial case where we just had one "var = const" clause, push
	 * the original clause back into the main planner machinery.  There is
	 * nothing to be gained by doing it differently, and we save the effort to
	 * re-build and re-analyze an equality clause that will be exactly
	 * equivalent to the old one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sources</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sources</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_MULTIPLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the constant member to use.  We prefer an actual constant to
	 * pseudo-constants (such as Params), because the constraint exclusion
	 * machinery might be able to exclude relations on the basis of generated
	 * "var = const" equalities, but "var = param" won't work for that.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>const_em</name> <operator>=</operator> <name>cur_em</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>const_em</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Generate a derived equality against each other member */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_op</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no children yet */</comment>
		<if_stmt><if>if <condition>(<expr><name>cur_em</name> <operator>==</operator> <name>const_em</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>eq_op</name> <operator>=</operator> <call><name>select_equality_operator</name><argument_list>(<argument><expr><name>ec</name></expr></argument>,
										 <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>,
										 <argument><expr><name><name>const_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eq_op</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* failed... */</comment>
			<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>process_implied_equality</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>eq_op</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></argument>,
								 <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name><name>const_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
								 <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr></argument>,
										   <argument><expr><name><name>const_em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>,
								 <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name></expr></argument>,
								 <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * generate_base_implied_equalities when EC contains no pseudoconstants
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_base_implied_equalities_no_const</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										  <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier><modifier>*</modifier></type><name>prev_ems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We scan the EC members once and track the last-seen member for each
	 * base relation.  When we see another member of the same base relation,
	 * we generate "prev_em = cur_em".  This results in the minimum number of
	 * derived clauses, but it's possible that it will fail when a different
	 * ordering would succeed.  XXX FIXME: use a UNION-FIND algorithm similar
	 * to the way we build merged ECs.  (Use a list-of-lists for each rel.)
	 */</comment>
	<expr_stmt><expr><name>prev_ems</name> <operator>=</operator> <operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EquivalenceMember</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>relid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no children yet */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_get_singleton_member</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>prev_ems</name><index>[<expr><name>relid</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>prev_em</name> <init>= <expr><name><name>prev_ems</name><index>[<expr><name>relid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_op</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>eq_op</name> <operator>=</operator> <call><name>select_equality_operator</name><argument_list>(<argument><expr><name>ec</name></expr></argument>,
											 <argument><expr><name><name>prev_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>,
											 <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eq_op</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* failed... */</comment>
				<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>process_implied_equality</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>eq_op</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></argument>,
									 <argument><expr><name><name>prev_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
									 <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>prev_em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr></argument>,
											   <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>,
									 <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>prev_ems</name><index>[<expr><name>relid</name></expr>]</index></name> <operator>=</operator> <name>cur_em</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prev_ems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We also have to make sure that all the Vars used in the member clauses
	 * will be available at any join node we might try to reference them at.
	 * For the moment we force all the Vars to be available at all join nodes
	 * for this eclass.  Perhaps this could be improved by doing some
	 * pre-analysis of which members we prefer to join, but it's no worse than
	 * what happened in the pre-8.3 code.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
										   <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
										   <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
										   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>add_vars_to_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * generate_base_implied_equalities cleanup after failure
 *
 * What we must do here is push any zero- or one-relation source RestrictInfos
 * of the EC back into the main restrictinfo datastructures.  Multi-relation
 * clauses will be regurgitated later by generate_join_implied_equalities().
 * (We do it this way to maintain continuity with the case that ec_broken
 * becomes set only after we've gone up a join level or two.)  However, for
 * an EC that contains constants, we can adopt a simpler strategy and just
 * throw back all the source RestrictInfos immediately; that works because
 * we know that such an EC can't become broken later.  (This rule justifies
 * ignoring ec_has_const ECs in generate_join_implied_equalities, even when
 * they are broken.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_base_implied_equalities_broken</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_sources</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>||</operator>
			<call><name>bms_membership</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_MULTIPLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * generate_join_implied_equalities
 *	  Generate any join clauses that we can deduce from equivalence classes.
 *
 * At a join node, we must enforce restriction clauses sufficient to ensure
 * that all equivalence-class members computable at that node are equal.
 * Since the set of clauses to enforce can vary depending on which subset
 * relations are the inputs, we have to compute this afresh for each join
 * relation pair.  Hence a fresh List of RestrictInfo nodes is built and
 * passed back on each call.
 *
 * In addition to its use at join nodes, this can be applied to generate
 * eclass-based join clauses for use in a parameterized scan of a base rel.
 * The reason for the asymmetry of specifying the inner rel as a RelOptInfo
 * and the outer rel by Relids is that this usage occurs before we have
 * built any join RelOptInfos.
 *
 * An annoying special case for parameterized scans is that the inner rel can
 * be an appendrel child (an "other rel").  In this case we must generate
 * appropriate clauses using child EC members.  add_child_rel_equivalences
 * must already have been done for the child rel.
 *
 * The results are sufficient for use in merge, hash, and plain nestloop join
 * methods.  We do not worry here about selecting clauses that are optimal
 * for use in a parameterized indexscan.  indxpath.c makes its own selections
 * of clauses to use, and if the ones we pick here are redundant with those,
 * the extras will be eliminated at createplan time, using the parent_ec
 * markers that we provide (see is_redundant_derived_clause()).
 *
 * Because the same join clauses are likely to be needed multiple times as
 * we consider different join paths, we avoid generating multiple copies:
 * whenever we select a particular pair of EquivalenceMembers to join,
 * we check to see if the pair matches any original clause (in ec_sources)
 * or previously-built clause (in ec_derives).  This saves memory and allows
 * re-use of information cached in RestrictInfos.
 *
 * join_relids should always equal bms_union(outer_relids, inner_rel-&gt;relids).
 * We could simplify this function's API by computing it internally, but in
 * most current uses, the caller has the value at hand anyway.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>generate_join_implied_equalities</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>Relids</name></type> <name>join_relids</name></decl></parameter>,
								 <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_relids</name> <init>= <expr><name><name>inner_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>nominal_inner_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>nominal_join_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>matching_ecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* If inner rel is a child, extra setup work is needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fetch relid set for the topmost parent rel */</comment>
		<expr_stmt><expr><name>nominal_inner_relids</name> <operator>=</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>;</expr_stmt>
		<comment type="block">/* ECs will be marked with the parent's relid, not the child's */</comment>
		<expr_stmt><expr><name>nominal_join_relids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>outer_relids</name></expr></argument>, <argument><expr><name>nominal_inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nominal_inner_relids</name> <operator>=</operator> <name>inner_relids</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nominal_join_relids</name> <operator>=</operator> <name>join_relids</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Get all eclasses that mention both inner and outer sides of the join
	 */</comment>
	<expr_stmt><expr><name>matching_ecs</name> <operator>=</operator> <call><name>get_common_eclass_indexes</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>nominal_inner_relids</name></expr></argument>,
											 <argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>matching_ecs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ECs containing consts do not need any further enforcement */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Single-member ECs won't generate any deductions */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Sanity check that this eclass overlaps the join */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name>nominal_join_relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>generate_join_implied_equalities_normal</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>ec</name></expr></argument>,
															  <argument><expr><name>join_relids</name></expr></argument>,
															  <argument><expr><name>outer_relids</name></expr></argument>,
															  <argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Recover if we failed to generate required derived clauses */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>generate_join_implied_equalities_broken</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>ec</name></expr></argument>,
															  <argument><expr><name>nominal_join_relids</name></expr></argument>,
															  <argument><expr><name>outer_relids</name></expr></argument>,
															  <argument><expr><name>nominal_inner_relids</name></expr></argument>,
															  <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_join_implied_equalities_for_ecs
 *	  As above, but consider only the listed ECs.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>generate_join_implied_equalities_for_ecs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>eclasses</name></decl></parameter>,
										 <parameter><decl><type><name>Relids</name></type> <name>join_relids</name></decl></parameter>,
										 <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
										 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_relids</name> <init>= <expr><name><name>inner_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>nominal_inner_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>nominal_join_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* If inner rel is a child, extra setup work is needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fetch relid set for the topmost parent rel */</comment>
		<expr_stmt><expr><name>nominal_inner_relids</name> <operator>=</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>;</expr_stmt>
		<comment type="block">/* ECs will be marked with the parent's relid, not the child's */</comment>
		<expr_stmt><expr><name>nominal_join_relids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>outer_relids</name></expr></argument>, <argument><expr><name>nominal_inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nominal_inner_relids</name> <operator>=</operator> <name>inner_relids</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nominal_join_relids</name> <operator>=</operator> <name>join_relids</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>eclasses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ECs containing consts do not need any further enforcement */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Single-member ECs won't generate any deductions */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* We can quickly ignore any that don't overlap the join, too */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name>nominal_join_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>generate_join_implied_equalities_normal</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>ec</name></expr></argument>,
															  <argument><expr><name>join_relids</name></expr></argument>,
															  <argument><expr><name>outer_relids</name></expr></argument>,
															  <argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Recover if we failed to generate required derived clauses */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sublist</name> <operator>=</operator> <call><name>generate_join_implied_equalities_broken</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>ec</name></expr></argument>,
															  <argument><expr><name>nominal_join_relids</name></expr></argument>,
															  <argument><expr><name>outer_relids</name></expr></argument>,
															  <argument><expr><name>nominal_inner_relids</name></expr></argument>,
															  <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_join_implied_equalities for a still-valid EC
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_join_implied_equalities_normal</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
										<parameter><decl><type><name>Relids</name></type> <name>join_relids</name></decl></parameter>,
										<parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
										<parameter><decl><type><name>Relids</name></type> <name>inner_relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_members</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outer_members</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inner_members</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, scan the EC to identify member values that are computable at the
	 * outer rel, at the inner rel, or at this relation but not in either
	 * input rel.  The outer-rel members should already be enforced equal,
	 * likewise for the inner-rel members.  We'll need to create clauses to
	 * enforce that any newly computable members are all equal to each other
	 * as well as to at least one input member, plus enforce at least one
	 * outer-rel member equal to at least one inner-rel member.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We don't need to check explicitly for child EC members.  This test
		 * against join_relids will cause them to be ignored except when
		 * considering a child inner rel, which is what we want.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>join_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* not computable yet, or wrong child */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>outer_members</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>outer_members</name></expr></argument>, <argument><expr><name>cur_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inner_members</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>inner_members</name></expr></argument>, <argument><expr><name>cur_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_members</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_members</name></expr></argument>, <argument><expr><name>cur_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * First, select the joinclause if needed.  We can equate any one outer
	 * member to any one inner member, but we have to find a datatype
	 * combination for which an opfamily member operator exists.  If we have
	 * choices, we prefer simple Var members (possibly with RelabelType) since
	 * these are (a) cheapest to compute at runtime and (b) most likely to
	 * have useful statistics. Also, prefer operators that are also
	 * hashjoinable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_members</name> <operator>&amp;&amp;</operator> <name>inner_members</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>best_outer_em</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>best_inner_em</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>best_eq_op</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_score</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>outer_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>outer_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>inner_members</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>inner_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_op</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>score</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>eq_op</name> <operator>=</operator> <call><name>select_equality_operator</name><argument_list>(<argument><expr><name>ec</name></expr></argument>,
												 <argument><expr><name><name>outer_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>,
												 <argument><expr><name><name>inner_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eq_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>outer_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>outer_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name><name>outer_em</name><operator>-&gt;</operator><name>em_expr</name></name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>score</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>inner_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>inner_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name><name>inner_em</name><operator>-&gt;</operator><name>em_expr</name></name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>score</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name>eq_op</name></expr></argument>,
									<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>outer_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>score</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&gt;</operator> <name>best_score</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>best_outer_em</name> <operator>=</operator> <name>outer_em</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_inner_em</name> <operator>=</operator> <name>inner_em</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_eq_op</name> <operator>=</operator> <name>eq_op</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_score</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>best_score</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* no need to look further */</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>best_score</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* no need to look further */</comment>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>best_score</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* failed... */</comment>
			<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Create clause, setting parent_ec to mark it as redundant with other
		 * joinclauses
		 */</comment>
		<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <call><name>create_join_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>, <argument><expr><name>best_eq_op</name></expr></argument>,
								   <argument><expr><name>best_outer_em</name></expr></argument>, <argument><expr><name>best_inner_em</name></expr></argument>,
								   <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now deal with building restrictions for any expressions that involve
	 * Vars from both sides of the join.  We have to equate all of these to
	 * each other as well as to at least one old member (if any).
	 *
	 * XXX as in generate_base_implied_equalities_no_const, we could be a lot
	 * smarter here to avoid unnecessary failures in cross-type situations.
	 * For now, use the same left-to-right method used there.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_members</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>old_members</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>outer_members</name></expr></argument>, <argument><expr><name>inner_members</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>prev_em</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl>;</decl_stmt>

		<comment type="block">/* For now, arbitrarily take the first old_member as the one to use */</comment>
		<if_stmt><if>if <condition>(<expr><name>old_members</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_members</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_members</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>old_members</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>new_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>prev_em</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_op</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>eq_op</name> <operator>=</operator> <call><name>select_equality_operator</name><argument_list>(<argument><expr><name>ec</name></expr></argument>,
												 <argument><expr><name><name>prev_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>,
												 <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eq_op</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* failed... */</comment>
					<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_broken</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>NIL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* do NOT set parent_ec, this qual is not redundant! */</comment>
				<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <call><name>create_join_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>, <argument><expr><name>eq_op</name></expr></argument>,
										   <argument><expr><name>prev_em</name></expr></argument>, <argument><expr><name>cur_em</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>prev_em</name> <operator>=</operator> <name>cur_em</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_join_implied_equalities cleanup after failure
 *
 * Return any original RestrictInfos that are enforceable at this join.
 *
 * In the case of a child inner relation, we have to translate the
 * original RestrictInfos from parent to child Vars.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_join_implied_equalities_broken</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
										<parameter><decl><type><name>Relids</name></type> <name>nominal_join_relids</name></decl></parameter>,
										<parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
										<parameter><decl><type><name>Relids</name></type> <name>nominal_inner_relids</name></decl></parameter>,
										<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_sources</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>clause_relids</name> <init>= <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>, <argument><expr><name>nominal_join_relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>, <argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>, <argument><expr><name>nominal_inner_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we have to translate, just brute-force apply adjust_appendrel_attrs
	 * to all the RestrictInfos at once.  This will result in returning
	 * RestrictInfos that are not listed in ec_derives, but there shouldn't be
	 * any duplication, and it's a sufficiently narrow corner case that we
	 * shouldn't sweat too much over it anyway.
	 *
	 * Since inner_rel might be an indirect descendant of the baserel
	 * mentioned in the ec_sources clauses, we have to be prepared to apply
	 * multiple levels of Var translation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>adjust_appendrel_attrs_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>,
															<argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
															<argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * select_equality_operator
 *	  Select a suitable equality operator for comparing two EC members
 *
 * Returns InvalidOid if no operator can be found for this datatype combination
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>select_equality_operator</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>righttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_opfamilies</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>opno</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>lefttype</name></expr></argument>, <argument><expr><name>righttype</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* If no barrier quals in query, don't worry about leaky operators */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_max_security</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>opno</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Otherwise, insist that selected operators be leakproof */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_func_leakproof</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>opno</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * create_join_clause
 *	  Find or make a RestrictInfo comparing the two given EC members
 *	  with the given operator.
 *
 * parent_ec is either equal to ec (if the clause is a potentially-redundant
 * join clause) or NULL (if not).  We have to treat this as part of the
 * match requirements --- it's possible that a clause comparing the same two
 * EMs is a join clause in one join path and a restriction clause in another.
 */</comment>
<function><type><specifier>static</specifier> <name>RestrictInfo</name> <modifier>*</modifier></type>
<name>create_join_clause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
				   <parameter><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>leftem</name></decl></parameter>,
				   <parameter><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>rightem</name></decl></parameter>,
				   <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>parent_ec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search to see if we already built a RestrictInfo for this pair of
	 * EquivalenceMembers.  We can use either original source clauses or
	 * previously-derived clauses.  The check on opno is probably redundant,
	 * but be safe ...
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_sources</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>==</operator> <name>leftem</name> <operator>&amp;&amp;</operator>
			<name><name>rinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>==</operator> <name>rightem</name> <operator>&amp;&amp;</operator>
			<name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name> <operator>==</operator> <name>parent_ec</name> <operator>&amp;&amp;</operator>
			<name>opno</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rinfo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_derives</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>==</operator> <name>leftem</name> <operator>&amp;&amp;</operator>
			<name><name>rinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>==</operator> <name>rightem</name> <operator>&amp;&amp;</operator>
			<name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name> <operator>==</operator> <name>parent_ec</name> <operator>&amp;&amp;</operator>
			<name>opno</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rinfo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Not there, so build it, in planner context so we can re-use it. (Not
	 * important in normal planning, but definitely so in GEQO.)
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <call><name>build_implied_join_equality</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>opno</name></expr></argument>,
										<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></argument>,
										<argument><expr><name><name>leftem</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
										<argument><expr><name><name>rightem</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
										<argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>leftem</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>,
												  <argument><expr><name><name>rightem</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>leftem</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr></argument>,
												  <argument><expr><name><name>rightem</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the clause as redundant, or not */</comment>
	<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name> <operator>=</operator> <name>parent_ec</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We know the correct values for left_ec/right_ec, ie this particular EC,
	 * so we can just set them directly instead of forcing another lookup.
	 */</comment>
	<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>

	<comment type="block">/* Mark it as usable with these EMs */</comment>
	<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>leftem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>rightem</name></expr>;</expr_stmt>
	<comment type="block">/* and save it for possible re-use */</comment>
	<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_derives</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_derives</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rinfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * reconsider_outer_join_clauses
 *	  Re-examine any outer-join clauses that were set aside by
 *	  distribute_qual_to_rels(), and see if we can derive any
 *	  EquivalenceClasses from them.  Then, if they were not made
 *	  redundant, push them out into the regular join-clause lists.
 *
 * When we have mergejoinable clauses A = B that are outer-join clauses,
 * we can't blindly combine them with other clauses A = C to deduce B = C,
 * since in fact the "equality" A = B won't necessarily hold above the
 * outer join (one of the variables might be NULL instead).  Nonetheless
 * there are cases where we can add qual clauses using transitivity.
 *
 * One case that we look for here is an outer-join clause OUTERVAR = INNERVAR
 * for which there is also an equivalence clause OUTERVAR = CONSTANT.
 * It is safe and useful to push a clause INNERVAR = CONSTANT into the
 * evaluation of the inner (nullable) relation, because any inner rows not
 * meeting this condition will not contribute to the outer-join result anyway.
 * (Any outer rows they could join to will be eliminated by the pushed-down
 * equivalence clause.)
 *
 * Note that the above rule does not work for full outer joins; nor is it
 * very interesting to consider cases where the generated equivalence clause
 * would involve relations outside the outer join, since such clauses couldn't
 * be pushed into the inner side's scan anyway.  So the restriction to
 * outervar = pseudoconstant is not really giving up anything.
 *
 * For full-join cases, we can only do something useful if it's a FULL JOIN
 * USING and a merged column has an equivalence MERGEDVAR = CONSTANT.
 * By the time it gets here, the merged column will look like
 *		COALESCE(LEFTVAR, RIGHTVAR)
 * and we will have a full-join clause LEFTVAR = RIGHTVAR that we can match
 * the COALESCE expression to. In this situation we can push LEFTVAR = CONSTANT
 * and RIGHTVAR = CONSTANT into the input relations, since any rows not
 * meeting these conditions cannot contribute to the join result.
 *
 * Again, there isn't any traction to be gained by trying to deal with
 * clauses comparing a mergedvar to a non-pseudoconstant.  So we can make
 * use of the EquivalenceClasses to search for matching variables that were
 * equivalenced to constants.  The interesting outer-join clauses were
 * accumulated for us by distribute_qual_to_rels.
 *
 * When we find one of these cases, we implement the changes we want by
 * generating a new equivalence clause INNERVAR = CONSTANT (or LEFTVAR, etc)
 * and pushing it into the EquivalenceClass structures.  This is because we
 * may already know that INNERVAR is equivalenced to some other var(s), and
 * we'd like the constant to propagate to them too.  Note that it would be
 * unsafe to merge any existing EC for INNERVAR with the OUTERVAR's EC ---
 * that could result in propagating constant restrictions from
 * INNERVAR to OUTERVAR, which would be very wrong.
 *
 * It's possible that the INNERVAR is also an OUTERVAR for some other
 * outer-join clause, in which case the process can be repeated.  So we repeat
 * looping over the lists of clauses until no further deductions can be made.
 * Whenever we do make a deduction, we remove the generating clause from the
 * lists, since we don't want to make the same deduction twice.
 *
 * If we don't find any match for a set-aside outer join clause, we must
 * throw it back into the regular joinclause processing by passing it to
 * distribute_restrictinfo_to_rels().  If we do generate a derived clause,
 * however, the outer-join clause is redundant.  We still throw it back,
 * because otherwise the join will be seen as a clauseless join and avoided
 * during join order searching; but we mark it as redundant to keep from
 * messing up the joinrel's size estimate.  (This behavior means that the
 * API for this routine is uselessly complex: we could have just put all
 * the clauses into the regular processing initially.  We keep it because
 * someday we might want to do something else, such as inserting "dummy"
 * joinclauses instead of real ones.)
 *
 * Outer join clauses that are marked outerjoin_delayed are special: this
 * condition means that one or both VARs might go to null due to a lower
 * outer join.  We can still push a constant through the clause, but only
 * if its operator is strict; and we *have to* throw the clause back into
 * regular joinclause processing.  By keeping the strict join clause,
 * we ensure that any null-extended rows that are mistakenly generated due
 * to suppressing rows not matching the constant will be rejected at the
 * upper outer join.  (This doesn't work for full-join clauses.)
 */</comment>
<function><type><name>void</name></type>
<name>reconsider_outer_join_clauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* Outer loop repeats until we find no more deductions */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Process the LEFT JOIN clauses */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>root-&gt;left_join_clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>reconsider_outer_join_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* remove it from the list */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>left_join_clauses</name></name> <operator>=</operator>
					<call><name>foreach_delete_current</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>left_join_clauses</name></name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* we throw it back anyway (see notes above) */</comment>
				<comment type="block">/* but the thrown-back clause has no extra selectivity */</comment>
				<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>norm_selec</name></name> <operator>=</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_selec</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Process the RIGHT JOIN clauses */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>root-&gt;right_join_clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>reconsider_outer_join_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* remove it from the list */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>right_join_clauses</name></name> <operator>=</operator>
					<call><name>foreach_delete_current</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>right_join_clauses</name></name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* we throw it back anyway (see notes above) */</comment>
				<comment type="block">/* but the thrown-back clause has no extra selectivity */</comment>
				<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>norm_selec</name></name> <operator>=</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_selec</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Process the FULL JOIN clauses */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>root-&gt;full_join_clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>reconsider_full_join_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* remove it from the list */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>full_join_clauses</name></name> <operator>=</operator>
					<call><name>foreach_delete_current</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>full_join_clauses</name></name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* we throw it back anyway (see notes above) */</comment>
				<comment type="block">/* but the thrown-back clause has no extra selectivity */</comment>
				<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>norm_selec</name></name> <operator>=</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_selec</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block> while <condition>(<expr><name>found</name></expr>)</condition>;</do>

	<comment type="block">/* Now, any remaining clauses have to be thrown back */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>root-&gt;left_join_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>root-&gt;right_join_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>root-&gt;full_join_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>distribute_restrictinfo_to_rels</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * reconsider_outer_join_clauses for a single LEFT/RIGHT JOIN clause
 *
 * Returns true if we were able to propagate a constant through the clause.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>reconsider_outer_join_clause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>outer_on_left</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>outervar</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>innervar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>,
				<decl><type ref="prev"/><name>collation</name></decl>,
				<decl><type ref="prev"/><name>left_type</name></decl>,
				<decl><type ref="prev"/><name>right_type</name></decl>,
				<decl><type ref="prev"/><name>inner_datatype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_relids</name></decl>,
				<decl><type ref="prev"/><name>inner_nullable_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_opclause</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>

	<comment type="block">/* If clause is outerjoin_delayed, operator must be strict */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>outerjoin_delayed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>op_strict</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Extract needed info from the clause */</comment>
	<expr_stmt><expr><call><name>op_input_types</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>outer_on_left</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>outervar</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>innervar</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_datatype</name> <operator>=</operator> <name>right_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_relids</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>outervar</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>innervar</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_datatype</name> <operator>=</operator> <name>left_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_relids</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>inner_nullable_relids</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name>inner_relids</name></expr></argument>,
										  <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan EquivalenceClasses for a match to outervar */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>root-&gt;eq_classes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore EC unless it contains pseudoconstants */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Never match to a volatile EC */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* It has to match the outer-join clause as to semantics, too */</comment>
		<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>!=</operator> <name><name>cur_ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name></expr></argument>, <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Does it contain a match to outervar? */</comment>
		<expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>cur_ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no children yet */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>outervar</name></expr></argument>, <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* no match, so ignore this EC */</comment>

		<comment type="block">/*
		 * Yes it does!  Try to generate a clause INNERVAR = CONSTANT for each
		 * CONSTANT in the EC.  Note that we must succeed with at least one
		 * constant before we can decide to throw away the outer-join clause.
		 */</comment>
		<expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>cur_ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_op</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>newrinfo</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore non-const members */</comment>
			<expr_stmt><expr><name>eq_op</name> <operator>=</operator> <call><name>select_equality_operator</name><argument_list>(<argument><expr><name>cur_ec</name></expr></argument>,
											 <argument><expr><name>inner_datatype</name></expr></argument>,
											 <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eq_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* can't generate equality */</comment>
			<expr_stmt><expr><name>newrinfo</name> <operator>=</operator> <call><name>build_implied_join_equality</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>eq_op</name></expr></argument>,
												   <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></argument>,
												   <argument><expr><name>innervar</name></expr></argument>,
												   <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
												   <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>inner_nullable_relids</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>process_equivalence</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newrinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we were able to equate INNERVAR to any constant, report success.
		 * Otherwise, fall out of the search loop, since we know the OUTERVAR
		 * appears in at most one EC.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* failed to make any deduction */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * reconsider_outer_join_clauses for a single FULL JOIN clause
 *
 * Returns true if we were able to propagate a constant through the clause.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>reconsider_full_join_clause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>leftvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>rightvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>,
				<decl><type ref="prev"/><name>collation</name></decl>,
				<decl><type ref="prev"/><name>left_type</name></decl>,
				<decl><type ref="prev"/><name>right_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>left_relids</name></decl>,
				<decl><type ref="prev"/><name>right_relids</name></decl>,
				<decl><type ref="prev"/><name>left_nullable_relids</name></decl>,
				<decl><type ref="prev"/><name>right_nullable_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<comment type="block">/* Can't use an outerjoin_delayed clause here */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>outerjoin_delayed</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Extract needed info from the clause */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_opclause</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>op_input_types</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftvar</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightvar</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_relids</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_relids</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_nullable_relids</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name>left_relids</name></expr></argument>,
										 <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_nullable_relids</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name>right_relids</name></expr></argument>,
										  <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>root-&gt;eq_classes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>coal_em</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>matchleft</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>matchright</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore EC unless it contains pseudoconstants */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Never match to a volatile EC */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* It has to match the outer-join clause as to semantics, too */</comment>
		<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>!=</operator> <name><name>cur_ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name></expr></argument>, <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Does it contain a COALESCE(leftvar, rightvar) construct?
		 *
		 * We can assume the COALESCE() inputs are in the same order as the
		 * join clause, since both were automatically generated in the cases
		 * we care about.
		 *
		 * XXX currently this may fail to match in cross-type cases because
		 * the COALESCE will contain typecast operations while the join clause
		 * may not (if there is a cross-type mergejoin operator available for
		 * the two column types). Is it OK to strip implicit coercions from
		 * the COALESCE arguments?
		 */</comment>
		<expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>cur_ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>coal_em</name> <operator>=</operator> <operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>coal_em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no children yet */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>coal_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name><name>coal_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cfirst</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>csecond</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>cfirst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>csecond</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftvar</name></expr></argument>, <argument><expr><name>cfirst</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>equal</name><argument_list>(<argument><expr><name>rightvar</name></expr></argument>, <argument><expr><name>csecond</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* no match, so ignore this EC */</comment>

		<comment type="block">/*
		 * Yes it does!  Try to generate clauses LEFTVAR = CONSTANT and
		 * RIGHTVAR = CONSTANT for each CONSTANT in the EC.  Note that we must
		 * succeed with at least one constant for each var before we can
		 * decide to throw away the outer-join clause.
		 */</comment>
		<expr_stmt><expr><name>matchleft</name> <operator>=</operator> <name>matchright</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>cur_ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_op</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>newrinfo</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore non-const members */</comment>
			<expr_stmt><expr><name>eq_op</name> <operator>=</operator> <call><name>select_equality_operator</name><argument_list>(<argument><expr><name>cur_ec</name></expr></argument>,
											 <argument><expr><name>left_type</name></expr></argument>,
											 <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eq_op</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newrinfo</name> <operator>=</operator> <call><name>build_implied_join_equality</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													   <argument><expr><name>eq_op</name></expr></argument>,
													   <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></argument>,
													   <argument><expr><name>leftvar</name></expr></argument>,
													   <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
													   <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>left_relids</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>left_nullable_relids</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>process_equivalence</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newrinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>matchleft</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>eq_op</name> <operator>=</operator> <call><name>select_equality_operator</name><argument_list>(<argument><expr><name>cur_ec</name></expr></argument>,
											 <argument><expr><name>right_type</name></expr></argument>,
											 <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eq_op</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newrinfo</name> <operator>=</operator> <call><name>build_implied_join_equality</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													   <argument><expr><name>eq_op</name></expr></argument>,
													   <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></argument>,
													   <argument><expr><name>rightvar</name></expr></argument>,
													   <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
													   <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>right_relids</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>right_nullable_relids</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_min_security</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>process_equivalence</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newrinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>matchright</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we were able to equate both vars to constants, we're done, and
		 * we can throw away the full-join clause as redundant.  Moreover, we
		 * can remove the COALESCE entry from the EC, since the added
		 * restrictions ensure it will always have the expected value. (We
		 * don't bother trying to update ec_relids or ec_sources.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>matchleft</name> <operator>&amp;&amp;</operator> <name>matchright</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>, <argument><expr><name>coal_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise, fall out of the search loop, since we know the COALESCE
		 * appears in at most one EC (XXX might stop being true if we allow
		 * stripping of coercions above?)
		 */</comment>
		<break>break;</break>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* failed to make any deduction */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * exprs_known_equal
 *	  Detect whether two expressions are known equal due to equivalence
 *	  relationships.
 *
 * Actually, this only shows that the expressions are equal according
 * to some opfamily's notion of equality --- but we only use it for
 * selectivity estimation, so a fuzzy idea of equality is OK.
 *
 * Note: does not bother to check for "equal(item1, item2)"; caller must
 * check that case if it's possible to pass identical items.
 */</comment>
<function><type><name>bool</name></type>
<name>exprs_known_equal</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>item1</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>item2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>root-&gt;eq_classes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>item1member</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>item2member</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* Never match to a volatile EC */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore children here */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>item1</name></expr></argument>, <argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>item1member</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>item2</name></expr></argument>, <argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>item2member</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Exit as soon as equality is proven */</comment>
			<if_stmt><if>if <condition>(<expr><name>item1member</name> <operator>&amp;&amp;</operator> <name>item2member</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * match_eclasses_to_foreign_key_col
 *	  See whether a foreign key column match is proven by any eclass.
 *
 * If the referenced and referencing Vars of the fkey's colno'th column are
 * known equal due to any eclass, return that eclass; otherwise return NULL.
 * (In principle there might be more than one matching eclass if multiple
 * collations are involved, but since collation doesn't matter for equality,
 * we ignore that fine point here.)  This is much like exprs_known_equal,
 * except that we insist on the comparison operator matching the eclass, so
 * that the result is definite not approximate.
 */</comment>
<function><type><name>EquivalenceClass</name> <modifier>*</modifier></type>
<name>match_eclasses_to_foreign_key_col</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								  <parameter><decl><type><name>ForeignKeyOptInfo</name> <modifier>*</modifier></type><name>fkinfo</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>var1varno</name> <init>= <expr><name><name>fkinfo</name><operator>-&gt;</operator><name>con_relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>var1attno</name> <init>= <expr><name><name>fkinfo</name><operator>-&gt;</operator><name>conkey</name><index>[<expr><name>colno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>var2varno</name> <init>= <expr><name><name>fkinfo</name><operator>-&gt;</operator><name>ref_relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>var2attno</name> <init>= <expr><name><name>fkinfo</name><operator>-&gt;</operator><name>confkey</name><index>[<expr><name>colno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>eqop</name> <init>= <expr><name><name>fkinfo</name><operator>-&gt;</operator><name>conpfeqop</name><index>[<expr><name>colno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>var1varno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>var2varno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opfamilies</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* compute only if needed */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>matching_ecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Consider only eclasses mentioning both relations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>ec_merging_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>matching_ecs</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>,
								 <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>matching_ecs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>,
															 <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>item1member</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>item2member</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* Never match to a volatile EC */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Note: it seems okay to match to "broken" eclasses here */</comment>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore children here */</comment>

			<comment type="block">/* EM must be a Var, possibly with RelabelType */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>var</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>var</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Match? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>var1varno</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>var1attno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>item1member</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>var2varno</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>var2attno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>item2member</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Have we found both PK and FK column in this EC? */</comment>
			<if_stmt><if>if <condition>(<expr><name>item1member</name> <operator>&amp;&amp;</operator> <name>item2member</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Succeed if eqop matches EC's opfamilies.  We could test
				 * this before scanning the members, but it's probably cheaper
				 * to test for member matches first.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>opfamilies</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* compute if we didn't already */</comment>
					<expr_stmt><expr><name>opfamilies</name> <operator>=</operator> <call><name>get_mergejoin_opfamilies</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>ec</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* Otherwise, done with this EC, move on to the next */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * add_child_rel_equivalences
 *	  Search for EC members that reference the root parent of child_rel, and
 *	  add transformed members referencing the child_rel.
 *
 * Note that this function won't be called at all unless we have at least some
 * reason to believe that the EC members it generates will be useful.
 *
 * parent_rel and child_rel could be derived from appinfo, but since the
 * caller has already computed them, we might as well just pass them in.
 *
 * The passed-in AppendRelInfo is not used when the parent_rel is not a
 * top-level baserel, since it shows the mapping from the parent_rel but
 * we need to translate EC expressions that refer to the top-level parent.
 * Using it is faster than using adjust_appendrel_attrs_multilevel(), though,
 * so we prefer it when we can.
 */</comment>
<function><type><name>void</name></type>
<name>add_child_rel_equivalences</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>top_parent_relids</name> <init>= <expr><name><name>child_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>child_relids</name> <init>= <expr><name><name>child_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * EC merging should be complete already, so we can use the parent rel's
	 * eclass_indexes to avoid searching all of root-&gt;eq_classes.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>ec_merging_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_members</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this EC contains a volatile expression, then generating child
		 * EMs would be downright dangerous, so skip it.  We rely on a
		 * volatile EC having only one EM.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Sanity check eclass_indexes only contain ECs for parent_rel */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>top_parent_relids</name></expr></argument>, <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't use foreach() here because there's no point in scanning
		 * newly-added child members, so we can stop after the last
		 * pre-existing EC member.
		 */</comment>
		<expr_stmt><expr><name>num_members</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>num_members</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore consts here */</comment>

			<comment type="block">/*
			 * We consider only original EC members here, not
			 * already-transformed child members.  Otherwise, if some original
			 * member expression references more than one appendrel, we'd get
			 * an O(N^2) explosion of useless derived expressions for
			 * combinations of children.  (But add_child_join_rel_equivalences
			 * may add targeted combinations for partitionwise-join purposes.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore children here */</comment>

			<comment type="block">/* Does this member reference child's topmost parent rel? */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes, generate transformed child version */</comment>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>child_expr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relids</name></type>		<name>new_relids</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relids</name></type>		<name>new_nullable_relids</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Simple single-level transformation */</comment>
					<expr_stmt><expr><name>child_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
						<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
											   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Must do multi-level transformation */</comment>
					<expr_stmt><expr><name>child_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
						<call><name>adjust_appendrel_attrs_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
														  <argument><expr><name>child_relids</name></expr></argument>,
														  <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * Transform em_relids to match.  Note we do *not* do
				 * pull_varnos(child_expr) here, as for example the
				 * transformation might have substituted a constant, but we
				 * don't want the child member to be marked as constant.
				 */</comment>
				<expr_stmt><expr><name>new_relids</name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>,
											<argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>new_relids</name></expr></argument>, <argument><expr><name>child_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * And likewise for nullable_relids.  Note this code assumes
				 * parent and child relids are singletons.
				 */</comment>
				<expr_stmt><expr><name>new_nullable_relids</name> <operator>=</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>new_nullable_relids</name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>new_nullable_relids</name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name>new_nullable_relids</name></expr></argument>,
														 <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_nullable_relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>new_nullable_relids</name></expr></argument>,
														  <argument><expr><name>child_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>add_eq_member</name><argument_list>(<argument><expr><name>cur_ec</name></expr></argument>, <argument><expr><name>child_expr</name></expr></argument>,
									 <argument><expr><name>new_relids</name></expr></argument>, <argument><expr><name>new_nullable_relids</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Record this EC index for the child rel */</comment>
				<expr_stmt><expr><name><name>child_rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * add_child_join_rel_equivalences
 *	  Like add_child_rel_equivalences(), but for joinrels
 *
 * Here we find the ECs relevant to the top parent joinrel and add transformed
 * member expressions that refer to this child joinrel.
 *
 * Note that this function won't be called at all unless we have at least some
 * reason to believe that the EC members it generates will be useful.
 */</comment>
<function><type><name>void</name></type>
<name>add_child_join_rel_equivalences</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>nappinfos</name></decl></parameter>, <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>,
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_joinrel</name></decl></parameter>,
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_joinrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>top_parent_relids</name> <init>= <expr><name><name>child_joinrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>child_relids</name> <init>= <expr><name><name>child_joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>matching_ecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>child_joinrel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>parent_joinrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We need consider only ECs that mention the parent joinrel */</comment>
	<expr_stmt><expr><name>matching_ecs</name> <operator>=</operator> <call><name>get_eclass_indexes_for_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're being called during GEQO join planning, we still have to
	 * create any new EC members in the main planner context, to avoid having
	 * a corrupt EC data structure after the GEQO context is reset.  This is
	 * problematic since we'll leak memory across repeated GEQO cycles.  For
	 * now, though, bloat is better than crash.  If it becomes a real issue
	 * we'll have to do something to avoid generating duplicate EC members.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>matching_ecs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_members</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this EC contains a volatile expression, then generating child
		 * EMs would be downright dangerous, so skip it.  We rely on a
		 * volatile EC having only one EM.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Sanity check on get_eclass_indexes_for_relids result */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>top_parent_relids</name></expr></argument>, <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't use foreach() here because there's no point in scanning
		 * newly-added child members, so we can stop after the last
		 * pre-existing EC member.
		 */</comment>
		<expr_stmt><expr><name>num_members</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>num_members</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore consts here */</comment>

			<comment type="block">/*
			 * We consider only original EC members here, not
			 * already-transformed child members.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore children here */</comment>

			<comment type="block">/*
			 * We may ignore expressions that reference a single baserel,
			 * because add_child_rel_equivalences should have handled them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_MULTIPLE</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Does this member reference child's topmost parent rel? */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes, generate transformed child version */</comment>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>child_expr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relids</name></type>		<name>new_relids</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relids</name></type>		<name>new_nullable_relids</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>parent_joinrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Simple single-level transformation */</comment>
					<expr_stmt><expr><name>child_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
						<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
											   <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Must do multi-level transformation */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent_joinrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_JOINREL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>child_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
						<call><name>adjust_appendrel_attrs_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
														  <argument><expr><name>child_relids</name></expr></argument>,
														  <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * Transform em_relids to match.  Note we do *not* do
				 * pull_varnos(child_expr) here, as for example the
				 * transformation might have substituted a constant, but we
				 * don't want the child member to be marked as constant.
				 */</comment>
				<expr_stmt><expr><name>new_relids</name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>,
											<argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_relids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>new_relids</name></expr></argument>, <argument><expr><name>child_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * For nullable_relids, we must selectively replace parent
				 * nullable relids with child ones.
				 */</comment>
				<expr_stmt><expr><name>new_nullable_relids</name> <operator>=</operator> <name><name>cur_em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>new_nullable_relids</name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>new_nullable_relids</name> <operator>=</operator>
						<call><name>adjust_child_relids_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													   <argument><expr><name>new_nullable_relids</name></expr></argument>,
													   <argument><expr><name>child_relids</name></expr></argument>,
													   <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>add_eq_member</name><argument_list>(<argument><expr><name>cur_ec</name></expr></argument>, <argument><expr><name>child_expr</name></expr></argument>,
									 <argument><expr><name>new_relids</name></expr></argument>, <argument><expr><name>new_nullable_relids</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * generate_implied_equalities_for_column
 *	  Create EC-derived joinclauses usable with a specific column.
 *
 * This is used by indxpath.c to extract potentially indexable joinclauses
 * from ECs, and can be used by foreign data wrappers for similar purposes.
 * We assume that only expressions in Vars of a single table are of interest,
 * but the caller provides a callback function to identify exactly which
 * such expressions it would like to know about.
 *
 * We assume that any given table/index column could appear in only one EC.
 * (This should be true in all but the most pathological cases, and if it
 * isn't, we stop on the first match anyway.)  Therefore, what we return
 * is a redundant list of clauses equating the table/index column to each of
 * the other-relation values it is known to be equal to.  Any one of
 * these clauses can be used to create a parameterized path, and there
 * is no value in using more than one.  (But it *is* worthwhile to create
 * a separate parameterized path for each one, since that leads to different
 * join orders.)
 *
 * The caller can pass a Relids set of rels we aren't interested in joining
 * to, so as to save the work of creating useless clauses.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>generate_implied_equalities_for_column</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
									   <parameter><decl><type><name>ec_matches_callback_type</name></type> <name>callback</name></decl></parameter>,
									   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>,
									   <parameter><decl><type><name>Relids</name></type> <name>prohibited_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_child_rel</name> <init>= <expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>parent_relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Should be OK to rely on eclass_indexes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>ec_merging_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Indexes are available only on base or "other" member relations. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it's a child rel, we'll need to know what its parent(s) are */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_child_rel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>parent_relids</name> <operator>=</operator> <call><name>find_childrel_parents</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>parent_relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* not used, but keep compiler quiet */</comment>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* Sanity check eclass_indexes only contain ECs for rel */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_child_rel</name> <operator>||</operator> <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Won't generate joinclauses if const or single-member (the latter
		 * test covers the volatile case too)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Scan members, looking for a match to the target column.  Note that
		 * child EC members are considered, but only when they belong to the
		 * target relation.  (Unlike regular members, the same expression
		 * could be a child member of more than one EC.  Therefore, it's
		 * potentially order-dependent which EC a child relation's target
		 * column gets matched to.  This is annoying but it only happens in
		 * corner cases, so for now we live with just reporting the first
		 * match.  See also get_eclass_for_sort_expr.)
		 */</comment>
		<expr_stmt><expr><name>cur_em</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>cur_ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>cur_em</name> <operator>=</operator> <operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>callback</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cur_ec</name></expr></argument>, <argument><expr><name>cur_em</name></expr></argument>, <argument><expr><name>callback_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>cur_em</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cur_em</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Found our match.  Scan the other EC members and attempt to generate
		 * joinclauses.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>cur_ec-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>other_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_op</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>other_em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore children here */</comment>

			<comment type="block">/* Make sure it'll be a join to a different rel */</comment>
			<if_stmt><if>if <condition>(<expr><name>other_em</name> <operator>==</operator> <name>cur_em</name> <operator>||</operator>
				<call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>other_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Forget it if caller doesn't want joins to this rel */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>other_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>prohibited_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Also, if this is a child rel, avoid generating a useless join
			 * to its parent rel(s).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>is_child_rel</name> <operator>&amp;&amp;</operator>
				<call><name>bms_overlap</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name><name>other_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>eq_op</name> <operator>=</operator> <call><name>select_equality_operator</name><argument_list>(<argument><expr><name>cur_ec</name></expr></argument>,
											 <argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>,
											 <argument><expr><name><name>other_em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eq_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* set parent_ec to mark as redundant with other joinclauses */</comment>
			<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <call><name>create_join_clause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cur_ec</name></expr></argument>, <argument><expr><name>eq_op</name></expr></argument>,
									   <argument><expr><name>cur_em</name></expr></argument>, <argument><expr><name>other_em</name></expr></argument>,
									   <argument><expr><name>cur_ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If somehow we failed to create any join clauses, we might as well
		 * keep scanning the ECs for another match.  But if we did make any,
		 * we're done, because we don't want to return non-redundant clauses.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * have_relevant_eclass_joinclause
 *		Detect whether there is an EquivalenceClass that could produce
 *		a joinclause involving the two given relations.
 *
 * This is essentially a very cut-down version of
 * generate_join_implied_equalities().  Note it's OK to occasionally say "yes"
 * incorrectly.  Hence we don't bother with details like whether the lack of a
 * cross-type operator might prevent the clause from actually being generated.
 */</comment>
<function><type><name>bool</name></type>
<name>have_relevant_eclass_joinclause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>matching_ecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Examine only eclasses mentioning both rel1 and rel2 */</comment>
	<expr_stmt><expr><name>matching_ecs</name> <operator>=</operator> <call><name>get_common_eclass_indexes</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											 <argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>matching_ecs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>,
															 <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Sanity check that get_common_eclass_indexes gave only ECs
		 * containing both rels.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>rel2</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Won't generate joinclauses if single-member (this test covers the
		 * volatile case too)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We do not need to examine the individual members of the EC, because
		 * all that we care about is whether each rel overlaps the relids of
		 * at least one member, and get_common_eclass_indexes() and the single
		 * member check above are sufficient to prove that.  (As with
		 * have_relevant_joinclause(), it is not necessary that the EC be able
		 * to form a joinclause relating exactly the two given rels, only that
		 * it be able to form a joinclause mentioning both, and this will
		 * surely be true if both of them overlap ec_relids.)
		 *
		 * Note we don't test ec_broken; if we did, we'd need a separate code
		 * path to look through ec_sources.  Checking the membership anyway is
		 * OK as a possibly-overoptimistic heuristic.
		 *
		 * We don't test ec_has_const either, even though a const eclass won't
		 * generate real join clauses.  This is because if we had "WHERE a.x =
		 * b.y and a.x = 42", it is worth considering a join between a and b,
		 * since the join result is likely to be small even though it'll end
		 * up being an unqualified nestloop.
		 */</comment>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * has_relevant_eclass_joinclause
 *		Detect whether there is an EquivalenceClass that could produce
 *		a joinclause involving the given relation and anything else.
 *
 * This is the same as have_relevant_eclass_joinclause with the other rel
 * implicitly defined as "everything else in the query".
 */</comment>
<function><type><name>bool</name></type>
<name>has_relevant_eclass_joinclause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>matched_ecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Examine only eclasses mentioning rel1 */</comment>
	<expr_stmt><expr><name>matched_ecs</name> <operator>=</operator> <call><name>get_eclass_indexes_for_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>matched_ecs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>,
															 <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Won't generate joinclauses if single-member (this test covers the
		 * volatile case too)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Per the comment in have_relevant_eclass_joinclause, it's sufficient
		 * to find an EC that mentions both this rel and some other rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name><name>rel1</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * eclass_useful_for_merging
 *	  Detect whether the EC could produce any mergejoinable join clauses
 *	  against the specified relation.
 *
 * This is just a heuristic test and doesn't have to be exact; it's better
 * to say "yes" incorrectly than "no".  Hence we don't bother with details
 * like whether the lack of a cross-type operator might prevent the clause
 * from actually being generated.
 */</comment>
<function><type><name>bool</name></type>
<name>eclass_useful_for_merging</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>eclass</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>eclass</name><operator>-&gt;</operator><name>ec_merged</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Won't generate joinclauses if const or single-member (the latter test
	 * covers the volatile case too)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>eclass</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>eclass</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note we don't test ec_broken; if we did, we'd need a separate code path
	 * to look through ec_sources.  Checking the members anyway is OK as a
	 * possibly-overoptimistic heuristic.
	 */</comment>

	<comment type="block">/* If specified rel is a child, we must consider the topmost parent rel */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* If rel already includes all members of eclass, no point in searching */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>eclass</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* To join, we need a member not in the given rel */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>eclass-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>cur_em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_is_child</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore children here */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>cur_em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * is_redundant_derived_clause
 *		Test whether rinfo is derived from same EC as any clause in clauselist;
 *		if so, it can be presumed to represent a condition that's redundant
 *		with that member of the list.
 */</comment>
<function><type><name>bool</name></type>
<name>is_redundant_derived_clause</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauselist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>parent_ec</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Fail if it's not a potentially-redundant clause from some EC */</comment>
	<if_stmt><if>if <condition>(<expr><name>parent_ec</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clauselist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>otherrinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>otherrinfo</name><operator>-&gt;</operator><name>parent_ec</name></name> <operator>==</operator> <name>parent_ec</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_redundant_with_indexclauses
 *		Test whether rinfo is redundant with any clause in the IndexClause
 *		list.  Here, for convenience, we test both simple identity and
 *		whether it is derived from the same EC as any member of the list.
 */</comment>
<function><type><name>bool</name></type>
<name>is_redundant_with_indexclauses</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexclauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>parent_ec</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>iclause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>IndexClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>otherrinfo</name> <init>= <expr><name><name>iclause</name><operator>-&gt;</operator><name>rinfo</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If indexclause is lossy, it won't enforce the condition exactly */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>iclause</name><operator>-&gt;</operator><name>lossy</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Match if it's same clause (pointer equality should be enough) */</comment>
		<if_stmt><if>if <condition>(<expr><name>rinfo</name> <operator>==</operator> <name>otherrinfo</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Match if derived from same EC */</comment>
		<if_stmt><if>if <condition>(<expr><name>parent_ec</name> <operator>&amp;&amp;</operator> <name><name>otherrinfo</name><operator>-&gt;</operator><name>parent_ec</name></name> <operator>==</operator> <name>parent_ec</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * No need to look at the derived clauses in iclause-&gt;indexquals; they
		 * couldn't match if the parent clause didn't.
		 */</comment>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_eclass_indexes_for_relids
 *		Build and return a Bitmapset containing the indexes into root's
 *		eq_classes list for all eclasses that mention any of these relids
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>get_eclass_indexes_for_relids</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>ec_indexes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Should be OK to rely on eclass_indexes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>ec_merging_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ec_indexes</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>ec_indexes</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>eclass_indexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>ec_indexes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_common_eclass_indexes
 *		Build and return a Bitmapset containing the indexes into root's
 *		eq_classes list for all eclasses that mention rels in both
 *		relids1 and relids2.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>get_common_eclass_indexes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids1</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>rel1ecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>rel2ecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>relid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel1ecs</name> <operator>=</operator> <call><name>get_eclass_indexes_for_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relids1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can get away with just using the relation's eclass_indexes directly
	 * when relids2 is a singleton set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_get_singleton_member</name><argument_list>(<argument><expr><name>relids2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rel2ecs</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>relid</name></expr>]</index></name><operator>-&gt;</operator><name>eclass_indexes</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rel2ecs</name> <operator>=</operator> <call><name>get_eclass_indexes_for_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relids2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Calculate and return the common EC indexes, recycling the left input. */</comment>
	<return>return <expr><call><name>bms_int_members</name><argument_list>(<argument><expr><name>rel1ecs</name></expr></argument>, <argument><expr><name>rel2ecs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
