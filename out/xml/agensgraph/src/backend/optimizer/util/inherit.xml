<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/optimizer/util/inherit.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * inherit.c
 *	  Routines to process child relations in inheritance trees
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/path/inherit.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/appendinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/inherit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/* source-code-compatibility hacks for pull_varnos() API change */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>make_restrictinfo</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>make_restrictinfo_new(a,b,c,d,e,f,g,h,i)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_partitioned_rtentry</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
									   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parentrte</name></decl></parameter>,
									   <parameter><decl><type><name>Index</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
									   <parameter><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>top_parentrc</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_single_inheritance_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parentrte</name></decl></parameter>,
											<parameter><decl><type><name>Index</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
											<parameter><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>top_parentrc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>childrel</name></decl></parameter>,
											<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>childrte_p</name></decl></parameter>,
											<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>childRTindex_p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>translate_col_privs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>parent_privs</name></decl></parameter>,
									  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_appendrel_subquery</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
									  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * expand_inherited_rtentry
 *		Expand a rangetable entry that has the "inh" bit set.
 *
 * "inh" is only allowed in two cases: RELATION and SUBQUERY RTEs.
 *
 * "inh" on a plain RELATION RTE means that it is a partitioned table or the
 * parent of a traditional-inheritance set.  In this case we must add entries
 * for all the interesting child tables to the query's rangetable, and build
 * additional planner data structures for them, including RelOptInfos,
 * AppendRelInfos, and possibly PlanRowMarks.
 *
 * Note that the original RTE is considered to represent the whole inheritance
 * set.  In the case of traditional inheritance, the first of the generated
 * RTEs is an RTE for the same table, but with inh = false, to represent the
 * parent table in its role as a simple member of the inheritance set.  For
 * partitioning, we don't need a second RTE because the partitioned table
 * itself has no data and need not be scanned.
 *
 * "inh" on a SUBQUERY RTE means that it's the parent of a UNION ALL group,
 * which is treated as an appendrel similarly to inheritance cases; however,
 * we already made RTEs and AppendRelInfos for the subqueries.  We only need
 * to build RelOptInfos for them, which is done by expand_appendrel_subquery.
 */</comment>
<function><type><name>void</name></type>
<name>expand_inherited_rtentry</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentOID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>oldrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>oldrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>old_isParent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_allMarkTypes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* else caller error */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>expand_appendrel_subquery</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>parentOID</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We used to check has_subclass() here, but there's no longer any need
	 * to, because subquery_planner already did.
	 */</comment>

	<comment type="block">/*
	 * The rewriter should already have obtained an appropriate lock on each
	 * relation named in the query, so we can open the parent relation without
	 * locking it.  However, for each child relation we add to the query, we
	 * must obtain an appropriate lock, because this will be the first use of
	 * those relations in the parse/rewrite/plan pipeline.  Child rels should
	 * use the same lockmode as their parent.
	 */</comment>
	<expr_stmt><expr><name>oldrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>parentOID</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If parent relation is selected FOR UPDATE/SHARE, we need to mark its
	 * PlanRowMark as isParent = true, and generate a new PlanRowMark for each
	 * child.
	 */</comment>
	<expr_stmt><expr><name>oldrc</name> <operator>=</operator> <call><name>get_plan_rowmark</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldrc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old_isParent</name> <operator>=</operator> <name><name>oldrc</name><operator>-&gt;</operator><name>isParent</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldrc</name><operator>-&gt;</operator><name>isParent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Save initial value of allMarkTypes before children add to it */</comment>
		<expr_stmt><expr><name>old_allMarkTypes</name> <operator>=</operator> <name><name>oldrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Scan the inheritance set and expand it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>oldrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Partitioned table, so set up for partitioning.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Recursively expand and lock the partitions.  While at it, also
		 * extract the partition key columns of all the partitioned tables.
		 */</comment>
		<expr_stmt><expr><call><name>expand_partitioned_rtentry</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>,
								   <argument><expr><name>oldrelation</name></expr></argument>, <argument><expr><name>oldrc</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Ordinary table, so process traditional-inheritance children.  (Note
		 * that partitioned tables are not allowed to have inheritance
		 * children, so it's not possible for both cases to apply.)
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inhOIDs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* Scan for all members of inheritance set, acquire needed locks */</comment>
		<expr_stmt><expr><name>inhOIDs</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>parentOID</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We used to special-case the situation where the table no longer has
		 * any children, by clearing rte-&gt;inh and exiting.  That no longer
		 * works, because this function doesn't get run until after decisions
		 * have been made that depend on rte-&gt;inh.  We have to treat such
		 * situations as normal inheritance.  The table itself should always
		 * have been found, though.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inhOIDs</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>inhOIDs</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>parentOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Expand simple_rel_array and friends to hold child objects. */</comment>
		<expr_stmt><expr><call><name>expand_planner_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>inhOIDs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Expand inheritance children in the order the OIDs were returned by
		 * find_all_inheritors.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>inhOIDs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childOID</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>newrelation</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childrte</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Index</name></type>		<name>childRTindex</name></decl>;</decl_stmt>

			<comment type="block">/* Open rel if needed; we already have required locks */</comment>
			<if_stmt><if>if <condition>(<expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childOID</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newrelation</name> <operator>=</operator> <name>oldrelation</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * It is possible that the parent table has children that are temp
			 * tables of other backends.  We cannot safely access such tables
			 * (because of buffering issues), and the best thing to do seems
			 * to be to silently ignore them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Create RTE and AppendRelInfo, plus PlanRowMark if needed. */</comment>
			<expr_stmt><expr><call><name>expand_single_inheritance_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>oldrelation</name></expr></argument>,
											<argument><expr><name>oldrc</name></expr></argument>, <argument><expr><name>newrelation</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>childrte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>childRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create the otherrel RelOptInfo too. */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close child relations, but keep locks */</comment>
			<if_stmt><if>if <condition>(<expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Some children might require different mark types, which would've been
	 * reported into oldrc.  If so, add relevant entries to the top-level
	 * targetlist and update parent rel's reltarget.  This should match what
	 * preprocess_targetlist() would have added if the mark types had been
	 * requested originally.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldrc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>new_allMarkTypes</name> <init>= <expr><name><name>oldrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>resname</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Add TID junk Var if needed, unless we had it already */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_allMarkTypes</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ROW_MARK_COPY</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name>old_allMarkTypes</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ROW_MARK_COPY</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Need to fetch TID */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>oldrc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
						  <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>,
						  <argument><expr><name>TIDOID</name></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						  <argument><expr><name>InvalidOid</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"ctid%u"</literal></expr></argument>, <argument><expr><name><name>oldrc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newvars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add whole-row junk Var if needed, unless we had it already */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>new_allMarkTypes</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ROW_MARK_COPY</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name>old_allMarkTypes</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ROW_MARK_COPY</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeWholeRowVar</name><argument_list>(<argument><expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>oldrc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>oldrc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"wholerow%u"</literal></expr></argument>, <argument><expr><name><name>oldrc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newvars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add tableoid junk Var, unless we had it already */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_isParent</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>oldrc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
						  <argument><expr><name>TableOidAttributeNumber</name></expr></argument>,
						  <argument><expr><name>OIDOID</name></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						  <argument><expr><name>InvalidOid</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"tableoid%u"</literal></expr></argument>, <argument><expr><name><name>oldrc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newvars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Add the newly added Vars to parent's reltarget.  We needn't worry
		 * about the children's reltargets, they'll be made later.
		 */</comment>
		<expr_stmt><expr><call><name>add_vars_to_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>newvars</name></expr></argument>, <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>oldrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * expand_partitioned_rtentry
 *		Recursively expand an RTE for a partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_partitioned_rtentry</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
						   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parentrte</name></decl></parameter>,
						   <parameter><decl><type><name>Index</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
						   <parameter><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>top_parentrc</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>live_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_live_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>PartitionDirectoryLookup</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>partition_directory</name></name></expr></argument>,
										<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A partitioned table should always have a partition descriptor. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note down whether any partition key cols are being updated. Though it's
	 * the root partitioned table's updatedCols we are interested in, we
	 * instead use parentrte to get the updatedCols. This is convenient
	 * because parentrte already has the root partrel's updatedCols translated
	 * to match the attribute ordering of parentrel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>partColsUpdated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>partColsUpdated</name></name> <operator>=</operator>
			<call><name>has_partition_attrs</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * There shouldn't be any generated columns in the partition key.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>has_partition_attrs</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing further to do here if there are no partitions. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Perform partition pruning using restriction clauses assigned to parent
	 * relation.  live_parts will contain PartitionDesc indexes of partitions
	 * that survive pruning.  Below, we will initialize child objects for the
	 * surviving partitions.
	 */</comment>
	<expr_stmt><expr><name>live_parts</name> <operator>=</operator> <call><name>prune_append_rel_partitions</name><argument_list>(<argument><expr><name>relinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expand simple_rel_array and friends to hold child objects. */</comment>
	<expr_stmt><expr><name>num_live_parts</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>live_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>num_live_parts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>expand_planner_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>num_live_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We also store partition RelOptInfo pointers in the parent relation.
	 * Since we're palloc0'ing, slots corresponding to pruned partitions will
	 * contain NULL.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relinfo</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>=</operator> <operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>nparts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelOptInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a child RTE for each live partition.  Note that unlike
	 * traditional inheritance, we don't need a child RTE for the partitioned
	 * table itself, because it's not going to be scanned.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>live_parts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childOID</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childrte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>childRTindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrelinfo</name></decl>;</decl_stmt>

		<comment type="block">/* Open rel, acquiring required locks */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childOID</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Temporary partitions belonging to other sessions should have been
		 * disallowed at definition, but for paranoia's sake, let's double
		 * check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"temporary relation from another session found as partition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Create RTE and AppendRelInfo, plus PlanRowMark if needed. */</comment>
		<expr_stmt><expr><call><name>expand_single_inheritance_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parentrte</name></expr></argument>, <argument><expr><name>parentRTindex</name></expr></argument>,
										<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>top_parentrc</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>childrte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>childRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create the otherrel RelOptInfo too. */</comment>
		<expr_stmt><expr><name>childrelinfo</name> <operator>=</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>, <argument><expr><name>relinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relinfo</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>childrelinfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relinfo</name><operator>-&gt;</operator><name>all_partrels</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>all_partrels</name></name></expr></argument>,
												<argument><expr><name><name>childrelinfo</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If this child is itself partitioned, recurse */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>expand_partitioned_rtentry</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childrelinfo</name></expr></argument>,
									   <argument><expr><name>childrte</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>,
									   <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>top_parentrc</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Close child relation, but keep locks */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * expand_single_inheritance_child
 *		Build a RangeTblEntry and an AppendRelInfo, plus maybe a PlanRowMark.
 *
 * We now expand the partition hierarchy level by level, creating a
 * corresponding hierarchy of AppendRelInfos and RelOptInfos, where each
 * partitioned descendant acts as a parent of its immediate partitions.
 * (This is a difference from what older versions of PostgreSQL did and what
 * is still done in the case of table inheritance for unpartitioned tables,
 * where the hierarchy is flattened during RTE expansion.)
 *
 * PlanRowMarks still carry the top-parent's RTI, and the top-parent's
 * allMarkTypes field still accumulates values from all descendents.
 *
 * "parentrte" and "parentRTindex" are immediate parent's RTE and
 * RTI. "top_parentrc" is top parent's PlanRowMark.
 *
 * The child RangeTblEntry and its RTI are returned in "childrte_p" and
 * "childRTindex_p" resp.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_single_inheritance_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parentrte</name></decl></parameter>,
								<parameter><decl><type><name>Index</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
								<parameter><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>top_parentrc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>childrel</name></decl></parameter>,
								<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>childrte_p</name></decl></parameter>,
								<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>childRTindex_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentOID</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>childOID</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childrte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>childRTindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>child_tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parent_colnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_colnames</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build an RTE for the child, and attach to query's rangetable list. We
	 * copy most scalar fields of the parent's RTE, but replace relation OID,
	 * relkind, and inh for the child.  Also, set requiredPerms to zero since
	 * all required permissions checks are done on the original RTE. Likewise,
	 * set the child's securityQuals to empty, because we only want to apply
	 * the parent's RLS conditions regardless of what RLS properties
	 * individual children may have.  (This is an intentional choice to make
	 * inherited RLS work like regular permissions checks.) The parent
	 * securityQuals will be propagated to children along with other base
	 * restriction clauses, so we don't need to do it here.  Other
	 * infrastructure of the parent RTE has to be translated to match the
	 * child table's column ordering, which we do below, so a "flat" copy is
	 * sufficient to start with.
	 */</comment>
	<expr_stmt><expr><name>childrte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>childrte</name></expr></argument>, <argument><expr><name>parentrte</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* else this is dubious */</comment>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>childOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<comment type="block">/* A partitioned child will need to be expanded further. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>childrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Link not-yet-fully-filled child RTE into data structures */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>childrte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>childRTindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>childrte_p</name> <operator>=</operator> <name>childrte</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>childRTindex_p</name> <operator>=</operator> <name>childRTindex</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build an AppendRelInfo struct for each parent/child pair.
	 */</comment>
	<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <call><name>make_append_rel_info</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
								   <argument><expr><name>parentRTindex</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tablesample is probably null, but copy it */</comment>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct an alias clause for the child, which we can also use as eref.
	 * This is important so that EXPLAIN will print the right column aliases
	 * for child-table columns.  (Since ruleutils.c doesn't have any easy way
	 * to reassociate parent and child columns, we must get the child column
	 * aliases right to start with.  Note that setting childrte-&gt;alias forces
	 * ruleutils.c to use these column names, which it otherwise would not.)
	 */</comment>
	<expr_stmt><expr><name>child_tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_colnames</name> <operator>=</operator> <name><name>parentrte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>child_colnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>cattno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>cattno</name> <operator>&lt;</operator> <name><name>child_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>cattno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>child_tupdesc</name></expr></argument>, <argument><expr><name>cattno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Always insert an empty string for a dropped column */</comment>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_colnos</name><index>[<expr><name>cattno</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <name><name>appinfo</name><operator>-&gt;</operator><name>parent_colnos</name><index>[<expr><name>cattno</name></expr>]</index></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>parent_colnames</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Duplicate the query-assigned name for the parent column */</comment>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>parent_colnames</name></expr></argument>,
									  <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_colnos</name><index>[<expr><name>cattno</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* New column, just use its real name */</comment>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>child_colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>child_colnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We just duplicate the parent's table alias name for each child.  If the
	 * plan gets printed, ruleutils.c has to sort out unique table aliases to
	 * use, which it can handle.
	 */</comment>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name><name>childrte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
												 <argument><expr><name>child_colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Translate the column permissions bitmaps to the child's attnums (we
	 * have to build the translated_vars list before we can do this).  But if
	 * this is the parent table, we can just duplicate the parent's bitmaps.
	 *
	 * Note: we need to do this even though the executor won't run any
	 * permissions checks on the child RTE.  The insertedCols/updatedCols
	 * bitmaps may be examined for trigger-firing purposes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>translate_col_privs</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>,
													 <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>translate_col_privs</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>,
													 <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <call><name>translate_col_privs</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>,
													<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name> <operator>=</operator> <call><name>translate_col_privs</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name></expr></argument>,
														 <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Store the RTE and appinfo in the respective PlannerInfo arrays, which
	 * the caller must already have allocated space for.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childRTindex</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>childRTindex</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>childRTindex</name></expr>]</index></name> <operator>=</operator> <name>childrte</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>childRTindex</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>childRTindex</name></expr>]</index></name> <operator>=</operator> <name>appinfo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a PlanRowMark if parent is marked FOR UPDATE/SHARE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>top_parentrc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>childrc</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name>childRTindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>prti</name></name> <operator>=</operator> <name><name>top_parentrc</name><operator>-&gt;</operator><name>rti</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>rowmarkId</name></name> <operator>=</operator> <name><name>top_parentrc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr>;</expr_stmt>
		<comment type="block">/* Reselect rowmark type, because relkind might not match parent */</comment>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>markType</name></name> <operator>=</operator> <call><name>select_rowmark_type</name><argument_list>(<argument><expr><name>childrte</name></expr></argument>,
												<argument><expr><name><name>top_parentrc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>childrc</name><operator>-&gt;</operator><name>markType</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name><name>top_parentrc</name><operator>-&gt;</operator><name>strength</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name><name>top_parentrc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We mark RowMarks for partitioned child tables as parent RowMarks so
		 * that the executor ignores them (except their existence means that
		 * the child tables will be locked using the appropriate mode).
		 */</comment>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>isParent</name></name> <operator>=</operator> <operator>(</operator><name><name>childrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Include child's rowmark type in top parent's allMarkTypes */</comment>
		<expr_stmt><expr><name><name>top_parentrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>|=</operator> <name><name>childrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>childrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * translate_col_privs
 *	  Translate a bitmapset representing per-column privileges from the
 *	  parent rel's attribute numbering to the child's.
 *
 * The only surprise here is that we don't translate a parent whole-row
 * reference into a child whole-row reference.  That would mean requiring
 * permissions on all child columns, which is overly strict, since the
 * query is really only going to reference the inherited columns.  Instead
 * we set the per-column bits for all inherited columns.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>translate_col_privs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>parent_privs</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>child_privs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>whole_row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* System attributes have the same numbers in all tables */</comment>
	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
						  <argument><expr><name>parent_privs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>child_privs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>child_privs</name></expr></argument>,
										 <argument><expr><name>attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Check if parent has whole-row reference */</comment>
	<expr_stmt><expr><name>whole_row</name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>InvalidAttrNumber</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
							  <argument><expr><name>parent_privs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And now translate the regular user attributes, using the vars list */</comment>
	<expr_stmt><expr><name>attno</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>translated_vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* ignore dropped columns */</comment>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>whole_row</name> <operator>||</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name>attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
						  <argument><expr><name>parent_privs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>child_privs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>child_privs</name></expr></argument>,
										 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>child_privs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * expand_appendrel_subquery
 *		Add "other rel" RelOptInfos for the children of an appendrel baserel
 *
 * "rel" is a subquery relation that has the rte-&gt;inh flag set, meaning it
 * is a UNION ALL subquery that's been flattened into an appendrel, with
 * child subqueries listed in root-&gt;append_rel_list.  We need to build
 * a RelOptInfo for each child relation so that we can plan scans on them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_appendrel_subquery</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>childRTindex</name> <init>= <expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childrte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name></decl>;</decl_stmt>

		<comment type="block">/* append_rel_list contains all append rels; ignore others */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>!=</operator> <name>rti</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* find the child RTE, which should already exist */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childRTindex</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>childrte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>childRTindex</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childrte</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build the child RelOptInfo. */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Child may itself be an inherited rel, either table or subquery. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>childrte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>expand_inherited_rtentry</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>childrte</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * apply_child_basequals
 *		Populate childrel's base restriction quals from parent rel's quals,
 *		translating them using appinfo.
 *
 * If any of the resulting clauses evaluate to constant false or NULL, we
 * return false and don't apply any quals.  Caller should mark the relation as
 * a dummy rel in this case, since it doesn't need to be scanned.
 */</comment>
<function><type><name>bool</name></type>
<name>apply_child_basequals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parentrel</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childRTE</name></decl></parameter>,
					  <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>childquals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>cq_min_security</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The child rel's targetlist might contain non-Var expressions, which
	 * means that substitution into the quals could produce opportunities for
	 * const-simplification, and perhaps even pseudoconstant quals. Therefore,
	 * transform each RestrictInfo separately to see if it reduces to a
	 * constant or pseudoconstant.  (We must process them separately to keep
	 * track of the security level of each qual.)
	 */</comment>
	<expr_stmt><expr><name>childquals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cq_min_security</name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parentrel-&gt;baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>childqual</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>childqual</name> <operator>=</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>,
										   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>childqual</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* check for flat-out constant */</comment>
		<if_stmt><if>if <condition>(<expr><name>childqual</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>childqual</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>childqual</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name> <operator>||</operator>
				<operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>childqual</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Restriction reduces to constant FALSE or NULL */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Restriction reduces to constant TRUE, so drop it */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* might have gotten an AND clause, if so flatten it */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>make_ands_implicit((Expr *) childqual)</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>onecq</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>pseudoconstant</name></decl>;</decl_stmt>

			<comment type="block">/* check for pseudoconstant (no Vars or volatile functions) */</comment>
			<expr_stmt><expr><name>pseudoconstant</name> <operator>=</operator>
				<operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>onecq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>onecq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pseudoconstant</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* tell createplan.c to check for gating quals */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasPseudoConstantQuals</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* reconstitute RestrictInfo with appropriate properties */</comment>
			<expr_stmt><expr><name>childquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>childquals</name></expr></argument>,
								 <argument><expr><call><name>make_restrictinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>onecq</name></expr></argument>,
												   <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>is_pushed_down</name></name></expr></argument>,
												   <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outerjoin_delayed</name></name></expr></argument>,
												   <argument><expr><name>pseudoconstant</name></expr></argument>,
												   <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* track minimum security level among child quals */</comment>
			<expr_stmt><expr><name>cq_min_security</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>cq_min_security</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/*
	 * In addition to the quals inherited from the parent, we might have
	 * securityQuals associated with this particular child node.  (Currently
	 * this can only happen in appendrels originating from UNION ALL;
	 * inheritance child tables don't have their own securityQuals, see
	 * expand_single_inheritance_child().)  Pull any such securityQuals up
	 * into the baserestrictinfo for the child.  This is similar to
	 * process_security_barrier_quals() for the parent rel, except that we
	 * can't make any general deductions from such quals, since they don't
	 * hold for the whole appendrel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>childRTE</name><operator>-&gt;</operator><name>securityQuals</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type>		<name>security_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>childRTE-&gt;securityQuals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qualset</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>qualset</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* not likely that we'd see constants here, so no check */</comment>
				<expr_stmt><expr><name>childquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>childquals</name></expr></argument>,
									 <argument><expr><call><name>make_restrictinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
													   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													   <argument><expr><name>security_level</name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cq_min_security</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>cq_min_security</name></expr></argument>, <argument><expr><name>security_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name>security_level</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>security_level</name> <operator>&lt;=</operator> <name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, we've got all the baserestrictinfo quals for this child.
	 */</comment>
	<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <name>childquals</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>baserestrict_min_security</name></name> <operator>=</operator> <name>cq_min_security</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
