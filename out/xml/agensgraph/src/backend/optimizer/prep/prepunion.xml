<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/optimizer/prep/prepunion.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * prepunion.c
 *	  Routines to plan set-operation queries.  The filename is a leftover
 *	  from a time when only UNIONs were implemented.
 *
 * There are two code paths in the planner for set-operation queries.
 * If a subquery consists entirely of simple UNION ALL operations, it
 * is converted into an "append relation".  Otherwise, it is handled
 * by the general code in this module (plan_set_operations and its
 * subroutines).  There is some support code here for the append-relation
 * case, but most of the heavy lifting for that is done elsewhere,
 * notably in prepjointree.c and allpaths.c.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/prep/prepunion.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>recurse_set_operations</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
										  <parameter><decl><type><name>bool</name></type> <name>junkOK</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>,
										  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pNumGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>generate_recursion_path</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>,
										   <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>generate_union_paths</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>generate_nonunion_paths</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>plan_union_children</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>top_union</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tlist_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type><name>make_union_unique</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
							   <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postprocess_setop_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>choose_hashed_setop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>,
								<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>input_path</name></decl></parameter>,
								<parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>dNumOutputRows</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>construct</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_setop_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
								  <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>hack_constants</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_tlist</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_append_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>flag</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_tlists</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_setop_grouplist</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * plan_set_operations
 *
 *	  Plans the queries for a tree of set operations (UNION/INTERSECT/EXCEPT)
 *
 * This routine only deals with the setOperations tree of the given query.
 * Any top-level ORDER BY requested in root-&gt;parse-&gt;sortClause will be handled
 * when we return to grouping_planner; likewise for LIMIT.
 *
 * What we return is an "upperrel" RelOptInfo containing at least one Path
 * that implements the set-operation tree.  In addition, root-&gt;processed_tlist
 * receives a targetlist representing the output of the topmost setop node.
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>plan_set_operations</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>topop</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>leftmostRTE</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>leftmostQuery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>setop_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>top_tlist</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>topop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check for unsupported stuff */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In the outer query level, we won't have any true equivalences to deal
	 * with; but we do want to be able to make pathkeys, which will require
	 * single-member EquivalenceClasses.  Indicate that EC merging is complete
	 * so that pathkeys.c won't complain.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>ec_merging_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We'll need to build RelOptInfos for each of the leaf subqueries, which
	 * are RTE_SUBQUERY rangetable entries in this Query.  Prepare the index
	 * arrays for those, and for AppendRelInfos in case they're needed.
	 */</comment>
	<expr_stmt><expr><call><name>setup_simple_rel_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the leftmost component Query.  We need to use its column names for
	 * all generated tlists (else SELECT INTO won't work right).
	 */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>topop</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>larg</name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostRTE</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostQuery</name> <operator>=</operator> <name><name>leftmostRTE</name><operator>-&gt;</operator><name>subquery</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostQuery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the topmost node is a recursive union, it needs special processing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasRecursion</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>setop_rel</name> <operator>=</operator> <call><name>generate_recursion_path</name><argument_list>(<argument><expr><name>topop</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
											<argument><expr><name><name>leftmostQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>top_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Recurse on setOperations tree to generate paths for set ops. The
		 * final output paths should have just the column types shown as the
		 * output from the top-level node, plus possibly resjunk working
		 * columns (we can rely on upper-level nodes to deal with that).
		 */</comment>
		<expr_stmt><expr><name>setop_rel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>topop</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name><name>topop</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>topop</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name><name>leftmostQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>top_tlist</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Must return the built tlist into root-&gt;processed_tlist. */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <name>top_tlist</name></expr>;</expr_stmt>

	<return>return <expr><name>setop_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * recurse_set_operations
 *	  Recursively handle one step in a tree of set operations
 *
 * colTypes: OID list of set-op's result column datatypes
 * colCollations: OID list of set-op's result column collations
 * junkOK: if true, child resjunk columns may be left in the result
 * flag: if &gt;= 0, add a resjunk output column indicating value of flag
 * refnames_tlist: targetlist to take column names from
 *
 * Returns a RelOptInfo for the subtree, as well as these output parameters:
 * *pTargetList: receives the fully-fledged tlist for the subtree's top plan
 * *pNumGroups: if not NULL, we estimate the number of distinct groups
 *		in the result, and store it there
 *
 * The pTargetList output parameter is mostly redundant with the pathtarget
 * of the returned RelOptInfo, but for the moment we need it because much of
 * the logic in this file depends on flag columns being marked resjunk.
 * Pending a redesign of how that works, this is the easy way out.
 *
 * We don't have to care about typmods here: the only allowed difference
 * between set-op input and output typmods is input is a specific typmod
 * and output is -1, and that does not require a coercion.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>recurse_set_operations</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>junkOK</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>,
					   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pNumGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* keep compiler quiet */</comment>

	<comment type="block">/* Guard against stack overflow due to overly complex setop nests */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subquery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build a RelOptInfo for this leaf subquery. */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* plan_params should not be in use in current query level */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Generate a subroot and Paths for the subquery */</comment>
		<expr_stmt><expr><name>subroot</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
												  <argument><expr><name>root</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>,
												  <argument><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It should not be possible for the primitive query to contain any
		 * cross-references to other primitive queries in the setop tree.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected outer reference in set operation subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Figure out the appropriate target list for this subquery. */</comment>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>generate_setop_tlist</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>, <argument><expr><name>colCollations</name></expr></argument>,
									 <argument><expr><name>flag</name></expr></argument>,
									 <argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>,
									 <argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Return the fully-fledged tlist to caller, too */</comment>
		<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark rel with estimated output rows, width, etc.  Note that we have
		 * to do this before generating outer-query paths, else
		 * cost_subqueryscan is not happy.
		 */</comment>
		<expr_stmt><expr><call><name>set_subquery_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since we may want to add a partial path to this relation, we must
		 * set its consider_parallel flag correctly.
		 */</comment>
		<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name><name>final_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * For the moment, we consider only a single Path for the subquery.
		 * This should change soon (make it look more like
		 * set_subquery_pathlist).
		 */</comment>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>get_cheapest_fractional_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>,
											   <argument><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Stick a SubqueryScanPath atop that.
		 *
		 * We don't bother to determine the subquery's output ordering since
		 * it won't be reflected in the set-op result anyhow; so just label
		 * the SubqueryScanPath with nil pathkeys.  (XXX that should change
		 * soon too, likely.)
		 */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>,
												 <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have a partial path for the child relation, we can use that
		 * to build a partial path for this relation.  But there's no point in
		 * considering any path but the cheapest.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>final_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>partial_subpath</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>partial_path</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>partial_subpath</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>final_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partial_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partial_subpath</name></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partial_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Estimate number of groups if caller wants it.  If the subquery used
		 * grouping or aggregation, its output is probably mostly unique
		 * anyway; otherwise do statistical estimation.
		 *
		 * XXX you don't really want to know about this: we do the estimation
		 * using the subquery's original targetlist expressions, not the
		 * subroot-&gt;processed_tlist which might seem more appropriate.  The
		 * reason is that if the subquery is itself a setop, it may return a
		 * processed_tlist containing "varno 0" Vars generated by
		 * generate_append_tlist, and those would confuse estimate_num_groups
		 * mightily.  We ought to get rid of the "varno 0" hack, but that
		 * requires a redesign of the parsetree representation of setops, so
		 * that there can be an RTE corresponding to each setop's output.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pNumGroups</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>subquery</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
				<name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
				<name><name>subroot</name><operator>-&gt;</operator><name>hasHavingQual</name></name> <operator>||</operator> <name><name>subquery</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>pNumGroups</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>pNumGroups</name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>,
												  <argument><expr><call><name>get_tlist_exprs</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* UNIONs are much different from INTERSECT/EXCEPT */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>generate_union_paths</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name>refnames_tlist</name></expr></argument>,
									   <argument><expr><name>pTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>generate_nonunion_paths</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>refnames_tlist</name></expr></argument>,
										  <argument><expr><name>pTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>pNumGroups</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>pNumGroups</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If necessary, add a Result node to project the caller-requested
		 * output columns.
		 *
		 * XXX you don't really want to know about this: setrefs.c will apply
		 * fix_upper_expr() to the Result node's tlist. This would fail if the
		 * Vars generated by generate_setop_tlist() were not exactly equal()
		 * to the corresponding tlist entries of the subplan. However, since
		 * the subplan was generated by generate_union_paths() or
		 * generate_nonunion_paths(), and hence its tlist was generated by
		 * generate_append_tlist(), this will work.  We just tell
		 * generate_setop_tlist() to use varno 0.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><call><name>tlist_same_datatypes</name><argument_list>(<argument><expr><operator>*</operator><name>pTargetList</name></expr></argument>, <argument><expr><name>colTypes</name></expr></argument>, <argument><expr><name>junkOK</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>tlist_same_collations</name><argument_list>(<argument><expr><operator>*</operator><name>pTargetList</name></expr></argument>, <argument><expr><name>colCollations</name></expr></argument>, <argument><expr><name>junkOK</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <call><name>generate_setop_tlist</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>, <argument><expr><name>colCollations</name></expr></argument>,
												<argument><expr><name>flag</name></expr></argument>,
												<argument><expr><literal type="number">0</literal></expr></argument>,
												<argument><expr><name>false</name></expr></argument>,
												<argument><expr><operator>*</operator><name>pTargetList</name></expr></argument>,
												<argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>*</operator><name>pTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Apply projection to each path */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
												<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* If we had to add a Result, path is different from subpath */</comment>
				<if_stmt><if>if <condition>(<expr><name>path</name> <operator>!=</operator> <name>subpath</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* Apply projection to each partial path */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* avoid apply_projection_to_path, in case of multiple refs */</comment>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
													   <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>postprocess_setop_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate paths for a recursive UNION node
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>generate_recursion_path</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>result_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>lrel</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>lpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>rpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lpath_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rpath_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroups</name></decl>;</decl_stmt>

	<comment type="block">/* Parser should have rejected other cases */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>setOp</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_UNION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only UNION queries can be recursive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Worktable ID should be assigned */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unlike a regular UNION node, process the left and right inputs
	 * separately without any intention of combining them into one Append.
	 */</comment>
	<expr_stmt><expr><name>lrel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>lpath_tlist</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lpath</name> <operator>=</operator> <name><name>lrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
	<comment type="block">/* The right path will want to look at the left one ... */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>non_recursive_path</name></name> <operator>=</operator> <name>lpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rrel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>rpath_tlist</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rpath</name> <operator>=</operator> <name><name>rrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>non_recursive_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate tlist for RecursiveUnion path node --- same as in Append cases
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>generate_append_tlist</name><argument_list>(<argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>lpath_tlist</name></expr></argument>, <argument><expr><name>rpath_tlist</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<comment type="block">/* Build result relation. */</comment>
	<expr_stmt><expr><name>result_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>,
								 <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>lrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If UNION, identify the grouping operators
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>setOp</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>groupList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Identify the grouping semantics */</comment>
		<expr_stmt><expr><name>groupList</name> <operator>=</operator> <call><name>generate_setop_grouplist</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We only support hashing here */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name>groupList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement recursive UNION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"All column datatypes must be hashable."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For the moment, take the number of distinct groups as equal to the
		 * total input size, ie, the worst case.
		 */</comment>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <name><name>lpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>+</operator> <name><name>rpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * And make the path node.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_recursiveunion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>result_rel</name></expr></argument>,
											   <argument><expr><name>lpath</name></expr></argument>,
											   <argument><expr><name>rpath</name></expr></argument>,
											   <argument><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
											   <argument><expr><name>groupList</name></expr></argument>,
											   <argument><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name></expr></argument>,
											   <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>postprocess_setop_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate paths for a UNION or UNION ALL node
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>generate_union_paths</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>result_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>save_fraction</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partial_pathlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partial_paths_valid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>consider_parallel</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rellist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If plain UNION, tell children to fetch all tuples.
	 *
	 * Note: in UNION ALL, we pass the top-level tuple_fraction unmodified to
	 * each arm of the UNION ALL.  One could make a case for reducing the
	 * tuple fraction for later arms (discounting by the expected size of the
	 * earlier arms' results) but it seems not worth the trouble. The normal
	 * case where tuple_fraction isn't already zero is a LIMIT at top level,
	 * and passing it down as-is is usually enough to get the desired result
	 * of preferring fast-start plans.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If any of my children are identical UNION nodes (same op, all-flag, and
	 * colTypes) then they can be merged into this node so that we generate
	 * only one Append and unique-ification for the lot.  Recurse to find such
	 * nodes and compute their children's paths.
	 */</comment>
	<expr_stmt><expr><name>rellist</name> <operator>=</operator> <call><name>plan_union_children</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>refnames_tlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlist_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate tlist for Append plan node.
	 *
	 * The tlist for an Append plan isn't important as far as the Append is
	 * concerned, but we must make it look real anyway for the benefit of the
	 * next plan level up.
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>generate_append_tlist</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>tlist_list</name></expr></argument>, <argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<comment type="block">/* Build path lists and relid set. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rellist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pathlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pathlist</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>consider_parallel</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>consider_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>partial_paths_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>partial_paths_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>partial_pathlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>partial_pathlist</name></expr></argument>,
										   <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Build result relation. */</comment>
	<expr_stmt><expr><name>result_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>consider_parallel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Append the child results together.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>pathlist</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For UNION ALL, we just need the Append path.  For UNION, need to add
	 * node(s) to remove duplicates.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>make_union_unique</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of groups.  For now we just assume the output is unique
	 * --- this is certainly true for the UNION case, and we want worst-case
	 * estimates anyway.
	 */</comment>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now consider doing the same thing using the partial paths plus Append
	 * plus Gather.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partial_paths_valid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>ppath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Find the highest number of workers requested for any subpath. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the use of parallel append is permitted, always request at least
		 * log2(# of children) paths.  We assume it can be useful to have
		 * extra workers in this case because they will be spread out across
		 * the children.  The precise formula is just a guess; see
		 * add_paths_to_append_rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_parallel_append</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>,
								   <argument><expr><call><name>fls</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>partial_pathlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>,
								   <argument><expr><name>max_parallel_workers_per_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ppath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>partial_pathlist</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>enable_parallel_append</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ppath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_gather_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>ppath</name></expr></argument>,
							   <argument><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ppath</name> <operator>=</operator> <call><name>make_union_unique</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ppath</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>ppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Undo effects of possibly forcing tuple_fraction to 0 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <name>save_fraction</name></expr>;</expr_stmt>

	<return>return <expr><name>result_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate paths for an INTERSECT, INTERSECT ALL, EXCEPT, or EXCEPT ALL node
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>generate_nonunion_paths</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>result_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>lrel</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>save_fraction</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>lpath</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rpath</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lpath_tlist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rpath_tlist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tlist_list</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tlist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>groupList</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pathlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dLeftGroups</name></decl>,
				<decl><type ref="prev"/><name>dRightGroups</name></decl>,
				<decl><type ref="prev"/><name>dNumGroups</name></decl>,
				<decl><type ref="prev"/><name>dNumOutputRows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOpCmd</name></type>	<name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstFlag</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Tell children to fetch all tuples.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

	<comment type="block">/* Recurse on children, ensuring their outputs are marked */</comment>
	<expr_stmt><expr><name>lrel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>lpath_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>dLeftGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lpath</name> <operator>=</operator> <name><name>lrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rrel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>rpath_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>dRightGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rpath</name> <operator>=</operator> <name><name>rrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>

	<comment type="block">/* Undo effects of forcing tuple_fraction to 0 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <name>save_fraction</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For EXCEPT, we must put the left input first.  For INTERSECT, either
	 * order should give the same results, and we prefer to put the smaller
	 * input first in order to minimize the size of the hash table in the
	 * hashing case.  "Smaller" means the one with the fewer groups.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_EXCEPT</name> <operator>||</operator> <name>dLeftGroups</name> <operator>&lt;=</operator> <name>dRightGroups</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pathlist</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>lpath</name></expr></argument>, <argument><expr><name>rpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist_list</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>lpath_tlist</name></expr></argument>, <argument><expr><name>rpath_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstFlag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>pathlist</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>rpath</name></expr></argument>, <argument><expr><name>lpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist_list</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>rpath_tlist</name></expr></argument>, <argument><expr><name>lpath_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstFlag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Generate tlist for Append plan node.
	 *
	 * The tlist for an Append plan isn't important as far as the Append is
	 * concerned, but we must make it look real anyway for the benefit of the
	 * next plan level up.  In fact, it has to be real enough that the flag
	 * column is shown as a variable not a constant, else setrefs.c will get
	 * confused.
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>generate_append_tlist</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>tlist_list</name></expr></argument>, <argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<comment type="block">/* Build result relation. */</comment>
	<expr_stmt><expr><name>result_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>,
								 <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>lrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Append the child results together.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>pathlist</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Identify the grouping semantics */</comment>
	<expr_stmt><expr><name>groupList</name> <operator>=</operator> <call><name>generate_setop_grouplist</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of distinct groups that we'll need hashtable entries
	 * for; this is the size of the left-hand input for EXCEPT, or the smaller
	 * input for INTERSECT.  Also estimate the number of eventual output rows.
	 * In non-ALL cases, we estimate each group produces one output row; in
	 * ALL cases use the relevant relation size.  These are worst-case
	 * estimates, of course, but we need to be conservative.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_EXCEPT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <name>dLeftGroups</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dNumOutputRows</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr> ?</condition><then> <expr><name><name>lpath</name><operator>-&gt;</operator><name>rows</name></name></expr> </then><else>: <expr><name>dNumGroups</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>dLeftGroups</name></expr></argument>, <argument><expr><name>dRightGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dNumOutputRows</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr> ?</condition><then> <expr><call><name>Min</name><argument_list>(<argument><expr><name><name>lpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>rpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>dNumGroups</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Decide whether to hash or sort, and add a sort node if needed.
	 */</comment>
	<expr_stmt><expr><name>use_hash</name> <operator>=</operator> <call><name>choose_hashed_setop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>groupList</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
								   <argument><expr><name>dNumGroups</name></expr></argument>, <argument><expr><name>dNumOutputRows</name></expr></argument>,
								   <argument><expr><ternary><condition><expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_INTERSECT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"INTERSECT"</literal></expr> </then><else>: <expr><literal type="string">"EXCEPT"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>groupList</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>result_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																	   <argument><expr><name>groupList</name></expr></argument>,
																	   <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Finally, add a SetOp path node to generate the correct output.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SETOP_INTERSECT</name></expr>:</case>
			<expr_stmt><expr><name>cmd</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr> ?</condition><then> <expr><name>SETOPCMD_INTERSECT_ALL</name></expr> </then><else>: <expr><name>SETOPCMD_INTERSECT</name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SETOP_EXCEPT</name></expr>:</case>
			<expr_stmt><expr><name>cmd</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr> ?</condition><then> <expr><name>SETOPCMD_EXCEPT_ALL</name></expr> </then><else>: <expr><name>SETOPCMD_EXCEPT</name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized set op: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>op</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>SETOPCMD_INTERSECT</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_setop_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>result_rel</name></expr></argument>,
									  <argument><expr><name>path</name></expr></argument>,
									  <argument><expr><name>cmd</name></expr></argument>,
									  <argument><expr><ternary><condition><expr><name>use_hash</name></expr> ?</condition><then> <expr><name>SETOP_HASHED</name></expr> </then><else>: <expr><name>SETOP_SORTED</name></expr></else></ternary></expr></argument>,
									  <argument><expr><name>groupList</name></expr></argument>,
									  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									  <argument><expr><ternary><condition><expr><name>use_hash</name></expr> ?</condition><then> <expr><name>firstFlag</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>,
									  <argument><expr><name>dNumGroups</name></expr></argument>,
									  <argument><expr><name>dNumOutputRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pull up children of a UNION node that are identically-propertied UNIONs.
 *
 * NOTE: we can also pull a UNION ALL up into a UNION, since the distinct
 * output rows will be lost anyway.
 *
 * NOTE: currently, we ignore collations while determining if a child has
 * the same properties.  This is semantically sound only so long as all
 * collations have the same notion of equality.  It is valid from an
 * implementation standpoint because we don't care about the ordering of
 * a UNION child's result: UNION ALL results are always unordered, and
 * generate_union_paths will force a fresh sort if the top level is a UNION.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>plan_union_children</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>top_union</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tlist_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pending_rels</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>top_union</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_tlist</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>tlist_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>pending_rels</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>setOp</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>pending_rels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pending_rels</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>pending_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name><name>top_union</name><operator>-&gt;</operator><name>op</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name> <operator>==</operator> <name><name>top_union</name><operator>-&gt;</operator><name>all</name></name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>all</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>top_union</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Same UNION, so fold children into parent */</comment>
				<expr_stmt><expr><name>pending_rels</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>pending_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pending_rels</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>pending_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Not same, so plan this child separately.
		 *
		 * Note we disallow any resjunk columns in child results.  This is
		 * necessary since the Append node that implements the union won't do
		 * any projection, and upper levels will get confused if some of our
		 * output tuples have junk and some don't.  This case only arises when
		 * we have an EXCEPT or INTERSECT as child, else there won't be
		 * resjunk anyway.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>recurse_set_operations</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
														<argument><expr><name><name>top_union</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>,
														<argument><expr><name><name>top_union</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
														<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
														<argument><expr><name>refnames_tlist</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>child_tlist</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tlist_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tlist_list</name></expr></argument>, <argument><expr><name>child_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add nodes to the given path tree to unique-ify the result of a UNION.
 */</comment>
<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>make_union_unique</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
				  <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>result_rel</name> <init>= <expr><call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroups</name></decl>;</decl_stmt>

	<comment type="block">/* Identify the grouping semantics */</comment>
	<expr_stmt><expr><name>groupList</name> <operator>=</operator> <call><name>generate_setop_grouplist</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX for the moment, take the number of distinct groups as equal to the
	 * total input size, ie, the worst case.  This is too conservative, but
	 * it's not clear how to get a decent estimate of the true size.  One
	 * should note as well the propensity of novices to write UNION rather
	 * than UNION ALL even when they don't expect any duplicates...
	 */</comment>
	<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/* Decide whether to hash or sort */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>choose_hashed_setop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>groupList</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
							<argument><expr><name>dNumGroups</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>,
							<argument><expr><literal type="string">"UNION"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Hashed aggregate plan --- no sort needed */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>result_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>AGG_HASHED</name></expr></argument>,
										<argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										<argument><expr><name>groupList</name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Sort and Unique */</comment>
		<if_stmt><if>if <condition>(<expr><name>groupList</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name>result_rel</name></expr></argument>,
								 <argument><expr><name>path</name></expr></argument>,
								 <argument><expr><call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															   <argument><expr><name>groupList</name></expr></argument>,
															   <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_upper_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>result_rel</name></expr></argument>,
												 <argument><expr><name>path</name></expr></argument>,
												 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postprocess_setop_rel - perform steps required after adding paths
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postprocess_setop_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We don't currently worry about allowing FDWs to contribute paths to
	 * this relation, but give extensions a chance.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Select cheapest path */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * choose_hashed_setop - should we use hashing for a set operation?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>choose_hashed_setop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>,
					<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>input_path</name></decl></parameter>,
					<parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>dNumOutputRows</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>construct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroupCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hash_mem_limit</name> <init>= <expr><call><name>get_hash_memory_limit</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_sort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hashentrysize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>hashed_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>sorted_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuple_fraction</name></decl>;</decl_stmt>

	<comment type="block">/* Check whether the operators support sorting or hashing */</comment>
	<expr_stmt><expr><name>can_sort</name> <operator>=</operator> <call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>can_hash</name> <operator>=</operator> <call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>can_hash</name> <operator>&amp;&amp;</operator> <name>can_sort</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we have a meaningful choice to make, continue ... */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>can_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>can_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is UNION, INTERSECT, or EXCEPT */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement %s"</literal></expr></argument>, <argument><expr><name>construct</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Some of the datatypes only support hashing, while others only support sorting."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Prefer sorting when enable_hashagg is off */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_hashagg</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't do it if it doesn't look like the hashtable will fit into
	 * hash_mem.
	 */</comment>
	<expr_stmt><expr><name>hashentrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hashentrysize</name> <operator>*</operator> <name>dNumGroups</name> <operator>&gt;</operator> <name>hash_mem_limit</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * See if the estimated cost is no more than doing it the other way.
	 *
	 * We need to consider input_plan + hashagg versus input_plan + sort +
	 * group.  Note that the actual result plan might involve a SetOp or
	 * Unique node, not Agg or Group, but the cost estimates for Agg and Group
	 * should be close enough for our purposes here.
	 *
	 * These path variables are dummies that just hold cost fields; we don't
	 * make actual Paths for these steps.
	 */</comment>
	<expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashed_p</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>AGG_HASHED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			 <argument><expr><name>numGroupCols</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>,
			 <argument><expr><name>NIL</name></expr></argument>,
			 <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
			 <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now for the sorted case.  Note that the input is *always* unsorted,
	 * since it was made by appending unrelated sub-relations together.
	 */</comment>
	<expr_stmt><expr><name><name>sorted_p</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>input_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sorted_p</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>input_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<comment type="block">/* XXX cost_sort doesn't actually look at pathkeys, so just pass NIL */</comment>
	<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sorted_p</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>sorted_p</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
			  <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
			  <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cost_group</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sorted_p</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>numGroupCols</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>,
			   <argument><expr><name>NIL</name></expr></argument>,
			   <argument><expr><name><name>sorted_p</name><operator>.</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>sorted_p</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
			   <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now make the decision using the top-level tuple fraction.  First we
	 * have to convert an absolute count (LIMIT) into fractional form.
	 */</comment>
	<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>/=</operator> <name>dNumOutputRows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>compare_fractional_path_costs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashed_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sorted_p</name></expr></argument>,
									  <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Hashed is cheaper, so use it */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate targetlist for a set-operation plan node
 *
 * colTypes: OID list of set-op's result column datatypes
 * colCollations: OID list of set-op's result column collations
 * flag: -1 if no flag column needed, 0 or 1 to create a const flag column
 * varno: varno to use in generated Vars
 * hack_constants: true to copy up constants (see comments in code)
 * input_tlist: targetlist of this node's input node
 * refnames_tlist: targetlist to take column names from
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_setop_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
					 <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>hack_constants</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_tlist</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ctlc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cclc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>itlc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rtlc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<macro><name>forfour</name><argument_list>(<argument>ctlc</argument>, <argument>colTypes</argument>, <argument>cclc</argument>, <argument>colCollations</argument>,
			<argument>itlc</argument>, <argument>input_tlist</argument>, <argument>rtlc</argument>, <argument>refnames_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colType</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>ctlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colColl</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cclc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>inputtle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>itlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>reftle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rtlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>inputtle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reftle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>inputtle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>reftle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate columns referencing input columns and having appropriate
		 * data types and column names.  Insert datatype coercions where
		 * necessary.
		 *
		 * HACK: constants in the input's targetlist are copied up as-is
		 * rather than being referenced as subquery outputs.  This is mainly
		 * to ensure that when we try to coerce them to the output column's
		 * datatype, the right things happen for UNKNOWN constants.  But do
		 * this only at the first level of subquery-scan plans; we don't want
		 * phony constants appearing in the output tlists of upper-level
		 * nodes!
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hack_constants</name> <operator>&amp;&amp;</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
									<argument><expr><name><name>inputtle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
									<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>colType</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: it's not really cool to be applying coerce_to_common_type
			 * here; one notable point is that assign_expr_collations never
			 * gets run on any generated nodes.  For the moment that's not a
			 * problem because we force the correct exposed collation below.
			 * It would likely be best to make the parser generate the correct
			 * output tlist for every set-op to begin with, though.
			 */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no UNKNOWNs here */</comment>
										 <argument><expr><name>expr</name></expr></argument>,
										 <argument><expr><name>colType</name></expr></argument>,
										 <argument><expr><literal type="string">"UNION/INTERSECT/EXCEPT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Ensure the tlist entry's exposed collation matches the set-op. This
		 * is necessary because plan_set_operations() reports the result
		 * ordering as a list of SortGroupClauses, which don't carry collation
		 * themselves but just refer to tlist entries.  If we don't show the
		 * right collation then planner.c might do the wrong thing in
		 * higher-level queries.
		 *
		 * Note we use RelabelType, not CollateExpr, since this expression
		 * will reach the executor without any further processing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>colColl</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>applyRelabelType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
									<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colColl</name></expr></argument>,
									<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name><operator>++</operator></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>reftle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * By convention, all non-resjunk columns in a setop tree have
		 * ressortgroupref equal to their resno.  In some cases the ref isn't
		 * needed, but this is a cleaner way than modifying the tlist later.
		 */</comment>
		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add a resjunk flag column */</comment>
		<comment type="block">/* flag value is the given constant */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>,
								  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name><operator>++</operator></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"flag"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate targetlist for a set-operation Append node
 *
 * colTypes: OID list of set-op's result column datatypes
 * colCollations: OID list of set-op's result column collations
 * flag: true to create a flag column copied up from subplans
 * input_tlists: list of tlists for sub-plans of the Append
 * refnames_tlist: targetlist to take column names from
 *
 * The entries in the Append's targetlist should always be simple Vars;
 * we just have to make sure they have the right datatypes/typmods/collations.
 * The Vars are always generated with varno 0.
 *
 * XXX a problem with the varno-zero approach is that set_pathtarget_cost_width
 * cannot figure out a realistic width for the tlist we make here.  But we
 * ought to refactor this code to produce a PathTarget directly, anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_append_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>flag</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_tlists</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curColType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curColCollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ref_tl_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlistl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>colTypmods</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First extract typmods to use.
	 *
	 * If the inputs all agree on type and typmod of a particular column, use
	 * that typmod; else use -1.
	 */</comment>
	<expr_stmt><expr><name>colTypmods</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tlistl</argument>, <argument>input_tlists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subtlist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlistl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>subtlistl</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>curColType</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>subtlistl</argument>, <argument>subtlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>subtle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subtlistl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>subtle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>curColType</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If first subplan, copy the typmod; else compare */</comment>
				<decl_stmt><decl><type><name>int32</name></type>		<name>subtypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>tlistl</name> <operator>==</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>input_tlists</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>colTypmods</name><index>[<expr><name>colindex</name></expr>]</index></name> <operator>=</operator> <name>subtypmod</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>subtypmod</name> <operator>!=</operator> <name><name>colTypmods</name><index>[<expr><name>colindex</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>colTypmods</name><index>[<expr><name>colindex</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* types disagree, so force typmod to -1 */</comment>
				<expr_stmt><expr><name><name>colTypmods</name><index>[<expr><name>colindex</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>curColType</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>, <argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colindex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>curColType</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now we can build the tlist for the Append.
	 */</comment>
	<expr_stmt><expr><name>colindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forthree</name><argument_list>(<argument>curColType</argument>, <argument>colTypes</argument>, <argument>curColCollation</argument>, <argument>colCollations</argument>,
			 <argument>ref_tl_item</argument>, <argument>refnames_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colType</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>colTypmod</name> <init>= <expr><name><name>colTypmods</name><index>[<expr><name>colindex</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colColl</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColCollation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>reftle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ref_tl_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reftle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>reftle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>resno</name></expr></argument>,
								<argument><expr><name>colType</name></expr></argument>,
								<argument><expr><name>colTypmod</name></expr></argument>,
								<argument><expr><name>colColl</name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name><operator>++</operator></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>reftle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * By convention, all non-resjunk columns in a setop tree have
		 * ressortgroupref equal to their resno.  In some cases the ref isn't
		 * needed, but this is a cleaner way than modifying the tlist later.
		 */</comment>
		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add a resjunk flag column */</comment>
		<comment type="block">/* flag value is shown as copied up from subplan */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>resno</name></expr></argument>,
								<argument><expr><name>INT4OID</name></expr></argument>,
								<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name><operator>++</operator></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"flag"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>colTypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_setop_grouplist
 *		Build a SortGroupClause list defining the sort/grouping properties
 *		of the setop's output columns.
 *
 * Parse analysis already determined the properties and built a suitable
 * list, except that the entries do not have sortgrouprefs set because
 * the parser output representation doesn't include a tlist for each
 * setop.  So what we need to do here is copy that list and install
 * proper sortgrouprefs into it (copying those from the targetlist).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_setop_grouplist</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>grouplist</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lg</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>grouplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* resjunk columns should not have sortgrouprefs */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>			<comment type="block">/* ignore resjunk columns */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* non-resjunk columns should have sortgroupref = resno */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* non-resjunk columns should have grouping clauses */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sgc</name> <operator>=</operator> <operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lg</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>grouplist</name></expr></argument>, <argument><expr><name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sgc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lg</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>grouplist</name></expr>;</return>
</block_content>}</block></function>
</unit>
