<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/optimizer/plan/setrefs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * setrefs.c
 *	  Post-processing of a completed plan tree: fix references to subplan
 *	  vars, compute regproc values for operators, etc
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/plan/setrefs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name></decl>;</decl_stmt>			<comment type="block">/* RT index of Var */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>varattno</name></decl>;</decl_stmt>		<comment type="block">/* attr number of Var */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>resno</name></decl>;</decl_stmt>			<comment type="block">/* TLE position of Var */</comment>
}</block></struct></type> <name>tlist_vinfo</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>			<comment type="block">/* underlying target list */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_vars</name></decl>;</decl_stmt>		<comment type="block">/* number of plain Var tlist entries */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_ph_vars</name></decl>;</decl_stmt>	<comment type="block">/* are there PlaceHolderVar entries? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_non_vars</name></decl>;</decl_stmt>	<comment type="block">/* are there other entries? */</comment>
	<decl_stmt><decl><type><name>tlist_vinfo</name></type> <name><name>vars</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* has num_vars entries */</comment>
}</block></struct></type> <name>indexed_tlist</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtoffset</name></decl>;</decl_stmt>
}</block></struct></type> <name>fix_scan_expr_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>outer_itlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>inner_itlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>acceptable_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtoffset</name></decl>;</decl_stmt>
}</block></struct></type> <name>fix_join_expr_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>subplan_itlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>newvarno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtoffset</name></decl>;</decl_stmt>
}</block></struct></type> <name>fix_upper_expr_context</name>;</typedef>

<comment type="block">/*
 * Check if a Const node is a regclass value.  We accept plain OID too,
 * since a regclass Const will get folded to that type if it's an argument
 * to oideq or similar operators.  (This might result in some extraneous
 * values in a plan's list of relation dependencies, but the worst result
 * would be occasional useless replans.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISREGCLASSCONST</name><parameter_list>(<parameter><type><name>con</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(((con)-&gt;consttype == REGCLASSOID || (con)-&gt;consttype == OIDOID) &amp;&amp; \
	 !(con)-&gt;constisnull)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fix_scan_list</name><parameter_list>(<parameter><type><name>root</name></type></parameter>, <parameter><type><name>lst</name></type></parameter>, <parameter><type><name>rtoffset</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((List *) fix_scan_expr(root, (Node *) (lst), rtoffset))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_rtes_to_flat_rtable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flatten_unplanned_rtes</name><parameter_list>(<parameter><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>flatten_rtes_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_rte_to_flat_rtable</name><parameter_list>(<parameter><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>set_plan_refs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>set_indexonlyscan_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										  <parameter><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>set_subqueryscan_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										 <parameter><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>trivial_subqueryscan</name><parameter_list>(<parameter><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>clean_up_removed_plan_level</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_foreignscan_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									   <parameter><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fscan</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_customscan_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									  <parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>set_append_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								   <parameter><decl><type><name>Append</name> <modifier>*</modifier></type><name>aplan</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>set_mergeappend_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										<parameter><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mplan</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_hash_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relids</name></type> <name>offset_relid_set</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>fix_scan_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>fix_scan_expr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>fix_scan_expr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>fix_scan_expr_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>fix_scan_expr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_join_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>join</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_upper_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_param_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>convert_combining_aggrefs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_dummy_tlist_references</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>indexed_tlist</name> <modifier>*</modifier></type><name>build_tlist_index</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type><name>search_indexed_tlist_for_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
										 <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl></parameter>,
										 <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type><name>search_indexed_tlist_for_non_var</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
											 <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl></parameter>,
											 <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type><name>search_indexed_tlist_for_sortgroupref</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
												  <parameter><decl><type><name>Index</name></type> <name>sortgroupref</name></decl></parameter>,
												  <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl></parameter>,
												  <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>fix_join_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
						   <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>outer_itlist</name></decl></parameter>,
						   <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>inner_itlist</name></decl></parameter>,
						   <parameter><decl><type><name>Index</name></type> <name>acceptable_rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>fix_join_expr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								   <parameter><decl><type><name>fix_join_expr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>fix_upper_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							<parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>subplan_itlist</name></decl></parameter>,
							<parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>fix_upper_expr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									<parameter><decl><type><name>fix_upper_expr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>set_returning_clause_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rlist</name></decl></parameter>,
											 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>topplan</name></decl></parameter>,
											 <parameter><decl><type><name>Index</name></type> <name>resultRelation</name></decl></parameter>,
											 <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* agensgraph */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_dijkstra_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *		SUBPLAN REFERENCES
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * set_plan_references
 *
 * This is the final processing pass of the planner/optimizer.  The plan
 * tree is complete; we just have to adjust some representational details
 * for the convenience of the executor:
 *
 * 1. We flatten the various subquery rangetables into a single list, and
 * zero out RangeTblEntry fields that are not useful to the executor.
 *
 * 2. We adjust Vars in scan nodes to be consistent with the flat rangetable.
 *
 * 3. We adjust Vars in upper plan nodes to refer to the outputs of their
 * subplans.
 *
 * 4. Aggrefs in Agg plan nodes need to be adjusted in some cases involving
 * partial aggregation or minmax aggregate optimization.
 *
 * 5. PARAM_MULTIEXPR Params are replaced by regular PARAM_EXEC Params,
 * now that we have finished planning all MULTIEXPR subplans.
 *
 * 6. We compute regproc OIDs for operators (ie, we look up the function
 * that implements each op).
 *
 * 7. We create lists of specific objects that the plan depends on.
 * This will be used by plancache.c to drive invalidation of cached plans.
 * Relation dependencies are represented by OIDs, and everything else by
 * PlanInvalItems (this distinction is motivated by the shared-inval APIs).
 * Currently, relations, user-defined functions, and domains are the only
 * types of objects that are explicitly tracked this way.
 *
 * 8. We assign every plan node in the tree a unique ID.
 *
 * We also perform one final optimization step, which is to delete
 * SubqueryScan, Append, and MergeAppend plan nodes that aren't doing
 * anything useful.  The reason for doing this last is that
 * it can't readily be done before set_plan_references, because it would
 * break set_upper_references: the Vars in the child plan's top tlist
 * wouldn't match up with the Vars in the outer plan tree.  A SubqueryScan
 * serves a necessary function as a buffer between outer query and subquery
 * variable numbering ... but after we've flattened the rangetable this is
 * no longer a problem, since then there's only one rtindex namespace.
 * Likewise, Append and MergeAppend buffer between the parent and child vars
 * of an appendrel, but we don't need to worry about that once we've done
 * set_plan_references.
 *
 * set_plan_references recursively traverses the whole plan tree.
 *
 * The return value is normally the same Plan node passed in, but can be
 * different when the passed-in Plan is a node we decide isn't needed.
 *
 * The flattened rangetable entries are appended to root-&gt;glob-&gt;finalrtable.
 * Also, rowmarks entries are appended to root-&gt;glob-&gt;finalrowmarks, and the
 * RT indexes of ModifyTable result relations to root-&gt;glob-&gt;resultRelations,
 * and flattened AppendRelInfos are appended to root-&gt;glob-&gt;appendRelations.
 * Plan dependencies are appended to root-&gt;glob-&gt;relationOids (for relations)
 * and root-&gt;glob-&gt;invalItems (for everything else).
 *
 * Notice that we modify Plan nodes in-place, but use expression_tree_mutator
 * to process targetlist and qual expressions.  We can assume that the Plan
 * nodes were just built by the planner and are not multiply referenced, but
 * it's not so safe to assume that for expression tree nodes.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>set_plan_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtoffset</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Add all the query's RTEs to the flattened rangetable.  The live ones
	 * will have their rangetable indexes increased by rtoffset.  (Additional
	 * RTEs, not referenced by the Plan tree, might get added after those.)
	 */</comment>
	<expr_stmt><expr><call><name>add_rtes_to_flat_rtable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust RT indexes of PlanRowMarks and add to final rowmarks list
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>newrc</name></decl>;</decl_stmt>

		<comment type="block">/* flat copy is enough since all fields are scalars */</comment>
		<expr_stmt><expr><name>newrc</name> <operator>=</operator> <operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newrc</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* adjust indexes ... but *not* the rowmarkId */</comment>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>rti</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>prti</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrowmarks</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrowmarks</name></name></expr></argument>, <argument><expr><name>newrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Adjust RT indexes of AppendRelInfos and add to final appendrels list.
	 * We assume the AppendRelInfos were built during planning and don't need
	 * to be copied.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* adjust RT indexes */</comment>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Rather than adjust the translated_vars entries, just drop 'em.
		 * Neither the executor nor EXPLAIN currently need that data.
		 */</comment>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>appendRelations</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>appendRelations</name></name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Now fix the Plan tree */</comment>
	<return>return <expr><call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract RangeTblEntries from the plan's rangetable, and add to flat rtable
 *
 * This can recurse into subquery plans; "recursing" is true if so.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_rtes_to_flat_rtable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Add the query's own RTEs to the flattened rangetable.
	 *
	 * At top level, we must add all RTEs so that their indexes in the
	 * flattened rangetable match up with their original indexes.  When
	 * recursing, we only care about extracting relation RTEs.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>||</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_rte_to_flat_rtable</name><argument_list>(<argument><expr><name>glob</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there are any dead subqueries, they are not referenced in the Plan
	 * tree, so we must add RTEs contained in them to the flattened rtable
	 * separately.  (If we failed to do this, the executor would not perform
	 * expected permission checks for tables mentioned in such subqueries.)
	 *
	 * Note: this pass over the rangetable can't be combined with the previous
	 * one, because that would mess up the numbering of the live RTEs in the
	 * flattened rangetable.
	 */</comment>
	<expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We should ignore inheritance-parent RTEs: their contents have been
		 * pulled up into our rangetable already.  Also ignore any subquery
		 * RTEs without matching RelOptInfos, as they likewise have been
		 * pulled up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator>
			<name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sanity check on array */</comment>

				<comment type="block">/*
				 * The subquery might never have been planned at all, if it
				 * was excluded on the basis of self-contradictory constraints
				 * in our query level.  In this case apply
				 * flatten_unplanned_rtes.
				 *
				 * If it was planned but the result rel is dummy, we assume
				 * that it has been omitted from our plan tree (see
				 * set_subquery_pathlist), and recurse to pull up its RTEs.
				 *
				 * Otherwise, it should be represented by a SubqueryScan node
				 * somewhere in our plan tree, and we'll pull up its RTEs when
				 * we process that plan node.
				 *
				 * However, if we're recursing, then we should pull up RTEs
				 * whether the subquery is dummy or not, because we've found
				 * that some upper query level is treating this one as dummy,
				 * and so we won't scan this level's plan tree at all.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>flatten_unplanned_rtes</name><argument_list>(<argument><expr><name>glob</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>recursing</name> <operator>||</operator>
						 <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>,
													  <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>add_rtes_to_flat_rtable</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rti</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Extract RangeTblEntries from a subquery that was never planned at all
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flatten_unplanned_rtes</name><parameter_list>(<parameter><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Use query_tree_walker to find all RTEs in the parse tree */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
							 <argument><expr><name>flatten_rtes_walker</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>glob</name></expr></argument>,
							 <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>flatten_rtes_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* As above, we need only save relation RTEs */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_rte_to_flat_rtable</name><argument_list>(<argument><expr><name>glob</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								 <argument><expr><name>flatten_rtes_walker</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>glob</name></expr></argument>,
								 <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>flatten_rtes_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>glob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add (a copy of) the given RTE to the final rangetable
 *
 * In the flat rangetable, we zero out substructure pointers that are not
 * needed by the executor; this reduces the storage space and copying cost
 * for cached plans.  We keep only the ctename, alias and eref Alias fields,
 * which are needed by EXPLAIN, and the selectedCols, insertedCols,
 * updatedCols, and extraUpdatedCols bitmaps, which are needed for
 * executor-startup permissions checking and for trigger event checking.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_rte_to_flat_rtable</name><parameter_list>(<parameter><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newrte</name></decl>;</decl_stmt>

	<comment type="block">/* flat copy to duplicate all the scalar fields */</comment>
	<expr_stmt><expr><name>newrte</name> <operator>=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newrte</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* zap unneeded sub-structure */</comment>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>joinleftcols</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>joinrightcols</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>tablefunc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr></argument>, <argument><expr><name>newrte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for RT index overflow; it's very unlikely, but if it did happen,
	 * the executor would get confused by varnos that match the special varno
	 * values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_SPECIAL_VARNO</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many range table entries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's a plain relation RTE, add the table to relationOids.
	 *
	 * We do this even though the RTE might be unreferenced in the plan tree;
	 * this would correspond to cases such as views that were expanded, child
	 * tables that were eliminated by constraint exclusion, etc. Schema
	 * invalidation on such a rel must still force rebuilding of the plan.
	 *
	 * Note we don't bother to avoid making duplicate list entries.  We could,
	 * but it would probably cost more cycles than it would save.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>newrte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>, <argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_plan_refs: recurse through the Plan nodes of a single subquery level
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>set_plan_refs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Assign this node a unique ID. */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>lastPlanNodeId</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Plan-type-specific fixes
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SeqScan</name>    <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>SeqScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SampleScan</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>SampleScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator>
					<call><name>fix_scan_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>splan</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>indexqualorig</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>indexorderby</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>indexorderby</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>indexorderbyorig</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>indexorderbyorig</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><call><name>set_indexonlyscan_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>splan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<comment type="block">/* no need to fix targetlist and qual */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>indexqualorig</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>bitmapqualorig</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>bitmapqualorig</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TidScan</name>    <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>tidquals</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>tidquals</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<comment type="block">/* Needs special treatment, see comments below */</comment>
			<return>return <expr><call><name>set_subqueryscan_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>,
											   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableFuncScan</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>tablefunc</name></name> <operator>=</operator> <operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator>
					<call><name>fix_scan_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>splan</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ValuesScan</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CteScan</name>    <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>CteScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>NamedTuplestoreScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WorkTableScan</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>WorkTableScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<expr_stmt><expr><call><name>set_foreignscan_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<expr_stmt><expr><call><name>set_customscan_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NestLoop</name></expr>:</case>
		<case>case <expr><name>T_NestLoopVLE</name></expr>:</case>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>
		<case>case <expr><name>T_Shortestpath</name></expr>:</case>
			<expr_stmt><expr><call><name>set_join_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Gather</name></expr>:</case>
		<case>case <expr><name>T_GatherMerge</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>set_upper_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_param_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Hash</name></expr>:</case>
			<expr_stmt><expr><call><name>set_hash_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<case>case <expr><name>T_IncrementalSort</name></expr>:</case>
		<case>case <expr><name>T_Unique</name></expr>:</case>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
		<case>case <expr><name>T_Hash2Side</name></expr>:</case>

			<comment type="block">/*
			 * These plan types don't actually bother to evaluate their
			 * targetlists, because they just return their unmodified input
			 * tuples.  Even though the targetlist won't be used by the
			 * executor, we fix it up for possible use by EXPLAIN (not to
			 * mention ease of debugging --- wrong varnos are very confusing).
			 */</comment>
			<expr_stmt><expr><call><name>set_dummy_tlist_references</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Since these plan types don't check quals either, we should not
			 * find any qual expression attached to them.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_LockRows</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>LockRows</name>   <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>LockRows</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Like the plan types above, LockRows doesn't evaluate its
				 * tlist or quals.  But we have to fix up the RT indexes in
				 * its rowmarks.
				 */</comment>
				<expr_stmt><expr><call><name>set_dummy_tlist_references</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>splan-&gt;rowMarks</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>prti</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Limit</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Limit</name>	   <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Like the plan types above, Limit doesn't evaluate its tlist
				 * or quals.  It does have live expressions for limit/offset,
				 * however; and those cannot contain subplan variable refs, so
				 * fix_scan_expr works for them.
				 */</comment>
				<expr_stmt><expr><call><name>set_dummy_tlist_references</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator>
					<call><name>fix_scan_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator>
					<call><name>fix_scan_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Agg</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If this node is combining partial-aggregation results, we
				 * must convert its Aggrefs to contain references to the
				 * partial-aggregate subexpressions that will be available
				 * from the child plan node.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
						<call><name>convert_combining_aggrefs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
						<call><name>convert_combining_aggrefs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>set_upper_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Group</name></expr>:</case>
			<expr_stmt><expr><call><name>set_upper_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>wplan</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>set_upper_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Like Limit node limit/offset expressions, WindowAgg has
				 * frame offset expressions, which cannot contain subplan
				 * variable refs, so fix_scan_expr works for them.
				 */</comment>
				<expr_stmt><expr><name><name>wplan</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>=</operator>
					<call><name>fix_scan_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>wplan</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>wplan</name><operator>-&gt;</operator><name>endOffset</name></name> <operator>=</operator>
					<call><name>fix_scan_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>wplan</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Result may or may not have a subplan; if not, it's more
				 * like a scan node than an upper node.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>set_upper_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
						<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
						<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<comment type="block">/* resconstantqual can't contain any subplan variable refs */</comment>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>resconstantqual</name></name> <operator>=</operator>
					<call><name>fix_scan_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>resconstantqual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ProjectSet</name></expr>:</case>
			<expr_stmt><expr><call><name>set_upper_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name> <operator>=</operator>
					<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>returningLists</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newRL</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcrl</name></decl>,
							   <decl><type ref="prev"><modifier>*</modifier></type><name>lcrr</name></decl>,
							   <decl><type ref="prev"><modifier>*</modifier></type><name>lcp</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Pass each per-subplan returningList through
					 * set_returning_clause_references().
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<macro><name>forthree</name><argument_list>(<argument>lcrl</argument>, <argument>splan-&gt;returningLists</argument>,
							 <argument>lcrr</argument>, <argument>splan-&gt;resultRelations</argument>,
							 <argument>lcp</argument>, <argument>splan-&gt;plans</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rlist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcrl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Index</name></type>		<name>resultrel</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcrr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>rlist</name> <operator>=</operator> <call><name>set_returning_clause_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																<argument><expr><name>rlist</name></expr></argument>,
																<argument><expr><name>subplan</name></expr></argument>,
																<argument><expr><name>resultrel</name></expr></argument>,
																<argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>newRL</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newRL</name></expr></argument>, <argument><expr><name>rlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>returningLists</name></name> <operator>=</operator> <name>newRL</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Set up the visible plan targetlist as being the same as
					 * the first RETURNING list. This is for the use of
					 * EXPLAIN; the executor won't pay any attention to the
					 * targetlist.  We postpone this step until here so that
					 * we don't have to do set_returning_clause_references()
					 * twice on identical targetlists.
					 */</comment>
					<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>newRL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We treat ModifyTable with ON CONFLICT as a form of 'pseudo
				 * join', where the inner side is the EXCLUDED tuple.
				 * Therefore use fix_join_expr to setup the relevant variables
				 * to INNER_VAR. We explicitly don't create any OUTER_VARs as
				 * those are already used by RETURNING and it seems better to
				 * be non-conflicting.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>itlist</name> <operator>=</operator> <call><name>build_tlist_index</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator>
						<call><name>fix_join_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>itlist</name></expr></argument>,
									  <argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
						<call><name>fix_join_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>splan</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>itlist</name></expr></argument>,
									  <argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>exclRelTlist</name></name> <operator>=</operator>
						<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>nominalRelation</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>rootRelation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>rootRelation</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>exclRelRTI</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>splan-&gt;resultRelations</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				</block_content>}</block>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>splan-&gt;rowMarks</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>prti</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
				</block_content>}</block>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>splan-&gt;plans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * Append this ModifyTable node's final result relation RT
				 * index(es) to the global list for the plan, and set its
				 * resultRelIndex to reflect their starting position in the
				 * global list.
				 */</comment>
				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>resultRelIndex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator>
					<call><name>list_concat</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>,
								<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the main target relation is a partitioned table, also
				 * add the partition root's RT index to rootResultRelations,
				 * and remember its index in that list in rootResultRelIndex.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>rootRelation</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>rootResultRelIndex</name></name> <operator>=</operator>
						<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>rootResultRelations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>rootResultRelations</name></name> <operator>=</operator>
						<call><name>lappend_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>rootResultRelations</name></name></expr></argument>,
									<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>rootRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Append</name></expr>:</case>
			<comment type="block">/* Needs special treatment, see comments below */</comment>
			<return>return <expr><call><name>set_append_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>,
										 <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<comment type="block">/* Needs special treatment, see comments below */</comment>
			<return>return <expr><call><name>set_mergeappend_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>,
											  <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
			<comment type="block">/* This doesn't evaluate targetlist or check quals either */</comment>
			<expr_stmt><expr><call><name>set_dummy_tlist_references</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapAnd</name>  <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* BitmapAnd works like Append, but has no tlist */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>splan-&gt;bitmapplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapOr</name>   <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* BitmapOr works like Append, but has no tlist */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>splan-&gt;bitmapplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ModifyGraph</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>splan</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>subplan</name></name> <operator>=</operator> <call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Dijkstra</name></expr>:</case>
			<expr_stmt><expr><call><name>set_dijkstra_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Now recurse into child plans, if any
	 *
	 * NOTE: it is essential that we recurse into child plans AFTER we set
	 * subplan references in this plan's tlist and quals.  If we did the
	 * reference-adjustments bottom-up, then we would fail to match this
	 * plan's var nodes against the already-modified nodes of the children.
	 */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_indexonlyscan_references
 *		Do set_plan_references processing on an IndexOnlyScan
 *
 * This is unlike the handling of a plain IndexScan because we have to
 * convert Vars referencing the heap into Vars referencing the index.
 * We can use the fix_upper_expr machinery for that, by working from a
 * targetlist describing the index columns.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>set_indexonlyscan_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>index_itlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stripped_indextlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Vars in the plan node's targetlist, qual, and recheckqual must only
	 * reference columns that the index AM can actually return.  To ensure
	 * this, remove non-returnable columns (which are marked as resjunk) from
	 * the indexed tlist.  We can just drop them because the indexed_tlist
	 * machinery pays attention to TLE resnos, not physical list position.
	 */</comment>
	<expr_stmt><expr><name>stripped_indextlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;indextlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>indextle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indextle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stripped_indextlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stripped_indextlist</name></expr></argument>, <argument><expr><name>indextle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>index_itlist</name> <operator>=</operator> <call><name>build_tlist_index</name><argument_list>(<argument><expr><name>stripped_indextlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
					   <argument><expr><name>index_itlist</name></expr></argument>,
					   <argument><expr><name>INDEX_VAR</name></expr></argument>,
					   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>,
					   <argument><expr><name>index_itlist</name></expr></argument>,
					   <argument><expr><name>INDEX_VAR</name></expr></argument>,
					   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>recheckqual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>recheckqual</name></name></expr></argument>,
					   <argument><expr><name>index_itlist</name></expr></argument>,
					   <argument><expr><name>INDEX_VAR</name></expr></argument>,
					   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* indexqual is already transformed to reference index columns */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator> <call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* indexorderby is already transformed to reference index columns */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>indexorderby</name></name> <operator>=</operator> <call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>indexorderby</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* indextlist must NOT be transformed to reference index columns */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>indextlist</name></name> <operator>=</operator> <call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>index_itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_subqueryscan_references
 *		Do set_plan_references processing on a SubqueryScan
 *
 * We try to strip out the SubqueryScan entirely; if we can't, we have
 * to do the normal processing on it.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>set_subqueryscan_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Need to look up the subquery's RelOptInfo, since we need its subroot */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Recursively process the subplan */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>subplan</name></name> <operator>=</operator> <call><name>set_plan_references</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>trivial_subqueryscan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can omit the SubqueryScan node and just pull up the subplan.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>clean_up_removed_plan_level</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Keep the SubqueryScan node.  We have to do the processing that
		 * set_plan_references would otherwise have done on it.  Notice we do
		 * not do set_upper_references() here, because a SubqueryScan will
		 * always have been created with correct references to its subplan's
		 * outputs to begin with.
		 */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * trivial_subqueryscan
 *		Detect whether a SubqueryScan can be deleted from the plan tree.
 *
 * We can delete it if it has no qual to check and the targetlist just
 * regurgitates the output of the child plan.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>trivial_subqueryscan</name><parameter_list>(<parameter><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* tlists not same length */</comment>

	<expr_stmt><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lp</argument>, <argument>plan-&gt;scan.plan.targetlist</argument>, <argument>lc</argument>, <argument>plan-&gt;subplan-&gt;targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ptle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ctle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ptle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>!=</operator> <name><name>ctle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* tlist doesn't match junk status */</comment>

		<comment type="block">/*
		 * We accept either a Var referencing the corresponding element of the
		 * subplan tlist, or a Const equaling the subplan element. See
		 * generate_setop_tlist() for motivation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ptle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>ptle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>ptle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>attrno</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* out of order */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ptle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>ptle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>ptle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>ctle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>attrno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * clean_up_removed_plan_level
 *		Do necessary cleanup when we strip out a SubqueryScan, Append, etc
 *
 * We are dropping the "parent" plan in favor of returning just its "child".
 * A few small tweaks are needed.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>clean_up_removed_plan_level</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We have to be sure we don't lose any initplans */</comment>
	<expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>,
								  <argument><expr><name><name>child</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We also have to transfer the parent's column labeling info into the
	 * child, else columns sent to client will be improperly labeled if this
	 * is the topmost plan level.  resjunk and so on may be important too.
	 */</comment>
	<expr_stmt><expr><call><name>apply_tlist_labeling</name><argument_list>(<argument><expr><name><name>child</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>child</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_foreignscan_references
 *	   Do set_plan_references processing on a ForeignScan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_foreignscan_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fscan</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Adjust scanrelid if it's valid */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Adjust tlist, qual, fdw_exprs, fdw_recheck_quals to reference
		 * foreign scan tuple
		 */</comment>
		<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name> <init>= <expr><call><name>build_tlist_index</name><argument_list>(<argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
						   <argument><expr><name>itlist</name></expr></argument>,
						   <argument><expr><name>INDEX_VAR</name></expr></argument>,
						   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>,
						   <argument><expr><name>itlist</name></expr></argument>,
						   <argument><expr><name>INDEX_VAR</name></expr></argument>,
						   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>,
						   <argument><expr><name>itlist</name></expr></argument>,
						   <argument><expr><name>INDEX_VAR</name></expr></argument>,
						   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fscan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name></expr></argument>,
						   <argument><expr><name>itlist</name></expr></argument>,
						   <argument><expr><name>INDEX_VAR</name></expr></argument>,
						   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* fdw_scan_tlist itself just needs fix_scan_list() adjustments */</comment>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Adjust tlist, qual, fdw_exprs, fdw_recheck_quals in the standard
		 * way
		 */</comment>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fs_relids</name></name> <operator>=</operator> <call><name>offset_relid_set</name><argument_list>(<argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>fs_relids</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_customscan_references
 *	   Do set_plan_references processing on a CustomScan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_customscan_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Adjust scanrelid if it's valid */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Adjust tlist, qual, custom_exprs to reference custom scan tuple */</comment>
		<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name> <init>= <expr><call><name>build_tlist_index</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
						   <argument><expr><name>itlist</name></expr></argument>,
						   <argument><expr><name>INDEX_VAR</name></expr></argument>,
						   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>,
						   <argument><expr><name>itlist</name></expr></argument>,
						   <argument><expr><name>INDEX_VAR</name></expr></argument>,
						   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>,
						   <argument><expr><name>itlist</name></expr></argument>,
						   <argument><expr><name>INDEX_VAR</name></expr></argument>,
						   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* custom_scan_tlist itself just needs fix_scan_list() adjustments */</comment>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Adjust tlist, qual, custom_exprs in the standard way */</comment>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name> <operator>=</operator>
			<call><name>fix_scan_list</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Adjust child plan-nodes recursively, if needed */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cscan-&gt;custom_plans</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_relids</name></name> <operator>=</operator> <call><name>offset_relid_set</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_relids</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_append_references
 *		Do set_plan_references processing on an Append
 *
 * We try to strip out the Append entirely; if we can't, we have
 * to do the normal processing on it.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>set_append_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>Append</name> <modifier>*</modifier></type><name>aplan</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Append, like Sort et al, doesn't actually evaluate its targetlist or
	 * check quals.  If it's got exactly one child plan, then it's not doing
	 * anything useful at all, and we can strip it out.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First, we gotta recurse on the children */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>aplan-&gt;appendplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * See if it's safe to get rid of the Append entirely.  For this to be
	 * safe, there must be only one child plan and that child plan's parallel
	 * awareness must match that of the Append's.  The reason for the latter
	 * is that the if the Append is parallel aware and the child is not then
	 * the calling plan may execute the non-parallel aware child multiple
	 * times.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aplan</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>aplan</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>parallel_aware</name> <operator>==</operator> <name><name>aplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>clean_up_removed_plan_level</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>aplan</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>aplan</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, clean up the Append as needed.  It's okay to do this after
	 * recursing to the children, because set_dummy_tlist_references doesn't
	 * look at those.
	 */</comment>
	<expr_stmt><expr><call><name>set_dummy_tlist_references</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>aplan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aplan</name><operator>-&gt;</operator><name>apprelids</name></name> <operator>=</operator> <call><name>offset_relid_set</name><argument_list>(<argument><expr><name><name>aplan</name><operator>-&gt;</operator><name>apprelids</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aplan</name><operator>-&gt;</operator><name>part_prune_info</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>aplan-&gt;part_prune_info-&gt;prune_infos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prune_infos</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>prune_infos</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionedRelPruneInfo</name> <modifier>*</modifier></type><name>pinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We don't need to recurse to lefttree or righttree ... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>aplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_mergeappend_references
 *		Do set_plan_references processing on a MergeAppend
 *
 * We try to strip out the MergeAppend entirely; if we can't, we have
 * to do the normal processing on it.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>set_mergeappend_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mplan</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * MergeAppend, like Sort et al, doesn't actually evaluate its targetlist
	 * or check quals.  If it's got exactly one child plan, then it's not
	 * doing anything useful at all, and we can strip it out.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First, we gotta recurse on the children */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>mplan-&gt;mergeplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>set_plan_refs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * See if it's safe to get rid of the MergeAppend entirely.  For this to
	 * be safe, there must be only one child plan and that child plan's
	 * parallel awareness must match that of the MergeAppend's.  The reason
	 * for the latter is that the if the MergeAppend is parallel aware and the
	 * child is not then the calling plan may execute the non-parallel aware
	 * child multiple times.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mplan</name><operator>-&gt;</operator><name>mergeplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>mplan</name><operator>-&gt;</operator><name>mergeplans</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>parallel_aware</name> <operator>==</operator> <name><name>mplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>clean_up_removed_plan_level</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>mplan</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>mplan</name><operator>-&gt;</operator><name>mergeplans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, clean up the MergeAppend as needed.  It's okay to do this
	 * after recursing to the children, because set_dummy_tlist_references
	 * doesn't look at those.
	 */</comment>
	<expr_stmt><expr><call><name>set_dummy_tlist_references</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>mplan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mplan</name><operator>-&gt;</operator><name>apprelids</name></name> <operator>=</operator> <call><name>offset_relid_set</name><argument_list>(<argument><expr><name><name>mplan</name><operator>-&gt;</operator><name>apprelids</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mplan</name><operator>-&gt;</operator><name>part_prune_info</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>mplan-&gt;part_prune_info-&gt;prune_infos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prune_infos</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>prune_infos</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionedRelPruneInfo</name> <modifier>*</modifier></type><name>pinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We don't need to recurse to lefttree or righttree ... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>mplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_hash_references
 *	   Do set_plan_references processing on a Hash node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_hash_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Hash</name>	   <modifier>*</modifier></type><name>hplan</name> <init>= <expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outer_plan</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>outer_itlist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Hash's hashkeys are used when feeding tuples into the hashtable,
	 * therefore have them reference Hash's outer plan (which itself is the
	 * inner plan of the HashJoin).
	 */</comment>
	<expr_stmt><expr><name>outer_itlist</name> <operator>=</operator> <call><name>build_tlist_index</name><argument_list>(<argument><expr><name><name>outer_plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hplan</name><operator>-&gt;</operator><name>hashkeys</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>hplan</name><operator>-&gt;</operator><name>hashkeys</name></name></expr></argument>,
					   <argument><expr><name>outer_itlist</name></expr></argument>,
					   <argument><expr><name>OUTER_VAR</name></expr></argument>,
					   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Hash doesn't project */</comment>
	<expr_stmt><expr><call><name>set_dummy_tlist_references</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Hash nodes don't have their own quals */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * offset_relid_set
 *		Apply rtoffset to the members of a Relids set.
 */</comment>
<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>offset_relid_set</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

	<comment type="block">/* If there's no offset to apply, we needn't recompute the value */</comment>
	<if_stmt><if>if <condition>(<expr><name>rtoffset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>relids</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>rtindex</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rtindex</name> <operator>+</operator> <name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copyVar
 *		Copy a Var node.
 *
 * fix_scan_expr and friends do this enough times that it's worth having
 * a bespoke routine instead of using the generic copyObject() function.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>copyVar</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>newvar</name> <operator>=</operator> <operator>*</operator><name>var</name></expr>;</expr_stmt>
	<return>return <expr><name>newvar</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fix_expr_common
 *		Do generic set_plan_references processing on an expression node
 *
 * This is code that is common to all variants of expression-fixing.
 * We must look up operator opcode info for OpExpr and related nodes,
 * add OIDs from regclass Const nodes into root-&gt;glob-&gt;relationOids, and
 * add PlanInvalItems for user-defined functions into root-&gt;glob-&gt;invalItems.
 * We also fill in column index lists for GROUPING() expressions.
 *
 * We assume it's okay to update opcode info in-place.  So this could possibly
 * scribble on the planner's input data structures, but it's OK.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fix_expr_common</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We assume callers won't call us on a NULL pointer */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>record_plan_function_dependency</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>aggfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>record_plan_function_dependency</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>winfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>record_plan_function_dependency</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>record_plan_function_dependency</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* rely on struct equivalence */</comment>
		<expr_stmt><expr><call><name>record_plan_function_dependency</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* rely on struct equivalence */</comment>
		<expr_stmt><expr><call><name>record_plan_function_dependency</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_sa_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>record_plan_function_dependency</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Check for regclass reference */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ISREGCLASSCONST</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator>
				<call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>,
							<argument><expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grouping_map</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If there are no grouping sets, we don't need this. */</comment>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>grouping_map</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>cols</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>grouping_map</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cols</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>g-&gt;refs</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><name><name>grouping_map</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>cols</name></name> <operator>||</operator> <call><name>equal</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>cols</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>cols</name></name> <operator>=</operator> <name>cols</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fix_param_node
 *		Do set_plan_references processing on a Param
 *
 * If it's a PARAM_MULTIEXPR, replace it with the appropriate Param from
 * root-&gt;multiexpr_params; otherwise no change is needed.
 * Just for paranoia's sake, we make a copy of the node in either case.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_param_node</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_MULTIEXPR</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>subqueryid</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>colno</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>subqueryid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<name>subqueryid</name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected PARAM_MULTIEXPR ID: %d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name></expr></argument>, <argument><expr><name>subqueryid</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>colno</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>colno</name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected PARAM_MULTIEXPR ID: %d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>colno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fix_scan_expr
 *		Do set_plan_references processing on a scan-level expression
 *
 * This consists of incrementing all Vars' varnos by rtoffset,
 * replacing PARAM_MULTIEXPR Params, expanding PlaceHolderVars,
 * replacing Aggref nodes that should be replaced by initplan output Params,
 * looking up operator opcode info for OpExpr and related nodes,
 * and adding OIDs from regclass Const nodes into root-&gt;glob-&gt;relationOids.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_scan_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>fix_scan_expr_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>rtoffset</name></name> <operator>=</operator> <name>rtoffset</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rtoffset</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>lastPHId</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>fix_scan_expr_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If rtoffset == 0, we don't need to change any Vars, and if there
		 * are no MULTIEXPR subqueries then we don't need to replace
		 * PARAM_MULTIEXPR Params, and if there are no placeholders anywhere
		 * we won't need to remove them, and if there are no minmax Aggrefs we
		 * won't need to replace them.  Then it's OK to just scribble on the
		 * input node tree instead of copying (since the only change, filling
		 * in any unset opfuncid fields, is harmless).  This saves just enough
		 * cycles to be noticeable on trivial queries.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fix_scan_expr_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_scan_expr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>fix_scan_expr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>copyVar</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We should not see any Vars marked INNER_VAR or OUTER_VAR.  But an
		 * indexqual expression could contain INDEX_VAR Vars.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>INNER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SPECIAL_VARNO</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>rtoffset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>rtoffset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fix_param_node</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* See if the Aggref should be replaced by a Param */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>curTarget</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;root-&gt;minmax_aggs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>mminfo</name> <init>= <expr><operator>(</operator><name>MinMaxAggInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>mminfo</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>==</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>&amp;&amp;</operator>
					<call><name>equal</name><argument_list>(<argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name><name>curTarget</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>param</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* If no match, just fall through to process it normally */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>!=</operator> <name>INNER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>!=</operator> <name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SPECIAL_VARNO</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>rtoffset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* At scan level, we should always just evaluate the contained expr */</comment>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<return>return <expr><call><name>fix_scan_expr_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>fix_expr_common</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fix_scan_expr_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fix_scan_expr_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>fix_scan_expr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fix_expr_common</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fix_scan_expr_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_join_references
 *	  Modify the target list and quals of a join node to reference its
 *	  subplans, by setting the varnos to OUTER_VAR or INNER_VAR and setting
 *	  attno values to the result domain number of either the corresponding
 *	  outer or inner join tuple item.  Also perform opcode lookup for these
 *	  expressions, and add regclass OIDs to root-&gt;glob-&gt;relationOids.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_join_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>join</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outer_plan</name> <init>= <expr><name><name>join</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>inner_plan</name> <init>= <expr><name><name>join</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>outer_itlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>inner_itlist</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>outer_itlist</name> <operator>=</operator> <call><name>build_tlist_index</name><argument_list>(<argument><expr><name><name>outer_plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_itlist</name> <operator>=</operator> <call><name>build_tlist_index</name><argument_list>(<argument><expr><name><name>inner_plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First process the joinquals (including merge or hash clauses).  These
	 * are logically below the join so they can always use all values
	 * available from the input tlists.  It's okay to also handle
	 * NestLoopParams now, because those couldn't refer to nullable
	 * subexpressions.
	 */</comment>
	<expr_stmt><expr><name><name>join</name><operator>-&gt;</operator><name>joinqual</name></name> <operator>=</operator> <call><name>fix_join_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><name><name>join</name><operator>-&gt;</operator><name>joinqual</name></name></expr></argument>,
								   <argument><expr><name>outer_itlist</name></expr></argument>,
								   <argument><expr><name>inner_itlist</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
								   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now do join-type-specific stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>join</name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>join</name></expr></argument>, <argument><expr><name>NestLoopVLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>join</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nl-&gt;nestParams</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>,
												   <argument><expr><name>outer_itlist</name></expr></argument>,
												   <argument><expr><name>OUTER_VAR</name></expr></argument>,
												   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Check we replaced any PlaceHolderVar with simple Var */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				  <name><name>nlp</name><operator>-&gt;</operator><name>paramval</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>OUTER_VAR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"NestLoopParam was not reduced to a simple Var"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>join</name></expr></argument>, <argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>mj</name> <init>= <expr><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>join</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>mj</name><operator>-&gt;</operator><name>mergeclauses</name></name> <operator>=</operator> <call><name>fix_join_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name><name>mj</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>,
										 <argument><expr><name>outer_itlist</name></expr></argument>,
										 <argument><expr><name>inner_itlist</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
										 <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>join</name></expr></argument>, <argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HashJoin</name>   <modifier>*</modifier></type><name>hj</name> <init>= <expr><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>join</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>hj</name><operator>-&gt;</operator><name>hashclauses</name></name> <operator>=</operator> <call><name>fix_join_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name><name>hj</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></argument>,
										<argument><expr><name>outer_itlist</name></expr></argument>,
										<argument><expr><name>inner_itlist</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
										<argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * HashJoin's hashkeys are used to look for matching tuples from its
		 * outer plan (not the Hash node!) in the hashtable.
		 */</comment>
		<expr_stmt><expr><name><name>hj</name><operator>-&gt;</operator><name>hashkeys</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>hj</name><operator>-&gt;</operator><name>hashkeys</name></name></expr></argument>,
											   <argument><expr><name>outer_itlist</name></expr></argument>,
											   <argument><expr><name>OUTER_VAR</name></expr></argument>,
											   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>join</name></expr></argument>, <argument><expr><name>Shortestpath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Shortestpath</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><operator>(</operator><name>Shortestpath</name> <operator>*</operator><operator>)</operator> <name>join</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>hashclauses</name></name> <operator>=</operator> <call><name>fix_join_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></argument>,
										<argument><expr><name>outer_itlist</name></expr></argument>,
										<argument><expr><name>inner_itlist</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
										<argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now we need to fix up the targetlist and qpqual, which are logically
	 * above the join.  This means they should not re-use any input expression
	 * that was computed in the nullable side of an outer join.  Vars and
	 * PlaceHolderVars are fine, so we can implement this restriction just by
	 * clearing has_non_vars in the indexed_tlist structs.
	 *
	 * XXX This is a grotty workaround for the fact that we don't clearly
	 * distinguish between a Var appearing below an outer join and the "same"
	 * Var appearing above it.  If we did, we'd not need to hack the matching
	 * rules this way.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>join</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
			<expr_stmt><expr><name><name>inner_itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
			<expr_stmt><expr><name><name>outer_itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<expr_stmt><expr><name><name>outer_itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inner_itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>join</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>fix_join_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name><name>join</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										  <argument><expr><name>outer_itlist</name></expr></argument>,
										  <argument><expr><name>inner_itlist</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
										  <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>join</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <call><name>fix_join_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name><name>join</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>,
									<argument><expr><name>outer_itlist</name></expr></argument>,
									<argument><expr><name>inner_itlist</name></expr></argument>,
									<argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
									<argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outer_itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>inner_itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_upper_references
 *	  Update the targetlist and quals of an upper-level plan node
 *	  to refer to the tuples returned by its lefttree subplan.
 *	  Also perform opcode lookup for these expressions, and
 *	  add regclass OIDs to root-&gt;glob-&gt;relationOids.
 *
 * This is used for single-input plan types like Agg, Group, Result.
 *
 * In most cases, we have to match up individual Vars in the tlist and
 * qual expressions with elements of the subplan's tlist (which was
 * generated by flattening these selfsame expressions, so it should have all
 * the required variables).  There is an important exception, however:
 * depending on where we are in the plan tree, sort/group columns may have
 * been pushed into the subplan tlist unflattened.  If these values are also
 * needed in the output then we want to reference the subplan tlist element
 * rather than recomputing the expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_upper_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>subplan_itlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>output_targetlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>subplan_itlist</name> <operator>=</operator> <call><name>build_tlist_index</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>output_targetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

		<comment type="block">/* If it's a sort/group item, first try to match by sortref */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
				<call><name>search_indexed_tlist_for_sortgroupref</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
													  <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></argument>,
													  <argument><expr><name>subplan_itlist</name></expr></argument>,
													  <argument><expr><name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newexpr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										 <argument><expr><name>subplan_itlist</name></expr></argument>,
										 <argument><expr><name>OUTER_VAR</name></expr></argument>,
										 <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
									 <argument><expr><name>subplan_itlist</name></expr></argument>,
									 <argument><expr><name>OUTER_VAR</name></expr></argument>,
									 <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>output_targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>output_targetlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>output_targetlist</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
					   <argument><expr><name>subplan_itlist</name></expr></argument>,
					   <argument><expr><name>OUTER_VAR</name></expr></argument>,
					   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>subplan_itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_param_references
 *	  Initialize the initParam list in Gather or Gather merge node such that
 *	  it contains reference of all the params that needs to be evaluated
 *	  before execution of the node.  It contains the initplan params that are
 *	  being passed to the plan nodes below it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_param_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>GatherMerge</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>extParam</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>proot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>initSetParam</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>proot</name> <operator>=</operator> <name>root</name></expr>;</init> <condition><expr><name>proot</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>proot</name> <operator>=</operator> <name><name>proot</name><operator>-&gt;</operator><name>parent_root</name></name></expr></incr>)</control>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>proot-&gt;init_plans</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>initsubplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>initsubplan-&gt;setParam</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name>initSetParam</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>initSetParam</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Remember the list of all external initplan params that are used by
		 * the children of Gather or Gather merge node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>initParam</name> <operator>=</operator>
				<call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>, <argument><expr><name>initSetParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GatherMerge</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>initParam</name> <operator>=</operator>
				<call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>, <argument><expr><name>initSetParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively scan an expression tree and convert Aggrefs to the proper
 * intermediate form for combining aggregates.  This means (1) replacing each
 * one's argument list with a single argument that is the original Aggref
 * modified to show partial aggregation and (2) changing the upper Aggref to
 * show combining aggregation.
 *
 * After this step, set_upper_references will replace the partial Aggrefs
 * with Vars referencing the lower Agg plan node's outputs, so that the final
 * form seen by the executor is a combining Aggref with a Var as input.
 *
 * It's rather messy to postpone this step until setrefs.c; ideally it'd be
 * done in createplan.c.  The difficulty is that once we modify the Aggref
 * expressions, they will no longer be equal() to their original form and
 * so cross-plan-node-level matches will fail.  So this has to happen after
 * the plan node above the Agg has resolved its subplan references.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>convert_combining_aggrefs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>orig_agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>child_agg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>parent_agg</name></decl>;</decl_stmt>

		<comment type="block">/* Assert we've not chosen to partial-ize any unsupported cases */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>orig_agg</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>orig_agg</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since aggregate calls can't be nested, we needn't recurse into the
		 * arguments.  But for safety, flat-copy the Aggref node itself rather
		 * than modifying it in-place.
		 */</comment>
		<expr_stmt><expr><name>child_agg</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>child_agg</name></expr></argument>, <argument><expr><name>orig_agg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For the parent Aggref, we want to copy all the fields of the
		 * original aggregate *except* the args list, which we'll replace
		 * below, and the aggfilter expression, which should be applied only
		 * by the child not the parent.  Rather than explicitly knowing about
		 * all the other fields here, we can momentarily modify child_agg to
		 * provide a suitable source for copyObject.
		 */</comment>
		<expr_stmt><expr><name><name>child_agg</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>child_agg</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_agg</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>child_agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>child_agg</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name><name>orig_agg</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>child_agg</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name><name>orig_agg</name><operator>-&gt;</operator><name>aggfilter</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now, set up child_agg to represent the first phase of partial
		 * aggregation.  For now, assume serialization is required.
		 */</comment>
		<expr_stmt><expr><call><name>mark_partial_aggref</name><argument_list>(<argument><expr><name>child_agg</name></expr></argument>, <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * And set up parent_agg to represent the second phase.
		 */</comment>
		<expr_stmt><expr><name><name>parent_agg</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>child_agg</name></expr></argument>,
													  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mark_partial_aggref</name><argument_list>(<argument><expr><name>parent_agg</name></expr></argument>, <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parent_agg</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>convert_combining_aggrefs</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_dummy_tlist_references
 *	  Replace the targetlist of an upper-level plan node with a simple
 *	  list of OUTER_VAR references to its child.
 *
 * This is used for plan types like Sort and Append that don't evaluate
 * their targetlists.  Although the executor doesn't care at all what's in
 * the tlist, EXPLAIN needs it to be realistic.
 *
 * Note: we could almost use set_upper_references() here, but it fails for
 * Append for lack of a lefttree subplan.  Single-purpose code is faster
 * anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_dummy_tlist_references</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>output_targetlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>output_targetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>oldvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newvar</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * As in search_indexed_tlist_for_non_var(), we prefer to keep Consts
		 * as Consts, not Vars referencing Consts.  Here, there's no speed
		 * advantage to be had, but it makes EXPLAIN output look cleaner, and
		 * again it avoids confusing the executor.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>oldvar</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* just reuse the existing TLE node */</comment>
			<expr_stmt><expr><name>output_targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>output_targetlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>OUTER_VAR</name></expr></argument>,
						 <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
						 <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>oldvar</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>oldvar</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>oldvar</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>oldvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>oldvar</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <name><name>oldvar</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>+</operator> <name>rtoffset</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <name><name>oldvar</name><operator>-&gt;</operator><name>varattnosyn</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* wasn't ever a plain Var */</comment>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>output_targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>output_targetlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>output_targetlist</name></expr>;</expr_stmt>

	<comment type="block">/* We don't touch plan-&gt;qual here */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * build_tlist_index --- build an index data structure for a child tlist
 *
 * In most cases, subplan tlists will be "flat" tlists with only Vars,
 * so we try to optimize that case by extracting information about Vars
 * in advance.  Matching a parent tlist to a child is still an O(N^2)
 * operation, but at least with a much smaller constant factor than plain
 * tlist_member() searches.
 *
 * The result of this function is an indexed_tlist struct to pass to
 * search_indexed_tlist_for_var() or search_indexed_tlist_for_non_var().
 * When done, the indexed_tlist may be freed with a single pfree().
 */</comment>
<function><type><specifier>static</specifier> <name>indexed_tlist</name> <modifier>*</modifier></type>
<name>build_tlist_index</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tlist_vinfo</name> <modifier>*</modifier></type><name>vinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Create data structure with enough slots for all tlist entries */</comment>
	<expr_stmt><expr><name>itlist</name> <operator>=</operator> <operator>(</operator><name>indexed_tlist</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>indexed_tlist</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>)</argument_list></call> <operator>+</operator>
			   <call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tlist_vinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>has_ph_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Find the Vars and fill in the index array */</comment>
	<expr_stmt><expr><name>vinfo</name> <operator>=</operator> <name><name>itlist</name><operator>-&gt;</operator><name>vars</name></name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>vinfo</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vinfo</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vinfo</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>vinfo</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>has_ph_vars</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>num_vars</name></name> <operator>=</operator> <operator>(</operator><name>vinfo</name> <operator>-</operator> <name><name>itlist</name><operator>-&gt;</operator><name>vars</name></name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>itlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_tlist_index_other_vars --- build a restricted tlist index
 *
 * This is like build_tlist_index, but we only index tlist entries that
 * are Vars belonging to some rel other than the one specified.  We will set
 * has_ph_vars (allowing PlaceHolderVars to be matched), but not has_non_vars
 * (so nothing other than Vars and PlaceHolderVars can be matched).
 */</comment>
<function><type><specifier>static</specifier> <name>indexed_tlist</name> <modifier>*</modifier></type>
<name>build_tlist_index_other_vars</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>ignore_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tlist_vinfo</name> <modifier>*</modifier></type><name>vinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Create data structure with enough slots for all tlist entries */</comment>
	<expr_stmt><expr><name>itlist</name> <operator>=</operator> <operator>(</operator><name>indexed_tlist</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>indexed_tlist</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>)</argument_list></call> <operator>+</operator>
			   <call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tlist_vinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>has_ph_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Find the desired Vars and fill in the index array */</comment>
	<expr_stmt><expr><name>vinfo</name> <operator>=</operator> <name><name>itlist</name><operator>-&gt;</operator><name>vars</name></name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>ignore_rel</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>vinfo</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vinfo</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vinfo</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>vinfo</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>has_ph_vars</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>itlist</name><operator>-&gt;</operator><name>num_vars</name></name> <operator>=</operator> <operator>(</operator><name>vinfo</name> <operator>-</operator> <name><name>itlist</name><operator>-&gt;</operator><name>vars</name></name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>itlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * search_indexed_tlist_for_var --- find a Var in an indexed tlist
 *
 * If a match is found, return a copy of the given Var with suitably
 * modified varno/varattno (to wit, newvarno and the resno of the TLE entry).
 * Also ensure that varnosyn is incremented by rtoffset.
 * If no match, return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>search_indexed_tlist_for_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl></parameter>,
							 <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>varattno</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>tlist_vinfo</name> <modifier>*</modifier></type><name>vinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>vinfo</name> <operator>=</operator> <name><name>itlist</name><operator>-&gt;</operator><name>vars</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>itlist</name><operator>-&gt;</operator><name>num_vars</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>vinfo</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>varno</name> <operator>&amp;&amp;</operator> <name><name>vinfo</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>varattno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a match */</comment>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newvar</name> <init>= <expr><call><name>copyVar</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>newvarno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>vinfo</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>newvar</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>+=</operator> <name>rtoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>newvar</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>vinfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* no match */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * search_indexed_tlist_for_non_var --- find a non-Var in an indexed tlist
 *
 * If a match is found, return a Var constructed to reference the tlist item.
 * If no match, return NULL.
 *
 * NOTE: it is a waste of time to call this unless itlist-&gt;has_ph_vars or
 * itlist-&gt;has_non_vars.  Furthermore, set_join_references() relies on being
 * able to prevent matching of non-Vars by clearing itlist-&gt;has_non_vars,
 * so there's a correctness reason not to call it unless that's set.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>search_indexed_tlist_for_non_var</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								 <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's a simple Const, replacing it with a Var is silly, even if there
	 * happens to be an identical Const below; a Var is more expensive to
	 * execute than a Const.  What's more, replacing it could confuse some
	 * places in the executor that expect to see simple Consts for, eg,
	 * dropped columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>itlist</name><operator>-&gt;</operator><name>tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tle</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found a matching subplan output expression */</comment>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newvar</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>newvarno</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* wasn't ever a plain Var */</comment>
		<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>newvar</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* no match */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * search_indexed_tlist_for_sortgroupref --- find a sort/group expression
 *
 * If a match is found, return a Var constructed to reference the tlist item.
 * If no match, return NULL.
 *
 * This is needed to ensure that we select the right subplan TLE in cases
 * where there are multiple textually-equal()-but-volatile sort expressions.
 * And it's also faster than search_indexed_tlist_for_non_var.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>search_indexed_tlist_for_sortgroupref</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									  <parameter><decl><type><name>Index</name></type> <name>sortgroupref</name></decl></parameter>,
									  <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl></parameter>,
									  <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>itlist-&gt;tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* The equal() check should be redundant, but let's be paranoid */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>==</operator> <name>sortgroupref</name> <operator>&amp;&amp;</operator>
			<call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a matching subplan output expression */</comment>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newvar</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>newvarno</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* wasn't ever a plain Var */</comment>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<return>return <expr><name>newvar</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* no match */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * fix_join_expr
 *	   Create a new set of targetlist entries or join qual clauses by
 *	   changing the varno/varattno values of variables in the clauses
 *	   to reference target list values from the outer and inner join
 *	   relation target lists.  Also perform opcode lookup and add
 *	   regclass OIDs to root-&gt;glob-&gt;relationOids.
 *
 * This is used in three different scenarios:
 * 1) a normal join clause, where all the Vars in the clause *must* be
 *	  replaced by OUTER_VAR or INNER_VAR references.  In this case
 *	  acceptable_rel should be zero so that any failure to match a Var will be
 *	  reported as an error.
 * 2) RETURNING clauses, which may contain both Vars of the target relation
 *	  and Vars of other relations. In this case we want to replace the
 *	  other-relation Vars by OUTER_VAR references, while leaving target Vars
 *	  alone. Thus inner_itlist = NULL and acceptable_rel = the ID of the
 *	  target relation should be passed.
 * 3) ON CONFLICT UPDATE SET/WHERE clauses.  Here references to EXCLUDED are
 *	  to be replaced with INNER_VAR references, while leaving target Vars (the
 *	  to-be-updated relation) alone. Correspondingly inner_itlist is to be
 *	  EXCLUDED elements, outer_itlist = NULL and acceptable_rel the target
 *	  relation.
 *
 * 'clauses' is the targetlist or list of join clauses
 * 'outer_itlist' is the indexed target list of the outer join relation,
 *		or NULL
 * 'inner_itlist' is the indexed target list of the inner join relation,
 *		or NULL
 * 'acceptable_rel' is either zero or the rangetable index of a relation
 *		whose Vars may appear in the clause without provoking an error
 * 'rtoffset': how much to increment varnos by
 *
 * Returns the new expression tree.  The original clause structure is
 * not modified.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fix_join_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
			  <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>outer_itlist</name></decl></parameter>,
			  <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>inner_itlist</name></decl></parameter>,
			  <parameter><decl><type><name>Index</name></type> <name>acceptable_rel</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>fix_join_expr_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>outer_itlist</name></name> <operator>=</operator> <name>outer_itlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>inner_itlist</name></name> <operator>=</operator> <name>inner_itlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>acceptable_rel</name></name> <operator>=</operator> <name>acceptable_rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>rtoffset</name></name> <operator>=</operator> <name>rtoffset</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>fix_join_expr_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clauses</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_join_expr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>fix_join_expr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newvar</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Look for the var in the input tlists, first in the outer */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>outer_itlist</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>search_indexed_tlist_for_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>,
												  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>outer_itlist</name></name></expr></argument>,
												  <argument><expr><name>OUTER_VAR</name></expr></argument>,
												  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtoffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newvar</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* then in the inner. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>inner_itlist</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>search_indexed_tlist_for_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>,
												  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>inner_itlist</name></name></expr></argument>,
												  <argument><expr><name>INNER_VAR</name></expr></argument>,
												  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtoffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newvar</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If it's for acceptable_rel, adjust and return it */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>acceptable_rel</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>copyVar</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>rtoffset</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>rtoffset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No referent found for Var */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"variable not found in subplan target lists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* See if the PlaceHolderVar has bubbled up from a lower plan node */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>outer_itlist</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>outer_itlist</name><operator>-&gt;</operator><name>has_ph_vars</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>search_indexed_tlist_for_non_var</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr></argument>,
													  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>outer_itlist</name></name></expr></argument>,
													  <argument><expr><name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newvar</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>inner_itlist</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>inner_itlist</name><operator>-&gt;</operator><name>has_ph_vars</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>search_indexed_tlist_for_non_var</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr></argument>,
													  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>inner_itlist</name></name></expr></argument>,
													  <argument><expr><name>INNER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newvar</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If not supplied by input plans, evaluate the contained expr */</comment>
		<return>return <expr><call><name>fix_join_expr_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Try matching more complex expressions too, if tlists have any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>outer_itlist</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>outer_itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>search_indexed_tlist_for_non_var</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>outer_itlist</name></name></expr></argument>,
												  <argument><expr><name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newvar</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>inner_itlist</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>inner_itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>search_indexed_tlist_for_non_var</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>inner_itlist</name></name></expr></argument>,
												  <argument><expr><name>INNER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newvar</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Special cases (apply only AFTER failing to match to lower tlist) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fix_param_node</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fix_expr_common</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								   <argument><expr><name>fix_join_expr_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fix_upper_expr
 *		Modifies an expression tree so that all Var nodes reference outputs
 *		of a subplan.  Also looks for Aggref nodes that should be replaced
 *		by initplan output Params.  Also performs opcode lookup, and adds
 *		regclass OIDs to root-&gt;glob-&gt;relationOids.
 *
 * This is used to fix up target and qual expressions of non-join upper-level
 * plan nodes, as well as index-only scan nodes.
 *
 * An error is raised if no matching var can be found in the subplan tlist
 * --- so this routine should only be applied to nodes whose subplans'
 * targetlists were generated by flattening the expressions used in the
 * parent node.
 *
 * If itlist-&gt;has_non_vars is true, then we try to match whole subexpressions
 * against elements of the subplan tlist, so that we can avoid recomputing
 * expressions that were already computed by the subplan.  (This is relatively
 * expensive, so we don't want to try it in the common case where the
 * subplan tlist is just a flattened list of Vars.)
 *
 * 'node': the tree to be fixed (a target item or qual)
 * 'subplan_itlist': indexed target list for subplan (or index)
 * 'newvarno': varno to use for Vars referencing tlist elements
 * 'rtoffset': how much to increment varnos by
 *
 * The resulting tree is a copy of the original in which all Var nodes have
 * varno = newvarno, varattno = resno of corresponding targetlist element.
 * The original tree is not modified.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_upper_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
			   <parameter><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>subplan_itlist</name></decl></parameter>,
			   <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>fix_upper_expr_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>subplan_itlist</name></name> <operator>=</operator> <name>subplan_itlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>newvarno</name></name> <operator>=</operator> <name>newvarno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>rtoffset</name></name> <operator>=</operator> <name>rtoffset</name></expr>;</expr_stmt>
	<return>return <expr><call><name>fix_upper_expr_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_upper_expr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>fix_upper_expr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newvar</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>search_indexed_tlist_for_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>subplan_itlist</name></name></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>newvarno</name></name></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtoffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newvar</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"variable not found in subplan target list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* See if the PlaceHolderVar has bubbled up from a lower plan node */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>subplan_itlist</name><operator>-&gt;</operator><name>has_ph_vars</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>search_indexed_tlist_for_non_var</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr></argument>,
													  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>subplan_itlist</name></name></expr></argument>,
													  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>newvarno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newvar</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* If not supplied by input plan, evaluate the contained expr */</comment>
		<return>return <expr><call><name>fix_upper_expr_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Try matching more complex expressions too, if tlist has any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>subplan_itlist</name><operator>-&gt;</operator><name>has_non_vars</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>search_indexed_tlist_for_non_var</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>subplan_itlist</name></name></expr></argument>,
												  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>newvarno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newvar</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Special cases (apply only AFTER failing to match to lower tlist) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>fix_param_node</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* See if the Aggref should be replaced by a Param */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>curTarget</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;root-&gt;minmax_aggs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>mminfo</name> <init>= <expr><operator>(</operator><name>MinMaxAggInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>mminfo</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>==</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>&amp;&amp;</operator>
					<call><name>equal</name><argument_list>(<argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name><name>curTarget</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>param</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* If no match, just fall through to process it normally */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>fix_expr_common</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								   <argument><expr><name>fix_upper_expr_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_returning_clause_references
 *		Perform setrefs.c's work on a RETURNING targetlist
 *
 * If the query involves more than just the result table, we have to
 * adjust any Vars that refer to other tables to reference junk tlist
 * entries in the top subplan's targetlist.  Vars referencing the result
 * table should be left alone, however (the executor will evaluate them
 * using the actual heap tuple, after firing triggers if any).  In the
 * adjusted RETURNING list, result-table Vars will have their original
 * varno (plus rtoffset), but Vars for other rels will have varno OUTER_VAR.
 *
 * We also must perform opcode lookup and add regclass OIDs to
 * root-&gt;glob-&gt;relationOids.
 *
 * 'rlist': the RETURNING targetlist to be fixed
 * 'topplan': the top subplan node that will be just below the ModifyTable
 *		node (note it's not yet passed through set_plan_refs)
 * 'resultRelation': RT index of the associated result relation
 * 'rtoffset': how much to increment varnos by
 *
 * Note: the given 'root' is for the parent query level, not the 'topplan'.
 * This does not matter currently since we only access the dependency-item
 * lists in root-&gt;glob, but it would need some hacking if we wanted a root
 * that actually matches the subplan.
 *
 * Note: resultRelation is not yet adjusted by rtoffset.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>set_returning_clause_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rlist</name></decl></parameter>,
								<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>topplan</name></decl></parameter>,
								<parameter><decl><type><name>Index</name></type> <name>resultRelation</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>itlist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can perform the desired Var fixup by abusing the fix_join_expr
	 * machinery that formerly handled inner indexscan fixup.  We search the
	 * top plan's targetlist for Vars of non-result relations, and use
	 * fix_join_expr to convert RETURNING Vars into references to those tlist
	 * entries, while leaving result-rel Vars as-is.
	 *
	 * PlaceHolderVars will also be sought in the targetlist, but no
	 * more-complex expressions will be.  Note that it is not possible for a
	 * PlaceHolderVar to refer to the result relation, since the result is
	 * never below an outer join.  If that case could happen, we'd have to be
	 * prepared to pick apart the PlaceHolderVar and evaluate its contained
	 * expression instead.
	 */</comment>
	<expr_stmt><expr><name>itlist</name> <operator>=</operator> <call><name>build_tlist_index_other_vars</name><argument_list>(<argument><expr><name><name>topplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rlist</name> <operator>=</operator> <call><name>fix_join_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						  <argument><expr><name>rlist</name></expr></argument>,
						  <argument><expr><name>itlist</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>resultRelation</name></expr></argument>,
						  <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rlist</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *					QUERY DEPENDENCY MANAGEMENT
 *****************************************************************************/</comment>

<comment type="block">/*
 * record_plan_function_dependency
 *		Mark the current plan as depending on a particular function.
 *
 * This is exported so that the function-inlining code can record a
 * dependency on a function that it's removed from the plan tree.
 */</comment>
<function><type><name>void</name></type>
<name>record_plan_function_dependency</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For performance reasons, we don't bother to track built-in functions;
	 * we just assume they'll never change (or at least not in ways that'd
	 * invalidate plans using them).  For this purpose we can consider a
	 * built-in function to be one with OID less than FirstBootstrapObjectId.
	 * Note that the OID generator guarantees never to generate such an OID
	 * after startup, even at OID wraparound.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>funcid</name> <operator>&gt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstBootstrapObjectId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanInvalItem</name> <modifier>*</modifier></type><name>inval_item</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlanInvalItem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * It would work to use any syscache on pg_proc, but the easiest is
		 * PROCOID since we already have the function's OID at hand.  Note
		 * that plancache.c knows we use PROCOID.
		 */</comment>
		<expr_stmt><expr><name><name>inval_item</name><operator>-&gt;</operator><name>cacheId</name></name> <operator>=</operator> <name>PROCOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inval_item</name><operator>-&gt;</operator><name>hashValue</name></name> <operator>=</operator> <call><name>GetSysCacheHashValue1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
													  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name></expr></argument>, <argument><expr><name>inval_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * record_plan_type_dependency
 *		Mark the current plan as depending on a particular type.
 *
 * This is exported so that eval_const_expressions can record a
 * dependency on a domain that it's removed a CoerceToDomain node for.
 *
 * We don't currently need to record dependencies on domains that the
 * plan contains CoerceToDomain nodes for, though that might change in
 * future.  Hence, this isn't actually called in this module, though
 * someday fix_expr_common might call it.
 */</comment>
<function><type><name>void</name></type>
<name>record_plan_type_dependency</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * As in record_plan_function_dependency, ignore the possibility that
	 * someone would change a built-in domain.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>&gt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstBootstrapObjectId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanInvalItem</name> <modifier>*</modifier></type><name>inval_item</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlanInvalItem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * It would work to use any syscache on pg_type, but the easiest is
		 * TYPEOID since we already have the type's OID at hand.  Note that
		 * plancache.c knows we use TYPEOID.
		 */</comment>
		<expr_stmt><expr><name><name>inval_item</name><operator>-&gt;</operator><name>cacheId</name></name> <operator>=</operator> <name>TYPEOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inval_item</name><operator>-&gt;</operator><name>hashValue</name></name> <operator>=</operator> <call><name>GetSysCacheHashValue1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
													  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name></expr></argument>, <argument><expr><name>inval_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * extract_query_dependencies
 *		Given a rewritten, but not yet planned, query or queries
 *		(i.e. a Query node or list of Query nodes), extract dependencies
 *		just as set_plan_references would do.  Also detect whether any
 *		rewrite steps were affected by RLS.
 *
 * This is needed by plancache.c to handle invalidation of cached unplanned
 * queries.
 *
 * Note: this does not go through eval_const_expressions, and hence doesn't
 * reflect its additions of inlined functions and elided CoerceToDomain nodes
 * to the invalItems list.  This is obviously OK for functions, since we'll
 * see them in the original query tree anyway.  For domains, it's OK because
 * we don't care about domains unless they get elided.  That is, a plan might
 * have domain dependencies that the query tree doesn't.
 */</comment>
<function><type><name>void</name></type>
<name>extract_query_dependencies</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationOids</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>invalItems</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasRowSecurity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name></type> <name>glob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name></type> <name>root</name></decl>;</decl_stmt>

	<comment type="block">/* Make up dummy planner state so we can use this module's machinery */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>glob</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>glob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_PlannerGlobal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>.</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>.</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<comment type="block">/* Hack: we use glob.dependsOnRole to collect hasRowSecurity flags */</comment>
	<expr_stmt><expr><name><name>glob</name><operator>.</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_PlannerInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>.</operator><name>glob</name></name> <operator>=</operator> <operator>&amp;</operator><name>glob</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>extract_query_dependencies_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>relationOids</name> <operator>=</operator> <name><name>glob</name><operator>.</operator><name>relationOids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>invalItems</name> <operator>=</operator> <name><name>glob</name><operator>.</operator><name>invalItems</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>hasRowSecurity</name> <operator>=</operator> <name><name>glob</name><operator>.</operator><name>dependsOnRole</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tree walker for extract_query_dependencies.
 *
 * This is exported so that expression_planner_with_deps can call it on
 * simple expressions (post-planning, not before planning, in that case).
 * In that usage, glob.dependsOnRole isn't meaningful, but the relationOids
 * and invalItems lists are added to as needed.
 */</comment>
<function><type><name>bool</name></type>
<name>extract_query_dependencies_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Ignore utility statements, except those (such as EXPLAIN) that
			 * contain a parsed-but-not-planned query.
			 */</comment>
			<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember if any Query has RLS quals applied by rewriter */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasRowSecurity</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Collect relation OIDs in this Query's rtable */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator>
					<call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_NAMEDTUPLESTORE</name> <operator>&amp;&amp;</operator>
					 <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator>
					<call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name></expr></argument>,
								<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* And recurse into the query's subexpressions */</comment>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>extract_query_dependencies_walker</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Extract function dependencies and check for regclass Consts */</comment>
	<expr_stmt><expr><call><name>fix_expr_common</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>extract_query_dependencies_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_dijkstra_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Dijkstra</name>   <modifier>*</modifier></type><name>dijkstra</name> <init>= <expr><operator>(</operator><name>Dijkstra</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>indexed_tlist</name> <modifier>*</modifier></type><name>subplan_itlist</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>set_upper_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>subplan_itlist</name> <operator>=</operator> <call><name>build_tlist_index</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dijkstra</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>dijkstra</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name>subplan_itlist</name></expr></argument>,
									  <argument><expr><name>OUTER_VAR</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dijkstra</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>dijkstra</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>subplan_itlist</name></expr></argument>,
									  <argument><expr><name>OUTER_VAR</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dijkstra</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <call><name>fix_upper_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>dijkstra</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>, <argument><expr><name>subplan_itlist</name></expr></argument>,
									 <argument><expr><name>OUTER_VAR</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
