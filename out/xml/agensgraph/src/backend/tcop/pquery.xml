<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/tcop/pquery.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pquery.c
 *	  POSTGRES process query command code
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/tcop/pquery.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tstoreReceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph_fn.h"</cpp:file></cpp:include>


<comment type="block">/*
 * ActivePortal is the currently executing Portal (the most closely nested,
 * if there are several).
 */</comment>
<decl_stmt><decl><type><name>Portal</name></type>		<name>ActivePortal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessQuery</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
						 <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
						 <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
						 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
						 <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FillPortalStore</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>RunFromStore</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>,
						   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>PortalRunSelect</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
							  <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PortalRunUtility</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setHoldSnapshot</name></decl></parameter>,
							 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PortalRunMulti</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setHoldSnapshot</name></decl></parameter>,
						   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>altdest</name></decl></parameter>,
						   <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>DoPortalRunFetch</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
							   <parameter><decl><type><name>FetchDirection</name></type> <name>fdirection</name></decl></parameter>,
							   <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
							   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DoPortalRewind</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* global variable - see postgres.c */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>GraphWriteStats</name></type> <name>graphWriteStats</name></decl>;</decl_stmt>

<comment type="block">/*
 * CreateQueryDesc
 */</comment>
<function><type><name>QueryDesc</name> <modifier>*</modifier></type>
<name>CreateQueryDesc</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
				<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
				<parameter><decl><type><name>Snapshot</name></type> <name>crosscheck_snapshot</name></decl></parameter>,
				<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
				<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
				<parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>instrument_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>qd</name> <init>= <expr><operator>(</operator><name>QueryDesc</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>	<comment type="block">/* operation */</comment>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>plannedstmt</name></name> <operator>=</operator> <name>plannedstmt</name></expr>;</expr_stmt>	<comment type="block">/* plan */</comment>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>sourceText</name></name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>	<comment type="block">/* query text */</comment>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* snapshot */</comment>
	<comment type="block">/* RI check snapshot */</comment>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>crosscheck_snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>crosscheck_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>			<comment type="block">/* output dest */</comment>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>		<comment type="block">/* parameter values passed into query */</comment>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>queryEnv</name></name> <operator>=</operator> <name>queryEnv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name>instrument_options</name></expr>;</expr_stmt>	<comment type="block">/* instrumentation wanted? */</comment>

	<comment type="block">/* null these fields until set by ExecutorStart */</comment>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* not yet executed */</comment>
	<expr_stmt><expr><name><name>qd</name><operator>-&gt;</operator><name>already_executed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>qd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FreeQueryDesc
 */</comment>
<function><type><name>void</name></type>
<name>FreeQueryDesc</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>qdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Can't be a live query */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* forget our snapshots */</comment>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>crosscheck_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Only the QueryDesc itself need be freed */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessQuery
 *		Execute a single plannable query within a PORTAL_MULTI_QUERY,
 *		PORTAL_ONE_RETURNING, or PORTAL_ONE_MOD_WITH portal
 *
 *	plan: the plan tree for the query
 *	sourceText: the source text of the query
 *	params: any parameters needed
 *	dest: where to send results
 *	qc: where to store the command completion status data.
 *
 * qc may be NULL if caller doesn't want a status string.
 *
 * Must be called in a memory context that will be reset or deleted on
 * error; otherwise the executor's memory usage will be leaked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessQuery</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>,
			 <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
			 <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
			 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
			 <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create the QueryDesc object
	 */</comment>
	<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>sourceText</name></expr></argument>,
								<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
								<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call ExecutorStart to prepare the plan for execution
	 */</comment>
	<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run the plan to completion.
	 */</comment>
	<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build command completion status data, if caller wants one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>qc</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CMD_SELECT</name></expr>:</case>
				<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><name>CMDTAG_SELECT</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_INSERT</name></expr>:</case>
				<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><name>CMDTAG_INSERT</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
				<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><name>CMDTAG_UPDATE</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_DELETE</name></expr>:</case>
				<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><name>CMDTAG_DELETE</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_GRAPHWRITE</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>uint64</name></type>		<name>sum</name> <init>= <expr><name><name>graphWriteStats</name><operator>.</operator><name>insertVertex</name></name> <operator>+</operator>
										<name><name>graphWriteStats</name><operator>.</operator><name>insertEdge</name></name> <operator>+</operator>
										<name><name>graphWriteStats</name><operator>.</operator><name>deleteVertex</name></name> <operator>+</operator>
										<name><name>graphWriteStats</name><operator>.</operator><name>deleteEdge</name></name> <operator>+</operator>
										<name><name>graphWriteStats</name><operator>.</operator><name>updateProperty</name></name></expr></init></decl>;</decl_stmt>
	
					<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><name>CMDTAG_UPDATE</name></expr></argument>, <argument><expr><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><name>CMDTAG_UNKNOWN</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now, we close down all the scans and free allocated resources.
	 */</comment>
	<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ChoosePortalStrategy
 *		Select portal execution strategy given the intended statement list.
 *
 * The list elements can be Querys or PlannedStmts.
 * That's more general than portals need, but plancache.c uses this too.
 *
 * See the comments in portal.h.
 */</comment>
<function><type><name>PortalStrategy</name></type>
<name>ChoosePortalStrategy</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nSetTag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * PORTAL_ONE_SELECT and PORTAL_UTIL_SELECT need only consider the
	 * single-statement case, since there are no rewrite rules that can add
	 * auxiliary queries to a SELECT or a utility command. PORTAL_ONE_MOD_WITH
	 * likewise allows only one top-level statement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>PORTAL_ONE_MOD_WITH</name></expr>;</return></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<return>return <expr><name>PORTAL_ONE_SELECT</name></expr>;</return></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>UtilityReturnsTuples</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>PORTAL_UTIL_SELECT</name></expr>;</return></block_content></block></if></if_stmt>
					<comment type="block">/* it can't be ONE_RETURNING, so give up */</comment>
					<return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>PORTAL_ONE_MOD_WITH</name></expr>;</return></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<return>return <expr><name>PORTAL_ONE_SELECT</name></expr>;</return></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>UtilityReturnsTuples</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>PORTAL_UTIL_SELECT</name></expr>;</return></block_content></block></if></if_stmt>
					<comment type="block">/* it can't be ONE_RETURNING, so give up */</comment>
					<return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * PORTAL_ONE_RETURNING has to allow auxiliary queries added by rewrite.
	 * Choose PORTAL_ONE_RETURNING if there is exactly one canSetTag query and
	 * it has a RETURNING list.
	 */</comment>
	<expr_stmt><expr><name>nSetTag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>++</operator><name>nSetTag</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no need to look further */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>||</operator>
					<name><name>query</name><operator>-&gt;</operator><name>returningList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no need to look further */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>++</operator><name>nSetTag</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no need to look further */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>||</operator>
					<operator>!</operator><name><name>pstmt</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no need to look further */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>nSetTag</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PORTAL_ONE_RETURNING</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else, it's the general case... */</comment>
	<return>return <expr><name>PORTAL_MULTI_QUERY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FetchPortalTargetList
 *		Given a portal that returns tuples, extract the query targetlist.
 *		Returns NIL if the portal doesn't have a determinable targetlist.
 *
 * Note: do not modify the result.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>FetchPortalTargetList</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* no point in looking if we determined it doesn't return tuples */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_MULTI_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* get the primary statement and find out what it returns */</comment>
	<return>return <expr><call><name>FetchStatementTargetList</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>PortalGetPrimaryStmt</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FetchStatementTargetList
 *		Given a statement that returns tuples, extract the query targetlist.
 *		Returns NIL if the statement doesn't have a determinable targetlist.
 *
 * This can be applied to a Query or a PlannedStmt.
 * That's more general than portals need, but plancache.c uses this too.
 *
 * Note: do not modify the result.
 *
 * XXX be careful to keep this in sync with UtilityReturnsTuples.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>FetchStatementTargetList</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>stmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* transfer attention to utility statement */</comment>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* transfer attention to utility statement */</comment>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>pstmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>pstmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>FetchStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>fstmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Portal</name></type>		<name>subportal</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>fstmt</name><operator>-&gt;</operator><name>ismove</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subportal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>fstmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>subportal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>FetchPortalTargetList</name><argument_list>(<argument><expr><name>subportal</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>estmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>estmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>FetchPreparedStatementTargetList</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PortalStart
 *		Prepare a portal for execution.
 *
 * Caller must already have created the portal, done PortalDefineQuery(),
 * and adjusted portal options if needed.
 *
 * If parameters are needed by the query, they must be passed in "params"
 * (caller is responsible for giving them appropriate lifetime).
 *
 * The caller can also provide an initial set of "eflags" to be passed to
 * ExecutorStart (but note these can be modified internally, and they are
 * currently only honored for PORTAL_ONE_SELECT portals).  Most callers
 * should simply pass zero.
 *
 * The caller can optionally pass a snapshot to be used; pass InvalidSnapshot
 * for the normal behavior of setting a new snapshot.  This parameter is
 * presently ignored for non-PORTAL_ONE_SELECT portals (it's only intended
 * to be used for cursors).
 *
 * On return, portal is ready to accept PortalRun() calls, and the result
 * tupdesc (if any) is known.
 */</comment>
<function><type><name>void</name></type>
<name>PortalStart</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>saveActivePortal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>savePortalContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>myeflags</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>PORTAL_DEFINED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up global portal context pointers.
	 */</comment>
	<expr_stmt><expr><name>saveActivePortal</name> <operator>=</operator> <name>ActivePortal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saveResourceOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>savePortalContext</name> <operator>=</operator> <name>PortalContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>portal</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Must remember portal param list, if any */</comment>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine the portal execution strategy
		 */</comment>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <call><name>ChoosePortalStrategy</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fire her up according to the strategy
		 */</comment>
		<switch>switch <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PORTAL_ONE_SELECT</name></expr>:</case>

				<comment type="block">/* Must set snapshot before starting executor. */</comment>
				<if_stmt><if>if <condition>(<expr><name>snapshot</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/*
				 * We could remember the snapshot in portal-&gt;portalSnapshot,
				 * but presently there seems no need to, as this code path
				 * cannot be used for non-atomic execution.  Hence there can't
				 * be any commit/abort that might destroy the snapshot.  Since
				 * we don't do that, there's also no need to force a
				 * non-default nesting level for the snapshot.
				 */</comment>

				<comment type="block">/*
				 * Create QueryDesc in portal's context; for the moment, set
				 * the destination to DestNone.
				 */</comment>
				<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
											<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
											<argument><expr><name>InvalidSnapshot</name></expr></argument>,
											<argument><expr><name>None_Receiver</name></expr></argument>,
											<argument><expr><name>params</name></expr></argument>,
											<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If it's a scrollable cursor, executor needs to support
				 * REWIND and backwards scan, as well as whatever the caller
				 * might've asked for.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>myeflags</name> <operator>=</operator> <name>eflags</name> <operator>|</operator> <name>EXEC_FLAG_REWIND</name> <operator>|</operator> <name>EXEC_FLAG_BACKWARD</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>myeflags</name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/*
				 * Call ExecutorStart to prepare the plan for execution
				 */</comment>
				<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>myeflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * This tells PortalCleanup to shut down the executor
				 */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name> <operator>=</operator> <name>queryDesc</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Remember tuple descriptor (computed by ExecutorStart)
				 */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Reset cursor position data to "start of query"
				 */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* allow fetches */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PORTAL_ONE_RETURNING</name></expr>:</case>
			<case>case <expr><name>PORTAL_ONE_MOD_WITH</name></expr>:</case>

				<comment type="block">/*
				 * We don't start the executor until we are told to run the
				 * portal.  We do need to set up the result tupdesc.
				 */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>PortalGetPrimaryStmt</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator>
						<call><name>ExecCleanTypeFromTL</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * Reset cursor position data to "start of query"
				 */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* allow fetches */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PORTAL_UTIL_SELECT</name></expr>:</case>

				<comment type="block">/*
				 * We don't set snapshot here, because PortalRunUtility will
				 * take care of it if needed.
				 */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>PortalGetPrimaryStmt</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <call><name>UtilityTupleDescriptor</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * Reset cursor position data to "start of query"
				 */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* allow fetches */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PORTAL_MULTI_QUERY</name></expr>:</case>
				<comment type="block">/* Need do nothing now */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Uncaught error while executing portal: mark it dead */</comment>
		<expr_stmt><expr><call><name>MarkPortalFailed</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restore global vars and propagate error */</comment>
		<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_READY</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PortalSetResultFormat
 *		Select the format codes for a portal's output.
 *
 * This must be run after PortalStart for a portal that will be read by
 * a DestRemote or DestRemoteExecute destination.  It is not presently needed
 * for other destination types.
 *
 * formats[] is the client format request, as per Bind message conventions.
 */</comment>
<function><type><name>void</name></type>
<name>PortalSetResultFormat</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nFormats</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>formats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing if portal won't return tuples */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name></name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr></argument>,
						   <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nFormats</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* format specified for each column */</comment>
		<if_stmt><if>if <condition>(<expr><name>nFormats</name> <operator>!=</operator> <name>natts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind message has %d result formats but query has %d columns"</literal></expr></argument>,
							<argument><expr><name>nFormats</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name></name></expr></argument>, <argument><expr><name>formats</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* single format specified, use for all columns */</comment>
		<decl_stmt><decl><type><name>int16</name></type>		<name>format1</name> <init>= <expr><name><name>formats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>format1</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* use default format for all columns */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PortalRun
 *		Run a portal's query or queries.
 *
 * count &lt;= 0 is interpreted as a no-op: the destination gets started up
 * and shut down, but nothing else happens.  Also, count == FETCH_ALL is
 * interpreted as "all rows".  Note that count is ignored in multi-query
 * situations, where we always run the portal to completion.
 *
 * isTopLevel: true if query is being executed at backend "top level"
 * (that is, directly from a client command message)
 *
 * dest: where to send output of primary (canSetTag) query
 *
 * altdest: where to send output of non-primary queries
 *
 * qc: where to store command completion status data.
 *		May be NULL if caller doesn't want status data.
 *
 * Returns true if the portal's execution is complete, false if it was
 * suspended due to exhaustion of the count parameter.
 */</comment>
<function><type><name>bool</name></type>
<name>PortalRun</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>run_once</name></decl></parameter>,
		  <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>altdest</name></decl></parameter>,
		  <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>nprocessed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveTopTransactionResourceOwner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>saveTopTransactionContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>saveActivePortal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>savePortalContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>saveMemoryContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_EXECUTE_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize empty completion data */</comment>
	<if_stmt><if>if <condition>(<expr><name>qc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitializeQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_executor_stats</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PORTAL_MULTI_QUERY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"PortalRun"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* PORTAL_MULTI_QUERY logs its own stats per query */</comment>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check for improper portal use, and mark portal active.
	 */</comment>
	<expr_stmt><expr><call><name>MarkPortalActive</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set run_once flag.  Shouldn't be clear if previously set. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name> <operator>||</operator> <name>run_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name> <operator>=</operator> <name>run_once</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up global portal context pointers.
	 *
	 * We have to play a special game here to support utility commands like
	 * VACUUM and CLUSTER, which internally start and commit transactions.
	 * When we are called to execute such a command, CurrentResourceOwner will
	 * be pointing to the TopTransactionResourceOwner --- which will be
	 * destroyed and replaced in the course of the internal commit and
	 * restart.  So we need to be prepared to restore it as pointing to the
	 * exit-time TopTransactionResourceOwner.  (Ain't that ugly?  This idea of
	 * internally starting whole new transactions is not good.)
	 * CurrentMemoryContext has a similar problem, but the other pointers we
	 * save here will be NULL or pointing to longer-lived objects.
	 */</comment>
	<expr_stmt><expr><name>saveTopTransactionResourceOwner</name> <operator>=</operator> <name>TopTransactionResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saveTopTransactionContext</name> <operator>=</operator> <name>TopTransactionContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saveActivePortal</name> <operator>=</operator> <name>ActivePortal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saveResourceOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>savePortalContext</name> <operator>=</operator> <name>PortalContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saveMemoryContext</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>portal</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PORTAL_ONE_SELECT</name></expr>:</case>
			<case>case <expr><name>PORTAL_ONE_RETURNING</name></expr>:</case>
			<case>case <expr><name>PORTAL_ONE_MOD_WITH</name></expr>:</case>
			<case>case <expr><name>PORTAL_UTIL_SELECT</name></expr>:</case>

				<comment type="block">/*
				 * If we have not yet run the command, do so, storing its
				 * results in the portal's tuplestore.  But we don't do that
				 * for the PORTAL_ONE_SELECT case.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PORTAL_ONE_SELECT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>FillPortalStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Now fetch desired portion of results.
				 */</comment>
				<expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the portal result contains a command tag and the caller
				 * gave us a pointer to store it, copy it and update the
				 * rowcount.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>qc</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>qc</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>CMDTAG_UNKNOWN</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>CopyQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>portal</name><operator>-&gt;</operator><name>qc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>qc</name><operator>-&gt;</operator><name>nprocessed</name></name> <operator>=</operator> <name>nprocessed</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Mark portal not active */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_READY</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Since it's a forward fetch, say DONE iff atEnd is now true.
				 */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PORTAL_MULTI_QUERY</name></expr>:</case>
				<expr_stmt><expr><call><name>PortalRunMulti</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>altdest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Prevent portal's commands from being re-executed */</comment>
				<expr_stmt><expr><call><name>MarkPortalDone</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Always complete at end of RunMulti */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized portal strategy: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Uncaught error while executing portal: mark it dead */</comment>
		<expr_stmt><expr><call><name>MarkPortalFailed</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restore global vars and propagate error */</comment>
		<if_stmt><if>if <condition>(<expr><name>saveMemoryContext</name> <operator>==</operator> <name>saveTopTransactionContext</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>saveMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>saveResourceOwner</name> <operator>==</operator> <name>saveTopTransactionResourceOwner</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>TopTransactionResourceOwner</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

		<comment type="block">/* todo: Is it using now? */</comment>
		<expr_stmt><expr><name>enableGraphDML</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>saveMemoryContext</name> <operator>==</operator> <name>saveTopTransactionContext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>saveMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>saveResourceOwner</name> <operator>==</operator> <name>saveTopTransactionResourceOwner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>TopTransactionResourceOwner</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_executor_stats</name> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PORTAL_MULTI_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"EXECUTOR STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_EXECUTE_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PortalRunSelect
 *		Execute a portal's query in PORTAL_ONE_SELECT mode, and also
 *		when fetching from a completed holdStore in PORTAL_ONE_RETURNING,
 *		PORTAL_ONE_MOD_WITH, and PORTAL_UTIL_SELECT cases.
 *
 * This handles simple N-rows-forward-or-backward cases.  For more complex
 * nonsequential access to a portal, see PortalRunFetch.
 *
 * count &lt;= 0 is interpreted as a no-op: the destination gets started up
 * and shut down, but nothing else happens.  Also, count == FETCH_ALL is
 * interpreted as "all rows".  (cf FetchStmt.howMany)
 *
 * Caller must already have validated the Portal and done appropriate
 * setup (cf. PortalRun).
 *
 * Returns number of rows processed (suitable for use in result tag)
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>PortalRunSelect</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>,
				<parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
				<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>direction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>nprocessed</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * NB: queryDesc will be NULL if we are fetching from a held cursor or a
	 * completed utility query; can't use it in that path.
	 */</comment>
	<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* Caller messed up if we have neither a ready query nor held data. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>||</operator> <name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force the queryDesc destination to the right thing.  This supports
	 * MOVE, for example, which will pass in dest = DestNone.  This is okay to
	 * change as long as we do it on every fetch.  (The Executor must not
	 * assume that dest never changes.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>queryDesc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Determine which direction to go in, and check to see if we're already
	 * at the end of the available tuples in that direction.  If so, set the
	 * direction to NoMovement to avoid trying to fetch any tuples.  (This
	 * check exists because not all plan node types are robust about being
	 * called again if they've already returned NULL once.)  Then call the
	 * executor (we must not skip this, because the destination needs to see a
	 * setup and shutdown even if no tuples are available).  Finally, update
	 * the portal position state depending on the number of tuples that were
	 * retrieved.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>||</operator> <name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>NoMovementScanDirection</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* don't pass negative count to executor */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* In the executor, zero count processes all rows */</comment>
		<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>FETCH_ALL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <call><name>RunFromStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr></argument>,
						<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ScanDirectionIsNoMovement</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nprocessed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* OK to go backward now */</comment>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nprocessed</name> <operator>&lt;</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* we retrieved 'em all */</comment>
			<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>+=</operator> <name>nprocessed</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_NO_SCROLL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor can only scan forward"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Declare it with SCROLL option to enable backward scan."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>||</operator> <name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>NoMovementScanDirection</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* don't pass negative count to executor */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>BackwardScanDirection</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* In the executor, zero count processes all rows */</comment>
		<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>FETCH_ALL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <call><name>RunFromStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr></argument>,
						<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nprocessed</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ScanDirectionIsNoMovement</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nprocessed</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* OK to go forward now */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* adjust for endpoint case */</comment>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nprocessed</name> <operator>&lt;</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>count</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* we retrieved 'em all */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>-=</operator> <name>nprocessed</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>nprocessed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FillPortalStore
 *		Run the query and load result tuples into the portal's tuple store.
 *
 * This is used for PORTAL_ONE_RETURNING, PORTAL_ONE_MOD_WITH, and
 * PORTAL_UTIL_SELECT cases only.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FillPortalStore</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>treceiver</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryCompletion</name></type> <name>qc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitializeQueryCompletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PortalCreateHoldStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>treceiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestTuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTuplestoreDestReceiverParams</name><argument_list>(<argument><expr><name>treceiver</name></expr></argument>,
									<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>,
									<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PORTAL_ONE_RETURNING</name></expr>:</case>
		<case>case <expr><name>PORTAL_ONE_MOD_WITH</name></expr>:</case>

			<comment type="block">/*
			 * Run the portal to completion just as for the default
			 * PORTAL_MULTI_QUERY case, but send the primary query's output to
			 * the tuplestore.  Auxiliary query outputs are discarded. Set the
			 * portal's holdSnapshot to the snapshot used (or a copy of it).
			 */</comment>
			<expr_stmt><expr><call><name>PortalRunMulti</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						   <argument><expr><name>treceiver</name></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PORTAL_UTIL_SELECT</name></expr>:</case>
			<expr_stmt><expr><call><name>PortalRunUtility</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>treceiver</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported portal strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Override portal completion data with actual command results */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qc</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>CMDTAG_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CopyQueryCompletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>portal</name><operator>-&gt;</operator><name>qc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name><name>treceiver</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name>treceiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RunFromStore
 *		Fetch tuples from the portal's tuple store.
 *
 * Calling conventions are similar to ExecutorRun, except that we
 * do not depend on having a queryDesc or estate.  Therefore we return the
 * number of tuples processed as the result, not in estate-&gt;es_processed.
 *
 * One difference from ExecutorRun is that the destination receiver functions
 * are run in the caller's memory context (since we have no estate).  Watch
 * out for memory leaks.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>RunFromStore</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>,
			 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>current_tuple_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>CMD_SELECT</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsNoMovement</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* do nothing except start/stop the destination */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>forward</name> <init>= <expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we are not able to send the tuple, we assume the destination
			 * has closed and no more tuples can be sent. If that's the case,
			 * end the loop.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * check our tuple count.. if we've processed the proper number
			 * then quit, else loop again and process more tuples. Zero count
			 * means no limit.
			 */</comment>
			<expr_stmt><expr><name>current_tuple_count</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>==</operator> <name>current_tuple_count</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>current_tuple_count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PortalRunUtility
 *		Execute a utility statement inside a portal.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PortalRunUtility</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setHoldSnapshot</name></decl></parameter>,
				 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Set snapshot if utility stmt needs one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PlannedStmtRequiresSnapshot</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name> <init>= <expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If told to, register the snapshot we're using and save in portal */</comment>
		<if_stmt><if>if <condition>(<expr><name>setHoldSnapshot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>holdSnapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In any case, make the snapshot active and remember it in portal.
		 * Because the portal now references the snapshot, we must tell
		 * snapmgr.c that the snapshot belongs to the portal's transaction
		 * level, else we risk portalSnapshot becoming a dangling pointer.
		 */</comment>
		<expr_stmt><expr><call><name>PushActiveSnapshotWithLevel</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>createLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* PushActiveSnapshotWithLevel might have copied the snapshot */</comment>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalSnapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalSnapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
				   <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
				   <argument><expr><ternary><condition><expr><name>isTopLevel</name></expr> ?</condition><then> <expr><name>PROCESS_UTILITY_TOPLEVEL</name></expr> </then><else>: <expr><name>PROCESS_UTILITY_QUERY</name></expr></else></ternary></expr></argument>,
				   <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr></argument>,
				   <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
				   <argument><expr><name>dest</name></expr></argument>,
				   <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Some utility statements may change context on us */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Some utility commands (e.g., VACUUM) pop the ActiveSnapshot stack from
	 * under us, so don't complain if it's now empty.  Otherwise, our snapshot
	 * should be the top one; pop it.  Note that this could be a different
	 * snapshot from the one we made above; see EnsurePortalSnapshotExists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>portalSnapshot</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalSnapshot</name></name> <operator>==</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalSnapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PortalRunMulti
 *		Execute a portal's queries in the general case (multi queries
 *		or non-SELECT-like queries)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PortalRunMulti</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setHoldSnapshot</name></decl></parameter>,
			   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>altdest</name></decl></parameter>,
			   <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>active_snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>stmtlist_item</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the destination is DestRemoteExecute, change to DestNone.  The
	 * reason is that the client won't be expecting any tuples, and indeed has
	 * no way to know what they are, since there is no provision for Describe
	 * to send a RowDescription message when this portal execution strategy is
	 * in effect.  This presently will only affect SELECT commands added to
	 * non-SELECT queries by rewrite rules: such commands will be executed,
	 * but the results will be discarded unless you use "simple Query"
	 * protocol.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestRemoteExecute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>None_Receiver</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>altdest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestRemoteExecute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>altdest</name> <operator>=</operator> <name>None_Receiver</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Loop to handle the individual queries generated from a single parsetree
	 * by analysis and rewrite.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>stmtlist_item</argument>, <argument>portal-&gt;stmts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>stmtlist_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we got a cancel signal in prior command, quit
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * process a plannable query.
			 */</comment>
			<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_EXECUTE_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>log_executor_stats</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Must always have a snapshot for plannable queries.  First time
			 * through, take a new snapshot; for subsequent queries in the
			 * same portal, just update the snapshot's copy of the command
			 * counter.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>active_snapshot_set</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name> <init>= <expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* If told to, register the snapshot and save in portal */</comment>
				<if_stmt><if>if <condition>(<expr><name>setHoldSnapshot</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>holdSnapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We can't have the holdSnapshot also be the active one,
				 * because UpdateActiveSnapshotCommandId would complain.  So
				 * force an extra snapshot copy.  Plain PushActiveSnapshot
				 * would have copied the transaction snapshot anyway, so this
				 * only adds a copy step when setHoldSnapshot is true.  (It's
				 * okay for the command ID of the active snapshot to diverge
				 * from what holdSnapshot has.)
				 */</comment>
				<expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * As for PORTAL_ONE_SELECT portals, it does not seem
				 * necessary to maintain portal-&gt;portalSnapshot here.
				 */</comment>

				<expr_stmt><expr><name>active_snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* statement can set tag string */</comment>
				<expr_stmt><expr><call><name>ProcessQuery</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
							 <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
							 <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr></argument>,
							 <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
							 <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* stmt added by rewrite cannot set tag */</comment>
				<expr_stmt><expr><call><name>ProcessQuery</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
							 <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>,
							 <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr></argument>,
							 <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
							 <argument><expr><name>altdest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>log_executor_stats</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"EXECUTOR STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_EXECUTE_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * process utility functions (create, destroy, etc..)
			 *
			 * We must not set a snapshot here for utility commands (if one is
			 * needed, PortalRunUtility will do it).  If a utility command is
			 * alone in a portal then everything's fine.  The only case where
			 * a utility command can be part of a longer list is that rules
			 * are allowed to include NotifyStmt.  NotifyStmt doesn't care
			 * whether it has a snapshot or not, so we just leave the current
			 * snapshot alone if we have one.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>active_snapshot_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* statement can set tag string */</comment>
				<expr_stmt><expr><call><name>PortalRunUtility</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* stmt added by rewrite cannot set tag */</comment>
				<expr_stmt><expr><call><name>PortalRunUtility</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name>altdest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Clear subsidiary contexts to recover temporary memory.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name> <operator>==</operator> <name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextDeleteChildren</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Avoid crashing if portal-&gt;stmts has been reset.  This can only
		 * occur if a CALL or DO utility statement executed an internal
		 * COMMIT/ROLLBACK (cf PortalReleaseCachedPlan).  The CALL or DO must
		 * have been the only statement in the portal, so there's nothing left
		 * for us to do; but we don't want to dereference a now-dangling list
		 * pointer.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Increment command counter between queries, but not after the last
		 * one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>, <argument><expr><name>stmtlist_item</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Pop the snapshot if we pushed one. */</comment>
	<if_stmt><if>if <condition>(<expr><name>active_snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If a query completion data was supplied, use it.  Otherwise use the
	 * portal's query completion data.
	 *
	 * Exception: Clients expect INSERT/UPDATE/DELETE tags to have counts, so
	 * fake them with zeros.  This can happen with DO INSTEAD rules if there
	 * is no replacement query of the same type as the original.  We print "0
	 * 0" here because technically there is no query of the matching tag type,
	 * and printing a non-zero count for a different query type seems wrong,
	 * e.g.  an INSERT that does an UPDATE instead should not print "0 1" if
	 * one row was updated.  See QueryRewrite(), step 3, for details.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>qc</name> <operator>&amp;&amp;</operator> <name><name>qc</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name>CMDTAG_UNKNOWN</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>qc</name><operator>.</operator><name>commandTag</name></name> <operator>!=</operator> <name>CMDTAG_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CopyQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>portal</name><operator>-&gt;</operator><name>qc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* If the caller supplied a qc, we should have set it by now. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qc</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>!=</operator> <name>CMDTAG_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PortalRunFetch
 *		Variant form of PortalRun that supports SQL FETCH directions.
 *
 * Note: we presently assume that no callers of this want isTopLevel = true.
 *
 * count &lt;= 0 is interpreted as a no-op: the destination gets started up
 * and shut down, but nothing else happens.  Also, count == FETCH_ALL is
 * interpreted as "all rows".  (cf FetchStmt.howMany)
 *
 * Returns number of rows processed (suitable for use in result tag)
 */</comment>
<function><type><name>uint64</name></type>
<name>PortalRunFetch</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
			   <parameter><decl><type><name>FetchDirection</name></type> <name>fdirection</name></decl></parameter>,
			   <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
			   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>saveActivePortal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>saveResourceOwner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>savePortalContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for improper portal use, and mark portal active.
	 */</comment>
	<expr_stmt><expr><call><name>MarkPortalActive</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If supporting FETCH, portal can't be run-once. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>run_once</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up global portal context pointers.
	 */</comment>
	<expr_stmt><expr><name>saveActivePortal</name> <operator>=</operator> <name>ActivePortal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saveResourceOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>savePortalContext</name> <operator>=</operator> <name>PortalContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>portal</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PORTAL_ONE_SELECT</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DoPortalRunFetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>fdirection</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PORTAL_ONE_RETURNING</name></expr>:</case>
			<case>case <expr><name>PORTAL_ONE_MOD_WITH</name></expr>:</case>
			<case>case <expr><name>PORTAL_UTIL_SELECT</name></expr>:</case>

				<comment type="block">/*
				 * If we have not yet run the command, do so, storing its
				 * results in the portal's tuplestore.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>FillPortalStore</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* isTopLevel */</comment> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Now fetch desired portion of results.
				 */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DoPortalRunFetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>fdirection</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported portal strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Uncaught error while executing portal: mark it dead */</comment>
		<expr_stmt><expr><call><name>MarkPortalFailed</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restore global vars and propagate error */</comment>
		<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark portal not active */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_READY</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ActivePortal</name> <operator>=</operator> <name>saveActivePortal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>saveResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <name>savePortalContext</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DoPortalRunFetch
 *		Guts of PortalRunFetch --- the portal context is already set up
 *
 * Here, count &lt; 0 typically reverses the direction.  Also, count == FETCH_ALL
 * is interpreted as "all rows".  (cf FetchStmt.howMany)
 *
 * Returns number of rows processed (suitable for use in result tag)
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>DoPortalRunFetch</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>,
				 <parameter><decl><type><name>FetchDirection</name></type> <name>fdirection</name></decl></parameter>,
				 <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>,
				 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>forward</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_ONE_SELECT</name> <operator>||</operator>
		   <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_ONE_RETURNING</name> <operator>||</operator>
		   <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_ONE_MOD_WITH</name> <operator>||</operator>
		   <name><name>portal</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PORTAL_UTIL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we disallow backwards fetch (including re-fetch of current row)
	 * for NO SCROLL cursors, but we interpret that very loosely: you can use
	 * any of the FetchDirection options, so long as the end result is to move
	 * forwards by at least one row.  Currently it's sufficient to check for
	 * NO SCROLL in DoPortalRewind() and in the forward == false path in
	 * PortalRunSelect(); but someday we might prefer to account for that
	 * restriction explicitly here.
	 */</comment>
	<switch>switch <condition>(<expr><name>fdirection</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FETCH_FORWARD</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fdirection</name> <operator>=</operator> <name>FETCH_BACKWARD</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>count</name> <operator>=</operator> <operator>-</operator><name>count</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* fall out of switch to share code with FETCH_BACKWARD */</comment>
			<break>break;</break>
		<case>case <expr><name>FETCH_BACKWARD</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fdirection</name> <operator>=</operator> <name>FETCH_FORWARD</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>count</name> <operator>=</operator> <operator>-</operator><name>count</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* fall out of switch to share code with FETCH_FORWARD */</comment>
			<break>break;</break>
		<case>case <expr><name>FETCH_ABSOLUTE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Definition: Rewind to start, advance count-1 rows, return
				 * next row (if any).
				 *
				 * In practice, if the goal is less than halfway back to the
				 * start, it's better to scan from where we are.
				 *
				 * Also, if current portalPos is outside the range of "long",
				 * do it the hard way to avoid possible overflow of the count
				 * argument to PortalRunSelect.  We must exclude exactly
				 * LONG_MAX, as well, lest the count look like FETCH_ALL.
				 *
				 * In any case, we arrange to fetch the target row going
				 * forwards.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><name>count</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>/</operator> <literal type="number">2</literal> <operator>||</operator>
					<name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>&gt;=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>LONG_MAX</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>DoPortalRewind</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>long</name></type>		<name>pos</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* need one extra fetch if off end */</comment>
					<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>pos</name> <operator>-</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name> <operator>-</operator> <name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Definition: Advance to end, back up abs(count)-1 rows,
				 * return prior row (if any).  We could optimize this if we
				 * knew in advance where the end was, but typically we won't.
				 * (Is it worth considering case where count &gt; half of size of
				 * query?  We could rewind once we know the size ...)
				 */</comment>
				<expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>FETCH_ALL</name></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* count == 0 */</comment>
				<comment type="block">/* Rewind to start, return zero rows */</comment>
				<expr_stmt><expr><call><name>DoPortalRewind</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>FETCH_RELATIVE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Definition: advance count-1 rows, return next row (if any).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Definition: back up abs(count)-1 rows, return prior row (if
				 * any).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* count == 0 */</comment>
				<comment type="block">/* Same as FETCH FORWARD 0, so fall out of switch */</comment>
				<expr_stmt><expr><name>fdirection</name> <operator>=</operator> <name>FETCH_FORWARD</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus direction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Get here with fdirection == FETCH_FORWARD or FETCH_BACKWARD, and count
	 * &gt;= 0.
	 */</comment>
	<expr_stmt><expr><name>forward</name> <operator>=</operator> <operator>(</operator><name>fdirection</name> <operator>==</operator> <name>FETCH_FORWARD</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Zero count means to re-fetch the current row, if any (per SQL)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>on_row</name></decl>;</decl_stmt>

		<comment type="block">/* Are we sitting on a row? */</comment>
		<expr_stmt><expr><name>on_row</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestNone</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* MOVE 0 returns 0/1 based on if FETCH 0 would return a row */</comment>
			<return>return <expr><ternary><condition><expr><name>on_row</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If we are sitting on a row, back up one so we can re-fetch it.
			 * If we are not sitting on a row, we still have to start up and
			 * shut down the executor so that the destination is initialized
			 * and shut down correctly; so keep going.  To PortalRunSelect,
			 * count == 0 means we will retrieve no row.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>on_row</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Set up to fetch one row forward */</comment>
				<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>forward</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Optimize MOVE BACKWARD ALL into a Rewind.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>forward</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>==</operator> <name>FETCH_ALL</name> <operator>&amp;&amp;</operator> <name><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestNone</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>result</name> <init>= <expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>DoPortalRewind</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>PortalRunSelect</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DoPortalRewind - rewind a Portal to starting point
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DoPortalRewind</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * No work is needed if we've not advanced nor attempted to advance the
	 * cursor (and we don't want to throw a NO SCROLL error in this case).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, cursor should allow scrolling.  However, we're only going to
	 * enforce that policy fully beginning in v15.  In older branches, insist
	 * on this only if the portal has a holdStore.  That prevents users from
	 * seeing that the holdStore may not have all the rows of the query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_NO_SCROLL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cursor can only scan forward"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Declare it with SCROLL option to enable backward scan."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Rewind holdStore, if we have one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>holdStore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Rewind executor, if active */</comment>
	<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>queryDesc</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>queryDesc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecutorRewind</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>atEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PlannedStmtRequiresSnapshot - what it says on the tin
 */</comment>
<function><type><name>bool</name></type>
<name>PlannedStmtRequiresSnapshot</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>utilityStmt</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If it's not a utility statement, it definitely needs a snapshot */</comment>
	<if_stmt><if>if <condition>(<expr><name>utilityStmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Most utility statements need a snapshot, and the default presumption
	 * about new ones should be that they do too.  Hence, enumerate those that
	 * do not need one.
	 *
	 * Transaction control, LOCK, and SET must *not* set a snapshot, since
	 * they need to be executable at the start of a transaction-snapshot-mode
	 * transaction without freezing a snapshot.  By extension we allow SHOW
	 * not to set a snapshot.  The other stmts listed are just efficiency
	 * hacks.  Beware of listing anything that can modify the database --- if,
	 * say, it has to update an index with expressions that invoke
	 * user-defined functions, then it had better have a snapshot.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>LockStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>VariableSetStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>VariableShowStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>ConstraintsSetStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
	<comment type="block">/* efficiency hacks from here down */</comment>
		<call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>FetchStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>ListenStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>UnlistenStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>CheckPointStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EnsurePortalSnapshotExists - recreate Portal-level snapshot, if needed
 *
 * Generally, we will have an active snapshot whenever we are executing
 * inside a Portal, unless the Portal's query is one of the utility
 * statements exempted from that rule (see PlannedStmtRequiresSnapshot).
 * However, procedures and DO blocks can commit or abort the transaction,
 * and thereby destroy all snapshots.  This function can be called to
 * re-establish the Portal-level snapshot when none exists.
 */</comment>
<function><type><name>void</name></type>
<name>EnsurePortalSnapshotExists</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Nothing to do if a snapshot is set.  (We take it on faith that the
	 * outermost active snapshot belongs to some Portal; or if there is no
	 * Portal, it's somebody else's responsibility to manage things.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise, we'd better have an active Portal */</comment>
	<expr_stmt><expr><name>portal</name> <operator>=</operator> <name>ActivePortal</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot execute SQL without an outer snapshot or portal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalSnapshot</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a new snapshot, make it active, and remember it in portal.
	 * Because the portal now references the snapshot, we must tell snapmgr.c
	 * that the snapshot belongs to the portal's transaction level, else we
	 * risk portalSnapshot becoming a dangling pointer.
	 */</comment>
	<expr_stmt><expr><call><name>PushActiveSnapshotWithLevel</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>createLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* PushActiveSnapshotWithLevel might have copied the snapshot */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalSnapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
