<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/tcop/utility.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * utility.c
 *	  Contains functions which control the execution of the POSTGRES utility
 *	  commands.  At one time acted as an interface between the Lisp and C
 *	  systems.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/tcop/utility.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/collationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/conversioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/createas.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/discard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/lockcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/matview.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/portalcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/proclang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/publicationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/schemacmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/seclabel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/subscriptioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/view.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteRemove.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/graphcmds.h"</cpp:file></cpp:include>

<comment type="block">/* Hook for plugins to get control in ProcessUtility() */</comment>
<decl_stmt><decl><type><name>ProcessUtility_hook_type</name></type> <name>ProcessUtility_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* local function declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ClassifyUtilityCommandAsReadOnly</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessUtilitySlow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							   <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
							   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
							   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
							   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
							   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
							   <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecDropStmt</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * CommandIsReadOnly: is an executable query read-only?
 *
 * This is a much stricter test than we apply for XactReadOnly mode;
 * the query must be *in truth* read-only, because the caller wishes
 * not to do CommandCounterIncrement for it.
 *
 * Note: currently no need to support raw or analyzed queries here
 */</comment>
<function><type><name>bool</name></type>
<name>CommandIsReadOnly</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>	<comment type="block">/* SELECT FOR [KEY] UPDATE/SHARE */</comment>
			<if type="elseif">else if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>	<comment type="block">/* data-modifying CTE */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
			<comment type="block">/* For now, treat all utility commands as read/write */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the degree to which a utility command is read only.
 *
 * Note the definitions of the relevant flags in src/include/utility/tcop.h.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ClassifyUtilityCommandAsReadOnly</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterStatsStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTypeStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
		<case>case <expr><name>T_DefineStmt</name></expr>:</case>
		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_DropStmt</name></expr>:</case>
		<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
		<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
		<case>case <expr><name>T_RuleStmt</name></expr>:</case>
		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
		<case>case <expr><name>T_ViewStmt</name></expr>:</case>
			<comment type="block">/* AgensGraph DDLs */</comment>
		<case>case <expr><name>T_CreateGraphStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateLabelStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterLabelStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateConstraintStmt</name></expr>:</case>
		<case>case <expr><name>T_DropConstraintStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePropertyIndexStmt</name></expr>:</case>
		<case>case <expr><name>T_DisableIndexStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* DDL is not read-only, and neither is TRUNCATE. */</comment>
				<return>return <expr><name>COMMAND_IS_NOT_READ_ONLY</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Surprisingly, ALTER SYSTEM meets all our definitions of
				 * read-only: it changes nothing that affects the output of
				 * pg_dump, it doesn't write WAL or imperil the application of
				 * future WAL, and it doesn't depend on any state that needs
				 * to be synchronized with parallel workers.
				 *
				 * So, despite the fact that it writes to a file, it's read
				 * only!
				 */</comment>
				<return>return <expr><name>COMMAND_IS_STRICTLY_READ_ONLY</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_CallStmt</name></expr>:</case>
		<case>case <expr><name>T_DoStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Commands inside the DO block or the called procedure might
				 * not be read only, but they'll be checked separately when we
				 * try to execute them.  Here we only need to worry about the
				 * DO or CALL command itself.
				 */</comment>
				<return>return <expr><name>COMMAND_IS_STRICTLY_READ_ONLY</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * You might think that this should not be permitted in
				 * recovery, but we interpret a CHECKPOINT command during
				 * recovery as a request for a restartpoint instead. We allow
				 * this since it can be a useful way of reducing switchover
				 * time when using various forms of replication.
				 */</comment>
				<return>return <expr><name>COMMAND_IS_STRICTLY_READ_ONLY</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
		<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
		<case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
		<case>case <expr><name>T_DiscardStmt</name></expr>:</case>
		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
		<case>case <expr><name>T_LoadStmt</name></expr>:</case>
		<case>case <expr><name>T_PrepareStmt</name></expr>:</case>
		<case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
		<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * These modify only backend-local state, so they're OK to run
				 * in a read-only transaction or on a standby. However, they
				 * are disallowed in parallel mode, because they either rely
				 * upon or modify backend-local state that might not be
				 * synchronized among cooperating backends.
				 */</comment>
				<return>return <expr><name>COMMAND_OK_IN_RECOVERY</name> <operator>|</operator> <name>COMMAND_OK_IN_READ_ONLY_TXN</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * These commands write WAL, so they're not strictly
				 * read-only, and running them in parallel workers isn't
				 * supported.
				 *
				 * However, they don't change the database state in a way that
				 * would affect pg_dump output, so it's fine to run them in a
				 * read-only transaction. (CLUSTER might change the order of
				 * rows on disk, which could affect the ordering of pg_dump
				 * output, but that's not semantically significant.)
				 */</comment>
				<return>return <expr><name>COMMAND_OK_IN_READ_ONLY_TXN</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CopyStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * You might think that COPY FROM is not at all read only, but
				 * it's OK to copy into a temporary table, because that
				 * wouldn't change the output of pg_dump.  If the target table
				 * turns out to be non-temporary, DoCopy itself will call
				 * PreventCommandIfReadOnly.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_from</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>COMMAND_OK_IN_READ_ONLY_TXN</name></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>COMMAND_IS_STRICTLY_READ_ONLY</name></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * These commands don't modify any data and are safe to run in
				 * a parallel worker.
				 */</comment>
				<return>return <expr><name>COMMAND_IS_STRICTLY_READ_ONLY</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ListenStmt</name></expr>:</case>
		<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * NOTIFY requires an XID assignment, so it can't be permitted
				 * on a standby. Perhaps LISTEN could, since without NOTIFY it
				 * would be OK to just do nothing, at least until promotion,
				 * but we currently prohibit it lest the user get the wrong
				 * idea.
				 *
				 * (We do allow T_UnlistenStmt on a standby, though, because
				 * it's a no-op.)
				 */</comment>
				<return>return <expr><name>COMMAND_OK_IN_READ_ONLY_TXN</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_LockStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>LockStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>LockStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Only weaker locker modes are allowed during recovery. The
				 * restrictions here must match those in
				 * LockAcquireExtended().
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>mode</name></name> <operator>&gt;</operator> <name>RowExclusiveLock</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>COMMAND_OK_IN_READ_ONLY_TXN</name></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>COMMAND_IS_STRICTLY_READ_ONLY</name></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block>

		<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * PREPARE, COMMIT PREPARED, and ROLLBACK PREPARED all write
				 * WAL, so they're not read-only in the strict sense; but the
				 * first and third do not change pg_dump output, so they're OK
				 * in a read-only transactions.
				 *
				 * We also consider COMMIT PREPARED to be OK in a read-only
				 * transaction environment, by way of exception.
				 */</comment>
				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>TRANS_STMT_BEGIN</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_START</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_COMMIT</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_ROLLBACK</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_SAVEPOINT</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_RELEASE</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_ROLLBACK_TO</name></expr>:</case>
						<return>return <expr><name>COMMAND_IS_STRICTLY_READ_ONLY</name></expr>;</return>

					<case>case <expr><name>TRANS_STMT_PREPARE</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_COMMIT_PREPARED</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED</name></expr>:</case>
						<return>return <expr><name>COMMAND_OK_IN_READ_ONLY_TXN</name></expr>;</return>
				</block_content>}</block></switch>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized TransactionStmtKind: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>		<comment type="block">/* silence stupider compilers */</comment>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>			<comment type="block">/* silence stupider compilers */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * PreventCommandIfReadOnly: throw error if XactReadOnly
 *
 * This is useful partly to ensure consistency of the error message wording;
 * some callers have checked XactReadOnly for themselves.
 */</comment>
<function><type><name>void</name></type>
<name>PreventCommandIfReadOnly</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>XactReadOnly</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL command, eg CREATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s in a read-only transaction"</literal></expr></argument>,
						<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PreventCommandIfParallelMode: throw error if current (sub)transaction is
 * in parallel mode.
 *
 * This is useful partly to ensure consistency of the error message wording;
 * some callers have checked IsInParallelMode() for themselves.
 */</comment>
<function><type><name>void</name></type>
<name>PreventCommandIfParallelMode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL command, eg CREATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s during a parallel operation"</literal></expr></argument>,
						<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PreventCommandDuringRecovery: throw error if RecoveryInProgress
 *
 * The majority of operations that are unsafe in a Hot Standby
 * will be rejected by XactReadOnly tests.  However there are a few
 * commands that are allowed in "read-only" xacts but cannot be allowed
 * in Hot Standby mode.  Those commands should call this function.
 */</comment>
<function><type><name>void</name></type>
<name>PreventCommandDuringRecovery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL command, eg CREATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s during recovery"</literal></expr></argument>,
						<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckRestrictedOperation: throw error for hazardous command if we're
 * inside a security restriction context.
 *
 * This is needed to protect session-local state for which there is not any
 * better-defined protection mechanism, such as ownership.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckRestrictedOperation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL command, eg PREPARE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s within security-restricted operation"</literal></expr></argument>,
						<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessUtility
 *		general utility function invoker
 *
 *	pstmt: PlannedStmt wrapper for the utility statement
 *	queryString: original source text of command
 *	context: identifies source of statement (toplevel client command,
 *		non-toplevel client command, subcommand of a larger utility command)
 *	params: parameters to use during execution
 *	queryEnv: environment for parse through execution (e.g., ephemeral named
 *		tables like trigger transition tables).  May be NULL.
 *	dest: where to send results
 *	qc: where to store command completion status data.  May be NULL,
 *		but if not, then caller must have initialized it.
 *
 * Caller MUST supply a queryString; it is not allowed (anymore) to pass NULL.
 * If you really don't have source text, you can pass a constant string,
 * perhaps "(query not available)".
 *
 * Note for users of ProcessUtility_hook: the same queryString may be passed
 * to multiple invocations of ProcessUtility when processing a query string
 * containing multiple semicolon-separated statements.  One should use
 * pstmt-&gt;stmt_location and pstmt-&gt;stmt_len to identify the substring
 * containing the current statement.  Keep in mind also that some utility
 * statements (e.g., CREATE SCHEMA) will recurse to ProcessUtility to process
 * sub-statements, often passing down the same queryString, stmt_location,
 * and stmt_len that were given for the whole statement.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
			   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
			   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
			   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
			   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
			   <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryString</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* required as of 8.4 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>qc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>qc</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name>CMDTAG_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We provide a function hook variable that lets loadable plugins get
	 * control when ProcessUtility is called.  Such a plugin would normally
	 * call standard_ProcessUtility().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ProcessUtility_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ProcessUtility_hook</name>) <argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
								<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
								<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
								<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
								<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * standard_ProcessUtility itself deals only with utility commands for
 * which we do not provide event trigger support.  Commands that do have
 * such support are passed down to ProcessUtilitySlow, which contains the
 * necessary infrastructure for such triggers.
 *
 * This division is not just for performance: it's critical that the
 * event trigger code not be invoked when doing START TRANSACTION for
 * example, because we might need to refresh the event trigger cache,
 * which requires being in a valid transaction.
 */</comment>
<function><type><name>void</name></type>
<name>standard_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
						<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
						<parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
						<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
						<parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isTopLevel</name> <init>= <expr><operator>(</operator><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isAtomicContext</name> <init>= <expr><operator>(</operator><operator>!</operator><operator>(</operator><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name> <operator>||</operator> <name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_QUERY_NONATOMIC</name><operator>)</operator> <operator>||</operator> <call><name>IsTransactionBlock</name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>readonly_flags</name></decl>;</decl_stmt>

	<comment type="block">/* This can recurse, so check for excessive recursion */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prohibit read/write commands in read-only states. */</comment>
	<expr_stmt><expr><name>readonly_flags</name> <operator>=</operator> <call><name>ClassifyUtilityCommandAsReadOnly</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>readonly_flags</name> <operator>!=</operator> <name>COMMAND_IS_STRICTLY_READ_ONLY</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>XactReadOnly</name> <operator>||</operator> <call><name>IsInParallelMode</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommandTag</name></type>	<name>commandtag</name> <init>= <expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>readonly_flags</name> <operator>&amp;</operator> <name>COMMAND_OK_IN_READ_ONLY_TXN</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><call><name>GetCommandTagName</name><argument_list>(<argument><expr><name>commandtag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>readonly_flags</name> <operator>&amp;</operator> <name>COMMAND_OK_IN_PARALLEL_MODE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><call><name>GetCommandTagName</name><argument_list>(<argument><expr><name>commandtag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>readonly_flags</name> <operator>&amp;</operator> <name>COMMAND_OK_IN_RECOVERY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><call><name>GetCommandTagName</name><argument_list>(<argument><expr><name>commandtag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_queryEnv</name></name> <operator>=</operator> <name>queryEnv</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * ******************** transactions ********************
			 */</comment>
		<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
						<comment type="block">/*
						 * START TRANSACTION, as defined by SQL99: Identical
						 * to BEGIN.  Same code for both.
						 */</comment>
					<case>case <expr><name>TRANS_STMT_BEGIN</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_START</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>BeginTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
							<block>{<block_content>
								<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

								<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>,
												  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
								<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>,
												  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
								<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>,
												  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							</block_content>}</block>
						</block_content>}</block>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EndTransactionBlock</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* report unsuccessful commit in qc */</comment>
							<if_stmt><if>if <condition>(<expr><name>qc</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><name>CMDTAG_ROLLBACK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_PREPARE</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PrepareTransactionBlock</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* report unsuccessful commit in qc */</comment>
							<if_stmt><if>if <condition>(<expr><name>qc</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><name>CMDTAG_ROLLBACK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT_PREPARED</name></expr>:</case>
						<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"COMMIT PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>FinishPreparedTransaction</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED</name></expr>:</case>
						<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>FinishPreparedTransaction</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK</name></expr>:</case>
						<expr_stmt><expr><call><name>UserAbortTransactionBlock</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>chain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_SAVEPOINT</name></expr>:</case>
						<expr_stmt><expr><call><name>RequireTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>DefineSavepoint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>savepoint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_RELEASE</name></expr>:</case>
						<expr_stmt><expr><call><name>RequireTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"RELEASE SAVEPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ReleaseSavepoint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>savepoint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK_TO</name></expr>:</case>
						<expr_stmt><expr><call><name>RequireTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>RollbackToSavepoint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>savepoint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * CommitTransactionCommand is in charge of
						 * re-defining the savepoint again
						 */</comment>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/*
			 * Portal (cursor) manipulation
			 */</comment>
		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>PerformCursorOpen</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
							  <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ClosePortalStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ClosePortalStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"CLOSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PerformPortalClose</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>PerformPortalFetch</name><argument_list>(<argument><expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DoStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecuteDoStmt</name><argument_list>(<argument><expr><operator>(</operator><name>DoStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isAtomicContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CreateTableSpace</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTableSpaceStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DropTableSpace</name><argument_list>(<argument><expr><operator>(</operator><name>DropTableSpaceStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterTableSpaceOptions</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTableSpaceOptionsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecuteTruncate</name><argument_list>(<argument><expr><operator>(</operator><name>TruncateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint64</name></type>		<name>processed</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>DoCopy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
					   <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>qc</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>qc</name></expr></argument>, <argument><expr><name>CMDTAG_COPY</name></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_PrepareStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"PREPARE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PrepareQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>PrepareStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
						 <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecuteQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name>params</name></expr></argument>,
						 <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"DEALLOCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DeallocateQuery</name><argument_list>(<argument><expr><operator>(</operator><name>DeallocateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>GrantRole</name><argument_list>(<argument><expr><operator>(</operator><name>GrantRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"CREATE DATABASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>createdb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreatedbStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterDatabase</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterDatabaseStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterDatabaseSet</name><argument_list>(<argument><expr><operator>(</operator><name>AlterDatabaseSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"DROP DATABASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DropDatabase</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>DropdbStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* Query-level asynchronous notification */</comment>
		<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NotifyStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>NotifyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Async_Notify</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ListenStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListenStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ListenStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"LISTEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We don't allow LISTEN in background processes, as there is
				 * no mechanism for them to collect NOTIFY messages, so they'd
				 * just block cleanout of the async SLRU indefinitely.
				 * (Authors of custom background workers could bypass this
				 * restriction by calling Async_Listen directly, but then it's
				 * on them to provide some mechanism to process the message
				 * queue.)  Note there seems no reason to forbid UNLISTEN.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>MyBackendType</name> <operator>!=</operator> <name>B_BACKEND</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<comment type="block">/* translator: %s is name of a SQL command, eg LISTEN */</comment>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s within a background process"</literal></expr></argument>,
									<argument><expr><literal type="string">"LISTEN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>Async_Listen</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>UnlistenStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>UnlistenStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"UNLISTEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Async_Unlisten</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Async_UnlistenAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_LoadStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>LoadStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>LoadStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>closeAllVfds</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* probably not necessary... */</comment>
				<comment type="block">/* Allowed names are restricted if you're not superuser */</comment>
				<expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecuteCallStmt</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>CallStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>isAtomicContext</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>cluster</name><argument_list>(<argument><expr><operator>(</operator><name>ClusterStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecVacuum</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>VacuumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ALTER SYSTEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AlterSystemSetConfigFile</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSystemStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSetVariableStmt</name><argument_list>(<argument><expr><operator>(</operator><name>VariableSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>VariableShowStmt</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>VariableShowStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GetPGVariable</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_DiscardStmt</name></expr>:</case>
			<comment type="block">/* should we allow DISCARD PLANS? */</comment>
			<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"DISCARD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DiscardCommand</name><argument_list>(<argument><expr><operator>(</operator><name>DiscardStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
			<comment type="block">/* no event triggers on event triggers */</comment>
			<expr_stmt><expr><call><name>CreateEventTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>CreateEventTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
			<comment type="block">/* no event triggers on event triggers */</comment>
			<expr_stmt><expr><call><name>AlterEventTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>AlterEventTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * ******************************** ROLE statements ****
			 */</comment>
		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>CreateRole</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterRole</name><argument_list>(<argument><expr><operator>(</operator><name>AlterRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterRoleSet</name><argument_list>(<argument><expr><operator>(</operator><name>AlterRoleSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>DropRole</name><argument_list>(<argument><expr><operator>(</operator><name>DropRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>ReassignOwnedObjects</name><argument_list>(<argument><expr><operator>(</operator><name>ReassignOwnedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockStmt</name></expr>:</case>

			<comment type="block">/*
			 * Since the lock would just get dropped immediately, LOCK TABLE
			 * outside a transaction block is presumed to be user error.
			 */</comment>
			<expr_stmt><expr><call><name>RequireTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"LOCK TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockTableCommand</name><argument_list>(<argument><expr><operator>(</operator><name>LockStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET CONSTRAINTS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AfterTriggerSetState</name><argument_list>(<argument><expr><operator>(</operator><name>ConstraintsSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to do CHECKPOINT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_IMMEDIATE</name> <operator>|</operator> <name>CHECKPOINT_WAIT</name> <operator>|</operator>
							  <operator>(</operator><ternary><condition><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>CHECKPOINT_FORCE</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ReindexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
											  <argument><expr><literal type="string">"REINDEX CONCURRENTLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>REINDEX_OBJECT_INDEX</name></expr>:</case>
						<expr_stmt><expr><call><name>ReindexIndex</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>REINDEX_OBJECT_TABLE</name></expr>:</case>
						<expr_stmt><expr><call><name>ReindexTable</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>REINDEX_OBJECT_SCHEMA</name></expr>:</case>
					<case>case <expr><name>REINDEX_OBJECT_SYSTEM</name></expr>:</case>
					<case>case <expr><name>REINDEX_OBJECT_DATABASE</name></expr>:</case>

						<comment type="block">/*
						 * This cannot run inside a user transaction block; if
						 * we were inside a transaction, then its commit- and
						 * start-transaction-command calls would not have the
						 * intended effect!
						 */</comment>
						<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
												  <argument><expr><ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_SCHEMA</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"REINDEX SCHEMA"</literal></expr> </then><else>:
												  <expr><ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_SYSTEM</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"REINDEX SYSTEM"</literal></expr> </then><else>:
												  <expr><literal type="string">"REINDEX DATABASE"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ReindexMultipleTables</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>REINDEX_OBJECT_VLABEL</name></expr>:</case>
						<expr_stmt><expr><call><name>ReindexLabel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>OBJECT_VLABEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>REINDEX_OBJECT_ELABEL</name></expr>:</case>
						<expr_stmt><expr><call><name>ReindexLabel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>OBJECT_ELABEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized object type: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/*
			 * The following statements are supported by Event Triggers only
			 * in some cases, so we "fast path" them in the other cases.
			 */</comment>

		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GrantStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecuteGrantStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DropStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecDropStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecRenameStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecAlterObjectDependsStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecAlterObjectSchemaStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecAlterOwnerStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CommentObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SecLabelStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>SecLabelStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecSecLabelStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_DisableIndexStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DisableIndexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DisableIndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>DisableIndexCommand</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<comment type="block">/* All other statement types have event trigger support */</comment>
			<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
							   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
							   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make effects of commands visible, for instance so that
	 * PreCommit_on_commit_actions() can see them (see for example bug
	 * #15631).
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The "Slow" variant of ProcessUtility should only receive statements
 * supported by the event triggers facility.  Therefore, we always
 * perform the trigger support calls if the context allows it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessUtilitySlow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
				   <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
				   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
				   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
				   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
				   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
				   <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>qc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isTopLevel</name> <init>= <expr><operator>(</operator><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isCompleteQuery</name> <init>= <expr><operator>(</operator><name>context</name> <operator>!=</operator> <name>PROCESS_UTILITY_SUBCOMMAND</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needCleanup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>commandCollected</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>secondaryObject</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* All event trigger calls are done only when isCompleteQuery is true */</comment>
	<expr_stmt><expr><name>needCleanup</name> <operator>=</operator> <name>isCompleteQuery</name> <operator>&amp;&amp;</operator> <call><name>EventTriggerBeginCompleteQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* PG_TRY block is to ensure we call EventTriggerEndCompleteQuery */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isCompleteQuery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>EventTriggerDDLCommandStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/*
				 * relation and attribute manipulation
				 */</comment>
			<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>CreateSchemaCommand</name><argument_list>(<argument><expr><operator>(</operator><name>CreateSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
									<argument><expr><name>queryString</name></expr></argument>,
									<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>,
									<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * EventTriggerCollectSimpleCommand called by
				 * CreateSchemaCommand
				 */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
			<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stmts</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>table_rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* Run parse analysis ... */</comment>
					<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>transformCreateStmt</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
												<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * ... and do it.  We can't use foreach() because we may
					 * modify the list midway through, so pick off the
					 * elements one at a time, the hard way.
					 */</comment>
					<while>while <condition>(<expr><name>stmts</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>cstmt</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Datum</name></type>		<name>toast_options</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>

							<comment type="block">/* Remember transformed RangeVar for LIKE */</comment>
							<expr_stmt><expr><name>table_rv</name> <operator>=</operator> <name><name>cstmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>CheckInheritLabel</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/* Create the table itself */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><name>cstmt</name></expr></argument>,
													 <argument><expr><name>RELKIND_RELATION</name></expr></argument>,
													 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
															 <argument><expr><name>secondaryObject</name></expr></argument>,
															 <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * Let NewRelationCreateToastTable decide if this
							 * one needs a secondary relation too.
							 */</comment>
							<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * parse and validate reloptions for the toast
							 * table
							 */</comment>
							<expr_stmt><expr><name>toast_options</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
																<argument><expr><name><name>cstmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
																<argument><expr><literal type="string">"toast"</literal></expr></argument>,
																<argument><expr><name>validnsps</name></expr></argument>,
																<argument><expr><name>true</name></expr></argument>,
																<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>,
												   <argument><expr><name>toast_options</name></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>NewRelationCreateToastTable</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>,
														<argument><expr><name>toast_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>CreateForeignTableStmt</name> <modifier>*</modifier></type><name>cstmt</name> <init>= <expr><operator>(</operator><name>CreateForeignTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>

							<comment type="block">/* Remember transformed RangeVar for LIKE */</comment>
							<expr_stmt><expr><name>table_rv</name> <operator>=</operator> <name><name>cstmt</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>relation</name></name></expr>;</expr_stmt>

							<comment type="block">/* Create the table itself */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstmt</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,
													 <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>,
													 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>CreateForeignTable</name><argument_list>(<argument><expr><name>cstmt</name></expr></argument>,
											   <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
															 <argument><expr><name>secondaryObject</name></expr></argument>,
															 <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>TableLikeClause</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Do delayed processing of LIKE options.  This
							 * will result in additional sub-statements for us
							 * to process.  Those should get done before any
							 * remaining actions, so prepend them to "stmts".
							 */</comment>
							<decl_stmt><decl><type><name>TableLikeClause</name> <modifier>*</modifier></type><name>like</name> <init>= <expr><operator>(</operator><name>TableLikeClause</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>morestmts</name></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>table_rv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><name>morestmts</name> <operator>=</operator> <call><name>expandTableLikeClause</name><argument_list>(<argument><expr><name>table_rv</name></expr></argument>, <argument><expr><name>like</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>morestmts</name></expr></argument>, <argument><expr><name>stmts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/*
							 * Recurse for anything else.  Note the recursive
							 * call will stash the objects so created into our
							 * event trigger context.
							 */</comment>
							<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>wrapper</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>wrapper</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>,
										   <argument><expr><name>queryString</name></expr></argument>,
										   <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
										   <argument><expr><name>params</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>None_Receiver</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>

						<comment type="block">/* Need CCI between commands */</comment>
						<if_stmt><if>if <condition>(<expr><name>stmts</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></while>

					<comment type="block">/*
					 * The multiple commands generated here are stashed
					 * individually, so disable collection below.
					 */</comment>
					<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_AlterLabelStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>atstmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_AlterLabelStmt</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>atstmt</name> <operator>=</operator> <call><name>transformAlterLabelStmt</name><argument_list>(
													<argument><expr><operator>(</operator><name>AlterLabelStmt</name> <operator>*</operator><operator>)</operator> <name>atstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>atstmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Figure out lock mode, and acquire lock.  This also does
					 * basic permissions checks, so that we won't wait for a
					 * lock on (for example) a relation on which we have no
					 * permissions.
					 */</comment>
					<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>atstmt</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>AlterTableUtilityContext</name></type> <name>atcontext</name></decl>;</decl_stmt>

						<comment type="block">/* Set up info needed for recursive callbacks ... */</comment>
						<expr_stmt><expr><name><name>atcontext</name><operator>.</operator><name>pstmt</name></name> <operator>=</operator> <name>pstmt</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>atcontext</name><operator>.</operator><name>queryString</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>atcontext</name><operator>.</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>atcontext</name><operator>.</operator><name>params</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>atcontext</name><operator>.</operator><name>queryEnv</name></name> <operator>=</operator> <name>queryEnv</name></expr>;</expr_stmt>

						<comment type="block">/* ... ensure we have an event trigger context ... */</comment>
						<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>EventTriggerAlterTableRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* ... and do it */</comment>
						<expr_stmt><expr><call><name>AlterTable</name><argument_list>(<argument><expr><name>atstmt</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>atcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* done */</comment>
						<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
										<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>

				<comment type="block">/* ALTER TABLE stashes commands internally */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>AlterDomainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterDomainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Some or all of these functions are recursive to cover
					 * inherited things, so permission checks are done there.
					 */</comment>
					<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><literal type="char">'T'</literal></expr>:</case>	<comment type="block">/* ALTER DOMAIN DEFAULT */</comment>

							<comment type="block">/*
							 * Recursively alter column default for table and,
							 * if requested, for descendants
							 */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainDefault</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
												   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'N'</literal></expr>:</case>	<comment type="block">/* ALTER DOMAIN DROP NOT NULL */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainNotNull</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'O'</literal></expr>:</case>	<comment type="block">/* ALTER DOMAIN SET NOT NULL */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainNotNull</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'C'</literal></expr>:</case>	<comment type="block">/* ADD CONSTRAINT */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainAddConstraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
														 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'X'</literal></expr>:</case>	<comment type="block">/* DROP CONSTRAINT */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainDropConstraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
														  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
														  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
														  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'V'</literal></expr>:</case>	<comment type="block">/* VALIDATE CONSTRAINT */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainValidateConstraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
															  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>	<comment type="block">/* oops */</comment>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter domain type: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block>
				<break>break;</break>

				<comment type="block">/*
				 * ************* object creation / destruction **************
				 */</comment>
			<case>case <expr><name>T_DefineStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefineStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DefineStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

					<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>DefineAggregate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
												<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldstyle</name></name></expr></argument>,
												<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>,
												<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineOperator</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
													 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineType</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
												 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSParser</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
													 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSDictionary</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
														 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSTemplate</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
													   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSConfiguration</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
															<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineCollation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
													  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>,
													  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized define stmt type: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_IndexStmt</name></expr>:</case>	<comment type="block">/* CREATE INDEX */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>is_alter_table</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
												  <argument><expr><literal type="string">"CREATE INDEX CONCURRENTLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Look up the relation OID just once, right here at the
					 * beginning, so that we don't end up repeating the name
					 * lookup later and latching onto a different relation
					 * partway through.  To avoid lock upgrade hazards, it's
					 * important that we take the strongest lock that will
					 * eventually be needed here, so the lockmode calculation
					 * needs to match what DefineIndex() does.
					 */</comment>
					<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr>
						</then><else>: <expr><name>ShareLock</name></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><name>relid</name> <operator>=</operator>
						<call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
												 <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><name>RangeVarCallbackOwnsRelation</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * CREATE INDEX on partitioned tables (but not regular
					 * inherited tables) recurses to partitions, so we must
					 * acquire locks early to avoid deadlocks.
					 *
					 * We also take the opportunity to verify that all
					 * partitions are something we can put an index on, to
					 * avoid building some indexes only to fail later.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator>
						<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inheritors</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>inheritors</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>inheritors</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
								<name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
								<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
								<name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected relkind \"%c\" on partition \"%s\""</literal></expr></argument>,
									 <argument><expr><name>relkind</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
								<operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create unique index on partitioned table \"%s\""</literal></expr></argument>,
												<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" contains partitions that are foreign tables."</literal></expr></argument>,
												   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block>
						<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>inheritors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If the IndexStmt is already transformed, it must have
					 * come from generateClonedIndexStmt, which in current
					 * usage means it came from expandTableLikeClause rather
					 * than from original parse analysis.  And that means we
					 * must treat it like ALTER TABLE ADD INDEX, not CREATE.
					 * (This is a bit grotty, but currently it doesn't seem
					 * worth adding a separate bool field for the purpose.)
					 */</comment>
					<expr_stmt><expr><name>is_alter_table</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>transformed</name></name></expr>;</expr_stmt>

					<comment type="block">/* Run parse analysis ... */</comment>
					<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* ... and do it */</comment>
					<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>address</name> <operator>=</operator>
						<call><name>DefineIndex</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,	<comment type="block">/* OID of heap relation */</comment>
									<argument><expr><name>stmt</name></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no predefined OID */</comment>
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent index */</comment>
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent constraint */</comment>
									<argument><expr><name>is_alter_table</name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>,	<comment type="block">/* check_rights */</comment>
									<argument><expr><name>true</name></expr></argument>,	<comment type="block">/* check_not_in_use */</comment>
									<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* skip_build */</comment>
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* quiet */</comment>

					<comment type="block">/*
					 * Add the CREATE INDEX node itself to stash right away;
					 * if there were any commands stashed in the ALTER TABLE
					 * code, we need them to appear after this one.
					 */</comment>
					<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
													 <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateExtension</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecAlterExtensionStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecAlterExtensionContentsStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterExtensionContentsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateForeignDataWrapper</name><argument_list>(<argument><expr><operator>(</operator><name>CreateFdwStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterForeignDataWrapper</name><argument_list>(<argument><expr><operator>(</operator><name>AlterFdwStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateForeignServer</name><argument_list>(<argument><expr><operator>(</operator><name>CreateForeignServerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterForeignServer</name><argument_list>(<argument><expr><operator>(</operator><name>AlterForeignServerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateUserMapping</name><argument_list>(<argument><expr><operator>(</operator><name>CreateUserMappingStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterUserMapping</name><argument_list>(<argument><expr><operator>(</operator><name>AlterUserMappingStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>RemoveUserMapping</name><argument_list>(<argument><expr><operator>(</operator><name>DropUserMappingStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no commands stashed for DROP */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>ImportForeignSchema</name><argument_list>(<argument><expr><operator>(</operator><name>ImportForeignSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* commands are stashed inside ImportForeignSchema */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>	<comment type="block">/* CREATE TYPE (composite) */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CompositeTypeStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CompositeTypeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineCompositeType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typevar</name></name></expr></argument>,
												  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>	<comment type="block">/* CREATE TYPE AS ENUM */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineEnum</name><argument_list>(<argument><expr><operator>(</operator><name>CreateEnumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case> <comment type="block">/* CREATE TYPE AS RANGE */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRange</name><argument_list>(<argument><expr><operator>(</operator><name>CreateRangeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>	<comment type="block">/* ALTER TYPE (enum) */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterEnum</name><argument_list>(<argument><expr><operator>(</operator><name>AlterEnumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ViewStmt</name></expr>:</case>	<comment type="block">/* CREATE VIEW */</comment>
				<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineView</name><argument_list>(<argument><expr><operator>(</operator><name>ViewStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									 <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
												 <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* stashed internally */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>	<comment type="block">/* CREATE FUNCTION */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>	<comment type="block">/* ALTER FUNCTION */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_RuleStmt</name></expr>:</case>	<comment type="block">/* CREATE RULE */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRule</name><argument_list>(<argument><expr><operator>(</operator><name>RuleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineSequence</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterSequence</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecCreateTableAs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
											<argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>

				<comment type="block">/*
				 * REFRESH CONCURRENTLY executes some DDL commands internally.
				 * Inhibit DDL command collection here to avoid those commands
				 * from showing up in the deparsed command queue.  The refresh
				 * command itself is queued, which is enough.
				 */</comment>
				<expr_stmt><expr><call><name>EventTriggerInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecRefreshMatView</name><argument_list>(<argument><expr><operator>(</operator><name>RefreshMatViewStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
												 <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<expr_stmt><expr><call><name>EventTriggerUndoInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
										<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateProceduralLanguage</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePLangStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineDomain</name><argument_list>(<argument><expr><operator>(</operator><name>CreateDomainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateConversionCommand</name><argument_list>(<argument><expr><operator>(</operator><name>CreateConversionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateCast</name><argument_list>(<argument><expr><operator>(</operator><name>CreateCastStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>DefineOpClass</name><argument_list>(<argument><expr><operator>(</operator><name>CreateOpClassStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* command is stashed in DefineOpClass */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineOpFamily</name><argument_list>(<argument><expr><operator>(</operator><name>CreateOpFamilyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * DefineOpFamily calls EventTriggerCollectSimpleCommand
				 * directly.
				 */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateTransform</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTransformStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>AlterOpFamily</name><argument_list>(<argument><expr><operator>(</operator><name>AlterOpFamilyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* commands are stashed in AlterOpFamily */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterTSDictionary</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTSDictionaryStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>AlterTSConfiguration</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTSConfigurationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Commands are stashed in MakeConfigurationMapping and
				 * DropConfigurationMapping, which are called from
				 * AlterTSConfiguration
				 */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>AlterTableMoveAll</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTableMoveAllStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* commands are stashed in AlterTableMoveAll */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>ExecDropStmt</name><argument_list>(<argument><expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no commands stashed for DROP */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_RenameStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecRenameStmt</name><argument_list>(<argument><expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator>
					<call><name>ExecAlterObjectDependsStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator>
					<call><name>ExecAlterObjectSchemaStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecAlterOwnerStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterOperator</name><argument_list>(<argument><expr><operator>(</operator><name>AlterOperatorStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTypeStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterType</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTypeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CommentStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CommentObject</name><argument_list>(<argument><expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_GrantStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>ExecuteGrantStmt</name><argument_list>(<argument><expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* commands are stashed in ExecGrantStmt_oids */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>DropOwnedObjects</name><argument_list>(<argument><expr><operator>(</operator><name>DropOwnedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no commands stashed for DROP */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>ExecAlterDefaultPrivilegesStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterDefaultPrivilegesStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EventTriggerCollectAlterDefPrivs</name><argument_list>(<argument><expr><operator>(</operator><name>AlterDefaultPrivilegesStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>	<comment type="block">/* CREATE POLICY */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreatePolicy</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePolicyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case> <comment type="block">/* ALTER POLICY */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterPolicy</name><argument_list>(<argument><expr><operator>(</operator><name>AlterPolicyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecSecLabelStmt</name><argument_list>(<argument><expr><operator>(</operator><name>SecLabelStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateAccessMethod</name><argument_list>(<argument><expr><operator>(</operator><name>CreateAmStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateGraphStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>CreateGraphCommand</name><argument_list>(<argument><expr><operator>(</operator><name>CreateGraphStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateLabelStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>CreateLabelCommand</name><argument_list>(<argument><expr><operator>(</operator><name>CreateLabelStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
								   <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>,
								   <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* stashed internally */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateConstraintStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>CreateConstraintCommand</name><argument_list>(<argument><expr><operator>(</operator><name>CreateConstraintStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
										<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>,
										<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropConstraintStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>DropConstraintCommand</name><argument_list>(<argument><expr><operator>(</operator><name>DropConstraintStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
									  <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>,
									  <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<comment type="block">/* see above case T_IndexStmt */</comment>
			<case>case <expr><name>T_CreatePropertyIndexStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreatePropertyIndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>idxstmt</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>stmt</name> <operator>=</operator> <operator>(</operator><name>CreatePropertyIndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
												  <argument><expr><literal type="string">"CREATE PROPERTY INDEX CONCURRENTLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Parser prevent to input graph name for label. */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RangeVarIsLabel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"label \"%s\" does not exist"</literal></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Look up the relation OID just once, right here at the
					 * beginning, so that we don't end up repeating the name
					 * lookup later and latching onto a different relation
					 * partway through.  To avoid lock upgrade hazards, it's
					 * important that we take the strongest lock that will
					 * eventually be needed here, so the lockmode calculation
					 * needs to match what DefineIndex() does.
					 */</comment>
					<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr>
												</then><else>: <expr><name>ShareLock</name></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><name>relid</name> <operator>=</operator>
						<call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
												 <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><name>RangeVarCallbackOwnsRelation</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Run parse analysis ... */</comment>
					<expr_stmt><expr><name>idxstmt</name> <operator>=</operator> <call><name>transformCreatePropertyIndexStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>,
															   <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* ... and do it */</comment>
					<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>address</name> <operator>=</operator>
						<call><name>DefineIndex</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,		<comment type="block">/* OID of heap relation */</comment>
									<argument><expr><name>idxstmt</name></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no predefined OID */</comment>
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent index */</comment>
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent constraint */</comment>
									<argument><expr><name>false</name></expr></argument>,		<comment type="block">/* is_alter_table */</comment>
									<argument><expr><name>true</name></expr></argument>,		<comment type="block">/* check_rights */</comment>
									<argument><expr><name>true</name></expr></argument>,		<comment type="block">/* check_not_in_use */</comment>
									<argument><expr><name>false</name></expr></argument>,		<comment type="block">/* skip_build */</comment>
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* quiet */</comment>

					<comment type="block">/*
					 * Add the CREATE INDEX node itself to stash right away;
					 * if there were any commands stashed in the ALTER TABLE
					 * code, we need them to appear after this one.
					 */</comment>
					<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
													 <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreatePublication</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePublicationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>AlterPublication</name><argument_list>(<argument><expr><operator>(</operator><name>AlterPublicationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * AlterPublication calls EventTriggerCollectSimpleCommand
				 * directly
				 */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
											 <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>DropSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>DropSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no commands stashed for DROP */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateStatistics</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStatsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterStatsStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterStatistics</name><argument_list>(<argument><expr><operator>(</operator><name>AlterStatsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterCollation</name><argument_list>(<argument><expr><operator>(</operator><name>AlterCollationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Remember the object so that ddl_command_end event triggers have
		 * access to it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commandCollected</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
											 <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isCompleteQuery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EventTriggerSQLDrop</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EventTriggerDDLCommandEnd</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needCleanup</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>EventTriggerEndCompleteQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessUtilityForAlterTable
 *		Recursive entry from ALTER TABLE
 *
 * ALTER TABLE sometimes generates subcommands such as CREATE INDEX.
 * It calls this, not the main entry point ProcessUtility, to execute
 * such subcommands.
 *
 * stmt: the utility command to execute
 * context: opaque passthrough struct with the info we need
 *
 * It's caller's responsibility to do CommandCounterIncrement after
 * calling this, if needed.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessUtilityForAlterTable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>AlterTableUtilityContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>wrapper</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For event triggers, we must "close" the current complex-command set,
	 * and start a new one afterwards; this is needed to ensure the ordering
	 * of command events is consistent with the way they were executed.
	 */</comment>
	<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a suitable wrapper */</comment>
	<expr_stmt><expr><name>wrapper</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>,
				   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>queryString</name></name></expr></argument>,
				   <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
				   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
				   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>queryEnv</name></name></expr></argument>,
				   <argument><expr><name>None_Receiver</name></expr></argument>,
				   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EventTriggerAlterTableRelid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dispatch function for DropStmt
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecDropStmt</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_PROPERTY_INDEX</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>graphname</name> <init>= <expr><call><name>get_graph_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* set graph path */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>object</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>graphname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper property index name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<comment type="block">/* fail through */</comment>

		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
										  <argument><expr><literal type="string">"DROP INDEX CONCURRENTLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* fall through */</comment>

		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>RemoveRelations</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>RemoveObjects</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * UtilityReturnsTuples
 *		Return "true" if this utility statement will send output to the
 *		destination.
 *
 * Generally, there should be a case here for each case in ProcessUtility
 * where "dest" is passed on.
 */</comment>
<function><type><name>bool</name></type>
<name>UtilityReturnsTuples</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CallStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CallStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>funcexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>==</operator> <name>RECORDOID</name><operator>)</operator></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not our business to raise error */</comment>
				<return>return <expr><ternary><condition><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not our business to raise error */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * UtilityTupleDescriptor
 *		Fetch the actual output tuple descriptor for a utility statement
 *		for which UtilityReturnsTuples() previously returned "true".
 *
 * The returned descriptor is created in (or copied into) the current memory
 * context.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>UtilityTupleDescriptor</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<return>return <expr><call><name>CallStmtResultDesc</name><argument_list>(<argument><expr><operator>(</operator><name>CallStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not our business to raise error */</comment>
				<return>return <expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not our business to raise error */</comment>
				<return>return <expr><call><name>FetchPreparedStatementResultDesc</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<return>return <expr><call><name>ExplainResultDesc</name><argument_list>(<argument><expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>VariableShowStmt</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>VariableShowStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><call><name>GetPGVariableResultDesc</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>

		<default>default:</default>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * QueryReturnsTuples
 *		Return "true" if this Query will send output to the destination.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>bool</name></type>
<name>QueryReturnsTuples</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>
			<comment type="block">/* returns tuples */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<comment type="block">/* the forms with RETURNING return tuples */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
			<return>return <expr><call><name>UtilityReturnsTuples</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>CMD_UNKNOWN</name></expr>:</case>
		<case>case <expr><name>CMD_NOTHING</name></expr>:</case>
			<comment type="block">/* probably shouldn't get here */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* default */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * UtilityContainsQuery
 *		Return the contained Query, or NULL if there is none
 *
 * Certain utility statements, such as EXPLAIN, contain a plannable Query.
 * This function encapsulates knowledge of exactly which ones do.
 * We assume it is invoked only on already-parse-analyzed statements
 * (else the contained parsetree isn't a Query yet).
 *
 * In some cases (currently, only EXPLAIN of CREATE TABLE AS/SELECT INTO and
 * CREATE MATERIALIZED VIEW), potentially Query-containing utility statements
 * can be nested.  This function will drill down to a non-utility Query, or
 * return NULL if none.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>UtilityContainsQuery</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>qry</name></expr>;</return>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>qry</name></expr>;</return>

		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>qry</name></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * AlterObjectTypeCommandTag
 *		helper function for CreateCommandTag
 *
 * This covers most cases where ALTER is used with an ObjectType enum.
 */</comment>
<function><type><specifier>static</specifier> <name>CommandTag</name></type>
<name>AlterObjectTypeCommandTag</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandTag</name></type>	<name>tag</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_AGGREGATE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_CAST</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_CAST</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_COLLATION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_CONVERSION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_DATABASE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
		<case>case <expr><name>OBJECT_DOMCONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_DOMAIN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_EXTENSION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_FOREIGN_DATA_WRAPPER</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_SERVER</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_FOREIGN_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_FUNCTION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_LANGUAGE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_LARGE_OBJECT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_OPERATOR_CLASS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_OPERATOR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_OPERATOR_FAMILY</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_POLICY</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_PROCEDURE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_PROPERTY_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_PROPERTY_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_ROLE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_ROUTINE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_RULE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_SCHEMA</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_SEQUENCE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TABLESPACE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TRIGGER</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_EVENT_TRIGGER</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TEXT_SEARCH_CONFIGURATION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TEXT_SEARCH_DICTIONARY</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TEXT_SEARCH_PARSER</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TEXT_SEARCH_TEMPLATE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_VIEW</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_MATERIALIZED_VIEW</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_PUBLICATION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_SUBSCRIPTION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_STATISTICS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_GRAPH</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_GRAPH</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_VLABEL</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_VLABEL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ELABEL</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_ELABEL</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>tag</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateCommandTag
 *		utility to get a CommandTag for the command operation,
 *		given either a raw (un-analyzed) parsetree, an analyzed Query,
 *		or a PlannedStmt.
 *
 * This must handle all command types, but since the vast majority
 * of 'em are utility commands, it seems sensible to keep it here.
 */</comment>
<function><type><name>CommandTag</name></type>
<name>CreateCommandTag</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandTag</name></type>	<name>tag</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* recurse if we're given a RawStmt */</comment>
		<case>case <expr><name>T_RawStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* raw plannable queries */</comment>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_INSERT</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DELETE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UPDATE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CypherStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CYPHER</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* utility statements --- same whether raw or cooked */</comment>
		<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>TRANS_STMT_BEGIN</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_BEGIN</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_START</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_START_TRANSACTION</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_COMMIT</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_ROLLBACK_TO</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ROLLBACK</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_SAVEPOINT</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SAVEPOINT</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_RELEASE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_RELEASE</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_PREPARE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_PREPARE_TRANSACTION</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT_PREPARED</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_COMMIT_PREPARED</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ROLLBACK_PREPARED</name></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DECLARE_CURSOR</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ClosePortalStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ClosePortalStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CLOSE_CURSOR_ALL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CLOSE_CURSOR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>CMDTAG_MOVE</name></expr> </then><else>: <expr><name>CMDTAG_FETCH</name></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_DOMAIN</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_SCHEMA</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateGraphStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_GRAPH</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateLabelStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CreateLabelStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CreateLabelStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>labelKind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>LABEL_VERTEX</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_VLABEL</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>LABEL_EDGE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_ELABEL</name></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CreateConstraintStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_CONSTRAINT</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropConstraintStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_CONSTRAINT</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterLabelStmt</name></expr>:</case>
			<block>{<block_content>
				<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>AlterLabelStmt</name><operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>OBJECT_VLABEL</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_VLABEL</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_ELABEL</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_ELABEL</name></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CreatePropertyIndexStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_PROPERTY_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TABLESPACE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_TABLESPACE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TABLESPACE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_EXTENSION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_EXTENSION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_EXTENSION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_FOREIGN_DATA_WRAPPER</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_FOREIGN_DATA_WRAPPER</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_SERVER</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_SERVER</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_USER_MAPPING</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_USER_MAPPING</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_USER_MAPPING</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_FOREIGN_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_IMPORT_FOREIGN_SCHEMA</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>removeType</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_TABLE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_SEQUENCE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_VIEW</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_MATERIALIZED_VIEW</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_INDEX</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_PROPERTY_INDEX</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_PROPERTY_INDEX</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_TYPE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_DOMAIN</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_COLLATION</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_CONVERSION</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_SCHEMA</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_TEXT_SEARCH_PARSER</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_TEXT_SEARCH_DICTIONARY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_TEXT_SEARCH_TEMPLATE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_TEXT_SEARCH_CONFIGURATION</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_FOREIGN_TABLE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_EXTENSION</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_FUNCTION</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_PROCEDURE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_ROUTINE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_AGGREGATE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_OPERATOR</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_LANGUAGE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_CAST</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_CAST</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_TRIGGER</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_EVENT_TRIGGER</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_RULE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_FOREIGN_DATA_WRAPPER</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_SERVER</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_OPERATOR_CLASS</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_OPERATOR_FAMILY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_POLICY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TRANSFORM</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_TRANSFORM</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_ACCESS_METHOD</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_PUBLICATION</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_STATISTICS</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_GRAPH</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_GRAPH</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_ELABEL</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_ELABEL</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_VLABEL</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_VLABEL</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_TRUNCATE_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_COMMENT</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SECURITY_LABEL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_COPY</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RenameStmt</name></expr>:</case>

			<comment type="block">/*
			 * When the column is renamed, the command tag is created from its
			 * relation type
			 */</comment>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>renameType</name> <operator>==</operator> <name>OBJECT_COLUMN</name></expr> ?</condition><then>
											<expr><operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>relationType</name></expr> </then><else>:
											<expr><operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>renameType</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterTableMoveAllStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_DOMAIN</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>AlterFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objtype</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_FUNCTION</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_PROCEDURE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_ROUTINE</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GrantStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>CMDTAG_GRANT</name></expr> </then><else>: <expr><name>CMDTAG_REVOKE</name></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GrantRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>CMDTAG_GRANT_ROLE</name></expr> </then><else>: <expr><name>CMDTAG_REVOKE_ROLE</name></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_DEFAULT_PRIVILEGES</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DefineStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>DefineStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>kind</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_AGGREGATE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_OPERATOR</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TYPE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TEXT_SEARCH_PARSER</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TEXT_SEARCH_DICTIONARY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TEXT_SEARCH_TEMPLATE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TEXT_SEARCH_CONFIGURATION</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_COLLATION</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_ACCESS_METHOD</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_VIEW</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CreateFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_PROCEDURE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_FUNCTION</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RuleStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_RULE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_SEQUENCE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_SEQUENCE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DoStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DO</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_DATABASE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_DATABASE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_DATABASE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_DATABASE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_NOTIFY</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ListenStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_LISTEN</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNLISTEN</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LoadStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_LOAD</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CLUSTER</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>VacuumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_vacuumcmd</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_VACUUM</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ANALYZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_EXPLAIN</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_select_into</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT_INTO</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TABLE_AS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_MATERIALIZED_VIEW</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_REFRESH_MATERIALIZED_VIEW</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_SYSTEM</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>VariableSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>kind</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
				<case>case <expr><name>VAR_SET_CURRENT</name></expr>:</case>
				<case>case <expr><name>VAR_SET_DEFAULT</name></expr>:</case>
				<case>case <expr><name>VAR_SET_MULTI</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SET</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>VAR_RESET</name></expr>:</case>
				<case>case <expr><name>VAR_RESET_ALL</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_RESET</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SHOW</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DiscardStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>DiscardStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>target</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>DISCARD_ALL</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DISCARD_ALL</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>DISCARD_PLANS</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DISCARD_PLANS</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>DISCARD_TEMP</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DISCARD_TEMP</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>DISCARD_SEQUENCES</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DISCARD_SEQUENCES</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TRANSFORM</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_TRIGGER</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_EVENT_TRIGGER</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_EVENT_TRIGGER</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_LANGUAGE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_ROLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_ROLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_ROLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_ROLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_OWNED</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_REASSIGN_OWNED</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_LOCK_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SET_CONSTRAINTS</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CHECKPOINT</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_REINDEX</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_CONVERSION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_CAST</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_OPERATOR_CLASS</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_OPERATOR_FAMILY</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_OPERATOR_FAMILY</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_OPERATOR</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTypeStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TEXT_SEARCH_DICTIONARY</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_TEXT_SEARCH_CONFIGURATION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_POLICY</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_POLICY</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_ACCESS_METHOD</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_PUBLICATION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_PUBLICATION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_SUBSCRIPTION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_SUBSCRIPTION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DROP_SUBSCRIPTION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_COLLATION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_PrepareStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_PREPARE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_EXECUTE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_CREATE_STATISTICS</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterStatsStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_ALTER_STATISTICS</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DeallocateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DeallocateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DEALLOCATE_ALL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DEALLOCATE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/* already-planned queries */</comment>
		<case>case <expr><name>T_PlannedStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CMD_SELECT</name></expr>:</case>

						<comment type="block">/*
						 * We take a little extra care here so that the result
						 * will be useful for complaints about read-only
						 * statements
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* not 100% but probably close enough */</comment>
							<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr>)</condition>
							<block>{<block_content>
								<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT_FOR_KEY_SHARE</name></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT_FOR_SHARE</name></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT_FOR_NO_KEY_UPDATE</name></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT_FOR_UPDATE</name></expr>;</expr_stmt>
									<break>break;</break>
								<default>default:</default>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT</name></expr>;</expr_stmt>
									<break>break;</break>
							</block_content>}</block></switch>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UPDATE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_INSERT</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_INSERT</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_DELETE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DELETE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/* parsed-and-rewritten-but-not-planned queries */</comment>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CMD_SELECT</name></expr>:</case>

						<comment type="block">/*
						 * We take a little extra care here so that the result
						 * will be useful for complaints about read-only
						 * statements
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* not 100% but probably close enough */</comment>
							<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr>)</condition>
							<block>{<block_content>
								<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT_FOR_KEY_SHARE</name></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT_FOR_SHARE</name></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT_FOR_NO_KEY_UPDATE</name></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT_FOR_UPDATE</name></expr>;</expr_stmt>
									<break>break;</break>
								<default>default:</default>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
									<break>break;</break>
							</block_content>}</block></switch>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_SELECT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UPDATE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_INSERT</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_INSERT</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_DELETE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_DELETE</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>CMDTAG_UNKNOWN</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>tag</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetCommandLogLevel
 *		utility to get the minimum log_statement level for a command,
 *		given either a raw (un-analyzed) parsetree, an analyzed Query,
 *		or a PlannedStmt.
 *
 * This must handle all command types, but since the vast majority
 * of 'em are utility commands, it seems sensible to keep it here.
 */</comment>
<function><type><name>LogStmtLevel</name></type>
<name>GetCommandLogLevel</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogStmtLevel</name></type> <name>lev</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* recurse if we're given a RawStmt */</comment>
		<case>case <expr><name>T_RawStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* raw plannable queries */</comment>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>intoClause</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* SELECT INTO */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CypherStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* utility statements --- same whether raw or cooked */</comment>
		<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateGraphStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateLabelStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterLabelStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateConstraintStmt</name></expr>:</case>
		<case>case <expr><name>T_DropConstraintStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePropertyIndexStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_PrepareStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PrepareStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PrepareStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Look through a PREPARE to the contained stmt */</comment>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>

				<comment type="block">/* Look through an EXECUTE to the referenced stmt */</comment>
				<expr_stmt><expr><name>ps</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ps</name> <operator>&amp;&amp;</operator> <name><name>ps</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTypeStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DefineStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RuleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DoStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ListenStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LoadStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>analyze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/* Look through an EXPLAIN ANALYZE to the contained stmt */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>analyze</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* don't "break", as explain.c will use the last value */</comment>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>analyze</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Plain EXPLAIN isn't so interesting */</comment>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DiscardStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>	<comment type="block">/* should this be DDL? */</comment>
			<break>break;</break>

		<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterStatsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* already-planned queries */</comment>
		<case>case <expr><name>T_PlannedStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CMD_SELECT</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<case>case <expr><name>CMD_DELETE</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/* parsed-and-rewritten-but-not-planned queries */</comment>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CMD_SELECT</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<case>case <expr><name>CMD_DELETE</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>

			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>lev</name></expr>;</return>
</block_content>}</block></function>
</unit>
