<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/partitioning/partbounds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * partbounds.c
 *		Support routines for manipulating partition bounds
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *		  src/backend/partitioning/partbounds.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * When qsort'ing partition bounds after reading from the catalog, each bound
 * is represented with one of the following structs.
 */</comment>

<comment type="block">/* One bound of a hash partition */</comment>
<typedef>typedef <type><struct>struct <name>PartitionHashBound</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>modulus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
}</block></struct></type> <name>PartitionHashBound</name>;</typedef>

<comment type="block">/* One value coming from some (index'th) list partition */</comment>
<typedef>typedef <type><struct>struct <name>PartitionListValue</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>PartitionListValue</name>;</typedef>

<comment type="block">/* One bound of a range partition */</comment>
<typedef>typedef <type><struct>struct <name>PartitionRangeBound</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>datums</name></decl>;</decl_stmt>			<comment type="block">/* range bound datums */</comment>
	<decl_stmt><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind</name></decl>;</decl_stmt>	<comment type="block">/* the kind of each datum */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lower</name></decl>;</decl_stmt>			<comment type="block">/* this is the lower (vs upper) bound */</comment>
}</block></struct></type> <name>PartitionRangeBound</name>;</typedef>

<comment type="block">/*
 * Mapping from partitions of a joining relation to partitions of a join
 * relation being computed (a.k.a merged partitions)
 */</comment>
<typedef>typedef <type><struct>struct <name>PartitionMap</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name></decl>;</decl_stmt>			<comment type="block">/* number of partitions */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>merged_indexes</name></decl>;</decl_stmt> <comment type="block">/* indexes of merged partitions */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>merged</name></decl>;</decl_stmt>			<comment type="block">/* flags to indicate whether partitions are
								 * merged with non-dummy partitions */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>did_remapping</name></decl>;</decl_stmt>	<comment type="block">/* did we re-map partitions? */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>old_indexes</name></decl>;</decl_stmt>	<comment type="block">/* old indexes of merged partitions if
								 * did_remapping */</comment>
}</block></struct></type> <name>PartitionMap</name>;</typedef>

<comment type="block">/* Macro for comparing two range bounds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compare_range_bounds</name><parameter_list>(<parameter><type><name>partnatts</name></type></parameter>, <parameter><type><name>partsupfunc</name></type></parameter>, <parameter><type><name>partcollations</name></type></parameter>, \
							 <parameter><type><name>bound1</name></type></parameter>, <parameter><type><name>bound2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(partition_rbound_cmp(partnatts, partsupfunc, partcollations, \
						  (bound1)-&gt;datums, (bound1)-&gt;kind, (bound1)-&gt;lower, \
						  bound2))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>qsort_partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>qsort_partition_list_value_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
											<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>qsort_partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
										<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type> <name>create_hash_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier><modifier>*</modifier></type><name>boundspecs</name></decl></parameter>,
											 <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>, <parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapping</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type> <name>create_list_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier><modifier>*</modifier></type><name>boundspecs</name></decl></parameter>,
											 <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>, <parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapping</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type> <name>create_range_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier><modifier>*</modifier></type><name>boundspecs</name></decl></parameter>,
											  <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>, <parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapping</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type> <name>merge_list_bounds</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
											<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>,
											<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
											<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
											<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>outer_parts</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>inner_parts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type> <name>merge_range_bounds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>,
											 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfuncs</name></decl></parameter>,
											 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollations</name></decl></parameter>,
											 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
											 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
											 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>outer_parts</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>inner_parts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_partition_map</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_partition_map</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_dummy_partition</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>part_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>merge_matching_partitions</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
									  <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>outer_part</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>inner_part</name></decl></parameter>,
									  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>process_outer_partition</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
									<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>outer_has_default</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>inner_has_default</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>outer_index</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>inner_default</name></decl></parameter>,
									<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
									<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>,
									<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>default_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>process_inner_partition</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
									<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>outer_has_default</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>inner_has_default</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>inner_index</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>outer_default</name></decl></parameter>,
									<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
									<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>,
									<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>default_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>merge_null_partitions</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
								  <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>outer_has_null</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>inner_has_null</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>outer_null</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>inner_null</name></decl></parameter>,
								  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
								  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>,
								  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>null_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>merge_default_partitions</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
									 <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>outer_has_default</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>inner_has_default</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>outer_default</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>inner_default</name></decl></parameter>,
									 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
									 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>,
									 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>default_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>merge_partition_with_dummy</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>,
									   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fix_merged_indexes</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
							   <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>nmerged</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merged_indexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_matching_part_pairs</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
										 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
										 <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
										 <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>nmerged</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>outer_parts</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>inner_parts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type> <name>build_merged_partition_bounds</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>strategy</name></decl></parameter>,
														<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merged_datums</name></decl></parameter>,
														<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merged_kinds</name></decl></parameter>,
														<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merged_indexes</name></decl></parameter>,
														<parameter><decl><type><name>int</name></type> <name>null_index</name></decl></parameter>,
														<parameter><decl><type><name>int</name></type> <name>default_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>get_range_partition</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>bi</name></decl></parameter>,
								<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb_pos</name></decl></parameter>,
								<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
								<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>ub</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>get_range_partition_internal</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>bi</name></decl></parameter>,
										 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb_pos</name></decl></parameter>,
										 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
										 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>ub</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>compare_range_partitions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfuncs</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollations</name></decl></parameter>,
									 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>outer_lb</name></decl></parameter>,
									 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>outer_ub</name></decl></parameter>,
									 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>inner_lb</name></decl></parameter>,
									 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>inner_ub</name></decl></parameter>,
									 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb_cmpval</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ub_cmpval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_merged_range_bounds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfuncs</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollations</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
									<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>outer_lb</name></decl></parameter>,
									<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>outer_ub</name></decl></parameter>,
									<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>inner_lb</name></decl></parameter>,
									<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>inner_ub</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>lb_cmpval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ub_cmpval</name></decl></parameter>,
									<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>merged_lb</name></decl></parameter>,
									<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>merged_ub</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_merged_range_bounds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfuncs</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollations</name></decl></parameter>,
									<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>merged_lb</name></decl></parameter>,
									<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>merged_ub</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>merged_index</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>merged_datums</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>merged_kinds</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>merged_indexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionRangeBound</name> <modifier>*</modifier></type><name>make_one_partition_rbound</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>,
													  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>datums</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lower</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>modulus1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>modulus2</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>remainder2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datums1</name></decl></parameter>,
								  <parameter><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lower1</name></decl></parameter>,
								  <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>partition_range_bsearch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
									<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
									<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>probe</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>make_partition_op_expr</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
									<parameter><decl><type><name>uint16</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>get_partition_operator</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>,
								   <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_relabel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_qual_for_hash</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_qual_for_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_qual_for_range</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>for_default</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_range_key_properties</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
									 <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name></decl></parameter>,
									 <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>udatum</name></decl></parameter>,
									 <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs_item</name></decl></parameter>,
									 <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyCol</name></decl></parameter>,
									 <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>lower_val</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>upper_val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_range_nulltest</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * get_qual_from_partbound
 *		Given a parser node for partition bound, return the list of executable
 *		expressions as partition constraint
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_qual_from_partbound</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
						<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>my_qual</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_for_hash</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_for_list</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_for_range</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>my_qual</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	partition_bounds_create
 *		Build a PartitionBoundInfo struct from a list of PartitionBoundSpec
 *		nodes
 *
 * This function creates a PartitionBoundInfo and fills the values of its
 * various members based on the input list.  Importantly, 'datums' array will
 * contain Datum representation of individual bounds (possibly after
 * de-duplication as in case of range bounds), sorted in a canonical order
 * defined by qsort_partition_* functions of respective partitioning methods.
 * 'indexes' array will contain as many elements as there are bounds (specific
 * exceptions to this rule are listed in the function body), which represent
 * the 0-based canonical positions of partitions.
 *
 * Upon return from this function, *mapping is set to an array of
 * list_length(boundspecs) elements, each of which maps the original index of
 * a partition to its canonical index.
 *
 * Note: The objects returned by this function are wholly allocated in the
 * current memory context.
 */</comment>
<function><type><name>PartitionBoundInfo</name></type>
<name>partition_bounds_create</name><parameter_list>(<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier><modifier>*</modifier></type><name>boundspecs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>,
						<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapping</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nparts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each partitioning method, we first convert the partition bounds
	 * from their parser node representation to the internal representation,
	 * along with any additional preprocessing (such as de-duplicating range
	 * bounds).  Resulting bound datums are then added to the 'datums' array
	 * in PartitionBoundInfo.  For each datum added, an integer indicating the
	 * canonical partition index is added to the 'indexes' array.
	 *
	 * For each bound, we remember its partition's position (0-based) in the
	 * original list to later map it to the canonical index.
	 */</comment>

	<comment type="block">/*
	 * Initialize mapping array with invalid values, this is filled within
	 * each sub-routine below depending on the bound type.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>mapping</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

	<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<return>return <expr><call><name>create_hash_bounds</name><argument_list>(<argument><expr><name>boundspecs</name></expr></argument>, <argument><expr><name>nparts</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<return>return <expr><call><name>create_list_bounds</name><argument_list>(<argument><expr><name>boundspecs</name></expr></argument>, <argument><expr><name>nparts</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<return>return <expr><call><name>create_range_bounds</name><argument_list>(<argument><expr><name>boundspecs</name></expr></argument>, <argument><expr><name>nparts</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * create_hash_bounds
 *		Create a PartitionBoundInfo for a hash partitioned table
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type>
<name>create_hash_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier><modifier>*</modifier></type><name>boundspecs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>,
				   <parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapping</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionHashBound</name> <modifier>*</modifier><modifier>*</modifier></type><name>hbounds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>boundinfo</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundInfoData</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<comment type="block">/* No special hash partitions. */</comment>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name>nparts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hbounds</name> <operator>=</operator> <operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionHashBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert from node to the internal representation */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><name><name>boundspecs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy in partition bound spec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionHashBound</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>modulus</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>remainder</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Sort all the bounds in ascending order */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>hbounds</name></expr></argument>, <argument><expr><name>nparts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionHashBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><name>qsort_partition_hbound_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* After sorting, moduli are now stored in ascending order. */</comment>
	<expr_stmt><expr><name>greatest_modulus</name> <operator>=</operator> <name><name>hbounds</name><index>[<expr><name>ndatums</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>modulus</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name>ndatums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>nindexes</name></name> <operator>=</operator> <name>greatest_modulus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>greatest_modulus</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * For hash partitioning, there are as many datums (modulus and remainder
	 * pairs) as there are partitions.  Indexes are simply values ranging from
	 * 0 to (nparts - 1).
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>modulus</name> <init>= <expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>modulus</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name> <init>= <expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>remainder</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>remainder</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* overlap? */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>remainder</name> <operator>+=</operator> <name>modulus</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr>]</index> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hbounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>boundinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_list_bounds
 *		Create a PartitionBoundInfo for a list partitioned table
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type>
<name>create_list_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier><modifier>*</modifier></type><name>boundspecs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>,
				   <parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapping</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionListValue</name> <modifier>*</modifier><modifier>*</modifier></type><name>all_values</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>default_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_null_values</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>boundinfo</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundInfoData</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<comment type="block">/* Will be set correctly below. */</comment>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Create a unified list of non-null values across all partitions. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><name><name>boundspecs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy in partition bound spec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Note the index of the partition bound spec for the default
		 * partition.  There's no datum to add to the list on non-null datums
		 * for this partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>default_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>c</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionListValue</name> <modifier>*</modifier></type><name>list_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>list_value</name> <operator>=</operator> <operator>(</operator><name>PartitionListValue</name> <operator>*</operator><operator>)</operator>
					<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>list_value</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>list_value</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Never put a null into the values array; save the index of
				 * the partition that stores nulls, instead.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>null_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found null more than once"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>null_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>list_value</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>non_null_values</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_null_values</name></expr></argument>, <argument><expr><name>list_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>non_null_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect all list values in one array. Alongside the value, we also save
	 * the index of partition the value comes from.
	 */</comment>
	<expr_stmt><expr><name>all_values</name> <operator>=</operator> <operator>(</operator><name>PartitionListValue</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>non_null_values</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionListValue</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionListValue</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>value</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>all_values</name></expr></argument>, <argument><expr><name>ndatums</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>qsort_partition_list_value_cmp</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name>ndatums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>nindexes</name></name> <operator>=</operator> <name>ndatums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy values.  Canonical indexes are values ranging from 0 to (nparts -
	 * 1) assigned to each partition such that all datums of a given partition
	 * receive the same value. The value for a given partition is the index of
	 * that partition's smallest datum in the all_values[] array.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>orig_index</name> <init>= <expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>value</name></expr></argument>,
											<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If the old index has no mapping, assign one */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>orig_index</name></expr>]</index> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>orig_index</name></expr>]</index> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>orig_index</name></expr>]</index></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Set the canonical value for null_index, if any.
	 *
	 * It is possible that the null-accepting partition has not been assigned
	 * an index yet, which could happen if such partition accepts only null
	 * and hence not handled in the above loop which only looked at non-null
	 * values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>null_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>null_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>null_index</name></expr>]</index> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>null_index</name></expr>]</index> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>null_index</name></expr>]</index></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set the canonical value for default_index, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name>default_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The default partition accepts any value not specified in the lists
		 * of other partitions, hence it should not get mapped index while
		 * assigning those for non-null datums.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>default_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>default_index</name></expr>]</index> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>default_index</name></expr>]</index> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>default_index</name></expr>]</index></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* All partitions must now have been assigned canonical indexes. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>next_index</name> <operator>==</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>boundinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_range_bounds
 *		Create a PartitionBoundInfo for a range partitioned table
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type>
<name>create_range_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier><modifier>*</modifier></type><name>boundspecs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>,
					<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>mapping</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier><modifier>*</modifier></type><name>rbounds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier><modifier>*</modifier></type><name>all_bounds</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>default_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>boundinfo</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundInfoData</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<comment type="block">/* There is no special null-accepting range partition. */</comment>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* Will be set correctly below. */</comment>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>all_bounds</name> <operator>=</operator> <operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a unified list of range bounds across all the partitions. */</comment>
	<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><name><name>boundspecs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lower</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>upper</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy in partition bound spec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Note the index of the partition bound spec for the default
		 * partition.  There's no datum to add to the all_bounds array for
		 * this partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>default_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>lower</name> <operator>=</operator> <call><name>make_one_partition_rbound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>upper</name> <operator>=</operator> <call><name>make_one_partition_rbound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_bounds</name><index>[<expr><name>ndatums</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>all_bounds</name><index>[<expr><name>ndatums</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>upper</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndatums</name> <operator>==</operator> <name>nparts</name> <operator>*</operator> <literal type="number">2</literal> <operator>||</operator>
		   <operator>(</operator><name>default_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>ndatums</name> <operator>==</operator> <operator>(</operator><name>nparts</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort all the bounds in ascending order */</comment>
	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>all_bounds</name></expr></argument>, <argument><expr><name>ndatums</name></expr></argument>,
			  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>qsort_partition_rbound_cmp</name></expr></argument>,
			  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save distinct bounds from all_bounds into rbounds. */</comment>
	<expr_stmt><expr><name>rbounds</name> <operator>=</operator> <operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name><name>all_bounds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_distinct</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<comment type="block">/* Is the current bound distinct from the previous one? */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>cmpval</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>cur</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>prev</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>is_distinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If the bounds are both MINVALUE or MAXVALUE, stop now and treat
			 * them as equal, since any values after this point must be
			 * ignored.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>prev</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>cmpval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>is_distinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Only if the bound is distinct save it into a temporary array, i.e,
		 * rbounds which is later copied into boundinfo datums array.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_distinct</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rbounds</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>all_bounds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Update ndatums to hold the count of distinct datums. */</comment>
	<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add datums to boundinfo.  Canonical indexes are values ranging from 0
	 * to nparts - 1, assigned in that order to each partition's upper bound.
	 * For 'datums' elements that are lower bounds, there is -1 in the
	 * 'indexes' array to signify that no partition exists for the values less
	 * than such a bound and greater than or equal to the previous upper
	 * bound.
	 */</comment>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name>ndatums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator>
			   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For range partitioning, an additional value of -1 is stored as the last
	 * element of the indexes[] array.
	 */</comment>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>nindexes</name></name> <operator>=</operator> <name>ndatums</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>ndatums</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator>
												<sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator>
				   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>kind</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
					<call><name>datumCopy</name><argument_list>(<argument><expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>datums</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>kind</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * There is no mapping for invalid indexes.
		 *
		 * Any lower bounds in the rbounds array have invalid indexes
		 * assigned, because the values between the previous bound (if there
		 * is one) and this (lower) bound are not part of the range of any
		 * existing partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>lower</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>orig_index</name> <init>= <expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* If the old index has no mapping, assign one */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>orig_index</name></expr>]</index> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>orig_index</name></expr>]</index> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>orig_index</name></expr>]</index></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Set the canonical value for default_index, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name>default_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>default_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>default_index</name></expr>]</index> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>default_index</name></expr>]</index> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>mapping</name><operator>)</operator><index>[<expr><name>default_index</name></expr>]</index></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The extra -1 element. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* All partitions must now have been assigned canonical indexes. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>next_index</name> <operator>==</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>boundinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Are two partition bound collections logically equal?
 *
 * Used in the keep logic of relcache.c (ie, in RelationClearRelation()).
 * This is also useful when b1 and b2 are bound collections of two separate
 * relations, respectively, because PartitionBoundInfo is a canonical
 * representation of partition bounds.
 */</comment>
<function><type><name>bool</name></type>
<name>partition_bounds_equal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>parttyplen</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>parttypbyval</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>b1</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>nindexes</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>nindexes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>null_index</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>null_index</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>default_index</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>default_index</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* For all partition strategies, the indexes[] arrays have to match */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b1</name><operator>-&gt;</operator><name>nindexes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Finally, compare the datums[] arrays */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We arrange the partitions in the ascending order of their moduli
		 * and remainders.  Also every modulus is factor of next larger
		 * modulus.  Therefore we can safely store index of a given partition
		 * in indexes array at remainder of that partition.  Also entries at
		 * (remainder + N * modulus) positions in indexes array are all same
		 * for (modulus, remainder) specification for any partition.  Thus the
		 * datums arrays from the given bounds are the same, if and only if
		 * their indexes arrays are the same.  So, it suffices to compare the
		 * indexes arrays.
		 *
		 * Nonetheless make sure that the bounds are indeed the same when the
		 * indexes match.  Hash partition bound stores modulus and remainder
		 * at b1-&gt;datums[i][0] and b1-&gt;datums[i][1] position respectively.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b1</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>b1</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>b2</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
					<name><name>b1</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>b2</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b1</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/* For range partitions, the bounds might not be finite. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* The different kinds of bound all differ from each other */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Non-finite bounds are equal without further
					 * examination.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Compare the actual values. Note that it would be both
				 * incorrect and unsafe to invoke the comparison operator
				 * derived from the partitioning specification here.  It would
				 * be incorrect because we want the relcache entry to be
				 * updated for ANY change to the partition bounds, not just
				 * those that the partitioning operator thinks are
				 * significant.  It would be unsafe because we might reach
				 * this code in the context of an aborted transaction, and an
				 * arbitrary partitioning operator might not be safe in that
				 * context.  datumIsEqual() should be simple enough to be
				 * safe.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>datumIsEqual</name><argument_list>(<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b2</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>parttypbyval</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>parttyplen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a copy of given PartitionBoundInfo structure. The data types of bounds
 * are described by given partition key specification.
 *
 * Note: it's important that this function and its callees not do any catalog
 * access, nor anything else that would result in allocating memory other than
 * the returned data structure.  Since this is called in a long-lived context,
 * that would result in unwanted memory leaks.
 */</comment>
<function><type><name>PartitionBoundInfo</name></type>
<name>partition_bounds_copy</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>src</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hash_part</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dest</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundInfo</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nindexes</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>nindexes</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>nindexes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<comment type="block">/* List partitioned tables have only a single partition key. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>||</operator> <name>partnatts</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator>
														 <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>partnatts</name> <operator>*</operator>
															   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For hash partitioning, datums array will have two elements - modulus
	 * and remainder.
	 */</comment>
	<expr_stmt><expr><name>hash_part</name> <operator>=</operator> <operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <ternary><condition><expr><name>hash_part</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><name>partnatts</name></expr></else></ternary></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>byval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>hash_part</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>typlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt> <comment type="block">/* Always int4 */</comment>
				<expr_stmt><expr><name>byval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* int4 is pass-by-value */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>byval</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<name><name>dest</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name>byval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>indexes</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>indexes</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>null_index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>default_index</name></name></expr>;</expr_stmt>

	<return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_bounds_merge
 *		Check to see whether every partition of 'outer_rel' matches/overlaps
 *		one partition of 'inner_rel' at most, and vice versa; and if so, build
 *		and return the partition bounds for a join relation between the rels,
 *		generating two lists of the matching/overlapping partitions, which are
 *		returned to *outer_parts and *inner_parts respectively.
 *
 * The lists contain the same number of partitions, and the partitions at the
 * same positions in the lists indicate join pairs used for partitioned join.
 * If a partition on one side matches/overlaps multiple partitions on the other
 * side, this function returns NULL, setting *outer_parts and *inner_parts to
 * NIL.
 */</comment>
<function><type><name>PartitionBoundInfo</name></type>
<name>partition_bounds_merge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>,
					   <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
					   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>outer_parts</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>inner_parts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Currently, this function is called only from try_partitionwise_join(),
	 * so the join type should be INNER, LEFT, FULL, SEMI, or ANTI.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_LEFT</name> <operator>||</operator>
		   <name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
		   <name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The partitioning strategies should be the same. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>outer_parts</name> <operator>=</operator> <operator>*</operator><name>inner_parts</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>outer_rel</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>

			<comment type="block">/*
			 * For hash partitioned tables, we currently support partitioned
			 * join only when they have exactly the same partition bounds.
			 *
			 * XXX: it might be possible to relax the restriction to support
			 * cases where hash partitioned tables have missing partitions
			 * and/or different moduli, but it's not clear if it would be
			 * useful to support the former case since it's unusual to have
			 * missing partitions.  On the other hand, it would be useful to
			 * support the latter case, but in that case, there is a high
			 * probability that a partition on one side will match multiple
			 * partitions on the other side, which is the scenario the current
			 * implementation of partitioned join can't handle.
			 */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<return>return <expr><call><name>merge_list_bounds</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
									 <argument><expr><name>partcollation</name></expr></argument>,
									 <argument><expr><name>outer_rel</name></expr></argument>,
									 <argument><expr><name>inner_rel</name></expr></argument>,
									 <argument><expr><name>jointype</name></expr></argument>,
									 <argument><expr><name>outer_parts</name></expr></argument>,
									 <argument><expr><name>inner_parts</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<return>return <expr><call><name>merge_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>,
									  <argument><expr><name>partsupfunc</name></expr></argument>,
									  <argument><expr><name>partcollation</name></expr></argument>,
									  <argument><expr><name>outer_rel</name></expr></argument>,
									  <argument><expr><name>inner_rel</name></expr></argument>,
									  <argument><expr><name>jointype</name></expr></argument>,
									  <argument><expr><name>outer_parts</name></expr></argument>,
									  <argument><expr><name>inner_parts</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * merge_list_bounds
 *		Create the partition bounds for a join relation between list
 *		partitioned tables, if possible
 *
 * In this function we try to find sets of matching partitions from both sides
 * by comparing list values stored in their partition bounds.  Since the list
 * values appear in the ascending order, an algorithm similar to merge join is
 * used for that.  If a partition on one side doesn't have a matching
 * partition on the other side, the algorithm tries to match it with the
 * default partition on the other side if any; if not, the algorithm tries to
 * match it with a dummy partition on the other side if it's on the
 * non-nullable side of an outer join.  Also, if both sides have the default
 * partitions, the algorithm tries to match them with each other.  We give up
 * if the algorithm finds a partition matching multiple partitions on the
 * other side, which is the scenario the current implementation of partitioned
 * join can't handle.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type>
<name>merge_list_bounds</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
				  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>outer_parts</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>inner_parts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>merged_bounds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>outer_bi</name> <init>= <expr><name><name>outer_rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>inner_bi</name> <init>= <expr><name><name>inner_rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>outer_has_default</name> <init>= <expr><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>outer_bi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inner_has_default</name> <init>= <expr><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>inner_bi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outer_default</name> <init>= <expr><name><name>outer_bi</name><operator>-&gt;</operator><name>default_index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inner_default</name> <init>= <expr><name><name>inner_bi</name><operator>-&gt;</operator><name>default_index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>outer_has_null</name> <init>= <expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>outer_bi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inner_has_null</name> <init>= <expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>inner_bi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionMap</name></type> <name>outer_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionMap</name></type> <name>inner_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outer_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inner_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>default_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>merged_datums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>merged_indexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>inner_parts</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>outer_bi</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&amp;&amp;</operator>
		   <name><name>outer_bi</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* List partitioning doesn't require kinds. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>outer_bi</name><operator>-&gt;</operator><name>kind</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>inner_bi</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_partition_map</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_partition_map</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the default partitions (if any) have been proven empty, deem them
	 * non-existent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_has_default</name> <operator>&amp;&amp;</operator> <call><name>is_dummy_partition</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>outer_default</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outer_has_default</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inner_has_default</name> <operator>&amp;&amp;</operator> <call><name>is_dummy_partition</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><name>inner_default</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_has_default</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Merge partitions from both sides.  In each iteration we compare a pair
	 * of list values, one from each side, and decide whether the
	 * corresponding partitions match or not.  If the two values match
	 * exactly, move to the next pair of list values, otherwise move to the
	 * next list value on the side with a smaller list value.
	 */</comment>
	<expr_stmt><expr><name>outer_pos</name> <operator>=</operator> <name>inner_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>outer_pos</name> <operator>&lt;</operator> <name><name>outer_bi</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>||</operator> <name>inner_pos</name> <operator>&lt;</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>outer_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>inner_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>outer_datums</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>inner_datums</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmpval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>merged_datum</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>merged_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>outer_pos</name> <operator>&lt;</operator> <name><name>outer_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the partition on the outer side has been proven empty,
			 * ignore it and move to the next datum on the outer side.
			 */</comment>
			<expr_stmt><expr><name>outer_index</name> <operator>=</operator> <name><name>outer_bi</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>outer_pos</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>is_dummy_partition</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>outer_index</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>outer_pos</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>inner_pos</name> <operator>&lt;</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the partition on the inner side has been proven empty,
			 * ignore it and move to the next datum on the inner side.
			 */</comment>
			<expr_stmt><expr><name>inner_index</name> <operator>=</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>inner_pos</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>is_dummy_partition</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><name>inner_index</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>inner_pos</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the list values. */</comment>
		<expr_stmt><expr><name>outer_datums</name> <operator>=</operator> <ternary><condition><expr><name>outer_pos</name> <operator>&lt;</operator> <name><name>outer_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr> ?</condition><then>
			<expr><name><name>outer_bi</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>outer_pos</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_datums</name> <operator>=</operator> <ternary><condition><expr><name>inner_pos</name> <operator>&lt;</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr> ?</condition><then>
			<expr><name><name>inner_bi</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>inner_pos</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * We run this loop till both sides finish.  This allows us to avoid
		 * duplicating code to handle the remaining values on the side which
		 * finishes later.  For that we set the comparison parameter cmpval in
		 * such a way that it appears as if the side which finishes earlier
		 * has an extra value higher than any other value on the unfinished
		 * side. That way we advance the values on the unfinished side till
		 * all of its values are exhausted.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>outer_pos</name> <operator>&gt;=</operator> <name><name>outer_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>inner_pos</name> <operator>&gt;=</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_datums</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>inner_datums</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
													 <argument><expr><name><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
													 <argument><expr><name><name>outer_datums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
													 <argument><expr><name><name>inner_datums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Two list values match exactly. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_pos</name> <operator>&lt;</operator> <name><name>outer_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_pos</name> <operator>&lt;</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Try merging both partitions.  If successful, add the list value
			 * and index of the merged partition below.
			 */</comment>
			<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>merge_matching_partitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
													 <argument><expr><name>outer_index</name></expr></argument>, <argument><expr><name>inner_index</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>merged_datum</name> <operator>=</operator> <name>outer_datums</name></expr>;</expr_stmt>

			<comment type="block">/* Move to the next pair of list values. */</comment>
			<expr_stmt><expr><name>outer_pos</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>inner_pos</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>cmpval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* A list value missing from the inner side. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_pos</name> <operator>&lt;</operator> <name><name>outer_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the inner side has the default partition, or this is an
			 * outer join, try to assign a merged partition to the outer
			 * partition (see process_outer_partition()).  Otherwise, the
			 * outer partition will not contribute to the result.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>inner_has_default</name> <operator>||</operator> <call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Get the outer partition. */</comment>
				<expr_stmt><expr><name>outer_index</name> <operator>=</operator> <name><name>outer_bi</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>outer_pos</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>process_outer_partition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
													   <argument><expr><name>outer_has_default</name></expr></argument>,
													   <argument><expr><name>inner_has_default</name></expr></argument>,
													   <argument><expr><name>outer_index</name></expr></argument>,
													   <argument><expr><name>inner_default</name></expr></argument>,
													   <argument><expr><name>jointype</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>next_index</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>default_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>merged_datum</name> <operator>=</operator> <name>outer_datums</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Move to the next list value on the outer side. */</comment>
			<expr_stmt><expr><name>outer_pos</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* A list value missing from the outer side. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cmpval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_pos</name> <operator>&lt;</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the outer side has the default partition, or this is a FULL
			 * join, try to assign a merged partition to the inner partition
			 * (see process_inner_partition()).  Otherwise, the inner
			 * partition will not contribute to the result.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>outer_has_default</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Get the inner partition. */</comment>
				<expr_stmt><expr><name>inner_index</name> <operator>=</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>inner_pos</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>process_inner_partition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
													   <argument><expr><name>outer_has_default</name></expr></argument>,
													   <argument><expr><name>inner_has_default</name></expr></argument>,
													   <argument><expr><name>inner_index</name></expr></argument>,
													   <argument><expr><name>outer_default</name></expr></argument>,
													   <argument><expr><name>jointype</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>next_index</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>default_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>merged_datum</name> <operator>=</operator> <name>inner_datums</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Move to the next list value on the inner side. */</comment>
			<expr_stmt><expr><name>inner_pos</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we assigned a merged partition, add the list value and index of
		 * the merged partition if appropriate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>merged_index</name> <operator>!=</operator> <name>default_index</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>merged_datums</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>merged_datums</name></expr></argument>, <argument><expr><name>merged_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>merged_indexes</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>merged_indexes</name></expr></argument>, <argument><expr><name>merged_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If the NULL partitions (if any) have been proven empty, deem them
	 * non-existent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_has_null</name> <operator>&amp;&amp;</operator>
		<call><name>is_dummy_partition</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name><name>outer_bi</name><operator>-&gt;</operator><name>null_index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outer_has_null</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inner_has_null</name> <operator>&amp;&amp;</operator>
		<call><name>is_dummy_partition</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><name><name>inner_bi</name><operator>-&gt;</operator><name>null_index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_has_null</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Merge the NULL partitions if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_has_null</name> <operator>||</operator> <name>inner_has_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>merge_null_partitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
							  <argument><expr><name>outer_has_null</name></expr></argument>, <argument><expr><name>inner_has_null</name></expr></argument>,
							  <argument><expr><name><name>outer_bi</name><operator>-&gt;</operator><name>null_index</name></name></expr></argument>, <argument><expr><name><name>inner_bi</name><operator>-&gt;</operator><name>null_index</name></name></expr></argument>,
							  <argument><expr><name>jointype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>null_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Merge the default partitions if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_has_default</name> <operator>||</operator> <name>inner_has_default</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>merge_default_partitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
								 <argument><expr><name>outer_has_default</name></expr></argument>, <argument><expr><name>inner_has_default</name></expr></argument>,
								 <argument><expr><name>outer_default</name></expr></argument>, <argument><expr><name>inner_default</name></expr></argument>,
								 <argument><expr><name>jointype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>default_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* If we have merged partitions, create the partition bounds. */</comment>
	<if_stmt><if>if <condition>(<expr><name>next_index</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Fix the merged_indexes list if necessary. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>outer_map</name><operator>.</operator><name>did_remapping</name></name> <operator>||</operator> <name><name>inner_map</name><operator>.</operator><name>did_remapping</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fix_merged_indexes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
							   <argument><expr><name>next_index</name></expr></argument>, <argument><expr><name>merged_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Use maps to match partitions from inputs. */</comment>
		<expr_stmt><expr><call><name>generate_matching_part_pairs</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
									 <argument><expr><name>next_index</name></expr></argument>,
									 <argument><expr><name>outer_parts</name></expr></argument>, <argument><expr><name>inner_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>inner_parts</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>inner_parts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make a PartitionBoundInfo struct to return. */</comment>
		<expr_stmt><expr><name>merged_bounds</name> <operator>=</operator> <call><name>build_merged_partition_bounds</name><argument_list>(<argument><expr><name><name>outer_bi</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>,
													  <argument><expr><name>merged_datums</name></expr></argument>,
													  <argument><expr><name>NIL</name></expr></argument>,
													  <argument><expr><name>merged_indexes</name></expr></argument>,
													  <argument><expr><name>null_index</name></expr></argument>,
													  <argument><expr><name>default_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>merged_bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
	<comment type="block">/* Free local memory before returning. */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>merged_datums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>merged_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_partition_map</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_partition_map</name><argument_list>(<argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>merged_bounds</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * merge_range_bounds
 *		Create the partition bounds for a join relation between range
 *		partitioned tables, if possible
 *
 * In this function we try to find sets of overlapping partitions from both
 * sides by comparing ranges stored in their partition bounds.  Since the
 * ranges appear in the ascending order, an algorithm similar to merge join is
 * used for that.  If a partition on one side doesn't have an overlapping
 * partition on the other side, the algorithm tries to match it with the
 * default partition on the other side if any; if not, the algorithm tries to
 * match it with a dummy partition on the other side if it's on the
 * non-nullable side of an outer join.  Also, if both sides have the default
 * partitions, the algorithm tries to match them with each other.  We give up
 * if the algorithm finds a partition overlapping multiple partitions on the
 * other side, which is the scenario the current implementation of partitioned
 * join can't handle.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type>
<name>merge_range_bounds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfuncs</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollations</name></decl></parameter>,
				   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
				   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>outer_parts</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>inner_parts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>merged_bounds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>outer_bi</name> <init>= <expr><name><name>outer_rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>inner_bi</name> <init>= <expr><name><name>inner_rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>outer_has_default</name> <init>= <expr><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>outer_bi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inner_has_default</name> <init>= <expr><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>inner_bi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outer_default</name> <init>= <expr><name><name>outer_bi</name><operator>-&gt;</operator><name>default_index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inner_default</name> <init>= <expr><name><name>inner_bi</name><operator>-&gt;</operator><name>default_index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionMap</name></type> <name>outer_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionMap</name></type> <name>inner_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outer_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inner_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outer_lb_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inner_lb_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeBound</name></type> <name>outer_lb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeBound</name></type> <name>outer_ub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeBound</name></type> <name>inner_lb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeBound</name></type> <name>inner_ub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>default_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>merged_datums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>merged_kinds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>merged_indexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>inner_parts</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>outer_bi</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name><name>inner_bi</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&amp;&amp;</operator>
		   <name><name>outer_bi</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_partition_map</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_partition_map</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the default partitions (if any) have been proven empty, deem them
	 * non-existent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_has_default</name> <operator>&amp;&amp;</operator> <call><name>is_dummy_partition</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>outer_default</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outer_has_default</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inner_has_default</name> <operator>&amp;&amp;</operator> <call><name>is_dummy_partition</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><name>inner_default</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_has_default</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Merge partitions from both sides.  In each iteration we compare a pair
	 * of ranges, one from each side, and decide whether the corresponding
	 * partitions match or not.  If the two ranges overlap, move to the next
	 * pair of ranges, otherwise move to the next range on the side with a
	 * lower range.  outer_lb_pos/inner_lb_pos keep track of the positions of
	 * lower bounds in the datums arrays in the outer/inner
	 * PartitionBoundInfos respectively.
	 */</comment>
	<expr_stmt><expr><name>outer_lb_pos</name> <operator>=</operator> <name>inner_lb_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>outer_index</name> <operator>=</operator> <call><name>get_range_partition</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>outer_bi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_lb_pos</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>outer_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_index</name> <operator>=</operator> <call><name>get_range_partition</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><name>inner_bi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_lb_pos</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>inner_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>outer_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>inner_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>overlap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ub_cmpval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>lb_cmpval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionRangeBound</name></type> <name>merged_lb</name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionRangeBound</name></type> <name>merged_ub</name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>merged_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We run this loop till both sides finish.  This allows us to avoid
		 * duplicating code to handle the remaining ranges on the side which
		 * finishes later.  For that we set the comparison parameter cmpval in
		 * such a way that it appears as if the side which finishes earlier
		 * has an extra range higher than any other range on the unfinished
		 * side. That way we advance the ranges on the unfinished side till
		 * all of its ranges are exhausted.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>outer_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lb_cmpval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>ub_cmpval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>inner_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lb_cmpval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>ub_cmpval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>overlap</name> <operator>=</operator> <call><name>compare_range_partitions</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>,
											   <argument><expr><name>partcollations</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>outer_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_ub</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>inner_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_ub</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>lb_cmpval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ub_cmpval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>overlap</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Two ranges overlap; form a join pair. */</comment>

			<decl_stmt><decl><type><name>PartitionRangeBound</name></type> <name>save_outer_ub</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionRangeBound</name></type> <name>save_inner_ub</name></decl>;</decl_stmt>

			<comment type="block">/* Both partitions should not have been merged yet. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>outer_map</name><operator>.</operator><name>merged_indexes</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
				   <name><name>outer_map</name><operator>.</operator><name>merged</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>inner_map</name><operator>.</operator><name>merged_indexes</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
				   <name><name>inner_map</name><operator>.</operator><name>merged</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Get the index of the merged partition.  Both partitions aren't
			 * merged yet, so the partitions should be merged successfully.
			 */</comment>
			<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>merge_matching_partitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
													 <argument><expr><name>outer_index</name></expr></argument>, <argument><expr><name>inner_index</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get the range bounds of the merged partition. */</comment>
			<expr_stmt><expr><call><name>get_merged_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>,
									<argument><expr><name>partcollations</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>outer_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_ub</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>inner_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_ub</name></expr></argument>,
									<argument><expr><name>lb_cmpval</name></expr></argument>, <argument><expr><name>ub_cmpval</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>merged_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged_ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Save the upper bounds of both partitions for use below. */</comment>
			<expr_stmt><expr><name>save_outer_ub</name> <operator>=</operator> <name>outer_ub</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>save_inner_ub</name> <operator>=</operator> <name>inner_ub</name></expr>;</expr_stmt>

			<comment type="block">/* Move to the next pair of ranges. */</comment>
			<expr_stmt><expr><name>outer_index</name> <operator>=</operator> <call><name>get_range_partition</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>outer_bi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_lb_pos</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>outer_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>inner_index</name> <operator>=</operator> <call><name>get_range_partition</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><name>inner_bi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_lb_pos</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>inner_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the range of a partition on one side overlaps the range of
			 * the next partition on the other side, that will cause the
			 * partition on one side to match at least two partitions on the
			 * other side, which is the case that we currently don't support
			 * partitioned join for; give up.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ub_cmpval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>inner_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>compare_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>save_outer_ub</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_lb</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>ub_cmpval</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>outer_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>compare_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>outer_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_inner_ub</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * A row from a non-overlapping portion (if any) of a partition on
			 * one side might find its join partner in the default partition
			 * (if any) on the other side, causing the same situation as
			 * above; give up in that case.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>outer_has_default</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>lb_cmpval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>ub_cmpval</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
				<operator>(</operator><name>inner_has_default</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lb_cmpval</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>ub_cmpval</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ub_cmpval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* A non-overlapping outer range. */</comment>

			<comment type="block">/* The outer partition should not have been merged yet. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>outer_map</name><operator>.</operator><name>merged_indexes</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
				   <name><name>outer_map</name><operator>.</operator><name>merged</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the inner side has the default partition, or this is an
			 * outer join, try to assign a merged partition to the outer
			 * partition (see process_outer_partition()).  Otherwise, the
			 * outer partition will not contribute to the result.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>inner_has_default</name> <operator>||</operator> <call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>process_outer_partition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
													   <argument><expr><name>outer_has_default</name></expr></argument>,
													   <argument><expr><name>inner_has_default</name></expr></argument>,
													   <argument><expr><name>outer_index</name></expr></argument>,
													   <argument><expr><name>inner_default</name></expr></argument>,
													   <argument><expr><name>jointype</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>next_index</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>default_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>merged_lb</name> <operator>=</operator> <name>outer_lb</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>merged_ub</name> <operator>=</operator> <name>outer_ub</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Move to the next range on the outer side. */</comment>
			<expr_stmt><expr><name>outer_index</name> <operator>=</operator> <call><name>get_range_partition</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>outer_bi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_lb_pos</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>outer_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outer_ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* A non-overlapping inner range. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ub_cmpval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* The inner partition should not have been merged yet. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>inner_map</name><operator>.</operator><name>merged_indexes</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
				   <name><name>inner_map</name><operator>.</operator><name>merged</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the outer side has the default partition, or this is a FULL
			 * join, try to assign a merged partition to the inner partition
			 * (see process_inner_partition()).  Otherwise, the inner
			 * partition will not contribute to the result.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>outer_has_default</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>process_inner_partition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
													   <argument><expr><name>outer_has_default</name></expr></argument>,
													   <argument><expr><name>inner_has_default</name></expr></argument>,
													   <argument><expr><name>inner_index</name></expr></argument>,
													   <argument><expr><name>outer_default</name></expr></argument>,
													   <argument><expr><name>jointype</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>next_index</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>default_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>merged_lb</name> <operator>=</operator> <name>inner_lb</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>merged_ub</name> <operator>=</operator> <name>inner_ub</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Move to the next range on the inner side. */</comment>
			<expr_stmt><expr><name>inner_index</name> <operator>=</operator> <call><name>get_range_partition</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><name>inner_bi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_lb_pos</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>inner_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we assigned a merged partition, add the range bounds and index
		 * of the merged partition if appropriate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>merged_index</name> <operator>!=</operator> <name>default_index</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_merged_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>merged_lb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged_ub</name></expr></argument>, <argument><expr><name>merged_index</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>merged_datums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged_kinds</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>merged_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Merge the default partitions if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_has_default</name> <operator>||</operator> <name>inner_has_default</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>merge_default_partitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
								 <argument><expr><name>outer_has_default</name></expr></argument>, <argument><expr><name>inner_has_default</name></expr></argument>,
								 <argument><expr><name>outer_default</name></expr></argument>, <argument><expr><name>inner_default</name></expr></argument>,
								 <argument><expr><name>jointype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>default_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* If we have merged partitions, create the partition bounds. */</comment>
	<if_stmt><if>if <condition>(<expr><name>next_index</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Unlike the case of list partitioning, we wouldn't have re-merged
		 * partitions, so did_remapping should be left alone.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>outer_map</name><operator>.</operator><name>did_remapping</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>inner_map</name><operator>.</operator><name>did_remapping</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Use maps to match partitions from inputs. */</comment>
		<expr_stmt><expr><call><name>generate_matching_part_pairs</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>,
									 <argument><expr><name>next_index</name></expr></argument>,
									 <argument><expr><name>outer_parts</name></expr></argument>, <argument><expr><name>inner_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>inner_parts</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>inner_parts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make a PartitionBoundInfo struct to return. */</comment>
		<expr_stmt><expr><name>merged_bounds</name> <operator>=</operator> <call><name>build_merged_partition_bounds</name><argument_list>(<argument><expr><name><name>outer_bi</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>,
													  <argument><expr><name>merged_datums</name></expr></argument>,
													  <argument><expr><name>merged_kinds</name></expr></argument>,
													  <argument><expr><name>merged_indexes</name></expr></argument>,
													  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
													  <argument><expr><name>default_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>merged_bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
	<comment type="block">/* Free local memory before returning. */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>merged_datums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>merged_kinds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>merged_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_partition_map</name><argument_list>(<argument><expr><operator>&amp;</operator><name>outer_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_partition_map</name><argument_list>(<argument><expr><operator>&amp;</operator><name>inner_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>merged_bounds</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * init_partition_map
 *		Initialize a PartitionMap struct for given relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_partition_map</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name>nparts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>merged_indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>merged</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>did_remapping</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>old_indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>old_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * free_partition_map
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_partition_map</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>merged_indexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>merged</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>old_indexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * is_dummy_partition --- has partition been proven empty?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_dummy_partition</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>part_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>part_rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>part_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>part_index</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>part_rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * merge_matching_partitions
 *		Try to merge given outer/inner partitions, and return the index of a
 *		merged partition produced from them if successful, -1 otherwise
 *
 * If the merged partition is newly created, *next_index is incremented.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>merge_matching_partitions</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>, <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>outer_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inner_index</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>outer_merged_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inner_merged_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>outer_merged</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inner_merged</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>outer_index</name> <operator>&lt;</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outer_merged_index</name> <operator>=</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>outer_index</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outer_merged</name> <operator>=</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>outer_index</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>inner_index</name> <operator>&lt;</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_merged_index</name> <operator>=</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>inner_index</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_merged</name> <operator>=</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>inner_index</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Handle cases where we have already assigned a merged partition to each
	 * of the given partitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>inner_merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the mereged partitions are the same, no need to do anything;
		 * return the index of the merged partitions.  Otherwise, if each of
		 * the given partitions has been merged with a dummy partition on the
		 * other side, re-map them to either of the two merged partitions.
		 * Otherwise, they can't be merged, so return -1.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>outer_merged_index</name> <operator>==</operator> <name>inner_merged_index</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>outer_merged_index</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outer_merged</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inner_merged</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This can only happen for a list-partitioning case.  We re-map
			 * them to the merged partition with the smaller of the two merged
			 * indexes to preserve the property that the canonical order of
			 * list partitions is determined by the indexes assigned to the
			 * smallest list value of each partition.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>outer_merged_index</name> <operator>&lt;</operator> <name>inner_merged_index</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>=</operator> <name>outer_merged_index</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>did_remapping</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>old_indexes</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>=</operator> <name>inner_merged_index</name></expr>;</expr_stmt>
				<return>return <expr><name>outer_merged_index</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>=</operator> <name>inner_merged_index</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>did_remapping</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>old_indexes</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>=</operator> <name>outer_merged_index</name></expr>;</expr_stmt>
				<return>return <expr><name>inner_merged_index</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* At least one of the given partitions should not have yet been merged. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>inner_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If neither of them has been merged, merge them.  Otherwise, if one has
	 * been merged with a dummy partition on the other side (and the other
	 * hasn't yet been merged with anything), re-merge them.  Otherwise, they
	 * can't be merged, so return -1.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>inner_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>merged_index</name> <init>= <expr><operator>*</operator><name>next_index</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>outer_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>inner_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>=</operator> <name>merged_index</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>=</operator> <name>merged_index</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>next_index</name> <operator>=</operator> <operator>*</operator><name>next_index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<return>return <expr><name>merged_index</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>outer_merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>outer_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>outer_index</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>inner_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>=</operator> <name>outer_merged_index</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>outer_merged_index</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inner_merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>inner_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>inner_index</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>outer_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>=</operator> <name>inner_merged_index</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>outer_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>inner_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>inner_merged_index</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * process_outer_partition
 *		Try to assign given outer partition a merged partition, and return the
 *		index of the merged partition if successful, -1 otherwise
 *
 * If the partition is newly created, *next_index is incremented.  Also, if it
 * is the default partition of the join relation, *default_index is set to the
 * index if not already done.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_outer_partition</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
						<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>outer_has_default</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>inner_has_default</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>outer_index</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>inner_default</name></decl></parameter>,
						<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>,
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>default_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>merged_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the inner side has the default partition, a row from the outer
	 * partition might find its join partner in the default partition; try
	 * merging the outer partition with the default partition.  Otherwise,
	 * this should be an outer join, in which case the outer partition has to
	 * be scanned all the way anyway; merge the outer partition with a dummy
	 * partition on the other side.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>inner_has_default</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_default</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the outer side has the default partition as well, the default
		 * partition on the inner side will have two matching partitions on
		 * the other side: the outer partition and the default partition on
		 * the outer side.  Partitionwise join doesn't handle this scenario
		 * yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>outer_has_default</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>merge_matching_partitions</name><argument_list>(<argument><expr><name>outer_map</name></expr></argument>, <argument><expr><name>inner_map</name></expr></argument>,
												 <argument><expr><name>outer_index</name></expr></argument>, <argument><expr><name>inner_default</name></expr></argument>,
												 <argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this is a FULL join, the default partition on the inner side has
		 * to be scanned all the way anyway, so the resulting partition will
		 * contain all key values from the default partition, which any other
		 * partition of the join relation will not contain.  Thus the
		 * resulting partition will act as the default partition of the join
		 * relation; record the index in *default_index if not already done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>default_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>default_index</name> <operator>=</operator> <name>merged_index</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>==</operator> <name>merged_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we have already assigned a partition, no need to do anything. */</comment>
		<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>outer_index</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>merge_partition_with_dummy</name><argument_list>(<argument><expr><name>outer_map</name></expr></argument>, <argument><expr><name>outer_index</name></expr></argument>,
													  <argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>merged_index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * process_inner_partition
 *		Try to assign given inner partition a merged partition, and return the
 *		index of the merged partition if successful, -1 otherwise
 *
 * If the partition is newly created, *next_index is incremented.  Also, if it
 * is the default partition of the join relation, *default_index is set to the
 * index if not already done.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_inner_partition</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
						<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>outer_has_default</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>inner_has_default</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>inner_index</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>outer_default</name></decl></parameter>,
						<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>,
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>default_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>merged_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the outer side has the default partition, a row from the inner
	 * partition might find its join partner in the default partition; try
	 * merging the inner partition with the default partition.  Otherwise,
	 * this should be a FULL join, in which case the inner partition has to be
	 * scanned all the way anyway; merge the inner partition with a dummy
	 * partition on the other side.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_has_default</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_default</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the inner side has the default partition as well, the default
		 * partition on the outer side will have two matching partitions on
		 * the other side: the inner partition and the default partition on
		 * the inner side.  Partitionwise join doesn't handle this scenario
		 * yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>inner_has_default</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>merge_matching_partitions</name><argument_list>(<argument><expr><name>outer_map</name></expr></argument>, <argument><expr><name>inner_map</name></expr></argument>,
												 <argument><expr><name>outer_default</name></expr></argument>, <argument><expr><name>inner_index</name></expr></argument>,
												 <argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this is an outer join, the default partition on the outer side
		 * has to be scanned all the way anyway, so the resulting partition
		 * will contain all key values from the default partition, which any
		 * other partition of the join relation will not contain.  Thus the
		 * resulting partition will act as the default partition of the join
		 * relation; record the index in *default_index if not already done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>default_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>default_index</name> <operator>=</operator> <name>merged_index</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>==</operator> <name>merged_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we have already assigned a partition, no need to do anything. */</comment>
		<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>inner_index</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>merge_partition_with_dummy</name><argument_list>(<argument><expr><name>inner_map</name></expr></argument>, <argument><expr><name>inner_index</name></expr></argument>,
													  <argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>merged_index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * merge_null_partitions
 *		Merge the NULL partitions from a join's outer and inner sides.
 *
 * If the merged partition produced from them is the NULL partition of the join
 * relation, *null_index is set to the index of the merged partition.
 *
 * Note: We assume here that the join clause for a partitioned join is strict
 * because have_partkey_equi_join() requires that the corresponding operator
 * be mergejoinable, and we currently assume that mergejoinable operators are
 * strict (see MJEvalOuterValues()/MJEvalInnerValues()).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_null_partitions</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>outer_has_null</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>inner_has_null</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>outer_null</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>inner_null</name></decl></parameter>,
					  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>,
					  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>null_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>consider_outer_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>consider_inner_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_has_null</name> <operator>||</operator> <name>inner_has_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>null_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check whether the NULL partitions have already been merged and if so,
	 * set the consider_outer_null/consider_inner_null flags.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_has_null</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_null</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>outer_null</name> <operator>&lt;</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>outer_null</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>consider_outer_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inner_has_null</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_null</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>inner_null</name> <operator>&lt;</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>inner_null</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>consider_inner_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If both flags are set false, we don't need to do anything. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>consider_outer_null</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>consider_inner_null</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>consider_outer_null</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>consider_inner_null</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_has_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is an outer join, the NULL partition on the outer side has
		 * to be scanned all the way anyway; merge the NULL partition with a
		 * dummy partition on the other side.  In that case
		 * consider_outer_null means that the NULL partition only contains
		 * NULL values as the key values, so the merged partition will do so;
		 * treat it as the NULL partition of the join relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>null_index</name> <operator>=</operator> <call><name>merge_partition_with_dummy</name><argument_list>(<argument><expr><name>outer_map</name></expr></argument>, <argument><expr><name>outer_null</name></expr></argument>,
													 <argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>consider_outer_null</name> <operator>&amp;&amp;</operator> <name>consider_inner_null</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_has_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is a FULL join, the NULL partition on the inner side has to
		 * be scanned all the way anyway; merge the NULL partition with a
		 * dummy partition on the other side.  In that case
		 * consider_inner_null means that the NULL partition only contains
		 * NULL values as the key values, so the merged partition will do so;
		 * treat it as the NULL partition of the join relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>null_index</name> <operator>=</operator> <call><name>merge_partition_with_dummy</name><argument_list>(<argument><expr><name>inner_map</name></expr></argument>, <argument><expr><name>inner_null</name></expr></argument>,
													 <argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consider_outer_null</name> <operator>&amp;&amp;</operator> <name>consider_inner_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_has_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_has_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is an outer join, the NULL partition on the outer side (and
		 * that on the inner side if this is a FULL join) have to be scanned
		 * all the way anyway, so merge them.  Note that each of the NULL
		 * partitions isn't merged yet, so they should be merged successfully.
		 * Like the above, each of the NULL partitions only contains NULL
		 * values as the key values, so the merged partition will do so; treat
		 * it as the NULL partition of the join relation.
		 *
		 * Note: if this an INNER/SEMI join, the join clause will never be
		 * satisfied by two NULL values (see comments above), so both the NULL
		 * partitions can be eliminated.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>null_index</name> <operator>=</operator> <call><name>merge_matching_partitions</name><argument_list>(<argument><expr><name>outer_map</name></expr></argument>, <argument><expr><name>inner_map</name></expr></argument>,
													<argument><expr><name>outer_null</name></expr></argument>, <argument><expr><name>inner_null</name></expr></argument>,
													<argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>null_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * merge_default_partitions
 *		Merge the default partitions from a join's outer and inner sides.
 *
 * If the merged partition produced from them is the default partition of the
 * join relation, *default_index is set to the index of the merged partition.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_default_partitions</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>outer_has_default</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>inner_has_default</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>outer_default</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>inner_default</name></decl></parameter>,
						 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>default_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>outer_merged_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inner_merged_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_has_default</name> <operator>||</operator> <name>inner_has_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the merged partition indexes for the default partitions. */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_has_default</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_default</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>outer_default</name> <operator>&lt;</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outer_merged_index</name> <operator>=</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>outer_default</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inner_has_default</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_default</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>inner_default</name> <operator>&lt;</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_merged_index</name> <operator>=</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>inner_default</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>outer_has_default</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inner_has_default</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If this is an outer join, the default partition on the outer side
		 * has to be scanned all the way anyway; if we have not yet assigned a
		 * partition, merge the default partition with a dummy partition on
		 * the other side.  The merged partition will act as the default
		 * partition of the join relation (see comments in
		 * process_inner_partition()).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>outer_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>default_index</name> <operator>=</operator> <call><name>merge_partition_with_dummy</name><argument_list>(<argument><expr><name>outer_map</name></expr></argument>,
															<argument><expr><name>outer_default</name></expr></argument>,
															<argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>==</operator> <name>outer_merged_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>outer_has_default</name> <operator>&amp;&amp;</operator> <name>inner_has_default</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If this is a FULL join, the default partition on the inner side has
		 * to be scanned all the way anyway; if we have not yet assigned a
		 * partition, merge the default partition with a dummy partition on
		 * the other side.  The merged partition will act as the default
		 * partition of the join relation (see comments in
		 * process_outer_partition()).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>inner_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>default_index</name> <operator>=</operator> <call><name>merge_partition_with_dummy</name><argument_list>(<argument><expr><name>inner_map</name></expr></argument>,
															<argument><expr><name>inner_default</name></expr></argument>,
															<argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>==</operator> <name>inner_merged_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_has_default</name> <operator>&amp;&amp;</operator> <name>inner_has_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The default partitions have to be joined with each other, so merge
		 * them.  Note that each of the default partitions isn't merged yet
		 * (see, process_outer_partition()/process_innerer_partition()), so
		 * they should be merged successfully.  The merged partition will act
		 * as the default partition of the join relation.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_merged_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>default_index</name> <operator>=</operator> <call><name>merge_matching_partitions</name><argument_list>(<argument><expr><name>outer_map</name></expr></argument>,
												   <argument><expr><name>inner_map</name></expr></argument>,
												   <argument><expr><name>outer_default</name></expr></argument>,
												   <argument><expr><name>inner_default</name></expr></argument>,
												   <argument><expr><name>next_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>default_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * merge_partition_with_dummy
 *		Assign given partition a new partition of a join relation
 *
 * Note: The caller assumes that the given partition doesn't have a non-dummy
 * matching partition on the other side, but if the given partition finds the
 * matching partition later, we will adjust the assignment.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>merge_partition_with_dummy</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>merged_index</name> <init>= <expr><operator>*</operator><name>next_index</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>map</name><operator>-&gt;</operator><name>merged</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>merged_index</name></expr>;</expr_stmt>
	<comment type="block">/* Leave the merged flag alone! */</comment>
	<expr_stmt><expr><operator>*</operator><name>next_index</name> <operator>=</operator> <operator>*</operator><name>next_index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>merged_index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fix_merged_indexes
 *		Adjust merged indexes of re-merged partitions
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fix_merged_indexes</name><parameter_list>(<parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>, <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nmerged</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merged_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>new_indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>merged_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nmerged</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_indexes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nmerged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmerged</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>new_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Build the mapping of old merged indexes to new merged indexes. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>outer_map</name><operator>-&gt;</operator><name>did_remapping</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>old_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>new_indexes</name><index>[<expr><name>merged_index</name></expr>]</index></name> <operator>=</operator> <name><name>outer_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>inner_map</name><operator>-&gt;</operator><name>did_remapping</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>old_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>new_indexes</name><index>[<expr><name>merged_index</name></expr>]</index></name> <operator>=</operator> <name><name>inner_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fix the merged_indexes list using the mapping. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>merged_indexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>merged_index</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>new_indexes</name><index>[<expr><name>merged_index</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>new_indexes</name><index>[<expr><name>merged_index</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * generate_matching_part_pairs
 *		Generate a pair of lists of partitions that produce merged partitions
 *
 * The lists of partitions are built in the order of merged partition indexes,
 * and returned in *outer_parts and *inner_parts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_matching_part_pairs</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
							 <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>outer_map</name></decl></parameter>, <parameter><decl><type><name>PartitionMap</name> <modifier>*</modifier></type><name>inner_map</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>nmerged</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>outer_parts</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>inner_parts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>outer_nparts</name> <init>= <expr><name><name>outer_map</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inner_nparts</name> <init>= <expr><name><name>inner_map</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>outer_indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>inner_indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_nparts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nmerged</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>inner_parts</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>outer_indexes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nmerged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_indexes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nmerged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmerged</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>outer_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>inner_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Set pairs of matching partitions. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_nparts</name> <operator>==</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_nparts</name> <operator>==</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_nparts</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>outer_nparts</name></expr></argument>, <argument><expr><name>inner_nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>outer_nparts</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>merged_index</name> <init>= <expr><name><name>outer_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>merged_index</name> <operator>&lt;</operator> <name>nmerged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outer_indexes</name><index>[<expr><name>merged_index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>inner_nparts</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>merged_index</name> <init>= <expr><name><name>inner_map</name><operator>-&gt;</operator><name>merged_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>merged_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>merged_index</name> <operator>&lt;</operator> <name>nmerged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inner_indexes</name><index>[<expr><name>merged_index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Build the list pairs. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmerged</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>outer_index</name> <init>= <expr><name><name>outer_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>inner_index</name> <init>= <expr><name><name>inner_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If both partitions are dummy, it means the merged partition that
		 * had been assigned to the outer/inner partition was removed when
		 * re-merging the outer/inner partition in
		 * merge_matching_partitions(); ignore the merged partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>outer_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>inner_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>outer_parts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>outer_parts</name></expr></argument>, <argument><expr><ternary><condition><expr><name>outer_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then>
							   <expr><name><name>outer_rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>outer_index</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inner_parts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>inner_parts</name></expr></argument>, <argument><expr><ternary><condition><expr><name>inner_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then>
							   <expr><name><name>inner_rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>inner_index</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outer_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>inner_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * build_merged_partition_bounds
 *		Create a PartitionBoundInfo struct from merged partition bounds
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionBoundInfo</name></type>
<name>build_merged_partition_bounds</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merged_datums</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merged_kinds</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merged_indexes</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>null_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>default_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>merged_bounds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>merged_datums</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>merged_bounds</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundInfo</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name>ndatums</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>merged_datums</argument>)</argument_list></macro>
		<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>merged_kinds</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>merged_kinds</argument>)</argument_list></macro>
			<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* There are ndatums+1 indexes in the case of range partitioning. */</comment>
		<expr_stmt><expr><name>merged_indexes</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>merged_indexes</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndatums</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>merged_kinds</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>merged_indexes</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>nindexes</name></name> <operator>=</operator> <name>ndatums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>merged_indexes</argument>)</argument_list></macro>
		<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <name>null_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>merged_bounds</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <name>default_index</name></expr>;</expr_stmt>

	<return>return <expr><name>merged_bounds</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_range_partition
 *		Get the next non-dummy partition of a range-partitioned relation,
 *		returning the index of that partition
 *
 * *lb and *ub are set to the lower and upper bounds of that partition
 * respectively, and *lb_pos is advanced to the next lower bound, if any.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_range_partition</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>bi</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb_pos</name></decl></parameter>,
					<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
					<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>ub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>part_index</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bi</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>part_index</name> <operator>=</operator> <call><name>get_range_partition_internal</name><argument_list>(<argument><expr><name>bi</name></expr></argument>, <argument><expr><name>lb_pos</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>, <argument><expr><name>ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>part_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><call><name>is_dummy_partition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>part_index</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

	<return>return <expr><name>part_index</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_range_partition_internal</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>bi</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb_pos</name></decl></parameter>,
							 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>,
							 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>ub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Return the index as -1 if we've exhausted all lower bounds. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>lb_pos</name> <operator>&gt;=</operator> <name><name>bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* A lower bound should have at least one more bound after it. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>lb_pos</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the lower bound. */</comment>
	<expr_stmt><expr><name><name>lb</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>bi</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><operator>*</operator><name>lb_pos</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lb</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <name><name>bi</name><operator>-&gt;</operator><name>datums</name><index>[<expr><operator>*</operator><name>lb_pos</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lb</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name><name>bi</name><operator>-&gt;</operator><name>kind</name><index>[<expr><operator>*</operator><name>lb_pos</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lb</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* Set the upper bound. */</comment>
	<expr_stmt><expr><name><name>ub</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>bi</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><operator>*</operator><name>lb_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ub</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <name><name>bi</name><operator>-&gt;</operator><name>datums</name><index>[<expr><operator>*</operator><name>lb_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ub</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name><name>bi</name><operator>-&gt;</operator><name>kind</name><index>[<expr><operator>*</operator><name>lb_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ub</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* The index assigned to an upper bound should be valid. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ub</name><operator>-&gt;</operator><name>index</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advance the position to the next lower bound.  If there are no bounds
	 * left beyond the upper bound, we have reached the last lower bound.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>lb_pos</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name><name>bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lb_pos</name> <operator>=</operator> <name><name>bi</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If the index assigned to the bound next to the upper bound isn't
		 * valid, that is the next lower bound; else, the upper bound is also
		 * the lower bound of the next range partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>bi</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><operator>*</operator><name>lb_pos</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>lb_pos</name> <operator>=</operator> <operator>*</operator><name>lb_pos</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>lb_pos</name> <operator>=</operator> <operator>*</operator><name>lb_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name><name>ub</name><operator>-&gt;</operator><name>index</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compare_range_partitions
 *		Compare the bounds of two range partitions, and return true if the
 *		two partitions overlap, false otherwise
 *
 * *lb_cmpval is set to -1, 0, or 1 if the outer partition's lower bound is
 * lower than, equal to, or higher than the inner partition's lower bound
 * respectively.  Likewise, *ub_cmpval is set to -1, 0, or 1 if the outer
 * partition's upper bound is lower than, equal to, or higher than the inner
 * partition's upper bound respectively.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>compare_range_partitions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfuncs</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollations</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>outer_lb</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>outer_ub</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>inner_lb</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>inner_ub</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lb_cmpval</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ub_cmpval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Check if the outer partition's upper bound is lower than the inner
	 * partition's lower bound; if so the partitions aren't overlapping.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>compare_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
							 <argument><expr><name>outer_ub</name></expr></argument>, <argument><expr><name>inner_lb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>lb_cmpval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ub_cmpval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if the outer partition's lower bound is higher than the inner
	 * partition's upper bound; if so the partitions aren't overlapping.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>compare_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
							 <argument><expr><name>outer_lb</name></expr></argument>, <argument><expr><name>inner_ub</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>lb_cmpval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ub_cmpval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* All other cases indicate overlapping partitions. */</comment>
	<expr_stmt><expr><operator>*</operator><name>lb_cmpval</name> <operator>=</operator> <call><name>compare_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
									  <argument><expr><name>outer_lb</name></expr></argument>, <argument><expr><name>inner_lb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ub_cmpval</name> <operator>=</operator> <call><name>compare_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
									  <argument><expr><name>outer_ub</name></expr></argument>, <argument><expr><name>inner_ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_merged_range_bounds
 *		Given the bounds of range partitions to be joined, determine the bounds
 *		of a merged partition produced from the range partitions
 *
 * *merged_lb and *merged_ub are set to the lower and upper bounds of the
 * merged partition.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_merged_range_bounds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfuncs</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollations</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>outer_lb</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>outer_ub</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>inner_lb</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>inner_ub</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>lb_cmpval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ub_cmpval</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>merged_lb</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>merged_ub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>compare_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
								<argument><expr><name>outer_lb</name></expr></argument>, <argument><expr><name>inner_lb</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>lb_cmpval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>compare_range_bounds</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
								<argument><expr><name>outer_ub</name></expr></argument>, <argument><expr><name>inner_ub</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ub_cmpval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>

			<comment type="block">/*
			 * An INNER/SEMI join will have the rows that fit both sides, so
			 * the lower bound of the merged partition will be the higher of
			 * the two lower bounds, and the upper bound of the merged
			 * partition will be the lower of the two upper bounds.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>merged_lb</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lb_cmpval</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>*</operator><name>outer_lb</name></expr> </then><else>: <expr><operator>*</operator><name>inner_lb</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>merged_ub</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>ub_cmpval</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>*</operator><name>outer_ub</name></expr> </then><else>: <expr><operator>*</operator><name>inner_ub</name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>

			<comment type="block">/*
			 * A LEFT/ANTI join will have all the rows from the outer side, so
			 * the bounds of the merged partition will be the same as the
			 * outer bounds.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>merged_lb</name> <operator>=</operator> <operator>*</operator><name>outer_lb</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>merged_ub</name> <operator>=</operator> <operator>*</operator><name>outer_ub</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>JOIN_FULL</name></expr>:</case>

			<comment type="block">/*
			 * A FULL join will have all the rows from both sides, so the
			 * lower bound of the merged partition will be the lower of the
			 * two lower bounds, and the upper bound of the merged partition
			 * will be the higher of the two upper bounds.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>merged_lb</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lb_cmpval</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>*</operator><name>outer_lb</name></expr> </then><else>: <expr><operator>*</operator><name>inner_lb</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>merged_ub</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>ub_cmpval</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>*</operator><name>outer_ub</name></expr> </then><else>: <expr><operator>*</operator><name>inner_ub</name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * add_merged_range_bounds
 *		Add the bounds of a merged partition to the lists of range bounds
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_merged_range_bounds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfuncs</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollations</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>merged_lb</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>merged_ub</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>merged_index</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>merged_datums</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>merged_kinds</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>merged_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmpval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>merged_datums</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First merged partition */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>*</operator><name>merged_kinds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>*</operator><name>merged_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionRangeBound</name></type> <name>prev_ub</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>merged_datums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>merged_kinds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>merged_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the last upper bound. */</comment>
		<expr_stmt><expr><name><name>prev_ub</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>llast_int</name><argument_list>(<argument><expr><operator>*</operator><name>merged_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_ub</name><operator>.</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><operator>*</operator><name>merged_datums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_ub</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><operator>*</operator><name>merged_kinds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prev_ub</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We pass to partition_rbound_cmp() lower1 as false to prevent it
		 * from considering the last upper bound to be smaller than the lower
		 * bound of the merged partition when the values of the two range
		 * bounds compare equal.
		 */</comment>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfuncs</name></expr></argument>, <argument><expr><name>partcollations</name></expr></argument>,
									  <argument><expr><name><name>merged_lb</name><operator>-&gt;</operator><name>datums</name></name></expr></argument>, <argument><expr><name><name>merged_lb</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev_ub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cmpval</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the lower bound is higher than the last upper bound, add the lower
	 * bound with the index as -1 indicating that that is a lower bound; else,
	 * the last upper bound will be reused as the lower bound of the merged
	 * partition, so skip this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>merged_datums</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>merged_datums</name></expr></argument>, <argument><expr><name><name>merged_lb</name><operator>-&gt;</operator><name>datums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>merged_kinds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>merged_kinds</name></expr></argument>, <argument><expr><name><name>merged_lb</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>merged_indexes</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>merged_indexes</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the upper bound and index of the merged partition. */</comment>
	<expr_stmt><expr><operator>*</operator><name>merged_datums</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>merged_datums</name></expr></argument>, <argument><expr><name><name>merged_ub</name><operator>-&gt;</operator><name>datums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>merged_kinds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>merged_kinds</name></expr></argument>, <argument><expr><name><name>merged_ub</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>merged_indexes</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>merged_indexes</name></expr></argument>, <argument><expr><name>merged_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * partitions_are_ordered
 *		Determine whether the partitions described by 'boundinfo' are ordered,
 *		that is partitions appearing earlier in the PartitionDesc sequence
 *		contain partition keys strictly less than those appearing later.
 *		Also, if NULL values are possible, they must come in the last
 *		partition defined in the PartitionDesc.
 *
 * If out of order, or there is insufficient info to know the order,
 * then we return false.
 */</comment>
<function><type><name>bool</name></type>
<name>partitions_are_ordered</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nparts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>boundinfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>

			<comment type="block">/*
			 * RANGE-type partitioning guarantees that the partitions can be
			 * scanned in the order that they're defined in the PartitionDesc
			 * to provide sequential, non-overlapping ranges of tuples.
			 * However, if a DEFAULT partition exists then it doesn't work, as
			 * that could contain tuples from either below or above the
			 * defined range, or tuples belonging to gaps between partitions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>

			<comment type="block">/*
			 * LIST partitioning can also guarantee ordering, but only if the
			 * partitions don't accept interleaved values.  We could likely
			 * check for this by looping over the PartitionBound's indexes
			 * array to check that the indexes are in order.  For now, let's
			 * just keep it simple and just accept LIST partitioning when
			 * there's no DEFAULT partition, exactly one value per partition,
			 * and optionally a NULL partition that does not accept any other
			 * values.  Such a NULL partition will come last in the
			 * PartitionDesc, and the other partitions will be properly
			 * ordered.  This is a cheap test to make as it does not require
			 * any per-partition processing.  Maybe we'd like to handle more
			 * complex cases in the future.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>+</operator> <call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call>
				<operator>==</operator> <name>nparts</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* HASH, or some other strategy */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_new_partition_bound
 *
 * Checks if the new partition's bound overlaps any of the existing partitions
 * of parent.  Also performs additional checks as necessary per strategy.
 */</comment>
<function><type><name>void</name></type>
<name>check_new_partition_bound</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
						  <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>with</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>overlap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The default partition bound never conflicts with any other
		 * partition's; if that's what we're attaching, the only possible
		 * problem is that one already exists, so check for that and we're
		 * done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>boundinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Default partition already exists, error out. */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition \"%s\" conflicts with existing default partition \"%s\""</literal></expr></argument>,
						<argument><expr><name>relname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Datum</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>datums</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>valid_modulus</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>prev_modulus</name></decl>,	<comment type="block">/* Previous largest modulus */</comment>
								<decl><type ref="prev"/><name>next_modulus</name></decl>;</decl_stmt>	<comment type="block">/* Next largest modulus */</comment>

					<comment type="block">/*
					 * Check rule that every modulus must be a factor of the
					 * next larger modulus.  For example, if you have a bunch
					 * of partitions that all have modulus 5, you can add a
					 * new partition with modulus 10 or a new partition with
					 * modulus 15, but you cannot add both a partition with
					 * modulus 10 and a partition with modulus 15, because 10
					 * is not a factor of 15.
					 *
					 * Get the greatest (modulus, remainder) pair contained in
					 * boundinfo-&gt;datums that is less than or equal to the
					 * (spec-&gt;modulus, spec-&gt;remainder) pair.
					 */</comment>
					<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>partition_hash_bsearch</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>,
													<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>,
													<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>next_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>valid_modulus</name> <operator>=</operator> <operator>(</operator><name>next_modulus</name> <operator>%</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>prev_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><name>offset</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>valid_modulus</name> <operator>=</operator> <operator>(</operator><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name> <operator>%</operator> <name>prev_modulus</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>valid_modulus</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>ndatums</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>next_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>valid_modulus</name> <operator>=</operator> <operator>(</operator><name>next_modulus</name> <operator>%</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_modulus</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"every hash partition modulus must be a factor of the next larger modulus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>greatest_modulus</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>nindexes</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Normally, the lowest remainder that could conflict with
					 * the new partition is equal to the remainder specified
					 * for the new partition, but when the new partition has a
					 * modulus higher than any used so far, we need to adjust.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>&gt;=</operator> <name>greatest_modulus</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name>remainder</name> <operator>%</operator> <name>greatest_modulus</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Check every potentially-conflicting remainder. */</comment>
					<do>do
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>remainder</name> <operator>+=</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr>;</expr_stmt>
					</block_content>}</block> while <condition>(<expr><name>remainder</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>)</condition>;</do>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>boundinfo</name> <operator>&amp;&amp;</operator>
						   <name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>&amp;&amp;</operator>
						   <operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
							<call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
															<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
															<argument><expr><name>boundinfo</name></expr></argument>,
															<argument><expr><name><name>val</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>equal</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lower</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>upper</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lower</name> <operator>=</operator> <call><name>make_one_partition_rbound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>upper</name> <operator>=</operator> <call><name>make_one_partition_rbound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * First check if the resulting range would be empty with
				 * specified lower and upper bounds
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
										 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>, <argument><expr><name><name>lower</name><operator>-&gt;</operator><name>datums</name></name></expr></argument>,
										 <argument><expr><name><name>lower</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"empty range bound specified for partition \"%s\""</literal></expr></argument>,
									<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Specified lower bound %s is greater than or equal to upper bound %s."</literal></expr></argument>,
									   <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>boundinfo</name> <operator>&amp;&amp;</operator>
						   <name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name> <operator>&amp;&amp;</operator>
						   <operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Test whether the new lower bound (which is treated
					 * inclusively as part of the new partition) lies inside
					 * an existing partition, or in a gap.
					 *
					 * If it's inside an existing partition, the bound at
					 * offset + 1 will be the upper bound of that partition,
					 * and its index will be &gt;= 0.
					 *
					 * If it's in a gap, the bound at offset + 1 will be the
					 * lower bound of the next partition, and its index will
					 * be -1. This is also true if there is no next partition,
					 * since the index array is initialised with an extra -1
					 * at the end.
					 */</comment>
					<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>partition_range_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
													 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
													 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
													 <argument><expr><name>boundinfo</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Check that the new partition will fit in the gap.
						 * For it to fit, the new upper bound must be less
						 * than or equal to the lower bound of the next
						 * partition, if there is one.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>datums</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>is_lower</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>datums</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>kind</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>is_lower</name> <operator>=</operator> <operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

							<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
														  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
														  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
														  <argument><expr><name>datums</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
														  <argument><expr><name>is_lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/*
								 * The new partition overlaps with the
								 * existing partition between offset + 1 and
								 * offset + 2.
								 */</comment>
								<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * The new partition overlaps with the existing
						 * partition between offset and offset + 1.
						 */</comment>
						<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>overlap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>with</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition \"%s\" would overlap partition \"%s\""</literal></expr></argument>,
						<argument><expr><name>relname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>with</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_default_partition_contents
 *
 * This function checks if there exists a row in the default partition that
 * would properly belong to the new partition being added.  If it finds one,
 * it throws an error.
 */</comment>
<function><type><name>void</name></type>
<name>check_default_partition_contents</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>default_rel</name></decl></parameter>,
								 <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>new_spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_part_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>def_part_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>all_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new_part_constraints</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>new_spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name><operator>)</operator></expr>
		?</condition><then> <expr><call><name>get_qual_for_list</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>new_spec</name></expr></argument>)</argument_list></call></expr>
		</then><else>: <expr><call><name>get_qual_for_range</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>new_spec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>def_part_constraints</name> <operator>=</operator>
		<call><name>get_proposed_default_constraint</name><argument_list>(<argument><expr><name>new_part_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Map the Vars in the constraint expression from parent's attnos to
	 * default_rel's.
	 */</comment>
	<expr_stmt><expr><name>def_part_constraints</name> <operator>=</operator>
		<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>def_part_constraints</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>default_rel</name></expr></argument>,
								<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the existing constraints on the default partition imply that it will
	 * not contain any row that would belong to the new partition, we can
	 * avoid scanning the default partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>, <argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" is implied by existing constraints"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Scan the default partition and its subpartitions, and check for rows
	 * that do not satisfy the revised partition constraints.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>default_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>all_parts</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>all_parts</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>all_parts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>part_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>part_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>partition_constraint</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>partqualstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupslot</name></decl>;</decl_stmt>

		<comment type="block">/* Lock already taken above. */</comment>
		<if_stmt><if>if <condition>(<expr><name>part_relid</name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>part_relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Map the Vars in the constraint expression from default_rel's
			 * the sub-partition's.
			 */</comment>
			<expr_stmt><expr><name>partition_constraint</name> <operator>=</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partition_constraint</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
				<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>partition_constraint</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the partition constraints on default partition child imply
			 * that it will not contain any row that would belong to the new
			 * partition, we can avoid scanning the child table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PartConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>,
													 <argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" is implied by existing constraints"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <name>default_rel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>partition_constraint</name> <operator>=</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Only RELKIND_RELATION relations (i.e. leaf partitions) need to be
		 * scanned.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>part_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>part_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipped scanning foreign table \"%s\" which is a partition of default partition \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build expression execution states for partition check quals */</comment>
		<expr_stmt><expr><name>partqualstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>partition_constraint</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupslot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Switch to per-tuple memory context and reset it for each tuple
		 * produced, so we don't leak memory.
		 */</comment>
		<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>tupslot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>tupslot</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>partqualstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" would be violated by some row"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errtable</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* keep the lock until commit */</comment>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * get_hash_partition_greatest_modulus
 *
 * Returns the greatest modulus of the hash partition bound.
 * This is no longer used in the core code, but we keep it around
 * in case external modules are using it.
 */</comment>
<function><type><name>int</name></type>
<name>get_hash_partition_greatest_modulus</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bound</name> <operator>&amp;&amp;</operator> <name><name>bound</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>bound</name><operator>-&gt;</operator><name>nindexes</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_one_partition_rbound
 *
 * Return a PartitionRangeBound given a list of PartitionRangeDatum elements
 * and a flag telling whether the bound is lower or not.  Made into a function
 * because there are multiple sites that want to use this facility.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionRangeBound</name> <modifier>*</modifier></type>
<name>make_one_partition_rbound</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>datums</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lower</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>bound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datums</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bound</name> <operator>=</operator> <operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator>
													  <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>datums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>datum</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* What's contained in this range datum? */</comment>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>datum</name><operator>-&gt;</operator><name>kind</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid range bound datum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>bound</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_rbound_cmp
 *
 * Return for two range bounds whether the 1st one (specified in datums1,
 * kind1, and lower1) is &lt;, =, or &gt; the bound specified in *b2.
 *
 * partnatts, partsupfunc and partcollation give the number of attributes in the
 * bounds to be compared, comparison function to be used and the collations of
 * attributes, respectively.
 *
 * Note that if the values of the two range bounds compare equal, then we take
 * into account whether they are upper or lower bounds, and an upper bound is
 * considered to be smaller than a lower bound. This is important to the way
 * that RelationBuildPartitionDesc() builds the PartitionBoundInfoData
 * structure, which only stores the upper bound of a common boundary between
 * two contiguous partitions.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datums1</name></decl></parameter>, <parameter><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind1</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>lower1</name></decl></parameter>, <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* placate compiler */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>datums2</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>datums</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind2</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>kind</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lower2</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>lower</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * First, handle cases where the column is unbounded, which should not
		 * invoke the comparison procedure, and should not consider any later
		 * columns. Note that the PartitionRangeDatumKind enum elements
		 * compare the same way as the values they represent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>kind1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>kind2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>kind1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>kind2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>kind1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>

			<comment type="block">/*
			 * The column bounds are both MINVALUE or both MAXVALUE. No later
			 * columns should be considered, but we still need to compare
			 * whether they are upper or lower bounds.
			 */</comment>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>datums1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>datums2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If the comparison is anything other than equal, we're done. If they
	 * compare equal though, we still have to consider whether the boundaries
	 * are inclusive or exclusive.  Exclusive one is considered smaller of the
	 * two.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lower1</name> <operator>!=</operator> <name>lower2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <ternary><condition><expr><name>lower1</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>cmpval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_rbound_datum_cmp
 *
 * Return whether range bound (specified in rb_datums and rb_kind)
 * is &lt;, =, or &gt; partition key of tuple (tuple_datums)
 *
 * n_tuple_datums, partsupfunc and partcollation give number of attributes in
 * the bounds to be compared, comparison function to be used and the collations
 * of attributes resp.
 *
 */</comment>
<function><type><name>int32</name></type>
<name>partition_rbound_datum_cmp</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>rb_datums</name></decl></parameter>, <parameter><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>rb_kind</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>tuple_datums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_tuple_datums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_tuple_datums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rb_kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rb_kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>rb_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>tuple_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>cmpval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_hbound_cmp
 *
 * Compares modulus first, then remainder if modulus is equal.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>modulus1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>modulus2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>modulus1</name> <operator>&lt;</operator> <name>modulus2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>modulus1</name> <operator>&gt;</operator> <name>modulus2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>modulus1</name> <operator>==</operator> <name>modulus2</name> <operator>&amp;&amp;</operator> <name>remainder1</name> <operator>!=</operator> <name>remainder2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name>remainder1</name> <operator>&gt;</operator> <name>remainder2</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_list_bsearch
 *		Returns the index of the greatest bound datum that is less than equal
 * 		to the given value or -1 if all of the bound datums are greater
 *
 * *is_equal is set to true if the bound datum at the returned index is equal
 * to the input value.
 */</comment>
<function><type><name>int</name></type>
<name>partition_list_bsearch</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_equal</name> <operator>=</operator> <operator>(</operator><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_equal</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_range_bsearch
 *		Returns the index of the greatest range bound that is less than or
 *		equal to the given range bound or -1 if all of the range bounds are
 *		greater
 *
 * *is_equal is set to true if the range bound at the returned index is equal
 * to the input range bound
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>partition_range_bsearch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
						<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>probe</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>,
									  <argument><expr><name>partcollation</name></expr></argument>,
									  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
									  <argument><expr><operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>mid</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,
									  <argument><expr><name>probe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_equal</name> <operator>=</operator> <operator>(</operator><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_equal</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_range_bsearch
 *		Returns the index of the greatest range bound that is less than or
 *		equal to the given tuple or -1 if all of the range bounds are greater
 *
 * *is_equal is set to true if the range bound at the returned index is equal
 * to the input tuple.
 */</comment>
<function><type><name>int</name></type>
<name>partition_range_datum_bsearch</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
							  <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
											<argument><expr><name>partcollation</name></expr></argument>,
											<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
											<argument><expr><name>values</name></expr></argument>,
											<argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_equal</name> <operator>=</operator> <operator>(</operator><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_equal</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_hash_bsearch
 *		Returns the index of the greatest (modulus, remainder) pair that is
 *		less than or equal to the given (modulus, remainder) pair or -1 if
 *		all of them are greater
 */</comment>
<function><type><name>int</name></type>
<name>partition_hash_bsearch</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>modulus</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>,
					<decl><type ref="prev"/><name>bound_modulus</name></decl>,
					<decl><type ref="prev"/><name>bound_remainder</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>bound_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bound_remainder</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_hbound_cmp</name><argument_list>(<argument><expr><name>bound_modulus</name></expr></argument>, <argument><expr><name>bound_remainder</name></expr></argument>,
									  <argument><expr><name>modulus</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_partition_hbound_cmp
 *
 * Hash bounds are sorted by modulus, then by remainder.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionHashBound</name> <modifier>*</modifier></type><name>h1</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionHashBound</name> <modifier>*</modifier></type><name>h2</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>partition_hbound_cmp</name><argument_list>(<argument><expr><name><name>h1</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>, <argument><expr><name><name>h1</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>,
								<argument><expr><name><name>h2</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>, <argument><expr><name><name>h2</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_partition_list_value_cmp
 *
 * Compare two list partition bound datums.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_partition_list_value_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val1</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionListValue</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>,
				<decl><type ref="prev"/><name>val2</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionListValue</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>PartitionKey</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
										   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
										   <argument><expr><name>val1</name></expr></argument>, <argument><expr><name>val2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_partition_rbound_cmp
 *
 * Used when sorting range bounds across all range partitions.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b1</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b2</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>PartitionKey</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
								<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>, <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>datums</name></name></expr></argument>, <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>,
								<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_operator
 *
 * Return oid of the operator of the given strategy for the given partition
 * key column.  It is assumed that the partitioning key is of the same type as
 * the chosen partitioning opclass, or at least binary-compatible.  In the
 * latter case, *need_relabel is set to true if the opclass is not of a
 * polymorphic type (indicating a RelabelType node needed on top), otherwise
 * false.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_partition_operator</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_relabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operoid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the operator in the partitioning opfamily using the opclass'
	 * declared input type as both left- and righttype.
	 */</comment>
	<expr_stmt><expr><name>operoid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in partition opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the partition key column is not of the same type as the operator
	 * class and not polymorphic, tell caller to wrap the non-Const expression
	 * in a RelabelType.  This matches what parse_coerce.c does.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>need_relabel</name> <operator>=</operator> <operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>col</name></expr>]</index></name> <operator>!=</operator> <name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name> <operator>&amp;&amp;</operator>
					 <name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name> <operator>!=</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
					 <operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>operoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_partition_op_expr
 *		Returns an Expr for the given partition key column with arg1 and
 *		arg2 as its leftop and rightop, respectively
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>make_partition_op_expr</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
					   <parameter><decl><type><name>uint16</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_relabel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get the correct btree operator for this partitioning column */</comment>
	<expr_stmt><expr><name>operoid</name> <operator>=</operator> <call><name>get_partition_operator</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>keynum</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>need_relabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Chosen operator may be such that the non-Const operand needs to be
	 * coerced, so apply the same; see the comment in
	 * get_partition_operator().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>need_relabel</name> <operator>||</operator>
		 <name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name> <operator>!=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>keynum</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>,
										<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Generate the actual expression */</comment>
	<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elems</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>arg2</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>elems</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nelems</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keynum</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>type_is_array</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrexpr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saopexpr</name></decl>;</decl_stmt>

					<comment type="block">/* Construct an ArrayExpr for the right-hand inputs */</comment>
					<expr_stmt><expr><name>arrexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator>
						<call><name>get_array_type</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>array_collid</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>keynum</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>keynum</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>elems</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<comment type="block">/* Build leftop = ANY (rightop) */</comment>
					<expr_stmt><expr><name>saopexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>operoid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>useOr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arrexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>saopexpr</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemops</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>elems</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>,
								   <decl><type ref="prev"><modifier>*</modifier></type><name>elemop</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>elemop</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>,
											   <argument><expr><name>BOOLOID</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>,
											   <argument><expr><name>InvalidOid</name></expr></argument>,
											   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>elemops</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elemops</name></expr></argument>, <argument><expr><name>elemop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>nelems</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>elemops</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>elemops</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>,
								   <argument><expr><name>BOOLOID</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>,
								   <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>,
								   <argument><expr><name>InvalidOid</name></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partitioning strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_for_hash
 *
 * Returns a CHECK constraint expression to use as a hash partition's
 * constraint, given the parent relation and partition bound structure.
 *
 * The partition constraint for a hash partition is always a call to the
 * built-in function satisfies_hash_partition().
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_qual_for_hash</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>relidConst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>modulusConst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>remainderConst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexprs_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Fixed arguments. */</comment>
	<expr_stmt><expr><name>relidConst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>,
									<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>modulusConst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
									  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>InvalidOid</name></expr></argument>,
									  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>remainderConst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>relidConst</name></expr></argument>, <argument><expr><name>modulusConst</name></expr></argument>, <argument><expr><name>remainderConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add an argument for each key column. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>

		<comment type="block">/* Left operand */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>, <argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>keyCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>F_SATISFIES_HASH_PARTITION</name></expr></argument>,
						 <argument><expr><name>BOOLOID</name></expr></argument>,
						 <argument><expr><name>args</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_for_list
 *
 * Returns an implicit-AND list of expressions to use as a list partition's
 * constraint, given the parent relation and partition bound structure.
 *
 * The function returns NIL for a default partition when it's the only
 * partition since in that case there is no constraint.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_qual_for_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>opexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nulltest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>list_has_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only single-column list partitioning is supported, so we are worried
	 * only about the partition key with index 0.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct Var or expression representing the partition column */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For default list partition, collect datums for all the partitions. The
	 * default partition constraint should check that the partition key is
	 * equal to none of those.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>pdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>pdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>boundinfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>list_has_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If default is the only partition, there need not be any partition
		 * constraint on it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ndatums</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>list_has_null</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Construct Const from known-not-null datum.  We must be careful
			 * to copy the value, because our result has to be able to outlive
			 * the relcache entry we're copying from.
			 */</comment>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><call><name>datumCopy</name><argument_list>(<argument><expr><operator>*</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* isnull */</comment>
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Create list of Consts for the allowed values, excluding any nulls.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>list_has_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>elems</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Generate the operator expression from the non-null partition
		 * values.
		 */</comment>
		<expr_stmt><expr><name>opexpr</name> <operator>=</operator> <call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
										<argument><expr><name>keyCol</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If there are no partition values, we don't need an operator
		 * expression.
		 */</comment>
		<expr_stmt><expr><name>opexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list_has_null</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Gin up a "col IS NOT NULL" test that will be AND'd with the main
		 * expression.  This might seem redundant, but the partition routing
		 * machinery needs it.
		 */</comment>
		<expr_stmt><expr><name>nulltest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>keyCol</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>opexpr</name></expr> ?</condition><then> <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>, <argument><expr><name>opexpr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Gin up a "col IS NULL" test that will be OR'd with the main
		 * expression.
		 */</comment>
		<expr_stmt><expr><name>nulltest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>keyCol</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>opexpr</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>or</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>or</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>, <argument><expr><name>opexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Note that, in general, applying NOT to a constraint expression doesn't
	 * necessarily invert the set of rows it accepts, because NOT (NULL) is
	 * NULL.  However, the partition constraints we construct here never
	 * evaluate to NULL, so applying NOT works as intended.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_for_range
 *
 * Returns an implicit-AND list of expressions to use as a range partition's
 * constraint, given the parent relation and partition bound structure.
 *
 * For a multi-column range partition key, say (a, b, c), with (al, bl, cl)
 * as the lower bound tuple and (au, bu, cu) as the upper bound tuple, we
 * generate an expression tree of the following form:
 *
 *	(a IS NOT NULL) and (b IS NOT NULL) and (c IS NOT NULL)
 *		AND
 *	(a &gt; al OR (a = al AND b &gt; bl) OR (a = al AND b = bl AND c &gt;= cl))
 *		AND
 *	(a &lt; au OR (a = au AND b &lt; bu) OR (a = au AND b = bu AND c &lt; cu))
 *
 * It is often the case that a prefix of lower and upper bound tuples contains
 * the same values, for example, (al = au), in which case, we will emit an
 * expression tree of the following form:
 *
 *	(a IS NOT NULL) and (b IS NOT NULL) and (c IS NOT NULL)
 *		AND
 *	(a = al)
 *		AND
 *	(b &gt; bl OR (b = bl AND c &gt;= cl))
 *		AND
 *	(b &lt; bu OR (b = bu AND c &lt; cu))
 *
 * If a bound datum is either MINVALUE or MAXVALUE, these expressions are
 * simplified using the fact that any value is greater than MINVALUE and less
 * than MAXVALUE. So, for example, if cu = MAXVALUE, c &lt; cu is automatically
 * true, and we need not emit any expression for it, and the last line becomes
 *
 *	(b &lt; bu) OR (b = bu), which is simplified to (b &lt;= bu)
 *
 * In most common cases with only one partition column, say a, the following
 * expression tree will be generated: a IS NOT NULL AND a &gt;= al AND a &lt; au
 *
 * For default partition, it returns the negation of the constraints of all
 * the other partitions.
 *
 * External callers should pass for_default as false; we set it to true only
 * when recursing.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_qual_for_range</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>for_default</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cell2</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>partexprs_item</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>partexprs_item_saved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>udatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>lower_val</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>upper_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lower_or_arms</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>upper_or_arms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_or_arms</name></decl>,
				<decl><type ref="prev"/><name>current_or_arm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lower_or_start_datum</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>upper_or_start_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_next_lower_arm</name></decl>,
				<decl><type ref="prev"/><name>need_next_upper_arm</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>or_expr_args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>pdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>inhoids</name> <init>= <expr><name><name>pdesc</name><operator>-&gt;</operator><name>oids</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>pdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>,
					<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>inhrelid</name> <init>= <expr><name><name>inhoids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>bspec</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null relpartbound for relation %u"</literal></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>bspec</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundSpec</name> <operator>*</operator><operator>)</operator>
				<call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>bspec</name></expr></argument>, <argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected PartitionBoundSpec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bspec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>part_qual</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>part_qual</name> <operator>=</operator> <call><name>get_qual_for_range</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bspec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * AND the constraints of the partition and add to
				 * or_expr_args
				 */</comment>
				<expr_stmt><expr><name>or_expr_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>or_expr_args</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>part_qual</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
									   ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>part_qual</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
									   </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>part_qual</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>or_expr_args</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>other_parts_constr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Combine the constraints obtained for non-default partitions
			 * using OR.  As requested, each of the OR's args doesn't include
			 * the NOT NULL test for partition keys (which is to avoid its
			 * useless repetition).  Add the same now.
			 */</comment>
			<expr_stmt><expr><name>other_parts_constr</name> <operator>=</operator>
				<call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>,
							 <argument><expr><call><name>lappend</name><argument_list>(<argument><expr><call><name>get_range_nulltest</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>or_expr_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
									 ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>or_expr_args</name></expr></argument>,
													<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
									 </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>or_expr_args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Finally, the default partition contains everything *NOT*
			 * contained in the non-default partitions.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>,
											 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>other_parts_constr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lower_or_start_datum</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>upper_or_start_datum</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_or_arms</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it is the recursive call for default, we skip the get_range_nulltest
	 * to avoid accumulating the NullTest on the same keys for each partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>for_default</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_range_nulltest</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Iterate over the key columns and check if the corresponding lower and
	 * upper datums are equal using the btree equality operator for the
	 * column's type.  If equal, we emit single keyCol = common_value
	 * expression.  Starting from the first column for which the corresponding
	 * lower and upper bound datums are not equal, we generate OR expressions
	 * as shown in the function's header comment.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs_item_saved</name> <operator>=</operator> <name>partexprs_item</name></expr>;</expr_stmt>	<comment type="block">/* placate compiler */</comment>
	<macro><name>forboth</name><argument_list>(<argument>cell1</argument>, <argument>spec-&gt;lowerdatums</argument>, <argument>cell2</argument>, <argument>spec-&gt;upperdatums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>test_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>test_exprstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>test_result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>udatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since get_range_key_properties() modifies partexprs_item, and we
		 * might need to start over from the previous expression in the later
		 * part of this function, save away the current value.
		 */</comment>
		<expr_stmt><expr><name>partexprs_item_saved</name> <operator>=</operator> <name>partexprs_item</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_range_key_properties</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>ldatum</name></expr></argument>, <argument><expr><name>udatum</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>partexprs_item</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>keyCol</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>lower_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If either value is NULL, the corresponding partition bound is
		 * either MINVALUE or MAXVALUE, and we treat them as unequal, because
		 * even if they're the same, there is no common value to equate the
		 * key column with.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lower_val</name> <operator>||</operator> <operator>!</operator><name>upper_val</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Create the test expression */</comment>
		<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>test_expr</name> <operator>=</operator> <call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lower_val</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>upper_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>test_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>test_exprstate</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>test_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>test_result</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>test_exprstate</name></expr></argument>,
												<argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If not equal, go generate the OR expressions */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The bounds for the last key column can't be equal, because such a
		 * range partition would never be allowed to be defined (it would have
		 * an empty range otherwise).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid range bound specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Equal, so generate keyCol = lower_val expression */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
												<argument><expr><name>keyCol</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lower_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* First pair of lower_val and upper_val that are not equal. */</comment>
	<expr_stmt><expr><name>lower_or_start_datum</name> <operator>=</operator> <name>cell1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>upper_or_start_datum</name> <operator>=</operator> <name>cell2</name></expr>;</expr_stmt>

	<comment type="block">/* OR will have as many arms as there are key columns left. */</comment>
	<expr_stmt><expr><name>num_or_arms</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>current_or_arm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>lower_or_arms</name> <operator>=</operator> <name>upper_or_arms</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>need_next_lower_arm</name> <operator>=</operator> <name>need_next_upper_arm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>current_or_arm</name> <operator>&lt;</operator> <name>num_or_arms</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lower_or_arm_args</name> <init>= <expr><name>NIL</name></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>upper_or_arm_args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Restart scan of columns from the i'th one */</comment>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <name>partexprs_item_saved</name></expr>;</expr_stmt>

		<macro><name>for_both_cell</name><argument_list>(<argument>cell1</argument>, <argument>spec-&gt;lowerdatums</argument>, <argument>lower_or_start_datum</argument>,
					  <argument>cell2</argument>, <argument>spec-&gt;upperdatums</argument>, <argument>upper_or_start_datum</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum_next</name> <init>= <expr><name>NULL</name></expr></init></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>udatum_next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>, <argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ldatum_next</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>,
									   <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>lnext</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>, <argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>udatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>, <argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>udatum_next</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>,
									   <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>lnext</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>, <argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>get_range_key_properties</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>ldatum</name></expr></argument>, <argument><expr><name>udatum</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>partexprs_item</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>keyCol</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>lower_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>need_next_lower_arm</name> <operator>&amp;&amp;</operator> <name>lower_val</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint16</name></type>		<name>strategy</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * For the non-last columns of this arm, use the EQ operator.
				 * For the last column of this arm, use GT, unless this is the
				 * last column of the whole bound check, or the next bound
				 * datum is MINVALUE, in which case use GE.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&lt;</operator> <name>current_or_arm</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
						 <operator>(</operator><name>ldatum_next</name> <operator>&amp;&amp;</operator>
						  <name><name>ldatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MINVALUE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTGreaterEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTGreaterStrategyNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>lower_or_arm_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lower_or_arm_args</name></expr></argument>,
											<argument><expr><call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
																   <argument><expr><name>strategy</name></expr></argument>,
																   <argument><expr><name>keyCol</name></expr></argument>,
																   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lower_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>need_next_upper_arm</name> <operator>&amp;&amp;</operator> <name>upper_val</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint16</name></type>		<name>strategy</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * For the non-last columns of this arm, use the EQ operator.
				 * For the last column of this arm, use LT, unless the next
				 * bound datum is MAXVALUE, in which case use LE.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&lt;</operator> <name>current_or_arm</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>udatum_next</name> <operator>&amp;&amp;</operator>
						 <name><name>udatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTLessEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTLessStrategyNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>upper_or_arm_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>upper_or_arm_args</name></expr></argument>,
											<argument><expr><call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
																   <argument><expr><name>strategy</name></expr></argument>,
																   <argument><expr><name>keyCol</name></expr></argument>,
																   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>upper_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Did we generate enough of OR's arguments?  First arm considers
			 * the first of the remaining columns, second arm considers first
			 * two of the remaining columns, and so on.
			 */</comment>
			<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&gt;</operator> <name>current_or_arm</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We must not emit any more arms if the new column that will
				 * be considered is unbounded, or this one was.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lower_val</name> <operator>||</operator> <operator>!</operator><name>ldatum_next</name> <operator>||</operator>
					<name><name>ldatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>need_next_lower_arm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>upper_val</name> <operator>||</operator> <operator>!</operator><name>udatum_next</name> <operator>||</operator>
					<name><name>udatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>need_next_upper_arm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>lower_or_arm_args</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lower_or_arms</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lower_or_arms</name></expr></argument>,
									<argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>lower_or_arm_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
									?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>lower_or_arm_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
									</then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>lower_or_arm_args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>upper_or_arm_args</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>upper_or_arms</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>upper_or_arms</name></expr></argument>,
									<argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>upper_or_arm_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
									?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>upper_or_arm_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
									</then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>upper_or_arm_args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If no work to do in the next iteration, break away. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_next_lower_arm</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>need_next_upper_arm</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>++</operator><name>current_or_arm</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Generate the OR expressions for each of lower and upper bounds (if
	 * required), and append to the list of implicitly ANDed list of
	 * expressions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lower_or_arms</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>lower_or_arms</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
						 ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>lower_or_arms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
						 </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>lower_or_arms</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>upper_or_arms</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>upper_or_arms</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
						 ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>upper_or_arms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
						 </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>upper_or_arms</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * As noted above, for non-default, we return list with constant TRUE. If
	 * the result is NIL during the recursive call for default, it implies
	 * this is the only other partition which can hold every value of the key
	 * except NULL. Hence we return the NullTest result skipped earlier.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>for_default</name></expr>
			?</condition><then> <expr><call><name>get_range_nulltest</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>
			</then><else>: <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_range_key_properties
 *		Returns range partition key information for a given column
 *
 * This is a subroutine for get_qual_for_range, and its API is pretty
 * specialized to that caller.
 *
 * Constructs an Expr for the key column (returned in *keyCol) and Consts
 * for the lower and upper range limits (returned in *lower_val and
 * *upper_val).  For MINVALUE/MAXVALUE limits, NULL is returned instead of
 * a Const.  All of these structures are freshly palloc'd.
 *
 * *partexprs_item points to the cell containing the next expression in
 * the key-&gt;partexprs list, or NULL.  It may be advanced upon return.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_range_key_properties</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>udatum</name></decl></parameter>,
						 <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs_item</name></decl></parameter>,
						 <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyCol</name></decl></parameter>,
						 <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>lower_val</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>upper_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Get partition key expression for this column */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>keynum</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>partexprs_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>keyCol</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>, <argument><expr><operator>*</operator><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Get appropriate Const nodes for the bounds */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ldatum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lower_val</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>ldatum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lower_val</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>udatum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>upper_val</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>udatum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>upper_val</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_range_nulltest
 *
 * A non-default range partition table does not currently allow partition
 * keys to be null, so emit an IS NOT NULL expression for each key column.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_range_nulltest</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nulltest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexprs_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>partexprs_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>, <argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>nulltest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>keyCol</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nulltest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compute_partition_hash_value
 *
 * Compute the hash value for given partition key values.
 */</comment>
<function><type><name>uint64</name></type>
<name>compute_partition_hash_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
							 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>seed</name> <init>= <expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>HASH_PARTITION_SEED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Nulls are just ignored */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>hash</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Compute hash for each datum value by calling respective
			 * datatype-specific hash functions of each partition key
			 * attribute.
			 */</comment>
			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Form a single 64-bit hash value */</comment>
			<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>hash_combine64</name><argument_list>(<argument><expr><name>rowHash</name></expr></argument>, <argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>rowHash</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * satisfies_hash_partition
 *
 * This is an SQL-callable function for use in hash partition constraints.
 * The first three arguments are the parent table OID, modulus, and remainder.
 * The remaining arguments are the value of the partitioning columns (or
 * expressions); these are hashed and the results are combined into a single
 * hash value by calling hash_combine64.
 *
 * Returns true if remainder produced when this computed single hash value is
 * divided by the given modulus is equal to given remainder, otherwise false.
 * NB: it's important that this never return null, as the constraint machinery
 * would consider that to be a "pass".
 *
 * See get_qual_for_hash() for usage.
 */</comment>
<function><type><name>Datum</name></type>
<name>satisfies_hash_partition</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<typedef>typedef <type><struct>struct <name>ColumnsHashData</name>
	<block>{
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>variadic_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>variadic_typlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>variadic_typbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>variadic_typalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>partcollid</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name><name>partsupfunc</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
	}</block></struct></type> <name>ColumnsHashData</name>;</typedef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>modulus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>seed</name> <init>= <expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>HASH_PARTITION_SEED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnsHashData</name> <modifier>*</modifier></type><name>my_extra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Return false if the parent OID, modulus, or remainder is NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>parentId</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>modulus</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remainder</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sanity check modulus and remainder. */</comment>
	<if_stmt><if>if <condition>(<expr><name>modulus</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modulus for hash partition must be an integer value greater than zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remainder for hash partition must be an integer value greater than or equal to zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>&gt;=</operator> <name>modulus</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remainder for hash partition must be less than modulus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Cache hash function information.
	 */</comment>
	<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ColumnsHashData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>my_extra</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name>parentId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<comment type="block">/* Open parent relation and fetch partition key info */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reject parent table that is not hash-partitioned. */</comment>
		<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a hash partitioned table"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_fn_expr_variadic</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* complain if wrong number of column values */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>!=</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of partitioning columns (%d) does not match number of partition keys provided (%d)"</literal></expr></argument>,
								<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* allocate space for our cache */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
									   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ColumnsHashData</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>)</argument_list></call> <operator>+</operator>
									   <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ColumnsHashData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>parentId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>partcollid</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
				   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* check argument types and save fmgr_infos */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>argtype</name> <operator>!=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %d of the partition key has type \"%s\", but supplied value is of type \"%s\""</literal></expr></argument>,
									<argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>variadic_array</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* allocate space for our cache -- just one FmgrInfo in this case */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
									   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ColumnsHashData</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>)</argument_list></call> <operator>+</operator>
									   <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ColumnsHashData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>parentId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>variadic_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typlen</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typbyval</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>partcollid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* check argument types */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %d of the partition key has type \"%s\", but supplied value is of type \"%s\""</literal></expr></argument>,
									<argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

			<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						   <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Hold lock until commit */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name> <init>= <expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For a non-variadic call, neither the number of arguments nor their
		 * types can change across calls, so avoid the expense of rechecking
		 * here.
		 */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>hash</name></decl>;</decl_stmt>

			<comment type="block">/* keys start from fourth argument of function. */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>argno</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>partcollid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Form a single 64-bit hash value */</comment>
			<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>hash_combine64</name><argument_list>(<argument><expr><name>rowHash</name></expr></argument>, <argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>variadic_array</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>variadic_array</name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typlen</name></name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typbyval</name></name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typalign</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>datum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* complain if wrong number of column values */</comment>
		<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>!=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of partitioning columns (%d) does not match number of partition keys provided (%d)"</literal></expr></argument>,
							<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>hash</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>partcollid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>datum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Form a single 64-bit hash value */</comment>
			<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>hash_combine64</name><argument_list>(<argument><expr><name>rowHash</name></expr></argument>, <argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>rowHash</name> <operator>%</operator> <name>modulus</name> <operator>==</operator> <name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
