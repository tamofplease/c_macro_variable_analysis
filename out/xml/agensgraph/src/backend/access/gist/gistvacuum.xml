<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/gist/gistvacuum.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gistvacuum.c
 *	  vacuuming routines for the postgres GiST index access method.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/access/gist/gistvacuum.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/integerset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/indexfsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/* Working state needed by gistbulkdelete */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>callback_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistNSN</name></type>		<name>startNSN</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * These are used to memorize all internal and empty leaf pages.  They are
	 * used for deleting all the empty pages.
	 */</comment>
	<decl_stmt><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>internal_page_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>empty_leaf_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>page_set_context</name></decl>;</decl_stmt>
}</block></struct></type> <name>GistVacState</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistvacuumscan</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
						   <parameter><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistvacuumpage</name><parameter_list>(<parameter><decl><type><name>GistVacState</name> <modifier>*</modifier></type><name>vstate</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>,
						   <parameter><decl><type><name>BlockNumber</name></type> <name>orig_blkno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistvacuum_delete_empty_pages</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
										  <parameter><decl><type><name>GistVacState</name> <modifier>*</modifier></type><name>vstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gistdeletepage</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
						   <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>downlink</name></decl></parameter>,
						   <parameter><decl><type><name>Buffer</name></type> <name>leafBuffer</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * VACUUM bulkdelete stage: remove index entries.
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>gistbulkdelete</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
			   <parameter><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* allocate stats if first time through, else re-use existing struct */</comment>
	<if_stmt><if>if <condition>(<expr><name>stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>gistvacuumscan</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>callback_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * VACUUM cleanup stage: delete empty pages, and update index statistics.
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>gistvacuumcleanup</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No-op in ANALYZE ONLY mode */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>analyze_only</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>stats</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If gistbulkdelete was called, we need not do anything, just return the
	 * stats from the latest gistbulkdelete call.  If it wasn't called, we
	 * still need to do a pass over the index, to obtain index statistics.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gistvacuumscan</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It's quite possible for us to be fooled by concurrent page splits into
	 * double-counting some index tuples, so disbelieve any total that exceeds
	 * the underlying heap's count ... if we know that accurately.  Otherwise
	 * this might just make matters worse.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>-&gt;</operator><name>estimated_count</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>&gt;</operator> <name><name>info</name><operator>-&gt;</operator><name>num_heap_tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>num_heap_tuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gistvacuumscan --- scan the index for VACUUMing purposes
 *
 * This scans the index for leaf tuples that are deletable according to the
 * vacuum callback, and updates the stats.  Both btbulkdelete and
 * btvacuumcleanup invoke this (the latter only if no btbulkdelete call
 * occurred).
 *
 * This also makes note of any empty leaf pages, as well as all internal
 * pages while looping over all index pages.  After scanning all the pages, we
 * remove the empty pages so that they can be reused.  Any deleted pages are
 * added directly to the free space map.  (They should've been added there
 * when they were originally deleted, already, but it's possible that the FSM
 * was lost at a crash, for example.)
 *
 * The caller is responsible for initially allocating/zeroing a stats struct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistvacuumscan</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
			   <parameter><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistVacState</name></type> <name>vstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>num_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reset counts that will be incremented during the scan; needed in case
	 * of multiple scans during a single VACUUM command.
	 */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>estimated_count</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>pages_free</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the integer sets to remember all the internal and the empty leaf
	 * pages in page_set_context.  Internally, the integer set will remember
	 * this context so that the subsequent allocations for these integer sets
	 * will be done from the same context.
	 */</comment>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>page_set_context</name></name> <operator>=</operator> <call><name>GenerationContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													  <argument><expr><literal type="string">"GiST VACUUM page set context"</literal></expr></argument>,
													  <argument><expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>vstate</name><operator>.</operator><name>page_set_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>internal_page_set</name></name> <operator>=</operator> <call><name>intset_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>empty_leaf_set</name></name> <operator>=</operator> <call><name>intset_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up info to pass down to gistvacuumpage */</comment>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>stats</name></name> <operator>=</operator> <name>stats</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>callback_state</name></name> <operator>=</operator> <name>callback_state</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>startNSN</name></name> <operator>=</operator> <call><name>GetInsertRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>startNSN</name></name> <operator>=</operator> <call><name>gistGetFakeLSN</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * The outer loop iterates over all index pages, in physical order (we
	 * hope the kernel will cooperate in providing read-ahead for speed).  It
	 * is critical that we visit all leaf pages, including ones added after we
	 * start the scan, else we might fail to delete some deletable tuples.
	 * Hence, we must repeatedly check the relation length.  We must acquire
	 * the relation-extension lock while doing so to avoid a race condition:
	 * if someone else is extending the relation, there is a window where
	 * bufmgr/smgr have created a new all-zero page but it hasn't yet been
	 * write-locked by gistNewBuffer().  If we manage to scan such a page
	 * here, we'll improperly assume it can be recycled.  Taking the lock
	 * synchronizes things enough to prevent a problem: either num_pages won't
	 * include the new page, or gistNewBuffer already has write lock on the
	 * buffer and it will be fully initialized before we can examine it.  (See
	 * also vacuumlazy.c, which has the same issue.)  Also, we need not worry
	 * if a page is added immediately after we look; the page splitting code
	 * already has write-lock on the left page before it adds a right page, so
	 * we must already have processed any tuples due to be moved into such a
	 * page.
	 *
	 * We can skip locking for new or temp relations, however, since no one
	 * else could be accessing them.
	 */</comment>
	<expr_stmt><expr><name>needLock</name> <operator>=</operator> <operator>!</operator><call><name>RELATION_IS_LOCAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>GIST_ROOT_BLKNO</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Get the current relation length */</comment>
		<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>num_pages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Quit if we've scanned the whole relation */</comment>
		<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>&gt;=</operator> <name>num_pages</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<comment type="block">/* Iterate over pages, then loop back to recheck length */</comment>
		<for>for <control>(<init>;</init> <condition><expr><name>blkno</name> <operator>&lt;</operator> <name>num_pages</name></expr>;</condition> <incr><expr><name>blkno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gistvacuumpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vstate</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we found any recyclable pages (and recorded them in the FSM), then
	 * forcibly update the upper-level FSM pages to ensure that searchers can
	 * find them.  It's possible that the pages were also found during
	 * previous scans and so this is a waste of time, but it's cheap enough
	 * relative to scanning the index that it shouldn't matter much, and
	 * making sure that free pages are available sooner not later seems
	 * worthwhile.
	 *
	 * Note that if no recyclable pages exist, we don't bother vacuuming the
	 * FSM at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>pages_free</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IndexFreeSpaceMapVacuum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* update statistics */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_pages</name></name> <operator>=</operator> <name>num_pages</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we saw any empty pages, try to unlink them from the tree so that
	 * they can be reused.
	 */</comment>
	<expr_stmt><expr><call><name>gistvacuum_delete_empty_pages</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we don't need the internal and empty page sets anymore */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>vstate</name><operator>.</operator><name>page_set_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>page_set_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>internal_page_set</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vstate</name><operator>.</operator><name>empty_leaf_set</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * gistvacuumpage --- VACUUM one page
 *
 * This processes a single page for gistbulkdelete().  In some cases we
 * must go back and re-examine previously-scanned pages; this routine
 * recurses when necessary to handle that case.
 *
 * blkno is the page to process.  orig_blkno is the highest block number
 * reached by the outer gistvacuumscan loop (the same as blkno, unless we
 * are recursing to re-examine a previous page).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistvacuumpage</name><parameter_list>(<parameter><decl><type><name>GistVacState</name> <modifier>*</modifier></type><name>vstate</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>orig_blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name><name>vstate</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name> <init>= <expr><name><name>vstate</name><operator>-&gt;</operator><name>callback</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>callback_state</name> <init>= <expr><name><name>vstate</name><operator>-&gt;</operator><name>callback_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>recurse_to</name></decl>;</decl_stmt>

<label><name>restart</name>:</label>
	<expr_stmt><expr><name>recurse_to</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>

	<comment type="block">/* call vacuum_delay_point while not holding any buffer lock */</comment>
	<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>,
								<argument><expr><name><name>info</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We are not going to stay here for a long time, aggressively grab an
	 * exclusive lock.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>gistPageRecyclable</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Okay to recycle this page */</comment>
		<expr_stmt><expr><call><name>RecordFreeIndexPage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vstate</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_free</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vstate</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>GistPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Already deleted, but can't recycle yet */</comment>
		<expr_stmt><expr><name><name>vstate</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>todelete</name><index>[<expr><name>MaxOffsetNumber</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntodelete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nremain</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GISTPageOpaque</name></type> <name>opaque</name> <init>= <expr><call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check whether we need to recurse back to earlier pages.  What we
		 * are concerned about is a page split that happened since we started
		 * the vacuum scan.  If the split moved some tuples to a lower page
		 * then we might have missed 'em.  If so, set up for tail recursion.
		 *
		 * This is similar to the checks we do during searches, when following
		 * a downlink, but we don't need to jump to higher-numbered pages,
		 * because we will process them later, anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>GistFollowRight</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <name><name>vstate</name><operator>-&gt;</operator><name>startNSN</name></name> <operator>&lt;</operator> <call><name>GistPageGetNSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>opaque</name><operator>-&gt;</operator><name>rightlink</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>opaque</name><operator>-&gt;</operator><name>rightlink</name></name> <operator>&lt;</operator> <name>orig_blkno</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>recurse_to</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>rightlink</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Scan over all items to see which ones need to be deleted according
		 * to the callback function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>callback</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
				 <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
				 <incr><expr><name>off</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>callback</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><name>callback_state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>todelete</name><index>[<expr><name>ntodelete</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Apply any needed deletes.  We issue just one WAL record per page,
		 * so as to minimize WAL traffic.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ntodelete</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>todelete</name></expr></argument>, <argument><expr><name>ntodelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GistMarkTuplesDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>gistXLogUpdate</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
										<argument><expr><name>todelete</name></expr></argument>, <argument><expr><name>ntodelete</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>gistGetFakeLSN</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>vstate</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>tuples_removed</name></name> <operator>+=</operator> <name>ntodelete</name></expr>;</expr_stmt>
			<comment type="block">/* must recompute maxoff */</comment>
			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>nremain</name> <operator>=</operator> <name>maxoff</name> <operator>-</operator> <name>FirstOffsetNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nremain</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The page is now completely empty.  Remember its block number,
			 * so that we will try to delete the page in the second stage.
			 *
			 * Skip this when recursing, because IntegerSet requires that the
			 * values are added in ascending order.  The next VACUUM will pick
			 * it up.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>orig_blkno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>intset_add_member</name><argument_list>(<argument><expr><name><name>vstate</name><operator>-&gt;</operator><name>empty_leaf_set</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>vstate</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>+=</operator> <name>nremain</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * On an internal page, check for "invalid tuples", left behind by an
		 * incomplete page split on PostgreSQL 9.0 or below.  These are not
		 * created by newer PostgreSQL versions, but unfortunately, there is
		 * no version number anywhere in a GiST index, so we don't know
		 * whether this index might still contain invalid tuples or not.
		 */</comment>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
			 <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
			 <incr><expr><name>off</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>GistTupleIsInvalid</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains an inner tuple marked as invalid"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This is caused by an incomplete page split at crash recovery before upgrading to PostgreSQL 9.1."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Remember the block number of this page, so that we can revisit it
		 * later in gistvacuum_delete_empty_pages(), when we search for
		 * parents of empty leaf pages.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>orig_blkno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>intset_add_member</name><argument_list>(<argument><expr><name><name>vstate</name><operator>-&gt;</operator><name>internal_page_set</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is really tail recursion, but if the compiler is too stupid to
	 * optimize it as such, we'd eat an uncomfortably large amount of stack
	 * space per recursion level (due to the deletable[] array).  A failure is
	 * improbable since the number of levels isn't likely to be large ... but
	 * just in case, let's hand-optimize into a loop.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recurse_to</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>recurse_to</name></expr>;</expr_stmt>
		<goto>goto <name>restart</name>;</goto>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Scan all internal pages, and try to delete their empty child pages.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistvacuum_delete_empty_pages</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>GistVacState</name> <modifier>*</modifier></type><name>vstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>empty_pages_remaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>blkno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Rescan all inner pages to find those that have empty child pages.
	 */</comment>
	<expr_stmt><expr><name>empty_pages_remaining</name> <operator>=</operator> <call><name>intset_num_entries</name><argument_list>(<argument><expr><name><name>vstate</name><operator>-&gt;</operator><name>empty_leaf_set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>intset_begin_iterate</name><argument_list>(<argument><expr><name><name>vstate</name><operator>-&gt;</operator><name>internal_page_set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>empty_pages_remaining</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <call><name>intset_iterate_next</name><argument_list>(<argument><expr><name><name>vstate</name><operator>-&gt;</operator><name>internal_page_set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>,
					<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>todelete</name><index>[<expr><name>MaxOffsetNumber</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name><name>leafs_to_delete</name><index>[<expr><name>MaxOffsetNumber</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntodelete</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>deleted</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>blkno</name></expr></argument>,
									<argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GistPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This page was an internal page earlier, but now it's something
			 * else. Shouldn't happen...
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Scan all the downlinks, and see if any of them point to empty leaf
		 * pages.
		 */</comment>
		<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ntodelete</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
			 <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name> <operator>&amp;&amp;</operator> <name>ntodelete</name> <operator>&lt;</operator> <name>maxoff</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition>
			 <incr><expr><name>off</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leafblk</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>leafblk</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>intset_is_member</name><argument_list>(<argument><expr><name><name>vstate</name><operator>-&gt;</operator><name>empty_leaf_set</name></name></expr></argument>, <argument><expr><name>leafblk</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>leafs_to_delete</name><index>[<expr><name>ntodelete</name></expr>]</index></name> <operator>=</operator> <name>leafblk</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>todelete</name><index>[<expr><name>ntodelete</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * In order to avoid deadlock, child page must be locked before
		 * parent, so we must release the lock on the parent, lock the child,
		 * and then re-acquire the lock the parent.  (And we wouldn't want to
		 * do I/O, while holding a lock, anyway.)
		 *
		 * At the instant that we're not holding a lock on the parent, the
		 * downlink might get moved by a concurrent insert, so we must
		 * re-check that it still points to the same child page after we have
		 * acquired both locks.  Also, another backend might have inserted a
		 * tuple to the page, so that it is no longer empty.  gistdeletepage()
		 * re-checks all these conditions.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>deleted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntodelete</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Buffer</name></type>		<name>leafbuf</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Don't remove the last downlink from the parent.  That would
			 * confuse the insertion code.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FirstOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>leafbuf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name><name>leafs_to_delete</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										 <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gistcheckpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>gistdeletepage</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name><name>vstate</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>,
							   <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>todelete</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>deleted</name></expr></argument>,
							   <argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>deleted</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* update stats */</comment>
		<expr_stmt><expr><name><name>vstate</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_removed</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can stop the scan as soon as we have seen the downlinks, even if
		 * we were not able to remove them all.
		 */</comment>
		<expr_stmt><expr><name>empty_pages_remaining</name> <operator>-=</operator> <name>ntodelete</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * gistdeletepage takes a leaf page, and its parent, and tries to delete the
 * leaf.  Both pages must be locked.
 *
 * Even if the page was empty when we first saw it, a concurrent inserter might
 * have added a tuple to it since.  Similarly, the downlink might have moved.
 * We re-check all the conditions, to make sure the page is still deletable,
 * before modifying anything.
 *
 * Returns true, if the page was deleted, and false if a concurrent update
 * prevented it.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gistdeletepage</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name></type> <name>parentBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>downlink</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name></type> <name>leafBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>parentPage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>parentBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>leafPage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leafBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>txid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that the leaf is still empty and deletable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>leafPage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* a leaf page should never become a non-leaf page */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GistFollowRight</name><argument_list>(<argument><expr><name>leafPage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* don't mess with a concurrent page split */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>leafPage</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* not empty anymore */</comment>

	<comment type="block">/*
	 * Ok, the leaf is deletable.  Is the downlink in the parent page still
	 * valid?  It might have been moved by a concurrent insert.  We could try
	 * to re-find it by scanning the page again, possibly moving right if the
	 * was split.  But for now, let's keep it simple and just give up.  The
	 * next VACUUM will pick it up.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GistPageIsDeleted</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* shouldn't happen, internal pages are never deleted */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>downlink</name>
		<operator>||</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>FirstOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>iid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>, <argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>idxtuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>leafBuffer</name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * All good, proceed with the deletion.
	 *
	 * The page cannot be immediately recycled, because in-progress scans that
	 * saw the downlink might still visit it.  Mark the page with the current
	 * next-XID counter, so that we know when it can be recycled.  Once that
	 * XID becomes older than GlobalXmin, we know that all scans that are
	 * currently in progress must have ended.  (That's much more conservative
	 * than needed, but let's keep it safe and simple.)
	 */</comment>
	<expr_stmt><expr><name>txid</name> <operator>=</operator> <call><name>ReadNextFullTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mark the page as deleted */</comment>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>leafBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GistPageSetDeleted</name><argument_list>(<argument><expr><name>leafPage</name></expr></argument>, <argument><expr><name>txid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* remove the downlink from the parent */</comment>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>parentBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>, <argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>gistXLogPageDelete</name><argument_list>(<argument><expr><name>leafBuffer</name></expr></argument>, <argument><expr><name>txid</name></expr></argument>, <argument><expr><name>parentBuffer</name></expr></argument>, <argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>gistGetFakeLSN</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>parentPage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>leafPage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
