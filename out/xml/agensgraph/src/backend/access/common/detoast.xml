<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/common/detoast.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * detoast.c
 *	  Retrieve compressed or external variable size attributes.
 *
 * Copyright (c) 2000-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/access/common/detoast.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/detoast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/toast_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_lzcompress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/expandeddatum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>toast_fetch_datum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>toast_fetch_datum_slice</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>,
											   <parameter><decl><type><name>int32</name></type> <name>sliceoffset</name></decl></parameter>,
											   <parameter><decl><type><name>int32</name></type> <name>slicelength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>toast_decompress_datum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>toast_decompress_datum_slice</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>slicelength</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------
 * detoast_external_attr -
 *
 *	Public entry point to get back a toasted value from
 *	external source (possibly still in compressed format).
 *
 * This will return a datum that contains all the data internally, ie, not
 * relying on external storage or memory, but it can still be compressed or
 * have a short header.  Note some callers assume that if the input is an
 * EXTERNAL datum, the result will be a pfree'able chunk.
 * ----------
 */</comment>
<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>detoast_external_attr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is an external stored plain value
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>toast_fetch_datum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is an indirect pointer --- dereference it
		 */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>redirect</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>redirect</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr>;</expr_stmt>

		<comment type="block">/* nested indirect Datums aren't allowed */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* recurse if value is still external in some other way */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>detoast_external_attr</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Copy into the caller's memory context, in case caller tries to
		 * pfree the result.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is an expanded-object pointer --- get flat format
		 */</comment>
		<decl_stmt><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eoh</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>resultsize</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>eoh</name> <operator>=</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultsize</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>resultsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EOH_flatten_into</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>, <argument><expr><name>resultsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This is a plain value inside of the main tuple - why am I called?
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * detoast_attr -
 *
 *	Public entry point to get back a toasted value from compression
 *	or external storage.  The result is always non-extended varlena form.
 *
 * Note some callers assume that if the input is an EXTERNAL or COMPRESSED
 * datum, the result will be a pfree'able chunk.
 * ----------
 */</comment>
<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>detoast_attr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is an externally stored datum --- fetch it back from there
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>toast_fetch_datum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If it's compressed, decompress it */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>attr</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>toast_decompress_datum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is an indirect pointer --- dereference it
		 */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>redirect</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>redirect</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr>;</expr_stmt>

		<comment type="block">/* nested indirect Datums aren't allowed */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* recurse in case value is still extended in some other way */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>detoast_attr</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if it isn't, we'd better copy it */</comment>
		<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attr</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is an expanded-object pointer --- get flat format
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>detoast_external_attr</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* flatteners are not allowed to produce compressed/short output */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is a compressed value inside of the main tuple
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>toast_decompress_datum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is a short-header varlena --- convert to 4-byte header format
		 */</comment>
		<decl_stmt><decl><type><name>Size</name></type>		<name>data_size</name> <init>= <expr><call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>new_size</name> <init>= <expr><name>data_size</name> <operator>+</operator> <name>VARHDRSZ</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_attr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>new_attr</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>new_attr</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>new_attr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <name>new_attr</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>attr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * detoast_attr_slice -
 *
 *		Public entry point to get back part of a toasted value
 *		from compression or external storage.
 *
 * sliceoffset is where to start (zero or more)
 * If slicelength &lt; 0, return everything beyond sliceoffset
 * ----------
 */</comment>
<function><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>detoast_attr_slice</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>,
				   <parameter><decl><type><name>int32</name></type> <name>sliceoffset</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>slicelength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>preslice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attrdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>slicelimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>attrsize</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sliceoffset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid sliceoffset: %d"</literal></expr></argument>, <argument><expr><name>sliceoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute slicelimit = offset + length, or -1 if we must fetch all of the
	 * value.  In case of integer overflow, we must fetch all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>slicelength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slicelimit</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_add_s32_overflow</name><argument_list>(<argument><expr><name>sliceoffset</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slicelimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slicelength</name> <operator>=</operator> <name>slicelimit</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* fast path for non-compressed external datums */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>toast_fetch_datum_slice</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>sliceoffset</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For compressed values, we need to fetch enough slices to decompress
		 * at least the requested part (when a prefix is requested).
		 * Otherwise, just fetch all slices.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>slicelimit</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type>		<name>max_size</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Determine maximum amount of compressed data needed for a prefix
			 * of a given length (after decompression).
			 */</comment>
			<expr_stmt><expr><name>max_size</name> <operator>=</operator> <call><name>pglz_maximum_compressed_size</name><argument_list>(<argument><expr><name>slicelimit</name></expr></argument>,
													<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Fetch enough compressed slices (compressed marker will get set
			 * automatically).
			 */</comment>
			<expr_stmt><expr><name>preslice</name> <operator>=</operator> <call><name>toast_fetch_datum_slice</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>max_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>preslice</name> <operator>=</operator> <call><name>toast_fetch_datum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>redirect</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>redirect</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* nested indirect Datums aren't allowed */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>detoast_attr_slice</name><argument_list>(<argument><expr><name><name>redirect</name><operator>.</operator><name>pointer</name></name></expr></argument>,
								  <argument><expr><name>sliceoffset</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pass it off to detoast_external_attr to flatten */</comment>
		<expr_stmt><expr><name>preslice</name> <operator>=</operator> <call><name>detoast_external_attr</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>preslice</name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>preslice</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Decompress enough to encompass the slice and the offset */</comment>
		<if_stmt><if>if <condition>(<expr><name>slicelimit</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>preslice</name> <operator>=</operator> <call><name>toast_decompress_datum_slice</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>slicelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>preslice</name> <operator>=</operator> <call><name>toast_decompress_datum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>attr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>attrdata</name> <operator>=</operator> <call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attrsize</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>attrdata</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attrsize</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* slicing of datum for compressed cases and plain value */</comment>

	<if_stmt><if>if <condition>(<expr><name>sliceoffset</name> <operator>&gt;=</operator> <name>attrsize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sliceoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>slicelength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>slicelength</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>slicelimit</name></expr></argument> &gt;</argument_list></name> <name>attrsize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slicelength</name> <operator>=</operator> <name>attrsize</name> <operator>-</operator> <name>sliceoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>slicelength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>slicelength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attrdata</name> <operator>+</operator> <name>sliceoffset</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>preslice</name> <operator>!=</operator> <name>attr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>preslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_fetch_datum -
 *
 *	Reconstruct an in memory Datum from the chunks saved
 *	in the toast relation
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>toast_fetch_datum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>attrsize</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"toast_fetch_datum shouldn't be called for non-ondisk datums"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Must copy to access aligned fields */</comment>
	<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attrsize</name> <operator>=</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>attrsize</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SET_VARSIZE_COMPRESSED</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>attrsize</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>attrsize</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attrsize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* Probably shouldn't happen, but just in
								 * case. */</comment>

	<comment type="block">/*
	 * Open the toast relation and its indexes
	 */</comment>
	<expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch all chunks */</comment>
	<expr_stmt><expr><call><name>table_relation_fetch_toast_slice</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
									 <argument><expr><name>attrsize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>attrsize</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close toast table */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_fetch_datum_slice -
 *
 *	Reconstruct a segment of a Datum from the chunks saved
 *	in the toast relation
 *
 *	Note that this function supports non-compressed external datums
 *	and compressed external datums (in which case the requested slice
 *	has to be a prefix, i.e. sliceoffset has to be 0).
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>toast_fetch_datum_slice</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>sliceoffset</name></decl></parameter>,
						<parameter><decl><type><name>int32</name></type> <name>slicelength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>attrsize</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"toast_fetch_datum_slice shouldn't be called for non-ondisk datums"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Must copy to access aligned fields */</comment>
	<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's nonsense to fetch slices of a compressed datum unless when it's a
	 * prefix -- this isn't lo_* we can't return a compressed datum which is
	 * meaningful to toast later.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">0</literal> <operator>==</operator> <name>sliceoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attrsize</name> <operator>=</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sliceoffset</name> <operator>&gt;=</operator> <name>attrsize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sliceoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>slicelength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When fetching a prefix of a compressed external datum, account for the
	 * rawsize tracking amount of raw data, which is stored at the beginning
	 * as an int32 value).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>slicelength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slicelength</name> <operator>=</operator> <name>slicelength</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Adjust length request if needed.  (Note: our sole caller,
	 * detoast_attr_slice, protects us against sliceoffset + slicelength
	 * overflowing.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>sliceoffset</name> <operator>+</operator> <name>slicelength</name><operator>)</operator> <operator>&gt;</operator> <name>attrsize</name><operator>)</operator> <operator>||</operator> <name>slicelength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slicelength</name> <operator>=</operator> <name>attrsize</name> <operator>-</operator> <name>sliceoffset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>slicelength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SET_VARSIZE_COMPRESSED</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>slicelength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>slicelength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>slicelength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* Can save a lot of work at this point! */</comment>

	<comment type="block">/* Open the toast relation */</comment>
	<expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch all chunks */</comment>
	<expr_stmt><expr><call><name>table_relation_fetch_toast_slice</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
									 <argument><expr><name>attrsize</name></expr></argument>, <argument><expr><name>sliceoffset</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>,
									 <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close toast table */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_decompress_datum -
 *
 * Decompress a compressed version of a varlena datum
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>toast_decompress_datum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>TOAST_COMPRESS_RAWSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>TOAST_COMPRESS_RAWSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pglz_decompress</name><argument_list>(<argument><expr><call><name>TOAST_COMPRESS_RAWDATA</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>TOAST_COMPRESS_SIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>TOAST_COMPRESS_RAWSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"compressed data is corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_decompress_datum_slice -
 *
 * Decompress the front of a compressed version of a varlena datum.
 * offset handling happens in detoast_attr_slice.
 * Here we just decompress a slice from the front.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type>
<name>toast_decompress_datum_slice</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>slicelength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>rawsize</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>slicelength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rawsize</name> <operator>=</operator> <call><name>pglz_decompress</name><argument_list>(<argument><expr><call><name>TOAST_COMPRESS_RAWDATA</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>TOAST_COMPRESS_HDRSZ</name></expr></argument>,
							  <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>slicelength</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rawsize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"compressed data is corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rawsize</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_raw_datum_size -
 *
 *	Return the raw (detoasted) size of a varlena datum
 *	(including the VARHDRSZ header)
 * ----------
 */</comment>
<function><type><name>Size</name></type>
<name>toast_raw_datum_size</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* va_rawsize is the size of the original datum -- including header */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* nested indirect Datums aren't allowed */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* here, va_rawsize is just the payload size */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARRAWSIZE_4B_C</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we have to normalize the header length to VARHDRSZ or else the
		 * callers of this function will be confused.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* plain untoasted datum */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_datum_size
 *
 *	Return the physical storage size (possibly compressed) of a varlena datum
 * ----------
 */</comment>
<function><type><name>Size</name></type>
<name>toast_datum_size</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Attribute is stored externally - return the extsize whether
		 * compressed or not.  We do not count the size of the toast pointer
		 * ... should we?
		 */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* nested indirect Datums aren't allowed */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_INDIRECT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>toast_datum_size</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Attribute is stored inline either compressed or not, just calculate
		 * the size of the datum in either case.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
