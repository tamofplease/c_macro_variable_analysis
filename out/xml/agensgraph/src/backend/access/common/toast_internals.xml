<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/common/toast_internals.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * toast_internals.c
 *	  Functions for internal use by the TOAST system.
 *
 * Copyright (c) 2000-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/access/common/toast_internals.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/detoast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heaptoast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/toast_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_lzcompress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>toastrel_valueid_exists</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>toastrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valueid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>toastid_valueid_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>toastrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valueid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------
 * toast_compress_datum -
 *
 *	Create a compressed version of a varlena datum
 *
 *	If we fail (ie, compressed result is actually bigger than original)
 *	then return NULL.  We must not use compressed data if it'd expand
 *	the tuple!
 *
 *	We use VAR{SIZE,DATA}_ANY so we can handle short varlenas here without
 *	copying them.  But we can't handle external or compressed datums.
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>toast_compress_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>valsize</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No point in wasting a palloc cycle if value size is out of the allowed
	 * range for compression
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>valsize</name> <argument_list type="generic">&lt; <argument><expr><name><name>PGLZ_strategy_default</name><operator>-&gt;</operator><name>min_input_size</name></name> <operator>||</operator>
		<name>valsize</name></expr></argument> &gt;</argument_list></name> <name><name>PGLZ_strategy_default</name><operator>-&gt;</operator><name>max_input_size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>PGLZ_MAX_OUTPUT</name><argument_list>(<argument><expr><name>valsize</name></expr></argument>)</argument_list></call> <operator>+</operator>
									<name>TOAST_COMPRESS_HDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We recheck the actual size even if pglz_compress() reports success,
	 * because it might be satisfied with having saved as little as one byte
	 * in the compressed data --- which could turn into a net loss once you
	 * consider header and alignment padding.  Worst case, the compressed
	 * format might require three padding bytes (plus header, which is
	 * included in VARSIZE(tmp)), whereas the uncompressed format would take
	 * only one header byte and no padding if the value is short enough.  So
	 * we insist on a savings of more than 2 bytes to ensure we have a gain.
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pglz_compress</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>valsize</name></expr></argument>,
						<argument><expr><call><name>TOAST_COMPRESS_RAWDATA</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>PGLZ_strategy_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>len</name> <operator>+</operator> <name>TOAST_COMPRESS_HDRSZ</name> <operator>&lt;</operator> <name>valsize</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TOAST_COMPRESS_SET_RAWSIZE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>valsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE_COMPRESSED</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>TOAST_COMPRESS_HDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* successful compression */</comment>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* incompressible data */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_save_datum -
 *
 *	Save one single datum into the secondary relation and return
 *	a Datum reference for it.
 *
 * rel: the main relation we're working with (not the toast rel!)
 * value: datum to be pushed to toast storage
 * oldexternal: if not NULL, toast pointer previously representing the datum
 * options: options to be passed to heap_insert() for toast rows
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>toast_save_datum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
				 <parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>oldexternal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>toasttup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>toasttupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>t_values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>t_isnull</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>mycid</name> <init>= <expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name></type> <name>hdr</name></decl>;</decl_stmt>
		<comment type="block">/* this is to make the union big enough for a chunk: */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>data</name><index>[<expr><name>TOAST_MAX_CHUNK_SIZE</name> <operator>+</operator> <name>VARHDRSZ</name></expr>]</index></name></decl>;</decl_stmt>
		<comment type="block">/* ensure union is aligned well enough: */</comment>
		<decl_stmt><decl><type><name>int32</name></type>		<name>align_it</name></decl>;</decl_stmt>
	}</block>			<decl><name>chunk_data</name></decl>;</union>
	<decl_stmt><decl><type><name>int32</name></type>		<name>chunk_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>chunk_seq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>data_todo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>dval</name> <init>= <expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>validIndex</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the toast relation and its indexes.  We can use the index to check
	 * uniqueness of the OID we assign to the toasted item, even though it has
	 * additional columns besides OID.
	 */</comment>
	<expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>toasttupDesc</name> <operator>=</operator> <name><name>toastrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

	<comment type="block">/* Open all the toast indexes and look for the valid one */</comment>
	<expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
									<argument><expr><name>RowExclusiveLock</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the data pointer and length, and compute va_rawsize and va_extsize.
	 *
	 * va_rawsize is the size of the equivalent fully uncompressed datum, so
	 * we have to adjust for short headers.
	 *
	 * va_extsize is the actual size of the data payload in the toast records.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>data_p</name> <operator>=</operator> <call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_todo</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name> <operator>=</operator> <name>data_todo</name> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>	<comment type="block">/* as if not short */</comment>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name> <operator>=</operator> <name>data_todo</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>data_p</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_todo</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
		<comment type="block">/* rawsize in a compressed datum is just the size of the payload */</comment>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name> <operator>=</operator> <call><name>VARRAWSIZE_4B_C</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name> <operator>=</operator> <name>data_todo</name></expr>;</expr_stmt>
		<comment type="block">/* Assert that the numbers look like it's compressed */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>data_p</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_todo</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name> <operator>=</operator> <name>data_todo</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Insert the correct table OID into the result TOAST pointer.
	 *
	 * Normally this is the actual OID of the target toast table, but during
	 * table-rewriting operations such as CLUSTER, we have to insert the OID
	 * of the table's real permanent toast table instead.  rd_toastoid is set
	 * if we have to substitute such an OID.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Choose an OID to use as the value ID for this toast value.
	 *
	 * Normally we just choose an unused OID within the toast table.  But
	 * during table-rewriting operations where we are preserving an existing
	 * toast table OID, we want to preserve toast value OIDs too.  So, if
	 * rd_toastoid is set and we had a prior external value from that same
	 * toast table, re-use its value ID.  If we didn't have a prior external
	 * value (which is a corner case, but possible if the table's attstorage
	 * options have been changed), we have to pick a value ID that doesn't
	 * conflict with either new or existing toast value OIDs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* normal case: just choose an unused OID */</comment>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>=</operator>
			<call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
							   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* rewrite case: check to see if value was in old toast table */</comment>
		<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oldexternal</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>old_toast_pointer</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>oldexternal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Must copy to access aligned fields */</comment>
			<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>old_toast_pointer</name></expr></argument>, <argument><expr><name>oldexternal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>old_toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* This value came from the old toast table; reuse its OID */</comment>
				<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>=</operator> <name><name>old_toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * There is a corner case here: the table rewrite might have
				 * to copy both live and recently-dead versions of a row, and
				 * those versions could easily reference the same toast value.
				 * When we copy the second or later version of such a row,
				 * reusing the OID will mean we select an OID that's already
				 * in the new toast table.  Check for that, and if so, just
				 * fall through without writing the data again.
				 *
				 * While annoying and ugly-looking, this is a good thing
				 * because it ensures that we wind up with only one copy of
				 * the toast value when there is only one copy in the old
				 * toast table.  Before we detected this case, we'd have made
				 * multiple copies, wasting space; and what's worse, the
				 * copies belonging to already-deleted heap tuples would not
				 * be reclaimed by VACUUM.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>toastrel_valueid_exists</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
											<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Match, so short-circuit the data storage loop below */</comment>
					<expr_stmt><expr><name>data_todo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * new value; must choose an OID that doesn't conflict in either
			 * old or new toast table
			 */</comment>
			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name> <operator>=</operator>
					<call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
									   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><call><name>toastid_valueid_exists</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_toastoid</name></name></expr></argument>,
											<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Initialize constant parts of the tuple data
	 */</comment>
	<expr_stmt><expr><name><name>t_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t_values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t_isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t_isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t_isnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Split up the item into chunks
	 */</comment>
	<while>while <condition>(<expr><name>data_todo</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Calculate the size of this chunk
		 */</comment>
		<expr_stmt><expr><name>chunk_size</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>TOAST_MAX_CHUNK_SIZE</name></expr></argument>, <argument><expr><name>data_todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build a tuple and store it
		 */</comment>
		<expr_stmt><expr><name><name>t_values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunk_seq</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk_data</name></expr></argument>, <argument><expr><name>chunk_size</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk_data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_p</name></expr></argument>, <argument><expr><name>chunk_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>toasttup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>toasttupDesc</name></expr></argument>, <argument><expr><name>t_values</name></expr></argument>, <argument><expr><name>t_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>toasttup</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create the index entry.  We cheat a little here by not using
		 * FormIndexDatum: this relies on the knowledge that the index columns
		 * are the same as the initial columns of the table for all the
		 * indexes.  We also cheat by not providing an IndexInfo: this is okay
		 * for now because btree doesn't need one, but we might have to be
		 * more honest someday.
		 *
		 * Note also that there had better not be any user-created index on
		 * the TOAST table, since we don't bother to update anything else.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_indexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Only index relations marked as ready can be updated */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>toastidxs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_index</name><operator>-&gt;</operator><name>indisready</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>index_insert</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>t_values</name></expr></argument>, <argument><expr><name>t_isnull</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>toasttup</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><name>toastrel</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name><name>toastidxs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr> ?</condition><then>
							 <expr><name>UNIQUE_CHECK_YES</name></expr> </then><else>: <expr><name>UNIQUE_CHECK_NO</name></expr></else></ternary></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Free memory
		 */</comment>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>toasttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Move on to next chunk
		 */</comment>
		<expr_stmt><expr><name>data_todo</name> <operator>-=</operator> <name>chunk_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_p</name> <operator>+=</operator> <name>chunk_size</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Done - close toast relation and its indexes but keep the lock until
	 * commit, so as a concurrent reindex done directly on the toast relation
	 * would be able to wait for this transaction.
	 */</comment>
	<expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the TOAST pointer value that we'll return
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>TOAST_POINTER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARTAG_EXTERNAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>VARTAG_ONDISK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA_EXTERNAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>toast_pointer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_delete_datum -
 *
 *	Delete a single external stored value.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>toast_delete_datum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_speculative</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>toastkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>toastscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>toasttup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>validIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotToast</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Must copy to access aligned fields */</comment>
	<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the toast relation and its indexes
	 */</comment>
	<expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_toastrelid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch valid relation used for process */</comment>
	<expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
									<argument><expr><name>RowExclusiveLock</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup a scan key to find chunks with matching va_valueid
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>,
				<argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find all the chunks.  (We don't actually care whether we see them in
	 * sequence or not, but since we've already locked the index we might as
	 * well use systable_beginscan_ordered.)
	 */</comment>
	<expr_stmt><expr><call><name>init_toast_snapshot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>toastscan</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>toasttup</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Have a chunk, delete it
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_speculative</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_abort_speculative</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>toasttup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>toasttup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * End scan and close relations but keep the lock until commit, so as a
	 * concurrent reindex done directly on the toast relation would be able to
	 * wait for this transaction.
	 */</comment>
	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toastrel_valueid_exists -
 *
 *	Test whether a toast value with the given ID exists in the toast relation.
 *	For safety, we consider a value to exist if there are either live or dead
 *	toast rows with that ID; see notes for GetNewOidWithIndex().
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>toastrel_valueid_exists</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>toastrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valueid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>toastkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>toastscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>validIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch a valid index relation */</comment>
	<expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
									<argument><expr><name>RowExclusiveLock</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup a scan key to find chunks with matching va_valueid
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>,
				<argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>valueid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Is there any such chunk?
	 */</comment>
	<expr_stmt><expr><name>toastscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>toastkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toastid_valueid_exists -
 *
 *	As above, but work from toast rel's OID not an open relation
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>toastid_valueid_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>toastrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valueid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>toastrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>toastrel_valueid_exists</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>valueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_get_valid_index
 *
 *	Get OID of valid index associated to given toast relation. A toast
 *	relation can have only one valid index at the same time.
 */</comment>
<function><type><name>Oid</name></type>
<name>toast_get_valid_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>toastoid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>validIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>validIndexOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name></decl>;</decl_stmt>

	<comment type="block">/* Open the toast relation */</comment>
	<expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>toastoid</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look for the valid index of the toast relation */</comment>
	<expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
									<argument><expr><name>lock</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>validIndexOid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close the toast relation and all its indexes */</comment>
	<expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>validIndexOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_open_indexes
 *
 *	Get an array of the indexes associated to the given toast relation
 *	and return as well the position of the valid index used by the toast
 *	relation in this array. It is the responsibility of the caller of this
 *	function to close the indexes as well as free them.
 */</comment>
<function><type><name>int</name></type>
<name>toast_open_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>toastrel</name></decl></parameter>,
				   <parameter><decl><type><name>LOCKMODE</name></type> <name>lock</name></decl></parameter>,
				   <parameter><decl><type><name>Relation</name> <modifier>*</modifier><modifier>*</modifier></type><name>toastidxs</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Get index list of the toast relation */</comment>
	<expr_stmt><expr><name>indexlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexlist</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_indexes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open all the index relations */</comment>
	<expr_stmt><expr><operator>*</operator><name>toastidxs</name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>num_indexes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><call><name>foreach</name><argument_list>(<argument><expr><name>lc</name></expr></argument>, <argument><expr><name>indexlist</name></expr></argument>)</argument_list></call>
		<argument_list>(<argument><expr><operator>*</operator><name>toastidxs</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name><operator>++</operator></expr>]</index> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch the first valid index in list */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_indexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>toastidx</name> <init>= <expr><operator>(</operator><operator>*</operator><name>toastidxs</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>toastidx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Free index list, not necessary anymore as relations are opened and a
	 * valid index has been found.
	 */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The toast relation should have one valid index, so something is going
	 * wrong if there is nothing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no valid index found for toast relation with Oid %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * toast_close_indexes
 *
 *	Close an array of indexes for a toast relation and free it. This should
 *	be called for a set of indexes opened previously with toast_open_indexes.
 */</comment>
<function><type><name>void</name></type>
<name>toast_close_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>toastidxs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_indexes</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Close relations and clean up things */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_indexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>toastidxs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * init_toast_snapshot
 *
 *	Initialize an appropriate TOAST snapshot.  We must use an MVCC snapshot
 *	to initialize the TOAST snapshot; since we don't know which one to use,
 *	just use the oldest one.  This is safe: at worst, we will get a "snapshot
 *	too old" error that might have been avoided otherwise.
 */</comment>
<function><type><name>void</name></type>
<name>init_toast_snapshot</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>toast_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name> <init>= <expr><call><name>GetOldestSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * GetOldestSnapshot returns NULL if the session has no active snapshots.
	 * We can get that if, for example, a procedure fetches a toasted value
	 * into a local variable, commits, and then tries to detoast the value.
	 * Such coding is unsafe, because once we commit there is nothing to
	 * prevent the toast data from being deleted.  Detoasting *must* happen in
	 * the same transaction that originally fetched the toast pointer.  Hence,
	 * rather than trying to band-aid over the problem, throw an error.  (This
	 * is not very much protection, because in many scenarios the procedure
	 * would have already created a new transaction snapshot, preventing us
	 * from detecting the problem.  But it's better than nothing, and for sure
	 * we shouldn't expend code on masking the problem more.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot fetch toast data without an active snapshot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>InitToastSnapshot</name><argument_list>(<argument><expr><operator>*</operator><name>toast_snapshot</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>whenTaken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
