<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/transam/xlogutils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * xlogutils.c
 *
 * PostgreSQL write-ahead log manager utility routines
 *
 * This file contains support routines that are used by XLOG replay functions.
 * None of this code is used during normal system operation.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/access/transam/xlogutils.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/timeline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/* GUC variable */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>ignore_invalid_pages</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * During XLOG replay, we may see XLOG records for incremental updates of
 * pages that no longer exist, because their relation was later dropped or
 * truncated.  (Note: this is only possible when full_page_writes = OFF,
 * since when it's ON, the first reference we see to a page should always
 * be a full-page rewrite not an incremental update.)  Rather than simply
 * ignoring such records, we make a note of the referenced page, and then
 * complain if we don't actually see a drop or truncate covering the page
 * later in replay.
 */</comment>
<typedef>typedef <type><struct>struct <name>xl_invalid_page_key</name>
<block>{
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>node</name></decl>;</decl_stmt>			<comment type="block">/* the relation */</comment>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkno</name></decl>;</decl_stmt>			<comment type="block">/* the fork number */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>			<comment type="block">/* the page */</comment>
}</block></struct></type> <name>xl_invalid_page_key</name>;</typedef>

<typedef>typedef <type><struct>struct <name>xl_invalid_page</name>
<block>{
	<decl_stmt><decl><type><name>xl_invalid_page_key</name></type> <name>key</name></decl>;</decl_stmt>	<comment type="block">/* hash key ... must be first */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>present</name></decl>;</decl_stmt>		<comment type="block">/* page existed but contained zeroes */</comment>
}</block></struct></type> <name>xl_invalid_page</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>invalid_page_tab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* Report a reference to an invalid page */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_invalid_page</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkno</name></decl></parameter>,
					<parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>present</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>relpathperm</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>forkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>present</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"page %u of relation %s is uninitialized"</literal></expr></argument>,
			 <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"page %u of relation %s does not exist"</literal></expr></argument>,
			 <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Log a reference to an invalid page */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_invalid_page</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkno</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>present</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_invalid_page_key</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_invalid_page</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Once recovery has reached a consistent state, the invalid-page table
	 * should be empty and remain so. If a reference to an invalid page is
	 * found after consistency is reached, PANIC immediately. This might seem
	 * aggressive, but it's better than letting the invalid reference linger
	 * in the hash table until the end of recovery and PANIC there, which
	 * might come only much later if this is a standby server.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reachedConsistency</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_page</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>forkno</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>present</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><ternary><condition><expr><name>ignore_invalid_pages</name></expr> ?</condition><then> <expr><name>WARNING</name></expr> </then><else>: <expr><name>PANIC</name></expr></else></ternary></expr></argument>,
			 <argument><expr><literal type="string">"WAL contains references to invalid pages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Log references to invalid pages at DEBUG1 level.  This allows some
	 * tracing of the cause (note the elog context mechanism will tell us
	 * something about the XLOG record that generated the reference).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_min_messages</name> <operator>&lt;=</operator> <name>DEBUG1</name> <operator>||</operator> <name>client_min_messages</name> <operator>&lt;=</operator> <name>DEBUG1</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_invalid_page</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>forkno</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>present</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>invalid_page_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* create hash table when first needed */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xl_invalid_page_key</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xl_invalid_page</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><name>invalid_page_tab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"XLOG invalid-page table"</literal></expr></argument>,
									   <argument><expr><literal type="number">100</literal></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
									   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we currently assume xl_invalid_page_key contains no padding */</comment>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>forkno</name></name> <operator>=</operator> <name>forkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>xl_invalid_page</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>invalid_page_tab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* hash_search already filled in the key */</comment>
		<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>present</name></name> <operator>=</operator> <name>present</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* repeat reference ... leave "present" as it was */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Forget any invalid pages &gt;= minblkno, because they've been dropped */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>forget_invalid_pages</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkno</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>minblkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_invalid_page</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>invalid_page_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>invalid_page_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>hentry</name> <operator>=</operator> <operator>(</operator><name>xl_invalid_page</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RelFileNodeEquals</name><argument_list>(<argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>forkno</name></name> <operator>==</operator> <name>forkno</name> <operator>&amp;&amp;</operator>
			<name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>blkno</name></name> <operator>&gt;=</operator> <name>minblkno</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>log_min_messages</name> <operator>&lt;=</operator> <name>DEBUG2</name> <operator>||</operator> <name>client_min_messages</name> <operator>&lt;=</operator> <name>DEBUG2</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>relpathperm</name><argument_list>(<argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"page %u of relation %s has been dropped"</literal></expr></argument>,
					 <argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>blkno</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>invalid_page_tab</name></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>hentry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Forget any invalid pages in a whole database */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>forget_invalid_pages_db</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_invalid_page</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>invalid_page_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>invalid_page_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>hentry</name> <operator>=</operator> <operator>(</operator><name>xl_invalid_page</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name> <operator>==</operator> <name>dbid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>log_min_messages</name> <operator>&lt;=</operator> <name>DEBUG2</name> <operator>||</operator> <name>client_min_messages</name> <operator>&lt;=</operator> <name>DEBUG2</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>relpathperm</name><argument_list>(<argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>forkno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"page %u of relation %s has been dropped"</literal></expr></argument>,
					 <argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>blkno</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>invalid_page_tab</name></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>hentry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Are there any unresolved references to invalid pages? */</comment>
<function><type><name>bool</name></type>
<name>XLogHaveInvalidPages</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>invalid_page_tab</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>invalid_page_tab</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Complain about any remaining invalid-page entries */</comment>
<function><type><name>void</name></type>
<name>XLogCheckInvalidPages</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_invalid_page</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>foundone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>invalid_page_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>invalid_page_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Our strategy is to emit WARNING messages for all remaining entries and
	 * only PANIC after we've dumped all the available info.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>hentry</name> <operator>=</operator> <operator>(</operator><name>xl_invalid_page</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_page</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>forkno</name></name></expr></argument>,
							<argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>present</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>foundone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>foundone</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><ternary><condition><expr><name>ignore_invalid_pages</name></expr> ?</condition><then> <expr><name>WARNING</name></expr> </then><else>: <expr><name>PANIC</name></expr></else></ternary></expr></argument>,
			 <argument><expr><literal type="string">"WAL contains references to invalid pages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>invalid_page_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>invalid_page_tab</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * XLogReadBufferForRedo
 *		Read a page during XLOG replay
 *
 * Reads a block referenced by a WAL record into shared buffer cache, and
 * determines what needs to be done to redo the changes to it.  If the WAL
 * record includes a full-page image of the page, it is restored.
 *
 * 'lsn' is the LSN of the record being replayed.  It is compared with the
 * page's LSN to determine if the record has already been replayed.
 * 'block_id' is the ID number the block was registered with, when the WAL
 * record was created.
 *
 * Returns one of the following:
 *
 *	BLK_NEEDS_REDO	- changes from the WAL record need to be applied
 *	BLK_DONE		- block doesn't need replaying
 *	BLK_RESTORED	- block was restored from a full-page image included in
 *					  the record
 *	BLK_NOTFOUND	- block was not found (because it was truncated away by
 *					  an operation later in the WAL stream)
 *
 * On return, the buffer is locked in exclusive-mode, and returned in *buf.
 * Note that the buffer is locked and returned even if it doesn't need
 * replaying.  (Getting the buffer lock is not really necessary during
 * single-process crash recovery, but some subroutines such as MarkBufferDirty
 * will complain if we don't have the lock.  In hot standby mode it's
 * definitely necessary.)
 *
 * Note: when a backup block is available in XLOG with the BKPIMAGE_APPLY flag
 * set, we restore it, even if the page in the database appears newer.  This
 * is to protect ourselves against database pages that were partially or
 * incorrectly written during a crash.  We assume that the XLOG data must be
 * good because it has passed a CRC check, while the database page might not
 * be.  This will force us to replay all subsequent modifications of the page
 * that appear in XLOG, rather than possibly ignoring them as already
 * applied, but that's not a huge drawback.
 */</comment>
<function><type><name>XLogRedoAction</name></type>
<name>XLogReadBufferForRedo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>,
					  <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pin and lock a buffer referenced by a WAL record, for the purpose of
 * re-initializing it.
 */</comment>
<function><type><name>Buffer</name></type>
<name>XLogInitBufferForRedo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><name>RBM_ZERO_AND_LOCK</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * XLogReadBufferForRedoExtended
 *		Like XLogReadBufferForRedo, but with extra options.
 *
 * In RBM_ZERO_* modes, if the page doesn't exist, the relation is extended
 * with all-zeroes pages up to the referenced block number.  In
 * RBM_ZERO_AND_LOCK and RBM_ZERO_AND_CLEANUP_LOCK modes, the return value
 * is always BLK_NEEDS_REDO.
 *
 * (The RBM_ZERO_AND_CLEANUP_LOCK mode is redundant with the get_cleanup_lock
 * parameter. Do not use an inconsistent combination!)
 *
 * If 'get_cleanup_lock' is true, a "cleanup lock" is acquired on the buffer
 * using LockBufferForCleanup(), instead of a regular exclusive lock.
 */</comment>
<function><type><name>XLogRedoAction</name></type>
<name>XLogReadBufferForRedoExtended</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
							  <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>,
							  <parameter><decl><type><name>ReadBufferMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>get_cleanup_lock</name></decl></parameter>,
							  <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>zeromode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>willinit</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forknum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Caller specified a bogus block_id */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to locate backup block with ID %d"</literal></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make sure that if the block is marked with WILL_INIT, the caller is
	 * going to initialize it. And vice versa.
	 */</comment>
	<expr_stmt><expr><name>zeromode</name> <operator>=</operator> <operator>(</operator><name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_LOCK</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_CLEANUP_LOCK</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>willinit</name> <operator>=</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>BKPBLOCK_WILL_INIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>willinit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>zeromode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"block with WILL_INIT flag in WAL record must be zeroed by redo routine"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>willinit</name> <operator>&amp;&amp;</operator> <name>zeromode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"block to be initialized in redo routine must be marked with WILL_INIT flag in the WAL record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If it has a full-page image and it should be restored, do it. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecBlockImageApply</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecHasBlockImage</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
									  <argument><expr><ternary><condition><expr><name>get_cleanup_lock</name></expr> ?</condition><then> <expr><name>RBM_ZERO_AND_CLEANUP_LOCK</name></expr> </then><else>: <expr><name>RBM_ZERO_AND_LOCK</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RestoreBlockImage</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to restore block image"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The page may be uninitialized. If so, we can't set the LSN because
		 * that would corrupt the page.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * At the end of crash recovery the init forks of unlogged relations
		 * are copied, without going through shared buffers. So we need to
		 * force the on-disk state of init forks to always be in sync with the
		 * state in shared buffers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>forknum</name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FlushOneBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>BLK_RESTORED</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>RBM_ZERO_AND_LOCK</name> <operator>&amp;&amp;</operator> <name>mode</name> <operator>!=</operator> <name>RBM_ZERO_AND_CLEANUP_LOCK</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>get_cleanup_lock</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>LockBufferForCleanup</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&lt;=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>BLK_DONE</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>BLK_NOTFOUND</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * XLogReadBufferExtended
 *		Read a page during XLOG replay
 *
 * This is functionally comparable to ReadBufferExtended. There's some
 * differences in the behavior wrt. the "mode" argument:
 *
 * In RBM_NORMAL mode, if the page doesn't exist, or contains all-zeroes, we
 * return InvalidBuffer. In this case the caller should silently skip the
 * update on this page. (In this situation, we expect that the page was later
 * dropped or truncated. If we don't see evidence of that later in the WAL
 * sequence, we'll complain at the end of WAL replay.)
 *
 * In RBM_ZERO_* modes, if the page doesn't exist, the relation is extended
 * with all-zeroes pages up to the given block number.
 *
 * In RBM_NORMAL_NO_LOG mode, we return InvalidBuffer if the page doesn't
 * exist, and we don't check for all-zeroes.  Thus, no log entry is made
 * to imply that the page should be dropped or truncated later.
 *
 * NB: A redo function should normally not call this directly. To get a page
 * to modify, use XLogReadBufferForRedoExtended instead. It is important that
 * all pages modified by a WAL record are registered in the WAL records, or
 * they will be invisible to tools that that need to know which pages are
 * modified.
 */</comment>
<function><type><name>Buffer</name></type>
<name>XLogReadBufferExtended</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
					   <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>ReadBufferMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lastblock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blkno</name> <operator>!=</operator> <name>P_NEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open the relation at smgr level */</comment>
	<expr_stmt><expr><name>smgr</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the target file if it doesn't already exist.  This lets us cope
	 * if the replay sequence contains writes to a relation that is later
	 * deleted.  (The original coding of this routine would instead suppress
	 * the writes, but that seems like it risks losing valuable data if the
	 * filesystem loses an inode during a crash.  Better to write the data
	 * until we are actually told to delete the file.)
	 */</comment>
	<expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lastblock</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>&lt;</operator> <name>lastblock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* page exists in file */</comment>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferWithoutRelcache</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
										   <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* hm, page doesn't exist in file */</comment>
		<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_NORMAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_invalid_page</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidBuffer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_NORMAL_NO_LOG</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>InvalidBuffer</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* OK to extend the file */</comment>
		<comment type="block">/* we do this in recovery only - no rel-extension lock needed */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>InRecovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_LOCK</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_CLEANUP_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferWithoutRelcache</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>,
											   <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		while <condition>(<expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>blkno</name></expr>)</condition>;</do>
		<comment type="block">/* Handle the corner case that P_NEW returns non-consecutive pages */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>blkno</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_LOCK</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>RBM_ZERO_AND_CLEANUP_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferWithoutRelcache</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
											   <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RBM_NORMAL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check that page has been initialized */</comment>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We assume that PageIsNew is safe without a lock. During recovery,
		 * there should be no other backends that could modify the buffer at
		 * the same time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>log_invalid_page</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidBuffer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Struct actually returned by CreateFakeRelcacheEntry, though the declared
 * return type is Relation.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>RelationData</name></type> <name>reldata</name></decl>;</decl_stmt>		<comment type="block">/* Note: this must be first */</comment>
	<decl_stmt><decl><type><name>FormData_pg_class</name></type> <name>pgc</name></decl>;</decl_stmt>
}</block></struct></type> <name>FakeRelCacheEntryData</name>;</typedef>

<typedef>typedef <type><name>FakeRelCacheEntryData</name> <modifier>*</modifier></type><name>FakeRelCacheEntry</name>;</typedef>

<comment type="block">/*
 * Create a fake relation cache entry for a physical relation
 *
 * It's often convenient to use the same functions in XLOG replay as in the
 * main codepath, but those functions typically work with a relcache entry.
 * We don't have a working relation cache during XLOG replay, but this
 * function can be used to create a fake relcache entry instead. Only the
 * fields related to physical storage, like rd_rel, are initialized, so the
 * fake entry is only usable in low-level operations like ReadBuffer().
 *
 * This is also used for syncing WAL-skipped files.
 *
 * Caller must free the returned entry with FreeFakeRelcacheEntry().
 */</comment>
<function><type><name>Relation</name></type>
<name>CreateFakeRelcacheEntry</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FakeRelCacheEntry</name></type> <name>fakeentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate the Relation struct and all related space in one block. */</comment>
	<expr_stmt><expr><name>fakeentry</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FakeRelCacheEntryData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <operator>(</operator><name>Relation</name><operator>)</operator> <name>fakeentry</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>fakeentry</name><operator>-&gt;</operator><name>pgc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We will never be working with temp rels during recovery or while
	 * syncing WAL-skipped files.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>

	<comment type="block">/* It must be a permanent table here */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>

	<comment type="block">/* We don't know the name of the relation; use relfilenode instead */</comment>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We set up the lockRelId in case anything tries to lock the dummy
	 * relation.  Note that this is fairly bogus since relNode may be
	 * different from the relation's OID.  It shouldn't really matter though.
	 * In recovery, we are running by ourselves and can't have any lock
	 * conflicts.  While syncing, we already hold AccessExclusiveLock.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name> <operator>=</operator> <name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name> <operator>=</operator> <name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a fake relation cache entry.
 */</comment>
<function><type><name>void</name></type>
<name>FreeFakeRelcacheEntry</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>fakerel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* make sure the fakerel is not referenced by the SmgrRelation anymore */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fakerel</name><operator>-&gt;</operator><name>rd_smgr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrclearowner</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fakerel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name><name>fakerel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fakerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop a relation during XLOG replay
 *
 * This is called when the relation is about to be deleted; we need to remove
 * any open "invalid-page" records for the relation.
 */</comment>
<function><type><name>void</name></type>
<name>XLogDropRelation</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>forget_invalid_pages</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop a whole database during XLOG replay
 *
 * As above, but for DROP DATABASE instead of dropping a single rel
 */</comment>
<function><type><name>void</name></type>
<name>XLogDropDatabase</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This is unnecessarily heavy-handed, as it will close SMgrRelation
	 * objects for other databases as well. DROP DATABASE occurs seldom enough
	 * that it's not worth introducing a variant of smgrclose for just this
	 * purpose. XXX: Or should we rather leave the smgr entries dangling?
	 */</comment>
	<expr_stmt><expr><call><name>smgrcloseall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>forget_invalid_pages_db</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Truncate a relation during XLOG replay
 *
 * We need to clean up any open "invalid-page" records for the dropped pages.
 */</comment>
<function><type><name>void</name></type>
<name>XLogTruncateRelation</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
					 <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>forget_invalid_pages</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine which timeline to read an xlog page from and set the
 * XLogReaderState's currTLI to that timeline ID.
 *
 * We care about timelines in xlogreader when we might be reading xlog
 * generated prior to a promotion, either if we're currently a standby in
 * recovery or if we're a promoted master reading xlogs generated by the old
 * master before our promotion.
 *
 * wantPage must be set to the start address of the page to read and
 * wantLength to the amount of the page that will be read, up to
 * XLOG_BLCKSZ. If the amount to be read isn't known, pass XLOG_BLCKSZ.
 *
 * We switch to an xlog segment from the new timeline eagerly when on a
 * historical timeline, as soon as we reach the start of the xlog segment
 * containing the timeline switch.  The server copied the segment to the new
 * timeline so all the data up to the switch point is the same, but there's no
 * guarantee the old segment will still exist. It may have been deleted or
 * renamed with a .partial suffix so we can't necessarily keep reading from
 * the old TLI even though tliSwitchPoint says it's OK.
 *
 * We can't just check the timeline when we read a page on a different segment
 * to the last page. We could've received a timeline switch from a cascading
 * upstream, so the current segment ends abruptly (possibly getting renamed to
 * .partial) and we have to switch to a new one.  Even in the middle of reading
 * a page we could have to dump the cached page and switch to a new TLI.
 *
 * Because of this, callers MAY NOT assume that currTLI is the timeline that
 * will be in a page's xlp_tli; the page may begin on an older timeline or we
 * might be reading from historical timeline data on a segment that's been
 * copied to a new timeline.
 *
 * The caller must also make sure it doesn't read past the current replay
 * position (using GetXLogReplayRecPtr) if executing in recovery, so it
 * doesn't fail to notice that the current timeline became historical. The
 * caller must also update ThisTimeLineID with the result of
 * GetXLogReplayRecPtr and must check RecoveryInProgress().
 */</comment>
<function><type><name>void</name></type>
<name>XLogReadDetermineTimeline</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>wantPage</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>wantLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>XLogRecPtr</name></type> <name>lastReadPage</name> <init>= <expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_segno</name></name> <operator>*</operator>
									 <name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>segoff</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wantPage</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>wantPage</name> <operator>%</operator> <name>XLOG_BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wantLength</name> <operator>&lt;=</operator> <name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>&lt;=</operator> <name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the desired page is currently read in and valid, we have nothing to
	 * do.
	 *
	 * The caller should've ensured that it didn't previously advance readOff
	 * past the valid limit of this timeline, so it doesn't matter if the
	 * current TLI has since become historical.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lastReadPage</name> <operator>==</operator> <name>wantPage</name> <operator>&amp;&amp;</operator>
		<name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>lastReadPage</name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>&gt;=</operator> <name>wantPage</name> <operator>+</operator> <call><name>Min</name><argument_list>(<argument><expr><name>wantLength</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're reading from the current timeline, it hasn't become historical
	 * and the page we're reading is after the last page read, we can again
	 * just carry on. (Seeking backwards requires a check to make sure the
	 * older page isn't on a prior timeline).
	 *
	 * ThisTimeLineID might've become historical since we last looked, but the
	 * caller is required not to read past the flush limit it saw at the time
	 * it looked up the timeline. There's nothing we can do about it if
	 * StartupXLOG() renames it to .partial concurrently.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name> <operator>==</operator> <name>ThisTimeLineID</name> <operator>&amp;&amp;</operator> <name>wantPage</name> <operator>&gt;=</operator> <name>lastReadPage</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're just reading pages from a previously validated historical
	 * timeline and the timeline we're reading from is valid until the end of
	 * the current segment we can just keep reading.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator>
		<name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name> <operator>!=</operator> <name>ThisTimeLineID</name> <operator>&amp;&amp;</operator>
		<name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>wantPage</name> <operator>+</operator> <name>wantLength</name><operator>)</operator> <operator>/</operator> <name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name><operator>)</operator> <operator>&lt;</operator>
		<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name> <operator>/</operator> <name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we reach this point we're either looking up a page for random
	 * access, the current timeline just became historical, or we're reading
	 * from a new segment containing a timeline switch. In all cases we need
	 * to determine the newest timeline on the segment.
	 *
	 * If it's the current timeline we can just keep reading from here unless
	 * we detect a timeline switch that makes the current timeline historical.
	 * If it's a historical timeline we can read all the segment on the newest
	 * timeline because it contains all the old timelines' data too. So only
	 * one switch check is required.
	 */</comment>
	<block>{<block_content>
		<comment type="block">/*
		 * We need to re-read the timeline history in case it's been changed
		 * by a promotion or replay from a cascaded replica.
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>timelineHistory</name> <init>= <expr><call><name>readTimeLineHistory</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>endOfSegment</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>endOfSegment</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>wantPage</name> <operator>/</operator> <name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
			<name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wantPage</name> <operator>/</operator> <name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name> <operator>==</operator>
			   <name>endOfSegment</name> <operator>/</operator> <name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find the timeline of the last LSN on the segment containing
		 * wantPage.
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name> <operator>=</operator> <call><name>tliOfPointInHistory</name><argument_list>(<argument><expr><name>endOfSegment</name></expr></argument>, <argument><expr><name>timelineHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name> <operator>=</operator> <call><name>tliSwitchPoint</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name></expr></argument>, <argument><expr><name>timelineHistory</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>nextTLI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name> <operator>||</operator>
			   <name>wantPage</name> <operator>+</operator> <name>wantLength</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>timelineHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"switched to timeline %u valid until %X/%X"</literal></expr></argument>,
			 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* XLogReaderRoutine-&gt;segment_open callback for local pg_wal files */</comment>
<function><type><name>void</name></type>
<name>wal_segment_open</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name></type> <name>nextSegNo</name></decl></parameter>,
				 <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>tli_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name> <init>= <expr><operator>*</operator><name>tli_p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>nextSegNo</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_file</name></name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested WAL segment %s has already been removed"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* stock XLogReaderRoutine-&gt;segment_close callback */</comment>
<function><type><name>void</name></type>
<name>wal_segment_close</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* need to check errno? */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_file</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * XLogReaderRoutine-&gt;page_read callback for reading local xlog files
 *
 * Public because it would likely be very helpful for someone writing another
 * output method outside walsender, e.g. in a bgworker.
 *
 * TODO: The walsender has its own version of this, but it relies on the
 * walsender's latch being set whenever WAL is flushed. No such infrastructure
 * exists for normal backends, so we have to do a check/sleep/repeat style of
 * loop for now.
 */</comment>
<function><type><name>int</name></type>
<name>read_local_xlog_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetPagePtr</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetRecPtr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cur_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>read_upto</name></decl>,
				<decl><type ref="prev"/><name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WALReadError</name></type> <name>errinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>loc</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name></expr>;</expr_stmt>

	<comment type="block">/* Loop waiting for xlog to be available if necessary */</comment>
	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Determine the limit of xlog we can currently read to, and what the
		 * most recent timeline is.
		 *
		 * RecoveryInProgress() will update ThisTimeLineID when it first
		 * notices recovery finishes, so we only have to maintain it for the
		 * local process until recovery ends.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>read_upto</name> <operator>=</operator> <call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>read_upto</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>tli</name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check which timeline to get the record from.
		 *
		 * We have to do it each time through the loop because if we're in
		 * recovery as a cascading standby, the current timeline might've
		 * become historical. We can't rely on RecoveryInProgress() because in
		 * a standby configuration like
		 *
		 * A =&gt; B =&gt; C
		 *
		 * if we're a logical decoding session on C, and B gets promoted, our
		 * timeline will change while we remain in recovery.
		 *
		 * We can't just keep reading from the old timeline as the last WAL
		 * archive in the timeline will get renamed to .partial by
		 * StartupXLOG().
		 *
		 * If that happens after our caller updated ThisTimeLineID but before
		 * we actually read the xlog page, we might still try to read from the
		 * old (now renamed) segment and fail. There's not much we can do
		 * about this, but it can only happen when we're a leaf of a cascading
		 * standby whose master gets promoted while we're decoding, so a
		 * one-off ERROR isn't too bad.
		 */</comment>
		<expr_stmt><expr><call><name>XLogReadDetermineTimeline</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>reqLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name> <operator>==</operator> <name>ThisTimeLineID</name></expr>)</condition>
		<block>{<block_content>

			<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&lt;=</operator> <name>read_upto</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We're on a historical timeline, so limit reading to the switch
			 * point where we moved to the next timeline.
			 *
			 * We don't need to GetFlushRecPtr or GetXLogReplayRecPtr. We know
			 * about the new timeline, so we must've received past the end of
			 * it.
			 */</comment>
			<expr_stmt><expr><name>read_upto</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Setting tli to our wanted record's TLI is slightly wrong; the
			 * page might begin on an older timeline if it contains a timeline
			 * switch, since its xlog segment will have been copied from the
			 * prior timeline. This is pretty harmless though, as nothing
			 * cares so long as the timeline doesn't go backwards.  We should
			 * read the page header instead; FIXME someday.
			 */</comment>
			<expr_stmt><expr><name>tli</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name></expr>;</expr_stmt>

			<comment type="block">/* No need to wait on a historical timeline */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>targetPagePtr</name> <operator>+</operator> <name>XLOG_BLCKSZ</name> <operator>&lt;=</operator> <name>read_upto</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * more than one block available; read only that block, have caller
		 * come back if they need more.
		 */</comment>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name> <operator>&gt;</operator> <name>read_upto</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not enough data there */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* enough bytes available to satisfy the request */</comment>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <name>read_upto</name> <operator>-</operator> <name>targetPagePtr</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Even though we just determined how much of the page can be validly read
	 * as 'count', read the whole page anyway. It's guaranteed to be
	 * zero-padded up to the page boundary if it's incomplete.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>WALRead</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>cur_page</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name>errinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WALReadRaiseError</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* number of valid bytes in the buffer */</comment>
	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Backend-specific convenience code to handle read errors encountered by
 * WALRead().
 */</comment>
<function><type><name>void</name></type>
<name>WALReadRaiseError</name><parameter_list>(<parameter><decl><type><name>WALReadError</name> <modifier>*</modifier></type><name>errinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WALOpenSegment</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><operator>&amp;</operator><name><name>errinfo</name><operator>-&gt;</operator><name>wre_seg</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>seg</name><operator>-&gt;</operator><name>ws_tli</name></name></expr></argument>, <argument><expr><name><name>seg</name><operator>-&gt;</operator><name>ws_segno</name></name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_read</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>errinfo</name><operator>-&gt;</operator><name>wre_errno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from log segment %s, offset %u: %m"</literal></expr></argument>,
						<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_off</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_read</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from log segment %s, offset %u: read %d of %zu"</literal></expr></argument>,
						<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_off</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_read</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name><name>errinfo</name><operator>-&gt;</operator><name>wre_req</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
