<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/transam/twophase.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * twophase.c
 *		Two-phase commit support functions.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *		src/backend/access/transam/twophase.c
 *
 * NOTES
 *		Each global transaction is associated with a global transaction
 *		identifier (GID). The client assigns a GID to a postgres
 *		transaction with the PREPARE TRANSACTION command.
 *
 *		We keep all active global transactions in a shared memory array.
 *		When the PREPARE TRANSACTION command is issued, the GID is
 *		reserved for the transaction in the array. This is done before
 *		a WAL entry is made, because the reservation checks for duplicate
 *		GIDs and aborts the transaction if there already is a global
 *		transaction in prepared state with the same GID.
 *
 *		A global transaction (gxact) also has dummy PGXACT and PGPROC; this is
 *		what keeps the XID considered running by TransactionIdIsInProgress.
 *		It is also convenient as a PGPROC to hook the gxact's locks to.
 *
 *		Information to recover prepared transactions in case of crash is
 *		now stored in WAL for the common case. In some cases there will be
 *		an extended period between preparing a GXACT and commit/abort, in
 *		which case we need to separately record prepared transaction data
 *		in permanent storage. This includes locking information, pending
 *		notifications etc. All that state information is written to the
 *		per-transaction state file in the pg_twophase directory.
 *		All prepared transactions will be written prior to shutdown.
 *
 *		Life track of state data is following:
 *
 *		* On PREPARE TRANSACTION backend writes state data only to the WAL and
 *		  stores pointer to the start of the WAL record in
 *		  gxact-&gt;prepare_start_lsn.
 *		* If COMMIT occurs before checkpoint then backend reads data from WAL
 *		  using prepare_start_lsn.
 *		* On checkpoint state data copied to files in pg_twophase directory and
 *		  fsynced
 *		* If COMMIT happens after checkpoint then backend reads state data from
 *		  files
 *
 *		During replay and replication, TwoPhaseState also holds information
 *		about active prepared transactions that haven't been moved to disk yet.
 *
 *		Replay of twophase records happens by the following rules:
 *
 *		* At the beginning of recovery, pg_twophase is scanned once, filling
 *		  TwoPhaseState with entries marked with gxact-&gt;inredo and
 *		  gxact-&gt;ondisk.  Two-phase file data older than the XID horizon of
 *		  the redo position are discarded.
 *		* On PREPARE redo, the transaction is added to TwoPhaseState-&gt;prepXacts.
 *		  gxact-&gt;inredo is set to true for such entries.
 *		* On Checkpoint we iterate through TwoPhaseState-&gt;prepXacts entries
 *		  that have gxact-&gt;inredo set and are behind the redo_horizon. We
 *		  save them to disk and then switch gxact-&gt;ondisk to true.
 *		* On COMMIT/ABORT we delete the entry from TwoPhaseState-&gt;prepXacts.
 *		  If gxact-&gt;ondisk is true, the corresponding entry from the disk
 *		  is additionally deleted.
 *		* RecoverPreparedTransactions(), StandbyRecoverPreparedTransactions()
 *		  and PrescanPreparedTransactions() have been modified to go through
 *		  gxact-&gt;inredo entries that have not made it to disk.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase_rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/syncrep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/md.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Directory where Two-phase commit files reside within PGDATA
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWOPHASE_DIR</name></cpp:macro> <cpp:value>"pg_twophase"</cpp:value></cpp:define>

<comment type="block">/* GUC variable, can't be changed after startup */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_prepared_xacts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This struct describes one global transaction that is in prepared state
 * or attempting to become prepared.
 *
 * The lifecycle of a global transaction is:
 *
 * 1. After checking that the requested GID is not in use, set up an entry in
 * the TwoPhaseState-&gt;prepXacts array with the correct GID and valid = false,
 * and mark it as locked by my backend.
 *
 * 2. After successfully completing prepare, set valid = true and enter the
 * referenced PGPROC into the global ProcArray.
 *
 * 3. To begin COMMIT PREPARED or ROLLBACK PREPARED, check that the entry is
 * valid and not locked, then mark the entry as locked by storing my current
 * backend ID into locking_backend.  This prevents concurrent attempts to
 * commit or rollback the same prepared xact.
 *
 * 4. On completion of COMMIT PREPARED or ROLLBACK PREPARED, remove the entry
 * from the ProcArray and the TwoPhaseState-&gt;prepXacts array and return it to
 * the freelist.
 *
 * Note that if the preparing transaction fails between steps 1 and 2, the
 * entry must be removed so that the GID and the GlobalTransaction struct
 * can be reused.  See AtAbort_Twophase().
 *
 * typedef struct GlobalTransactionData *GlobalTransaction appears in
 * twophase.h
 */</comment>

<typedef>typedef <type><struct>struct <name>GlobalTransactionData</name>
<block>{
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>next</name></decl>;</decl_stmt>		<comment type="block">/* list link for free list */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>pgprocno</name></decl>;</decl_stmt>		<comment type="block">/* ID of associated dummy PGPROC */</comment>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>dummyBackendId</name></decl>;</decl_stmt> <comment type="block">/* similar to backend id for backends */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl>;</decl_stmt>	<comment type="block">/* time of preparation */</comment>

	<comment type="block">/*
	 * Note that we need to keep track of two LSNs for each GXACT. We keep
	 * track of the start LSN because this is the address we must use to read
	 * state data back from WAL when committing a prepared GXACT. We keep
	 * track of the end LSN because that is the LSN we need to wait for prior
	 * to commit.
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>prepare_start_lsn</name></decl>;</decl_stmt>	<comment type="block">/* XLOG offset of prepare record start */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>prepare_end_lsn</name></decl>;</decl_stmt>	<comment type="block">/* XLOG offset of prepare record end */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>			<comment type="block">/* The GXACT id */</comment>

	<decl_stmt><decl><type><name>Oid</name></type>			<name>owner</name></decl>;</decl_stmt>			<comment type="block">/* ID of user that executed the xact */</comment>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>locking_backend</name></decl>;</decl_stmt>	<comment type="block">/* backend currently working on the xact */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>			<comment type="block">/* true if PGPROC entry is in proc array */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ondisk</name></decl>;</decl_stmt>			<comment type="block">/* true if prepare state file is on disk */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inredo</name></decl>;</decl_stmt>			<comment type="block">/* true if entry was added via xlog_redo */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>gid</name><index>[<expr><name>GIDSIZE</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* The GID assigned to the prepared xact */</comment>
}</block></struct></type>			<name>GlobalTransactionData</name>;</typedef>

<comment type="block">/*
 * Two Phase Commit shared state.  Access to this struct is protected
 * by TwoPhaseStateLock.
 */</comment>
<typedef>typedef <type><struct>struct <name>TwoPhaseStateData</name>
<block>{
	<comment type="block">/* Head of linked list of free GlobalTransactionData structs */</comment>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>freeGXacts</name></decl>;</decl_stmt>

	<comment type="block">/* Number of valid prepXacts entries. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPrepXacts</name></decl>;</decl_stmt>

	<comment type="block">/* There are max_prepared_xacts items in this array */</comment>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name><name>prepXacts</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>TwoPhaseStateData</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>TwoPhaseStateData</name> <modifier>*</modifier></type><name>TwoPhaseState</name></decl>;</decl_stmt>

<comment type="block">/*
 * Global transaction entry currently locked by us, if any.  Note that any
 * access to the entry pointed to by this variable must be protected by
 * TwoPhaseStateLock, though obviously the pointer itself doesn't need to be
 * (since it's just local memory).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>GlobalTransaction</name></type> <name>MyLockedGxact</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>twophaseExitRegistered</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordTransactionCommitPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>,
											<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>,
											<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>ninvalmsgs</name></decl></parameter>,
											<parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalmsgs</name></decl></parameter>,
											<parameter><decl><type><name>bool</name></type> <name>initfileinval</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordTransactionAbortPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>,
										   <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>,
										   <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>,
										   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessRecords</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bufptr</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>TwoPhaseCallback</name></type> <name><name>callbacks</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveGXact</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XlogReadTwoPhaseData</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ProcessTwoPhaseBuffer</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
								   <parameter><decl><type><name>XLogRecPtr</name></type> <name>prepare_start_lsn</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>fromdisk</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setParent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setNextXid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MarkAsPreparingGuts</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>owner</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>giveWarning</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecreateTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>content</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialization of shared memory
 */</comment>
<function><type><name>Size</name></type>
<name>TwoPhaseShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* Need the fixed struct, the array of pointers, and the GTD structs */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>TwoPhaseStateData</name></expr></argument>, <argument><expr><name>prepXacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_prepared_xacts</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransaction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_prepared_xacts</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>TwoPhaseShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>TwoPhaseState</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Prepared Transaction Table"</literal></expr></argument>,
									<argument><expr><call><name>TwoPhaseShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxacts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the linked list of free GlobalTransactionData structs
		 */</comment>
		<expr_stmt><expr><name>gxacts</name> <operator>=</operator> <operator>(</operator><name>GlobalTransaction</name><operator>)</operator>
			<operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>TwoPhaseState</name> <operator>+</operator>
			 <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>TwoPhaseStateData</name></expr></argument>, <argument><expr><name>prepXacts</name></expr></argument>)</argument_list></call> <operator>+</operator>
					  <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransaction</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_prepared_xacts</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_prepared_xacts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* insert into linked list */</comment>
			<expr_stmt><expr><name><name>gxacts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>gxacts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* associate it with a PGPROC assigned by InitProcGlobal */</comment>
			<expr_stmt><expr><name><name>gxacts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pgprocno</name> <operator>=</operator> <name><name>PreparedXactProcs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pgprocno</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Assign a unique ID for each dummy proc, so that the range of
			 * dummy backend IDs immediately follows the range of normal
			 * backend IDs. We don't dare to assign a real backend ID to dummy
			 * procs, because prepared transactions don't take part in cache
			 * invalidation like a real backend ID would imply, but having a
			 * unique ID for them is nevertheless handy. This arrangement
			 * allows you to allocate an array of size (MaxBackends +
			 * max_prepared_xacts + 1), and have a slot for every backend and
			 * prepared transaction. Currently multixact.c uses that
			 * technique.
			 */</comment>
			<expr_stmt><expr><name><name>gxacts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dummyBackendId</name> <operator>=</operator> <name>MaxBackends</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exit hook to unlock the global transaction entry we're working on.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtProcExit_Twophase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* same logic as abort */</comment>
	<expr_stmt><expr><call><name>AtAbort_Twophase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Abort hook to unlock the global transaction entry we're working on.
 */</comment>
<function><type><name>void</name></type>
<name>AtAbort_Twophase</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MyLockedGxact</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * What to do with the locked global transaction entry?  If we were in the
	 * process of preparing the transaction, but haven't written the WAL
	 * record and state file yet, the transaction must not be considered as
	 * prepared.  Likewise, if we are in the process of finishing an
	 * already-prepared transaction, and fail after having already written the
	 * 2nd phase commit or rollback record to the WAL, the transaction should
	 * not be considered as prepared anymore.  In those cases, just remove the
	 * entry from shared memory.
	 *
	 * Otherwise, the entry must be left in place so that the transaction can
	 * be finished later, so just unlock it.
	 *
	 * If we abort during prepare, after having written the WAL record, we
	 * might not have transferred all locks and other state to the prepared
	 * transaction yet.  Likewise, if we abort during commit or rollback,
	 * after having written the WAL record, we might not have released all the
	 * resources held by the transaction yet.  In those cases, the in-memory
	 * state can be wrong, but it's too late to back out.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MyLockedGxact</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveGXact</name><argument_list>(<argument><expr><name>MyLockedGxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>MyLockedGxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is called after we have finished transferring state to the prepared
 * PGXACT entry.
 */</comment>
<function><type><name>void</name></type>
<name>PostPrepare_Twophase</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyLockedGxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MarkAsPreparing
 *		Reserve the GID for the given transaction.
 */</comment>
<function><type><name>GlobalTransaction</name></type>
<name>MarkAsPreparing</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>,
				<parameter><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>GIDSIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction identifier \"%s\" is too long"</literal></expr></argument>,
						<argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* fail immediately if feature is disabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_prepared_xacts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transactions are disabled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set max_prepared_transactions to a nonzero value."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* on first call, register the exit hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>twophaseExitRegistered</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>AtProcExit_Twophase</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>twophaseExitRegistered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for conflicting GID */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>gxact</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction identifier \"%s\" is already in use"</literal></expr></argument>,
							<argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Get a free gxact from the freelist */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"maximum number of prepared transactions reached"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase max_prepared_transactions (currently %d)."</literal></expr></argument>,
						 <argument><expr><name>max_prepared_xacts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>gxact</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkAsPreparingGuts</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>prepared_at</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>databaseid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* And insert it into the active array */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name> <operator>&lt;</operator> <name>max_prepared_xacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>gxact</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MarkAsPreparingGuts
 *
 * This uses a gxact struct and puts it into the active array.
 * NOTE: this is also used when reloading a gxact after a crash; so avoid
 * assuming that we can use very much backend context.
 *
 * Note: This function should be called with appropriate locks held.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MarkAsPreparingGuts</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>,
					<parameter><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>pgxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gxact</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pgxact</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Initialize the PGPROC entry */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueElemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>=</operator> <name>STATUS_OK</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>LocalTransactionIdIsValid</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* clone VXID, for TwoPhaseGetXidByVirtualXID() to find */</comment>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AmStartupProcess</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>IsPostmasterEnvironment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* GetLockConflicts() uses this to specify a wait on the XID */</comment>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>delayChkptEnd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>=</operator> <name>databaseid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>roleId</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>tempNamespaceId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>isBackgroundWorker</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lwWaiting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>lwWaitMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<comment type="block">/* subxid data must be filled later by GXactLoadSubxactData */</comment>
	<expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_at</name></name> <operator>=</operator> <name>prepared_at</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember that we have this GlobalTransaction entry locked for us. If we
	 * abort after this, we must release it.
	 */</comment>
	<expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GXactLoadSubxactData
 *
 * If the transaction being persisted had any subtransactions, this must
 * be called before MarkAsPrepared() to load information into the dummy
 * PGPROC.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GXactLoadSubxactData</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsubxacts</name></decl></parameter>,
					 <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We need no extra lock since the GXACT isn't valid yet */</comment>
	<if_stmt><if>if <condition>(<expr><name>nsubxacts</name> <operator>&gt;</operator> <name>PGPROC_MAX_CACHED_SUBXIDS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nsubxacts</name> <operator>=</operator> <name>PGPROC_MAX_CACHED_SUBXIDS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nsubxacts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
			   <argument><expr><name>nsubxacts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <name>nsubxacts</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MarkAsPrepared
 *		Mark the GXACT as fully valid, and enter it into the global ProcArray.
 *
 * lock_held indicates whether caller already holds TwoPhaseStateLock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MarkAsPrepared</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lock_held</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Lock here may be overkill, but I'm not convinced of that ... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock_held</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock_held</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Put it into the global ProcArray so TransactionIdIsInProgress considers
	 * the XID as still running.
	 */</comment>
	<expr_stmt><expr><call><name>ProcArrayAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LockGXact
 *		Locate the prepared transaction and mark it busy for COMMIT or PREPARE.
 */</comment>
<function><type><specifier>static</specifier> <name>GlobalTransaction</name></type>
<name>LockGXact</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* on first call, register the exit hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>twophaseExitRegistered</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>AtProcExit_Twophase</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>twophaseExitRegistered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore not-yet-valid GIDs */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Found it, but has someone else got it locked? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction with identifier \"%s\" is busy"</literal></expr></argument>,
							<argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>user</name> <operator>!=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to finish prepared transaction"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Must be superuser or the user that prepared the transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Note: it probably would be possible to allow committing from
		 * another database; but at the moment NOTIFY is known not to work and
		 * there may be some other issues as well.  Hence disallow until
		 * someone gets motivated to make it work.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>MyDatabaseId</name> <operator>!=</operator> <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction belongs to another database"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Connect to the database where the transaction was prepared to finish it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK for me to lock it */</comment>
		<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>gxact</name></expr>;</return>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction with identifier \"%s\" does not exist"</literal></expr></argument>,
					<argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NOTREACHED */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveGXact
 *		Remove the prepared transaction from the shared memory array.
 *
 * NB: caller should have already removed it from ProcArray
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveGXact</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>gxact</name> <operator>==</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* remove from the active array */</comment>
			<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* and put it back in the freelist */</comment>
			<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find %p in GlobalTransaction array"</literal></expr></argument>, <argument><expr><name>gxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns an array of all prepared transactions for the user-level
 * function pg_prepared_xact.
 *
 * The returned array and all its elements are copies of internal data
 * structures, to minimize the time we need to hold the TwoPhaseStateLock.
 *
 * WARNING -- we return even those transactions that are not fully prepared
 * yet.  The caller should filter them out if he doesn't want them.
 *
 * The returned array is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetPreparedTransactionList</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name> <modifier>*</modifier></type><name>gxacts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>gxacts</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>array</name> <operator>=</operator> <operator>(</operator><name>GlobalTransaction</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>gxacts</name> <operator>=</operator> <name>array</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>array</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Working status for pg_prepared_xact */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ngxacts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>currIdx</name></decl>;</decl_stmt>
}</block></struct></type> <name>Working_State</name>;</typedef>

<comment type="block">/*
 * pg_prepared_xact
 *		Produce a view with one row per prepared transaction.
 *
 * This function is here so we don't have to export the
 * GlobalTransactionData struct definition.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_prepared_xact</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Working_State</name> <modifier>*</modifier></type><name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build tupdesc for result tuples */</comment>
		<comment type="block">/* this had better match pg_prepared_xacts view in system_views.sql */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"transaction"</literal></expr></argument>,
						   <argument><expr><name>XIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"gid"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"prepared"</literal></expr></argument>,
						   <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ownerid"</literal></expr></argument>,
						   <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"dbid"</literal></expr></argument>,
						   <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Collect all the 2PC status information that we will format and send
		 * out as a result set.
		 */</comment>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name>Working_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Working_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>status</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>ngxacts</name></name> <operator>=</operator> <call><name>GetPreparedTransactionList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>status</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name>Working_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>status</name><operator>-&gt;</operator><name>array</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&lt;</operator> <name><name>status</name><operator>-&gt;</operator><name>ngxacts</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><operator>&amp;</operator><name><name>status</name><operator>-&gt;</operator><name>array</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Form tuple with appropriate data.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TwoPhaseGetGXact
 *		Get the GlobalTransaction struct for a prepared transaction
 *		specified by XID
 *
 * If lock_held is set to true, TwoPhaseStateLock will not be taken, so the
 * caller had better hold it.
 */</comment>
<function><type><specifier>static</specifier> <name>GlobalTransaction</name></type>
<name>TwoPhaseGetGXact</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lock_held</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>cached_xid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>GlobalTransaction</name></type> <name>cached_gxact</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>lock_held</name> <operator>||</operator> <call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * During a recovery, COMMIT PREPARED, or ABORT PREPARED, we'll be called
	 * repeatedly for the same XID.  We can save work with a simple cache.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>xid</name> <operator>==</operator> <name>cached_xid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cached_gxact</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock_held</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>==</operator> <name>xid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock_held</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find GlobalTransaction for xid %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cached_xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cached_gxact</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TwoPhaseGetXidByVirtualXID
 *		Lookup VXID among xacts prepared since last startup.
 *
 * (This won't find recovered xacts.)  If more than one matches, return any
 * and set "have_more" to true.  To witness multiple matches, a single
 * BackendId must consume 2^32 LXIDs, with no intervening database restart.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>TwoPhaseGetXidByVirtualXID</name><parameter_list>(<parameter><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>have_more</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>result</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>proc_vxid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GET_VXID_FROM_PGPROC</name><argument_list>(<argument><expr><name>proc_vxid</name></expr></argument>, <argument><expr><operator>*</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdEquals</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>, <argument><expr><name>proc_vxid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Startup process sets proc-&gt;backendId to InvalidBackendId. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>have_more</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TwoPhaseGetDummyBackendId
 *		Get the dummy backend ID for prepared transaction specified by XID
 *
 * Dummy backend IDs are similar to real backend IDs of real backends.
 * They start at MaxBackends + 1, and are unique across all currently active
 * real backends and prepared transactions.  If lock_held is set to true,
 * TwoPhaseStateLock will not be taken, so the caller had better hold it.
 */</comment>
<function><type><name>BackendId</name></type>
<name>TwoPhaseGetDummyBackendId</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lock_held</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><call><name>TwoPhaseGetGXact</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lock_held</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>gxact</name><operator>-&gt;</operator><name>dummyBackendId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TwoPhaseGetDummyProc
 *		Get the PGPROC that represents a prepared transaction specified by XID
 *
 * If lock_held is set to true, TwoPhaseStateLock will not be taken, so the
 * caller had better hold it.
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>TwoPhaseGetDummyProc</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lock_held</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><call><name>TwoPhaseGetGXact</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lock_held</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/************************************************************************/</comment>
<comment type="block">/* State file support													*/</comment>
<comment type="block" format="doxygen">/************************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TwoPhaseFilePath</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>snprintf(path, MAXPGPATH, TWOPHASE_DIR "/%08X", xid)</cpp:value></cpp:define>

<comment type="block">/*
 * 2PC state file format:
 *
 *	1. TwoPhaseFileHeader
 *	2. TransactionId[] (subtransactions)
 *	3. RelFileNode[] (files to be deleted at commit)
 *	4. RelFileNode[] (files to be deleted at abort)
 *	5. SharedInvalidationMessage[] (inval messages to be sent at commit)
 *	6. TwoPhaseRecordOnDisk
 *	7. ...
 *	8. TwoPhaseRecordOnDisk (end sentinel, rmid == TWOPHASE_RM_END_ID)
 *	9. checksum (CRC-32C)
 *
 * Each segment except the final checksum is MAXALIGN'd.
 */</comment>

<comment type="block">/*
 * Header for a 2PC state file
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWOPHASE_MAGIC</name></cpp:macro>	<cpp:value>0x57F94534</cpp:value></cpp:define>	<comment type="block">/* format identifier */</comment>

<typedef>typedef <type><name>xl_xact_prepare</name></type> <name>TwoPhaseFileHeader</name>;</typedef>

<comment type="block">/*
 * Header for each record in a state file
 *
 * NOTE: len counts only the rmgr data, not the TwoPhaseRecordOnDisk header.
 * The rmgr data will be stored starting on a MAXALIGN boundary.
 */</comment>
<typedef>typedef <type><struct>struct <name>TwoPhaseRecordOnDisk</name>
<block>{
	<decl_stmt><decl><type><name>uint32</name></type>		<name>len</name></decl>;</decl_stmt>			<comment type="block">/* length of rmgr data */</comment>
	<decl_stmt><decl><type><name>TwoPhaseRmgrId</name></type> <name>rmid</name></decl>;</decl_stmt>		<comment type="block">/* resource manager for this record */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>info</name></decl>;</decl_stmt>			<comment type="block">/* flag bits for use by rmgr */</comment>
}</block></struct></type> <name>TwoPhaseRecordOnDisk</name>;</typedef>

<comment type="block">/*
 * During prepare, the state file is assembled in memory before writing it
 * to WAL and the actual state file.  We use a chain of StateFileChunk blocks
 * for that.
 */</comment>
<typedef>typedef <type><struct>struct <name>StateFileChunk</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>StateFileChunk</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>StateFileChunk</name>;</typedef>

<struct><specifier>static</specifier> struct <name>xllist</name>
<block>{
	<decl_stmt><decl><type><name>StateFileChunk</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>		<comment type="block">/* first data block in the chain */</comment>
	<decl_stmt><decl><type><name>StateFileChunk</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>		<comment type="block">/* last block in chain */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>num_chunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>bytes_free</name></decl>;</decl_stmt>		<comment type="block">/* free bytes left in tail block */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>total_len</name></decl>;</decl_stmt>		<comment type="block">/* total data bytes in chain */</comment>
}</block>			<decl><name>records</name></decl>;</struct>


<comment type="block">/*
 * Append a block of data to records data structure.
 *
 * NB: each block is padded to a MAXALIGN multiple.  This must be
 * accounted for when the file is later read!
 *
 * The data is copied, so the caller is free to modify it afterwards.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>save_state_data</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>padlen</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>padlen</name> <operator>&gt;</operator> <name><name>records</name><operator>.</operator><name>bytes_free</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StateFileChunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>records</name><operator>.</operator><name>num_chunks</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>padlen</name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator> <operator>+</operator> <name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>padlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name> <operator>-=</operator> <name>padlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>total_len</name></name> <operator>+=</operator> <name>padlen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start preparing a state file.
 *
 * Initializes data structure and inserts the 2PC file header record.
 */</comment>
<function><type><name>void</name></type>
<name>StartPrepare</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TwoPhaseFileHeader</name></type> <name>hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>commitrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>abortrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalmsgs</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize linked list */</comment>
	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>head</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StateFileChunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>records</name><operator>.</operator><name>bytes_free</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>num_chunks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>total_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Create header */</comment>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>TWOPHASE_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>total_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* EndPrepare will fill this in */</comment>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>database</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>prepared_at</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>prepared_at</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>nsubxacts</name></name> <operator>=</operator> <call><name>xactGetCommittedChildren</name><argument_list>(<argument><expr><operator>&amp;</operator><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>ncommitrels</name></name> <operator>=</operator> <call><name>smgrGetPendingDeletes</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commitrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>nabortrels</name></name> <operator>=</operator> <call><name>smgrGetPendingDeletes</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abortrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>ninvalmsgs</name></name> <operator>=</operator> <call><name>xactGetCommittedInvalidationMessages</name><argument_list>(<argument><expr><operator>&amp;</operator><name>invalmsgs</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name><name>hdr</name><operator>.</operator><name>initfileinval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>.</operator><name>gidlen</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* Include '\0' */</comment>

	<expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>gidlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add the additional info about subxacts, deletable files and cache
	 * invalidation messages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>nsubxacts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>nsubxacts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* While we have the child-xact data, stuff it in the gxact too */</comment>
		<expr_stmt><expr><call><name>GXactLoadSubxactData</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>ncommitrels</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>commitrels</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>ncommitrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>commitrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>nabortrels</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>abortrels</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>nabortrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>abortrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>.</operator><name>ninvalmsgs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>invalmsgs</name></expr></argument>,
						<argument><expr><name><name>hdr</name><operator>.</operator><name>ninvalmsgs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>invalmsgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finish preparing state data and writing it to WAL.
 */</comment>
<function><type><name>void</name></type>
<name>EndPrepare</name><parameter_list>(<parameter><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StateFileChunk</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replorigin</name></decl>;</decl_stmt>

	<comment type="block">/* Add the end sentinel to the list of 2PC records */</comment>
	<expr_stmt><expr><call><name>RegisterTwoPhaseRecord</name><argument_list>(<argument><expr><name>TWOPHASE_RM_END_ID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Go back and fill in total_len in the file header record */</comment>
	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name><name>records</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>TWOPHASE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>total_len</name></name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>total_len</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>replorigin</name> <operator>=</operator> <operator>(</operator><name>replorigin_session_origin</name> <operator>!=</operator> <name>InvalidRepOriginId</name> <operator>&amp;&amp;</operator>
				  <name>replorigin_session_origin</name> <operator>!=</operator> <name>DoNotReplicateId</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>replorigin</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>origin_lsn</name></name> <operator>=</operator> <name>replorigin_session_origin_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>origin_timestamp</name></name> <operator>=</operator> <name>replorigin_session_origin_timestamp</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>origin_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>origin_timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the data size exceeds MaxAllocSize, we won't be able to read it in
	 * ReadTwoPhaseFile. Check for that now, rather than fail in the case
	 * where we write data to file and then re-read at commit time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>total_len</name></name> <operator>&gt;</operator> <name>MaxAllocSize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"two-phase state file maximum length exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now writing 2PC state data to WAL. We let the WAL's CRC protection
	 * cover us, so no need to calculate a separate CRC.
	 *
	 * We have to set delayChkpt here, too; otherwise a checkpoint starting
	 * immediately after the WAL record is inserted could complete without
	 * fsync'ing our state file.  (This is essentially the same kind of race
	 * condition as the COMMIT-to-clog-write case that RecordTransactionCommit
	 * uses delayChkpt for; see notes there.)
	 *
	 * We save the PREPARE record's location in the gxact for later use by
	 * CheckPointTwoPhase.
	 */</comment>
	<expr_stmt><expr><call><name>XLogEnsureRecordSpace</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>records</name><operator>.</operator><name>num_chunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>delayChkpt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>record</name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>record</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XACT_ID</name></expr></argument>, <argument><expr><name>XLOG_XACT_PREPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>replorigin</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Move LSNs forward for this replication origin */</comment>
		<expr_stmt><expr><call><name>replorigin_session_advance</name><argument_list>(<argument><expr><name>replorigin_session_origin_lsn</name></expr></argument>,
								   <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we crash now, we have prepared: WAL replay will fix things */</comment>

	<comment type="block">/* Store record's start location to read that later on Commit */</comment>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name> <operator>=</operator> <name>ProcLastRecPtr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the prepared transaction as valid.  As soon as xact.c marks
	 * MyPgXact as not running our XID (which it will do immediately after
	 * this function returns), others can commit/rollback the xact.
	 *
	 * NB: a side effect of this is to make a dummy ProcArray entry for the
	 * prepared XID.  This must happen before we clear the XID from MyPgXact,
	 * else there is a window where the XID is not running according to
	 * TransactionIdIsInProgress, and onlookers would be entitled to assume
	 * the xact crashed.  Instead we have a window where the same XID appears
	 * twice in ProcArray, which is OK.
	 */</comment>
	<expr_stmt><expr><call><name>MarkAsPrepared</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we can mark ourselves as out of the commit critical section: a
	 * checkpoint starting after this will certainly see the gxact as a
	 * candidate for fsyncing.
	 */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember that we have this GlobalTransaction entry locked for us.  If
	 * we crash after this point, it's too late to abort, but we must unlock
	 * it so that the prepared transaction can be committed or rolled back.
	 */</comment>
	<expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait for synchronous replication, if required.
	 *
	 * Note that at this stage we have marked the prepare, but still show as
	 * running in the procarray (twice!) and continue to hold locks.
	 */</comment>
	<expr_stmt><expr><call><name>SyncRepWaitForLSN</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name><name>records</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>records</name><operator>.</operator><name>num_chunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a 2PC record to be written to state file.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterTwoPhaseRecord</name><parameter_list>(<parameter><decl><type><name>TwoPhaseRmgrId</name></type> <name>rmid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TwoPhaseRecordOnDisk</name></type> <name>record</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>record</name><operator>.</operator><name>rmid</name></name> <operator>=</operator> <name>rmid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>record</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseRecordOnDisk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>save_state_data</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Read and validate the state file for xid.
 *
 * If it looks OK (has a valid magic number and CRC), return the palloc'd
 * contents of the file, issuing an error when finding corrupted data.  If
 * missing_ok is true, which indicates that missing files can be safely
 * ignored, then return NULL.  This state can be reached when doing recovery.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ReadTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>crc_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>calc_crc</name></decl>,
				<decl><type ref="prev"/><name>file_crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TwoPhaseFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check file length.  We can determine a lower bound pretty easily. We
	 * set an upper bound to avoid palloc() failure on a corrupt file, though
	 * we can't guarantee that we won't get an out of memory error anyway,
	 * even on a valid file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stat</name><operator>.</operator><name>st_size</name></name> <operator>&lt;</operator> <operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
						<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseRecordOnDisk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
						<sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>||</operator>
		<name><name>stat</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <name>MaxAllocSize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"incorrect size of file \"%s\": %zu byte"</literal></expr></argument>,
							   <argument><expr><literal type="string">"incorrect size of file \"%s\": %zu bytes"</literal></expr></argument>,
							   <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name><name>stat</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name><name>stat</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>crc_offset</name> <operator>=</operator> <name><name>stat</name><operator>.</operator><name>st_size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>crc_offset</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>crc_offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect alignment of CRC offset for file \"%s\""</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * OK, slurp in the file.
	 */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>stat</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TWOPHASE_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stat</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name><name>stat</name><operator>.</operator><name>st_size</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": read %d of %zu"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name><name>stat</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>TWOPHASE_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid magic number stored in file \"%s\""</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>total_len</name></name> <operator>!=</operator> <name><name>stat</name><operator>.</operator><name>st_size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid size stored in file \"%s\""</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>calc_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>calc_crc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>crc_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>calc_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>file_crc</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>pg_crc32c</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>buf</name> <operator>+</operator> <name>crc_offset</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name>calc_crc</name></expr></argument>, <argument><expr><name>file_crc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"calculated CRC checksum does not match value stored in file \"%s\""</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Reads 2PC data from xlog. During checkpoint this data will be moved to
 * twophase files and ReadTwoPhaseFile should be used instead.
 *
 * Note clearly that this function can access WAL during normal operation,
 * similarly to the way WALSender or Logical Decoding would do.  While
 * accessing WAL, read_local_xlog_page() may change ThisTimeLineID,
 * particularly if this routine is called for the end-of-recovery checkpoint
 * in the checkpointer itself, so save the current timeline number value
 * and restore it once done.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XlogReadTwoPhaseData</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>save_currtli</name> <init>= <expr><name>ThisTimeLineID</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>xlogreader</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><call><name>XL_ROUTINE</name><argument_list>(<argument><expr><operator>.</operator><name>page_read</name> <operator>=</operator> <operator>&amp;</operator><name>read_local_xlog_page</name></expr></argument>,
											   <argument><expr><operator>.</operator><name>segment_open</name> <operator>=</operator> <operator>&amp;</operator><name>wal_segment_open</name></expr></argument>,
											   <argument><expr><operator>.</operator><name>segment_close</name> <operator>=</operator> <operator>&amp;</operator><name>wal_segment_close</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlogreader</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed while allocating a WAL reading processor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>XLogBeginRead</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Restore immediately the timeline where it was previously, as
	 * read_local_xlog_page() could have changed it if the record was read
	 * while recovery was finishing or if the timeline has jumped in-between.
	 */</comment>
	<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <name>save_currtli</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errormsg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read two-phase state from WAL at %X/%X: %s"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>,
							<argument><expr><name>errormsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read two-phase state from WAL at %X/%X"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RM_XACT_ID</name> <operator>||</operator>
		<operator>(</operator><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_XACT_OPMASK</name><operator>)</operator> <operator>!=</operator> <name>XLOG_XACT_PREPARE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected two-phase state data is not present in WAL at %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogReaderFree</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Confirms an xid is prepared, during recovery
 */</comment>
<function><type><name>bool</name></type>
<name>StandbyTransactionIdIsPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_prepared_xacts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* nothing to do */</comment>

	<comment type="block">/* Read and validate file */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check header also */</comment>
	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FinishPreparedTransaction: execute COMMIT PREPARED or ROLLBACK PREPARED
 */</comment>
<function><type><name>void</name></type>
<name>FinishPreparedTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>pgxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>commitrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>abortrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>delrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndelrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalmsgs</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Validate the GID, and lock the GXACT to ensure that two backends do not
	 * try to commit the same GID at once.
	 */</comment>
	<expr_stmt><expr><name>gxact</name> <operator>=</operator> <call><name>LockGXact</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pgxact</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>gxact</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>pgxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read and validate 2PC state data. State data will typically be stored
	 * in WAL files if the LSN is after the last checkpoint record, or moved
	 * to disk if for some reason they have lived for a long time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XlogReadTwoPhaseData</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


	<comment type="block">/*
	 * Disassemble the header area
	 */</comment>
	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>gidlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>children</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commitrels</name> <operator>=</operator> <operator>(</operator><name>RelFileNode</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ncommitrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>abortrels</name> <operator>=</operator> <operator>(</operator><name>RelFileNode</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nabortrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>invalmsgs</name> <operator>=</operator> <operator>(</operator><name>SharedInvalidationMessage</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ninvalmsgs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute latestXid among all children */</comment>
	<expr_stmt><expr><name>latestXid</name> <operator>=</operator> <call><name>TransactionIdLatest</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prevent cancel/die interrupt while cleaning up */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The order of operations here is critical: make the XLOG entry for
	 * commit or abort, then mark the transaction committed or aborted in
	 * pg_xact, then remove its PGPROC from the global ProcArray (which means
	 * TransactionIdIsInProgress will stop saying the prepared xact is in
	 * progress), then run the post-commit or post-abort callbacks. The
	 * callbacks will release the locks the transaction held.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RecordTransactionCommitPrepared</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
										<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
										<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ncommitrels</name></name></expr></argument>, <argument><expr><name>commitrels</name></expr></argument>,
										<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ninvalmsgs</name></name></expr></argument>, <argument><expr><name>invalmsgs</name></expr></argument>,
										<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>initfileinval</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RecordTransactionAbortPrepared</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
									   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
									   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nabortrels</name></name></expr></argument>, <argument><expr><name>abortrels</name></expr></argument>,
									   <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ProcArrayRemove</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In case we fail while running the callbacks, mark the gxact invalid so
	 * no one else will try to commit/rollback, and so it will be recycled if
	 * we fail after this point.  It is still locked by our backend so it
	 * won't go away yet.
	 *
	 * (We assume it's safe to do this without taking TwoPhaseStateLock.)
	 */</comment>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to remove any files that were supposed to be dropped. For
	 * consistency with the regular xact.c code paths, must do this before
	 * releasing locks, so do it before running the callbacks.
	 *
	 * NB: this code knows that we couldn't be dropping any temp rels ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>delrels</name> <operator>=</operator> <name>commitrels</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndelrels</name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>ncommitrels</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>delrels</name> <operator>=</operator> <name>abortrels</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndelrels</name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nabortrels</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Make sure files supposed to be dropped are dropped */</comment>
	<expr_stmt><expr><call><name>DropRelationFiles</name><argument_list>(<argument><expr><name>delrels</name></expr></argument>, <argument><expr><name>ndelrels</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Handle cache invalidation messages.
	 *
	 * Relcache init file invalidation requires processing both before and
	 * after we send the SI messages. See AtEOXact_Inval()
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>initfileinval</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationCacheInitFilePreInvalidate</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SendSharedInvalidMessages</name><argument_list>(<argument><expr><name>invalmsgs</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ninvalmsgs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>initfileinval</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationCacheInitFilePostInvalidate</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Acquire the two-phase lock.  We want to work on the two-phase callbacks
	 * while holding it to avoid potential conflicts with other transactions
	 * attempting to use the same GID, so the lock is released once the shared
	 * memory state is cleared.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And now do the callbacks */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ProcessRecords</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>twophase_postcommit_callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ProcessRecords</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>twophase_postabort_callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PredicateLockTwoPhaseFinish</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear shared memory state */</comment>
	<expr_stmt><expr><call><name>RemoveGXact</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release the lock as all callbacks are called and shared memory cleanup
	 * is done.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Count the prepared xact as committed or aborted */</comment>
	<expr_stmt><expr><call><name>AtEOXact_PgStat</name><argument_list>(<argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And now we can clean up any files we may have left.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>MyLockedGxact</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Scan 2PC state data in memory and call the indicated callbacks for each 2PC record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessRecords</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bufptr</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>TwoPhaseCallback</name></type> <name><name>callbacks</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TwoPhaseRecordOnDisk</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><operator>(</operator><name>TwoPhaseRecordOnDisk</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>rmid</name></name> <operator>&lt;=</operator> <name>TWOPHASE_RM_MAX_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>rmid</name></name> <operator>==</operator> <name>TWOPHASE_RM_END_ID</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseRecordOnDisk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>callbacks</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>rmid</name></name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>callbacks</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>rmid</name></name></expr>]</index></name> <operator>(</operator><name>xid</name><operator>,</operator> <name><name>record</name><operator>-&gt;</operator><name>info</name></name><operator>,</operator>
									 <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>bufptr</name><operator>,</operator> <name><name>record</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the 2PC file for the specified XID.
 *
 * If giveWarning is false, do not complain about file-not-present;
 * this is an expected case during WAL replay.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>giveWarning</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TwoPhaseFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name> <operator>||</operator> <name>giveWarning</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recreates a state file. This is used in WAL replay and during
 * checkpoint creation.
 *
 * Note: content and len don't include CRC.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecreateTwoPhaseFile</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>content</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>statefile_crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<comment type="block">/* Recompute CRC */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>statefile_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>statefile_crc</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>statefile_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TwoPhaseFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
						   <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not recreate file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Write content and CRC */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TWOPHASE_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statefile_crc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32c</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must fsync the file because the end-of-replay checkpoint will not do
	 * so, there being no GXACT in shared memory yet to tell it to.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TWOPHASE_FILE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckPointTwoPhase -- handle 2PC component of checkpointing.
 *
 * We must fsync the state file of any GXACT that is valid or has been
 * generated during redo and has a PREPARE LSN &lt;= the checkpoint's redo
 * horizon.  (If the gxact isn't valid yet, has not been generated in
 * redo, or has a later LSN, this checkpoint is not responsible for
 * fsyncing it.)
 *
 * This is deliberately run as late as possible in the checkpoint sequence,
 * because GXACTs ordinarily have short lifespans, and so it is quite
 * possible that GXACTs that were valid at checkpoint start will no longer
 * exist if we wait a little bit. With typical checkpoint settings this
 * will be about 3 minutes for an online checkpoint, so as a result we
 * expect that there will be no GXACTs that need to be copied to disk.
 *
 * If a GXACT remains valid across multiple checkpoints, it will already
 * be on disk so we don't bother to repeat that write.
 */</comment>
<function><type><name>void</name></type>
<name>CheckPointTwoPhase</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>redo_horizon</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serialized_xacts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_prepared_xacts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We are expecting there to be zero GXACTs that need to be copied to
	 * disk, so we perform all I/O while holding TwoPhaseStateLock for
	 * simplicity. This prevents any new xacts from preparing while this
	 * occurs, which shouldn't be a problem since the presence of long-lived
	 * prepared xacts indicates the transaction manager isn't active.
	 *
	 * It's also possible to move I/O out of the lock, but on every error we
	 * should check whether somebody committed our transaction in different
	 * backend. Let's leave this optimization for future, if somebody will
	 * spot that this place cause bottleneck.
	 *
	 * Note that it isn't possible for there to be a GXACT with a
	 * prepare_end_lsn set prior to the last checkpoint yet is marked invalid,
	 * because of the efforts with delayChkpt.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Note that we are using gxact not pgxact so this works in recovery
		 * also
		 */</comment>
		<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>||</operator> <name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name> <operator>&amp;&amp;</operator>
			<name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name> <operator>&lt;=</operator> <name>redo_horizon</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XlogReadTwoPhaseData</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RecreateTwoPhaseFile</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>serialized_xacts</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Flush unconditionally the parent directory to make any information
	 * durable on disk.  Two-phase files could have been removed and those
	 * removals need to be made persistent as well as any files newly created
	 * previously since the last checkpoint.
	 */</comment>
	<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><name>TWOPHASE_DIR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_checkpoints</name> <operator>&amp;&amp;</operator> <name>serialized_xacts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"%u two-phase state file was written "</literal>
							   <literal type="string">"for a long-running prepared transaction"</literal></expr></argument>,
							   <argument><expr><literal type="string">"%u two-phase state files were written "</literal>
							   <literal type="string">"for long-running prepared transactions"</literal></expr></argument>,
							   <argument><expr><name>serialized_xacts</name></expr></argument>,
							   <argument><expr><name>serialized_xacts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * restoreTwoPhaseData
 *
 * Scan pg_twophase and fill TwoPhaseState depending on the on-disk data.
 * This is called once at the beginning of recovery, saving any extra
 * lookups in the future.  Two-phase files that are newer than the
 * minimum XID horizon are discarded on the way.
 */</comment>
<function><type><name>void</name></type>
<name>restoreTwoPhaseData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>cldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>clde</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cldir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>TWOPHASE_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>clde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>cldir</name></expr></argument>, <argument><expr><name>TWOPHASE_DIR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator>
			<call><name>strspn</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789ABCDEF"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">8</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>xid</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ProcessTwoPhaseBuffer</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PrepareRedoAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
						   <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>InvalidRepOriginId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>cldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PrescanPreparedTransactions
 *
 * Scan the shared memory entries of TwoPhaseState and determine the range
 * of valid XIDs present.  This is run during database startup, after we
 * have completed reading WAL.  ShmemVariableCache-&gt;nextFullXid has been set to
 * one more than the highest XID for which evidence exists in WAL.
 *
 * We throw away any prepared xacts with main XID beyond nextFullXid --- if any
 * are present, it suggests that the DBA has done a PITR recovery to an
 * earlier point in time without cleaning out pg_twophase.  We dare not
 * try to recover such prepared xacts since they likely depend on database
 * state that doesn't exist now.
 *
 * However, we will advance nextFullXid beyond any subxact XIDs belonging to
 * valid prepared xacts.  We need to do this since subxact commit doesn't
 * write a WAL entry, and so there might be no evidence in WAL of those
 * subxact XIDs.
 *
 * On corrupted two-phase files, fail immediately.  Keeping around broken
 * entries and let replay continue causes harm on the system, and a new
 * backup should be rolled in.
 *
 * Our other responsibility is to determine and return the oldest valid XID
 * among the prepared xacts (if none, return ShmemVariableCache-&gt;nextFullXid).
 * This is needed to synchronize pg_subtrans startup properly.
 *
 * If xids_p and nxids_p are not NULL, pointer to a palloc'd array of all
 * top-level xids is stored in *xids_p. The number of entries in the array
 * is returned in *nxids_p.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>PrescanPreparedTransactions</name><parameter_list>(<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier><modifier>*</modifier></type><name>xids_p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nxids_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>nextFullXid</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>origNextXid</name> <init>= <expr><call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name>nextFullXid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>result</name> <init>= <expr><name>origNextXid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nxids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>allocsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ProcessTwoPhaseBuffer</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
									<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>,
									<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK, we think this file is valid.  Incorporate xid into the
		 * running-minimum result.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>xids_p</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>==</operator> <name>allocsize</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>allocsize</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>xids</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>allocsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>allocsize</name> <operator>=</operator> <name>allocsize</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>xids</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>xids</name></expr></argument>, <argument><expr><name>allocsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>xids</name><index>[<expr><name>nxids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xids_p</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>xids_p</name> <operator>=</operator> <name>xids</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>nxids_p</name> <operator>=</operator> <name>nxids</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StandbyRecoverPreparedTransactions
 *
 * Scan the shared memory entries of TwoPhaseState and setup all the required
 * information to allow standby queries to treat prepared transactions as still
 * active.
 *
 * This is never called at the end of recovery - we use
 * RecoverPreparedTransactions() at that point.
 *
 * The lack of calls to SubTransSetParent() calls here is by design;
 * those calls are made by RecoverPreparedTransactions() at the end of recovery
 * for those xacts that need this.
 */</comment>
<function><type><name>void</name></type>
<name>StandbyRecoverPreparedTransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ProcessTwoPhaseBuffer</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
									<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>,
									<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RecoverPreparedTransactions
 *
 * Scan the shared memory entries of TwoPhaseState and reload the state for
 * each prepared transaction (reacquire locks, etc).
 *
 * This is run at the end of recovery, but before we allow backends to write
 * WAL.
 *
 * At the end of recovery the way we take snapshots will change. We now need
 * to mark all running transactions with their full SubTransSetParent() info
 * to allow normal snapshots to work correctly if snapshots overflow.
 * We do this here because by definition prepared transactions are the only
 * type of write transaction still running, so this is necessary and
 * complete.
 */</comment>
<function><type><name>void</name></type>
<name>RecoverPreparedTransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reconstruct subtrans state for the transaction --- needed because
		 * pg_subtrans is not preserved over a restart.  Note that we are
		 * linking all the subtransactions directly to the top-level XID;
		 * there may originally have been a more complex hierarchy, but
		 * there's no need to restore that exactly. It's possible that
		 * SubTransSetParent has been set before, if the prepared transaction
		 * generated xid assignment records.
		 */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ProcessTwoPhaseBuffer</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
									<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name></expr></argument>,
									<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovering prepared transaction %u from shared memory"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>gid</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>gidlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subxids</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ncommitrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nabortrels</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ninvalmsgs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Recreate its GXACT and dummy PGPROC. But, check whether it was
		 * added in redo and already has a shmem entry for it.
		 */</comment>
		<expr_stmt><expr><call><name>MarkAsPreparingGuts</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>,
							<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>prepared_at</name></name></expr></argument>,
							<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* recovered, so reset the flag for entries generated by redo */</comment>
		<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>GXactLoadSubxactData</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>subxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkAsPrepared</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Recover other state (notably locks) using resource managers.
		 */</comment>
		<expr_stmt><expr><call><name>ProcessRecords</name><argument_list>(<argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>twophase_recover_callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Release locks held by the standby process after we process each
		 * prepared transaction. As a result, we don't need too many
		 * additional locks at any one time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>StandbyReleaseLockTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name>subxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We're done with recovering this transaction. Clear MyLockedGxact,
		 * like we do in PrepareTransaction() during normal operation.
		 */</comment>
		<expr_stmt><expr><call><name>PostPrepare_Twophase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessTwoPhaseBuffer
 *
 * Given a transaction id, read it either from disk or read it directly
 * via shmem xlog record pointer using the provided "prepare_start_lsn".
 *
 * If setParent is true, set up subtransaction parent linkages.
 *
 * If setNextXid is true, set ShmemVariableCache-&gt;nextFullXid to the newest
 * value scanned.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ProcessTwoPhaseBuffer</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
					  <parameter><decl><type><name>XLogRecPtr</name></type> <name>prepare_start_lsn</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>fromdisk</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>setParent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>setNextXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>nextFullXid</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>origNextXid</name> <init>= <expr><call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name>nextFullXid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fromdisk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>prepare_start_lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Already processed? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fromdisk</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing stale two-phase state file for transaction %u"</literal></expr></argument>,
							<argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing stale two-phase state from memory for transaction %u"</literal></expr></argument>,
							<argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PrepareRedoRemove</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Reject XID if too new */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>origNextXid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fromdisk</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing future two-phase state file for transaction %u"</literal></expr></argument>,
							<argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing future two-phase state from memory for transaction %u"</literal></expr></argument>,
							<argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PrepareRedoRemove</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fromdisk</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Read and validate file */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Read xlog data */</comment>
		<expr_stmt><expr><call><name>XlogReadTwoPhaseData</name><argument_list>(<argument><expr><name>prepare_start_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Deconstruct header */</comment>
	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fromdisk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted two-phase state file for transaction %u"</literal></expr></argument>,
							<argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted two-phase state in memory for transaction %u"</literal></expr></argument>,
							<argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Examine subtransaction XIDs ... they should all follow main XID, and
	 * they may force us to advance nextFullXid.
	 */</comment>
	<expr_stmt><expr><name>subxids</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>buf</name> <operator>+</operator>
								 <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
								 <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>gidlen</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>subxid</name> <init>= <expr><name><name>subxids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* update nextFullXid if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>setNextXid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AdvanceNextFullTransactionIdPastXid</name><argument_list>(<argument><expr><name>subxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>setParent</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SubTransSetParent</name><argument_list>(<argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	RecordTransactionCommitPrepared
 *
 * This is basically the same as RecordTransactionCommit (q.v. if you change
 * this function): in particular, we must set the delayChkpt flag to avoid a
 * race condition.
 *
 * We know the transaction made at least one XLOG entry (its PREPARE),
 * so it is never possible to optimize out the commit record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordTransactionCommitPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>,
								<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>,
								<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>ninvalmsgs</name></decl></parameter>,
								<parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalmsgs</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>initfileinval</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>committs</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replorigin</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Are we using the replication origins feature?  Or, in other words, are
	 * we replaying remote actions?
	 */</comment>
	<expr_stmt><expr><name>replorigin</name> <operator>=</operator> <operator>(</operator><name>replorigin_session_origin</name> <operator>!=</operator> <name>InvalidRepOriginId</name> <operator>&amp;&amp;</operator>
				  <name>replorigin_session_origin</name> <operator>!=</operator> <name>DoNotReplicateId</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* See notes in RecordTransactionCommit */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>delayChkpt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Emit the XLOG commit record. Note that we mark 2PC commits as
	 * potentially having AccessExclusiveLocks since we don't know whether or
	 * not they do.
	 */</comment>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XactLogCommitRecord</name><argument_list>(<argument><expr><name>committs</name></expr></argument>,
								 <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>, <argument><expr><name>nrels</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>,
								 <argument><expr><name>ninvalmsgs</name></expr></argument>, <argument><expr><name>invalmsgs</name></expr></argument>,
								 <argument><expr><name>initfileinval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name>MyXactFlags</name> <operator>|</operator> <name>XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK</name></expr></argument>,
								 <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name>replorigin</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Move LSNs forward for this replication origin */</comment>
		<expr_stmt><expr><call><name>replorigin_session_advance</name><argument_list>(<argument><expr><name>replorigin_session_origin_lsn</name></expr></argument>,
								   <argument><expr><name>XactLastRecEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Record commit timestamp.  The value comes from plain commit timestamp
	 * if replorigin is not enabled, or replorigin already set a value for us
	 * in replorigin_session_origin_timestamp otherwise.
	 *
	 * We don't need to WAL-log anything here, as the commit record written
	 * above already contains the data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replorigin</name> <operator>||</operator> <name>replorigin_session_origin_timestamp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>replorigin_session_origin_timestamp</name> <operator>=</operator> <name>committs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TransactionTreeSetCommitTsData</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
								   <argument><expr><name>replorigin_session_origin_timestamp</name></expr></argument>,
								   <argument><expr><name>replorigin_session_origin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't currently try to sleep before flush here ... nor is there any
	 * support for async commit of a prepared xact (the very idea is probably
	 * a contradiction)
	 */</comment>

	<comment type="block">/* Flush XLOG to disk */</comment>
	<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the transaction committed in pg_xact */</comment>
	<expr_stmt><expr><call><name>TransactionIdCommitTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Checkpoint can proceed now */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait for synchronous replication, if required.
	 *
	 * Note that at this stage we have marked clog, but still show as running
	 * in the procarray and continue to hold locks.
	 */</comment>
	<expr_stmt><expr><call><name>SyncRepWaitForLSN</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	RecordTransactionAbortPrepared
 *
 * This is basically the same as RecordTransactionAbort.
 *
 * We know the transaction made at least one XLOG entry (its PREPARE),
 * so it is never possible to optimize out the abort record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordTransactionAbortPrepared</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>,
							   <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>,
							   <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Catch the scenario where we aborted partway through
	 * RecordTransactionCommitPrepared ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"cannot abort transaction %u, it was already committed"</literal></expr></argument>,
			 <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Emit the XLOG commit record. Note that we mark 2PC aborts as
	 * potentially having AccessExclusiveLocks since we don't know whether or
	 * not they do.
	 */</comment>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XactLogAbortRecord</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
								<argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
								<argument><expr><name>nrels</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>,
								<argument><expr><name>MyXactFlags</name> <operator>|</operator> <name>XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK</name></expr></argument>,
								<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Always flush, since we're about to remove the 2PC state file */</comment>
	<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the transaction aborted in clog.  This is not absolutely necessary
	 * but we may as well do it while we are here.
	 */</comment>
	<expr_stmt><expr><call><name>TransactionIdAbortTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait for synchronous replication, if required.
	 *
	 * Note that at this stage we have marked clog, but still show as running
	 * in the procarray and continue to hold locks.
	 */</comment>
	<expr_stmt><expr><call><name>SyncRepWaitForLSN</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PrepareRedoAdd
 *
 * Store pointers to the start/end of the WAL record along with the xid in
 * a gxact entry in shared memory TwoPhaseState structure.  If caller
 * specifies InvalidXLogRecPtr as WAL location to fetch the two-phase
 * data, the entry is marked as located on disk.
 */</comment>
<function><type><name>void</name></type>
<name>PrepareRedoAdd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>,
			   <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>, <parameter><decl><type><name>RepOriginId</name></type> <name>origin_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TwoPhaseFileHeader</name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator><name>TwoPhaseFileHeader</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TwoPhaseFileHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>gid</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>bufptr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reserve the GID for the given transaction in the redo code path.
	 *
	 * This creates a gxact struct and puts it into the active array.
	 *
	 * In redo, this struct is mainly used to track PREPARE/COMMIT entries in
	 * shared memory. Hence, we only fill up the bare minimum contents here.
	 * The gxact also gets marked with gxact-&gt;inredo set to true to indicate
	 * that it got added in the redo phase
	 */</comment>

	<comment type="block">/* Get a free gxact from the freelist */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"maximum number of prepared transactions reached"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase max_prepared_transactions (currently %d)."</literal></expr></argument>,
						 <argument><expr><name>max_prepared_xacts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>gxact</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>freeGXacts</name></name> <operator>=</operator> <name><name>gxact</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepared_at</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>prepared_at</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_start_lsn</name></name> <operator>=</operator> <name>start_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>prepare_end_lsn</name></name> <operator>=</operator> <name>end_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>owner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>locking_backend</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name> <operator>=</operator> <call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>start_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* yes, added in redo */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And insert it into the active array */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name> <operator>&lt;</operator> <name>max_prepared_xacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>gxact</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>origin_id</name> <operator>!=</operator> <name>InvalidRepOriginId</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* recover apply progress */</comment>
		<expr_stmt><expr><call><name>replorigin_advance</name><argument_list>(<argument><expr><name>origin_id</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>origin_lsn</name></name></expr></argument>, <argument><expr><name>end_lsn</name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument> <comment type="block">/* backward */</comment> , <argument><expr><name>false</name></expr></argument> <comment type="block">/* WAL */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"added 2PC data in shared memory for transaction %u"</literal></expr></argument>, <argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PrepareRedoRemove
 *
 * Remove the corresponding gxact entry from TwoPhaseState. Also remove
 * the 2PC file if a prepared transaction was saved via an earlier checkpoint.
 *
 * Caller must hold TwoPhaseStateLock in exclusive mode, because TwoPhaseState
 * is updated.
 */</comment>
<function><type><name>void</name></type>
<name>PrepareRedoRemove</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>giveWarning</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>numPrepXacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>gxact</name> <operator>=</operator> <name><name>TwoPhaseState</name><operator>-&gt;</operator><name>prepXacts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>==</operator> <name>xid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gxact</name><operator>-&gt;</operator><name>inredo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Just leave if there is nothing, this is expected during WAL replay.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * And now we can clean up any files we may have left.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"removing 2PC data for transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>gxact</name><operator>-&gt;</operator><name>ondisk</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveTwoPhaseFile</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>giveWarning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>RemoveGXact</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
