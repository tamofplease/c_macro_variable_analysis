<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/transam/xlogreader.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * xlogreader.c
 *		Generic XLog reading facility
 *
 * Portions Copyright (c) 2013-2020, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		src/backend/access/transam/xlogreader.c
 *
 * NOTES
 *		See xlogreader.h for more notes on this facility.
 *
 *		This file is compiled as both front-end and backend code, so it
 *		may not use ereport, server-defined static variables, etc.
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogrecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_lzcompress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_invalid_record</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
			pg_attribute_printf<parameter_list>(</parameter_list>2<operator>,</operator> 3</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>allocate_recordbuf</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>reclength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ReadPageInternal</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>pageptr</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogReaderInvalReadState</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ValidXLogRecordHeader</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>,
								  <parameter><decl><type><name>XLogRecPtr</name></type> <name>PrevRecPtr</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>randAccess</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ValidXLogRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
							<parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResetDecoder</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WALOpenSegmentInit</name><parameter_list>(<parameter><decl><type><name>WALOpenSegment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>WALSegmentContext</name> <modifier>*</modifier></type><name>segcxt</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>segsize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>waldir</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* size of the buffer allocated for error message. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ERRORMSG_LEN</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/*
 * Construct a string in state-&gt;errormsg_buf explaining what's wrong with
 * the current record being read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_invalid_record</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>, <argument><expr><name>MAX_ERRORMSG_LEN</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate and initialize a new XLogReader.
 *
 * Returns NULL if the xlogreader couldn't be allocated.
 */</comment>
<function><type><name>XLogReaderState</name> <modifier>*</modifier></type>
<name>XLogReaderAllocate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>wal_segment_size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>waldir</name></decl></parameter>,
				   <parameter><decl><type><name>XLogReaderRoutine</name> <modifier>*</modifier></type><name>routine</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>XLogReaderState</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc_extended</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogReaderState</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						<argument><expr><name>MCXT_ALLOC_NO_OOM</name> <operator>|</operator> <name>MCXT_ALLOC_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>state</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* initialize caller-provided support functions */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>routine</name></name> <operator>=</operator> <operator>*</operator><name>routine</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Permanently allocate readBuf.  We do it this way, rather than just
	 * making a static array, for two reasons: (1) no need to waste the
	 * storage in most instantiations of the backend; (2) a static char array
	 * isn't guaranteed to have any particular alignment, whereas
	 * palloc_extended() will provide MAXALIGN'd storage.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc_extended</name><argument_list>(<argument><expr><name>XLOG_BLCKSZ</name></expr></argument>,
											  <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize segment info. */</comment>
	<expr_stmt><expr><call><name>WALOpenSegmentInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>segcxt</name></name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>,
					   <argument><expr><name>waldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* system_identifier initialized to zeroes above */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>private_data</name></name> <operator>=</operator> <name>private_data</name></expr>;</expr_stmt>
	<comment type="block">/* ReadRecPtr, EndRecPtr and readLen initialized to zeroes above */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name> <operator>=</operator> <call><name>palloc_extended</name><argument_list>(<argument><expr><name>MAX_ERRORMSG_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										  <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate an initial readRecordBuf of minimal size, which can later be
	 * enlarged if necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>allocate_recordbuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>XLogReaderFree</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>block_id</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_file</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>state</name><operator>-&gt;</operator><name>routine</name><operator>.</operator><name>segment_close</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name>XLR_MAX_BLOCK_ID</name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate readRecordBuf to fit a record of at least the given length.
 * Returns true if successful, false if out of memory.
 *
 * readRecordBufSize is set to the new buffer size.
 *
 * To avoid useless small increases, round its size to a multiple of
 * XLOG_BLCKSZ, and make sure it's at least 5*Max(BLCKSZ, XLOG_BLCKSZ) to start
 * with.  (That is enough for all "normal" records, but very large commit or
 * abort records might need more space.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>allocate_recordbuf</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>reclength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newSize</name> <init>= <expr><name>reclength</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>newSize</name> <operator>+=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <operator>(</operator><name>newSize</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>newSize</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>, <argument><expr><literal type="number">5</literal> <operator>*</operator> <call><name>Max</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>

	<comment type="block">/*
	 * Note that in much unlucky circumstances, the random data read from a
	 * recycled segment can cause this routine to be called with a size
	 * causing a hard failure at allocation.  For a standby, this would cause
	 * the instance to stop suddenly with a hard failure, preventing it to
	 * retry fetching WAL from one of its sources which could allow it to move
	 * on with replay without a manual restart. If the data comes from a past
	 * recycled segment and is still valid, then the allocation may succeed
	 * but record checks are going to fail so this would be short-lived.  If
	 * the allocation fails because of a memory shortage, then this is not a
	 * hard failure either per the guarantee given by MCXT_ALLOC_NO_OOM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name> <operator>=</operator>
		<operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc_extended</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>, <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBufSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBufSize</name></name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the passed segment structs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WALOpenSegmentInit</name><parameter_list>(<parameter><decl><type><name>WALOpenSegment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>WALSegmentContext</name> <modifier>*</modifier></type><name>segcxt</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>segsize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>waldir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>seg</name><operator>-&gt;</operator><name>ws_file</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seg</name><operator>-&gt;</operator><name>ws_segno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seg</name><operator>-&gt;</operator><name>ws_tli</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>segcxt</name><operator>-&gt;</operator><name>ws_segsize</name></name> <operator>=</operator> <name>segsize</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>waldir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>segcxt</name><operator>-&gt;</operator><name>ws_dir</name></name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>waldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Begin reading WAL at 'RecPtr'.
 *
 * 'RecPtr' should point to the beginnning of a valid WAL record.  Pointing at
 * the beginning of a page is also OK, if there is a new record right after
 * the page header, i.e. not a continuation.
 *
 * This does not make any attempt to read the WAL yet, and hence cannot fail.
 * If the starting address is not correct, the first call to XLogReadRecord()
 * will error out.
 */</comment>
<function><type><name>void</name></type>
<name>XLogBeginRead</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResetDecoder</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Begin at the passed-in record pointer. */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to read an XLOG record.
 *
 * XLogBeginRead() or XLogFindNextRecord() must be called before the first call
 * to XLogReadRecord().
 *
 * If the page_read callback fails to read the requested data, NULL is
 * returned.  The callback is expected to have reported the error; errormsg
 * is set to NULL.
 *
 * If the reading fails for some other reason, NULL is also returned, and
 * *errormsg is set to a string with details of the failure.
 *
 * The returned pointer (or *errormsg) points to an internal buffer that's
 * valid until the next call to XLogReadRecord.
 */</comment>
<function><type><name>XLogRecord</name> <modifier>*</modifier></type>
<name>XLogReadRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>RecPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>targetPagePtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>randAccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>len</name></decl>,
				<decl><type ref="prev"/><name>total_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>targetRecOff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>pageHeaderSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>assembled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>gotheader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>readOff</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * randAccess indicates whether to verify the previous-record pointer of
	 * the record we're reading.  We only do this if we're reading
	 * sequentially, which is what we initially assume.
	 */</comment>
	<expr_stmt><expr><name>randAccess</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* reset error state */</comment>
	<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResetDecoder</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>abortedRecPtr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>missingContrecPtr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>RecPtr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* read the record after the one we just read */</comment>

		<comment type="block">/*
		 * EndRecPtr is pointing to end+1 of the previous WAL record.  If
		 * we're at a page boundary, no more records can fit on the current
		 * page. We must skip over the page header, but we can't do that until
		 * we've read in the page, since the header size is variable.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Caller supplied a position to start at.
		 *
		 * In this case, EndRecPtr should already be pointing to a valid
		 * record starting position.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XRecOffIsValid</name><argument_list>(<argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>randAccess</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<label><name>restart</name>:</label>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>assembled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetPagePtr</name> <operator>=</operator> <name>RecPtr</name> <operator>-</operator> <operator>(</operator><name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetRecOff</name> <operator>=</operator> <name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the page containing the record into state-&gt;readBuf. Request enough
	 * byte to cover the whole record header, or at least the part of it that
	 * fits on the same page.
	 */</comment>
	<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
							   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>targetRecOff</name> <operator>+</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * ReadPageInternal always returns at least the page header, so we can
	 * examine it now.
	 */</comment>
	<expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>targetRecOff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At page start, so skip over page header.
		 */</comment>
		<expr_stmt><expr><name>RecPtr</name> <operator>+=</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetRecOff</name> <operator>=</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>targetRecOff</name> <operator>&lt;</operator> <name>pageHeaderSize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"invalid record offset at %X/%X"</literal></expr></argument>,
							  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name><operator>)</operator><operator>-&gt;</operator><name>xlp_info</name> <operator>&amp;</operator> <name>XLP_FIRST_IS_CONTRECORD</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>targetRecOff</name> <operator>==</operator> <name>pageHeaderSize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"contrecord is requested by %X/%X"</literal></expr></argument>,
							  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ReadPageInternal has verified the page header */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pageHeaderSize</name> <operator>&lt;=</operator> <name>readOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the record length.
	 *
	 * NB: Even though we use an XLogRecord pointer here, the whole record
	 * header might not fit on this page. xl_tot_len is the first field of the
	 * struct, so it must be on this page (the records are MAXALIGNed), but we
	 * cannot access any other fields until we've verified that we got the
	 * whole header.
	 */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name> <operator>+</operator> <name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_len</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the whole record header is on this page, validate it immediately.
	 * Otherwise do just a basic sanity check on xl_tot_len, and validate the
	 * rest of the header after reading it from the next page.  The xl_tot_len
	 * check is necessary here to ensure that we enter the "Need to reassemble
	 * record" code path below; otherwise we might fail to apply
	 * ValidXLogRecordHeader at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetRecOff</name> <operator>&lt;=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>SizeOfXLogRecord</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogRecordHeader</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>, <argument><expr><name>record</name></expr></argument>,
								   <argument><expr><name>randAccess</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>gotheader</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* XXX: more validation should be done here */</comment>
		<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&lt;</operator> <name>SizeOfXLogRecord</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								  <argument><expr><literal type="string">"invalid record length at %X/%X: wanted %u, got %u"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>gotheader</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&gt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Need to reassemble record */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>contdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>pageHeader</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>gotlen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>assembled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Enlarge readRecordBuf as needed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBufSize</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>allocate_recordbuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We treat this as a "bogus data" condition */</comment>
			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"record length %u at %X/%X too long"</literal></expr></argument>,
								  <argument><expr><name>total_len</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Copy the first fragment of the record from the first page. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr></argument>,
			   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name> <operator>+</operator> <name>RecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>gotlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

		<do>do
		<block>{<block_content>
			<comment type="block">/* Calculate pointer to beginning of next page */</comment>
			<expr_stmt><expr><name>targetPagePtr</name> <operator>+=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

			<comment type="block">/* Wait for the next page to become available */</comment>
			<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
									   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>total_len</name> <operator>-</operator> <name>gotlen</name> <operator>+</operator> <name>SizeOfXLogShortPHD</name></expr></argument>,
										   <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SizeOfXLogShortPHD</name> <operator>&lt;=</operator> <name>readOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pageHeader</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we were expecting a continuation record and got an
			 * "overwrite contrecord" flag, that means the continuation record
			 * was overwritten with a different record.  Restart the read by
			 * assuming the address to read is the location where we found
			 * this flag; but keep track of the LSN of the record we were
			 * reading, for later verification.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>XLP_FIRST_IS_OVERWRITE_CONTRECORD</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>overwrittenRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ResetDecoder</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>RecPtr</name> <operator>=</operator> <name>targetPagePtr</name></expr>;</expr_stmt>
				<goto>goto <name>restart</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Check that the continuation on next page looks valid */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>XLP_FIRST_IS_CONTRECORD</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									  <argument><expr><literal type="string">"there is no contrecord flag at %X/%X"</literal></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Cross-check that xlp_rem_len agrees with how much of the record
			 * we expect there to be left.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>total_len</name> <operator>!=</operator> <operator>(</operator><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>+</operator> <name>gotlen</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									  <argument><expr><literal type="string">"invalid contrecord length %u at %X/%X"</literal></expr></argument>,
									  <argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Append the continuation from this page to the buffer */</comment>
			<expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><name>pageHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <name>pageHeaderSize</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
										   <argument><expr><name>pageHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pageHeaderSize</name> <operator>&lt;=</operator> <name>readOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>contdata</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name> <operator>+</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name>XLOG_BLCKSZ</name> <operator>-</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <name>pageHeaderSize</name> <operator>+</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
										   <argument><expr><name>pageHeaderSize</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>contdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>gotlen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

			<comment type="block">/* If we just reassembled the record header, validate it. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gotheader</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogRecordHeader</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
										   <argument><expr><name>record</name></expr></argument>, <argument><expr><name>randAccess</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>gotheader</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block> while <condition>(<expr><name>gotlen</name> <operator>&lt;</operator> <name>total_len</name></expr>)</condition>;</do>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gotheader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>pageHeaderSize</name>
			<operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Wait for the record data to become available */</comment>
		<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
								   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>targetRecOff</name> <operator>+</operator> <name>total_len</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Record does not cross a page boundary */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidXLogRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <name>RecPtr</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Special processing if it's an XLOG SWITCH record
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>==</operator> <name>RM_XLOG_ID</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name><operator>)</operator> <operator>==</operator> <name>XLOG_SWITCH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Pretend it extends to end of segment */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>-=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DecodeXLogRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>record</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>

<label><name>err</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>assembled</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We get here when a record that spans multiple pages needs to be
		 * assembled, but something went wrong -- perhaps a contrecord piece
		 * was lost.  If caller is WAL replay, it will know where the aborted
		 * record was and where to direct followup WAL to be written, marking
		 * the next piece with XLP_FIRST_IS_OVERWRITE_CONTRECORD, which will
		 * in turn signal downstream WAL consumers that the broken WAL record
		 * is to be ignored.
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>abortedRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>missingContrecPtr</name></name> <operator>=</operator> <name>targetPagePtr</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Invalidate the read state. We might read from a different source after
	 * failure.
	 */</comment>
	<expr_stmt><expr><call><name>XLogReaderInvalReadState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a single xlog page including at least [pageptr, reqLen] of valid data
 * via the page_read() callback.
 *
 * Returns -1 if the required page cannot be read for some reason; errormsg_buf
 * is set in that case (unless the error occurs in the page_read callback).
 *
 * We fetch the page from a reader-local cache if we know we have the required
 * data and if there hasn't been any error since caching the data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadPageInternal</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>pageptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>readLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>targetPageOff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>targetSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>hdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>pageptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>pageptr</name></expr></argument>, <argument><expr><name>targetSegNo</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetPageOff</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>pageptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check whether we have all the requested data already */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetSegNo</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_segno</name></name> <operator>&amp;&amp;</operator>
		<name>targetPageOff</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>segoff</name></name> <operator>&amp;&amp;</operator> <name>reqLen</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>readLen</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>readLen</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Data is not in our buffer.
	 *
	 * Every time we actually read the segment, even if we looked at parts of
	 * it before, we need to do verification as the page_read callback might
	 * now be rereading data from a different source.
	 *
	 * Whenever switching to a new WAL segment, we read the first page of the
	 * file and validate its header, even if that's not where the target
	 * record is.  This is so that we can check the additional identification
	 * info that is present in the first page's "long" header.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetSegNo</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_segno</name></name> <operator>&amp;&amp;</operator> <name>targetPageOff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>targetSegmentPtr</name> <init>= <expr><name>pageptr</name> <operator>-</operator> <name>targetPageOff</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>routine</name><operator>.</operator><name>page_read</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetSegmentPtr</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>,
										   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name></expr></argument>,
										   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* we can be sure to have enough WAL available, we scrolled back */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>readLen</name> <operator>==</operator> <name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogReaderValidatePageHeader</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetSegmentPtr</name></expr></argument>,
										  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * First, read the requested data length, but at least a short page header
	 * so that we can validate it.
	 */</comment>
	<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>routine</name><operator>.</operator><name>page_read</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pageptr</name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>reqLen</name></expr></argument>, <argument><expr><name>SizeOfXLogShortPHD</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name></expr></argument>,
									   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>readLen</name> <operator>&lt;=</operator> <name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do we have enough data to check the header length? */</comment>
	<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;=</operator> <name>SizeOfXLogShortPHD</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>readLen</name> <operator>&gt;=</operator> <name>reqLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr>;</expr_stmt>

	<comment type="block">/* still not enough */</comment>
	<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>routine</name><operator>.</operator><name>page_read</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pageptr</name></expr></argument>, <argument><expr><call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name></expr></argument>,
										   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that we know we have the full header, validate it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogReaderValidatePageHeader</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pageptr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* update read state information */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_segno</name></name> <operator>=</operator> <name>targetSegNo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>segoff</name></name> <operator>=</operator> <name>targetPageOff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>=</operator> <name>readLen</name></expr>;</expr_stmt>

	<return>return <expr><name>readLen</name></expr>;</return>

<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>XLogReaderInvalReadState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Invalidate the xlogreader's read state to force a re-read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogReaderInvalReadState</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_segno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>segoff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Validate an XLOG record header.
 *
 * This is just a convenience subroutine to avoid duplicated code in
 * XLogReadRecord.  It's not intended for use from anywhere else.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ValidXLogRecordHeader</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>,
					  <parameter><decl><type><name>XLogRecPtr</name></type> <name>PrevRecPtr</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>randAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>&lt;</operator> <name>SizeOfXLogRecord</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
							  <argument><expr><literal type="string">"invalid record length at %X/%X: wanted %u, got %u"</literal></expr></argument>,
							  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>&gt;</operator> <name>RM_MAX_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
							  <argument><expr><literal type="string">"invalid resource manager ID %u at %X/%X"</literal></expr></argument>,
							  <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
							  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>randAccess</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can't exactly verify the prev-link, but surely it should be less
		 * than the record's own address.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&lt;</operator> <name>RecPtr</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								  <argument><expr><literal type="string">"record with incorrect prev-link %X/%X at %X/%X"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Record's prev-link should exactly match our previous location. This
		 * check guards against torn WAL pages where a stale but valid-looking
		 * WAL record starts on a sector boundary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>!=</operator> <name>PrevRecPtr</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								  <argument><expr><literal type="string">"record with incorrect prev-link %X/%X at %X/%X"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CRC-check an XLOG record.  We do not believe the contents of an XLOG
 * record (other than to the minimal extent of computing the amount of
 * data to read in) until we've checked the CRCs.
 *
 * We assume all of the record (that is, xl_tot_len bytes) has been read
 * into memory at *record.  Also, ValidXLogRecordHeader() has accepted the
 * record's header, which means in particular that xl_tot_len is at least
 * SizeOfXLogRecord.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ValidXLogRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>crc</name></decl>;</decl_stmt>

	<comment type="block">/* Calculate the CRC */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator> <operator>+</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>-</operator> <name>SizeOfXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* include the record header last */</comment>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
							  <argument><expr><literal type="string">"incorrect resource manager data checksum in record at %X/%X"</literal></expr></argument>,
							  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate a page header.
 *
 * Check if 'phdr' is valid as the header of the XLog page at position
 * 'recptr'.
 */</comment>
<function><type><name>bool</name></type>
<name>XLogReaderValidatePageHeader</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>phdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recaddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>hdr</name> <init>= <expr><operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name>phdr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>recptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>, <argument><expr><name>recaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_magic</name></name> <operator>!=</operator> <name>XLOG_PAGE_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_tli</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
							  <argument><expr><literal type="string">"invalid magic number %04X in log segment %s, offset %u"</literal></expr></argument>,
							  <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_magic</name></name></expr></argument>,
							  <argument><expr><name>fname</name></expr></argument>,
							  <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLP_ALL_FLAGS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_tli</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
							  <argument><expr><literal type="string">"invalid info bits %04X in log segment %s, offset %u"</literal></expr></argument>,
							  <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name></expr></argument>,
							  <argument><expr><name>fname</name></expr></argument>,
							  <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>XLP_LONG_HEADER</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogLongPageHeader</name></type> <name>longhdr</name> <init>= <expr><operator>(</operator><name>XLogLongPageHeader</name><operator>)</operator> <name>hdr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name> <operator>&amp;&amp;</operator>
			<name><name>longhdr</name><operator>-&gt;</operator><name>xlp_sysid</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								  <argument><expr><literal type="string">"WAL file is from different database system: WAL file database system identifier is %llu, pg_control database system identifier is %llu"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name><name>longhdr</name><operator>-&gt;</operator><name>xlp_sysid</name></name></expr></argument>,
								  <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_seg_size</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								  <argument><expr><literal type="string">"WAL file is from different database system: incorrect segment size in page header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_xlog_blcksz</name></name> <operator>!=</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								  <argument><expr><literal type="string">"WAL file is from different database system: incorrect XLOG_BLCKSZ in page header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_tli</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* hmm, first page of file doesn't have a long header? */</comment>
		<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
							  <argument><expr><literal type="string">"invalid info bits %04X in log segment %s, offset %u"</literal></expr></argument>,
							  <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name></expr></argument>,
							  <argument><expr><name>fname</name></expr></argument>,
							  <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that the address on the page agrees with what we expected. This
	 * check typically fails when an old WAL segment is recycled, and hasn't
	 * yet been overwritten with new data yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>!=</operator> <name>recaddr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_tli</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
							  <argument><expr><literal type="string">"unexpected pageaddr %X/%X in log segment %s, offset %u"</literal></expr></argument>,
							  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name></expr></argument>,
							  <argument><expr><name>fname</name></expr></argument>,
							  <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since child timelines are always assigned a TLI greater than their
	 * immediate parent's TLI, we should never see TLI go backwards across
	 * successive pages of a consistent WAL sequence.
	 *
	 * Sometimes we re-read a segment that's already been (partially) read. So
	 * we only verify TLIs for pages that are later than the last remembered
	 * LSN.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recptr</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>latestPagePtr</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_tli</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>latestPageTLI</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_tli</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								  <argument><expr><literal type="string">"out-of-sequence timeline ID %u (after %u) in log segment %s, offset %u"</literal></expr></argument>,
								  <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_tli</name></name></expr></argument>,
								  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>latestPageTLI</name></name></expr></argument>,
								  <argument><expr><name>fname</name></expr></argument>,
								  <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>latestPagePtr</name></name> <operator>=</operator> <name>recptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>latestPageTLI</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>xlp_tli</name></name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FRONTEND</name></cpp:ifdef>
<comment type="block">/*
 * Functions that are currently not needed in the backend, but are better
 * implemented inside xlogreader.c because of the internal facilities available
 * here.
 */</comment>

<comment type="block">/*
 * Find the first record with an lsn &gt;= RecPtr.
 *
 * This is different from XLogBeginRead() in that RecPtr doesn't need to point
 * to a valid record boundary.  Useful for checking whether RecPtr is a valid
 * xlog address for reading, and to find the first valid address after some
 * address when dumping records for debugging purposes.
 *
 * This positions the reader, like XLogBeginRead(), so that the next call to
 * XLogReadRecord() will read the next valid record.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>XLogFindNextRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>tmpRecPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>found</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * skip over potential continuation data, keeping in mind that it may span
	 * multiple pages
	 */</comment>
	<expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>targetPagePtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>targetRecOff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>pageHeaderSize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>readLen</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Compute targetRecOff. It should typically be equal or greater than
		 * short page-header since a valid record can't start anywhere before
		 * that, except when caller has explicitly specified the offset that
		 * falls somewhere there or when we are skipping multi-page
		 * continuation record. It doesn't matter though because
		 * ReadPageInternal() is prepared to handle that and will read at
		 * least short page-header worth of data
		 */</comment>
		<expr_stmt><expr><name>targetRecOff</name> <operator>=</operator> <name>tmpRecPtr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

		<comment type="block">/* scroll back to page boundary */</comment>
		<expr_stmt><expr><name>targetPagePtr</name> <operator>=</operator> <name>tmpRecPtr</name> <operator>-</operator> <name>targetRecOff</name></expr>;</expr_stmt>

		<comment type="block">/* Read the page containing the record */</comment>
		<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>targetRecOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>readBuf</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>XLogPageHeaderSize</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make sure we have enough data for the page header */</comment>
		<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name>ReadPageInternal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>pageHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* skip over potential continuation data */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>XLP_FIRST_IS_CONTRECORD</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the length of the remaining continuation data is more than
			 * what can fit in this page, the continuation record crosses over
			 * this page. Read the next page and try again. xlp_rem_len in the
			 * next page header will contain the remaining length of the
			 * continuation data
			 *
			 * Note that record headers are MAXALIGN'ed
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>-</operator> <name>pageHeaderSize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The previous continuation record ends in this page. Set
				 * tmpRecPtr to point to the first valid record
				 */</comment>
				<expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>pageHeaderSize</name>
					<operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * we know now that tmpRecPtr is an address pointing to a valid XLogRecord
	 * because either we're at the first record after the beginning of a page
	 * or we just jumped over the remaining data of a continuation.
	 */</comment>
	<expr_stmt><expr><call><name>XLogBeginRead</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tmpRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* past the record we've found, break out */</comment>
		<if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Rewind the reader to the beginning of the last record. */</comment>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogBeginRead</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>found</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>XLogReaderInvalReadState</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* FRONTEND */</comment>

<comment type="block">/*
 * Helper function to ease writing of XLogRoutine-&gt;page_read callbacks.
 * If this function is used, caller must supply a segment_open callback in
 * 'state', as that is used here.
 *
 * Read 'count' bytes into 'buf', starting at location 'startptr', from WAL
 * fetched from timeline 'tli'.
 *
 * Returns true if succeeded, false if an error occurs, in which case
 * 'errinfo' receives error details.
 *
 * XXX probably this should be improved to suck data directly from the
 * WAL buffers when possible.
 */</comment>
<function><type><name>bool</name></type>
<name>WALRead</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
		<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>startptr</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>,
		<parameter><decl><type><name>WALReadError</name> <modifier>*</modifier></type><name>errinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name>startptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>startoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>readbytes</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>startoff</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the data we want is not in a segment we have open, close what we
		 * have (if anything) and open the next one, using the caller's
		 * provided openSegment callback.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_file</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_segno</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>tli</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_tli</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>nextSegNo</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>state</name><operator>-&gt;</operator><name>routine</name><operator>.</operator><name>segment_close</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>nextSegNo</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>state</name><operator>-&gt;</operator><name>routine</name><operator>.</operator><name>segment_open</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>nextSegNo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* This shouldn't happen -- indicates a bug in segment_open */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Update the current segment info. */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_tli</name></name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_segno</name></name> <operator>=</operator> <name>nextSegNo</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* How many bytes are within this segment? */</comment>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name> <operator>-</operator> <name>startoff</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>segcxt</name><operator>.</operator><name>ws_segsize</name></name> <operator>-</operator> <name>startoff</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Reset errno first; eases reporting non-errno-affecting errors */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>readbytes</name> <operator>=</operator> <call><name>pg_pread</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>ws_file</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>segbytes</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>startoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>readbytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_errno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_req</name></name> <operator>=</operator> <name>segbytes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_read</name></name> <operator>=</operator> <name>readbytes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_off</name></name> <operator>=</operator> <name>startoff</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>errinfo</name><operator>-&gt;</operator><name>wre_seg</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>seg</name></name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update state for read */</comment>
		<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>-=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------
 * Functions for decoding the data and block references in a record.
 * ----------------------------------------
 */</comment>

<comment type="block">/* private function to reset the state between records */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetDecoder</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>block_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>in_use</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>has_image</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>has_data</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>apply_image</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decode the previously read record.
 *
 * On error, a human-readable error message is returned in *errormsg, and
 * the return value is false.
 */</comment>
<function><type><name>bool</name></type>
<name>DecodeXLogRecord</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * read next _size bytes from record buffer, but check for overrun first.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_HEADER_FIELD</name><parameter_list>(<parameter><type><name>_dst</name></type></parameter>, <parameter><type><name>_size</name></type></parameter>)</parameter_list></cpp:macro>			\
	<cpp:value>do {										\
		if (remaining &lt; _size)					\
			goto shortdata_err;					\
		memcpy(_dst, ptr, _size);				\
		ptr += _size;							\
		remaining -= _size;						\
	} while(0)</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>remaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>datatotal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>block_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResetDecoder</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name></name> <operator>=</operator> <name>record</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>record_origin</name></name> <operator>=</operator> <name>InvalidRepOriginId</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>SizeOfXLogRecord</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>remaining</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>-</operator> <name>SizeOfXLogRecord</name></expr>;</expr_stmt>

	<comment type="block">/* Decode the headers */</comment>
	<expr_stmt><expr><name>datatotal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <name>datatotal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block_id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_DATA_SHORT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* XLogRecordDataHeaderShort */</comment>
			<decl_stmt><decl><type><name>uint8</name></type>		<name>main_data_len</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>main_data_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>=</operator> <name>main_data_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>datatotal</name> <operator>+=</operator> <name>main_data_len</name></expr>;</expr_stmt>
			<break>break;</break>				<comment type="block">/* by convention, the main data fragment is
								 * always last */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_DATA_LONG</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* XLogRecordDataHeaderLong */</comment>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>main_data_len</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>main_data_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>=</operator> <name>main_data_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>datatotal</name> <operator>+=</operator> <name>main_data_len</name></expr>;</expr_stmt>
			<break>break;</break>				<comment type="block">/* by convention, the main data fragment is
								 * always last */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_ORIGIN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>record_origin</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RepOriginId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>block_id</name> <operator>&lt;=</operator> <name>XLR_MAX_BLOCK_ID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* XLogRecordBlockHeader */</comment>
			<decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>blk</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint8</name></type>		<name>fork_flags</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									  <argument><expr><literal type="string">"out-of-order block_id %u at %X/%X"</literal></expr></argument>,
									  <argument><expr><name>block_id</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>=</operator> <name>block_id</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>blk</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>apply_image</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fork_flags</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>forknum</name></name> <operator>=</operator> <name>fork_flags</name> <operator>&amp;</operator> <name>BKPBLOCK_FORK_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>fork_flags</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>fork_flags</name> <operator>&amp;</operator> <name>BKPBLOCK_HAS_IMAGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>fork_flags</name> <operator>&amp;</operator> <name>BKPBLOCK_HAS_DATA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* cross-check that the HAS_DATA flag is set iff data_length &gt; 0 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>&amp;&amp;</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									  <argument><expr><literal type="string">"BKPBLOCK_HAS_DATA set, but no data included at %X/%X"</literal></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>&amp;&amp;</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									  <argument><expr><literal type="string">"BKPBLOCK_HAS_DATA not set, but data length is %u at %X/%X"</literal></expr></argument>,
									  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>datatotal</name> <operator>+=</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>apply_image</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_APPLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>datatotal</name> <operator>+=</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * cross-check that hole_offset &gt; 0, hole_length &gt; 0 and
				 * bimg_len &lt; BLCKSZ if the HAS_HOLE flag is set.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					 <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name> <operator>==</operator> <name>BLCKSZ</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"BKPIMAGE_HAS_HOLE set, but hole offset %u length %u block image length %u at %X/%X"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * cross-check that hole_offset == 0 and hole_length == 0 if
				 * the HAS_HOLE flag is not set.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"BKPIMAGE_HAS_HOLE not set, but hole offset %u length %u at %X/%X"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * cross-check that bimg_len &lt; BLCKSZ if the IS_COMPRESSED
				 * flag is set.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name> <operator>==</operator> <name>BLCKSZ</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"BKPIMAGE_IS_COMPRESSED set, but block image length %u at %X/%X"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * cross-check that bimg_len = BLCKSZ if neither HAS_HOLE nor
				 * IS_COMPRESSED flag is set.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"neither BKPIMAGE_HAS_HOLE nor BKPIMAGE_IS_COMPRESSED set, but block image length is %u at %X/%X"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>fork_flags</name> <operator>&amp;</operator> <name>BKPBLOCK_SAME_REL</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rnode</name> <operator>=</operator> <operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>rnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"BKPBLOCK_SAME_REL set but no previous rel at %X/%X"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name> <operator>=</operator> <operator>*</operator><name>rnode</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>COPY_HEADER_FIELD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								  <argument><expr><literal type="string">"invalid block_id %u at %X/%X"</literal></expr></argument>,
								  <argument><expr><name>block_id</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>!=</operator> <name>datatotal</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>shortdata_err</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ok, we've parsed the fragment headers, and verified that the total
	 * length of the payload in the fragments is equal to the amount of data
	 * left. Copy the data of each fragment to a separate buffer.
	 *
	 * We could just set up pointers into readRecordBuf, but we want to align
	 * the data for the convenience of the callers. Backup images are not
	 * copied, however; they don't need alignment.
	 */</comment>

	<comment type="block">/* block data first */</comment>
	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>blk</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>blk</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name> <operator>||</operator> <operator>!</operator><name><name>blk</name><operator>-&gt;</operator><name>apply_image</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>bkp_image</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>blk</name><operator>-&gt;</operator><name>data</name></name> <operator>||</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name> <operator>&gt;</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_bufsz</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Force the initial request to be BLCKSZ so that we don't
				 * waste time with lots of trips through this stanza as a
				 * result of WAL compression.
				 */</comment>
				<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>data_bufsz</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data_bufsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* and finally, the main data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>main_data_bufsz</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * main_data_bufsz must be MAXALIGN'ed.  In many xlog record
			 * types, we omit trailing struct padding on-disk to save a few
			 * bytes; but compilers may generate accesses to the xlog struct
			 * that assume that padding bytes are present.  If the palloc
			 * request is not large enough to include such padding bytes then
			 * we'll get valgrind complaints due to otherwise-harmless fetches
			 * of the padding bytes.
			 *
			 * In addition, force the initial request to be reasonably large
			 * so that we don't waste time with lots of trips through this
			 * stanza.  BLCKSZ / 2 seems like a good compromise choice.
			 */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_bufsz</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name></expr></argument>,
												  <argument><expr><name>BLCKSZ</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_bufsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>

<label><name>shortdata_err</name>:</label>
	<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
						  <argument><expr><literal type="string">"record with invalid length at %X/%X"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
	<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns information about the block that a block reference refers to.
 *
 * If the WAL record contains a block reference with the given ID, *rnode,
 * *forknum, and *blknum are filled in (if not NULL), and returns true.
 * Otherwise returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>XLogRecGetBlockTag</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>,
				   <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name> <modifier>*</modifier></type><name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>blknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>bkpb</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>in_use</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bkpb</name> <operator>=</operator> <operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rnode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>rnode</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>rnode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>forknum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>forknum</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>forknum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>blknum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>blknum</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>blkno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the data associated with a block reference, or NULL if there is
 * no data (e.g. because a full-page image was taken instead). The returned
 * pointer points to a MAXALIGNed buffer.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>XLogRecGetBlockData</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>bkpb</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>in_use</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bkpb</name> <operator>=</operator> <operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bkpb</name><operator>-&gt;</operator><name>has_data</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>data_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name><name>bkpb</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Restore a full-page image from a backup block attached to an XLOG record.
 *
 * Returns true if a full-page image is restored.
 */</comment>
<function><type><name>bool</name></type>
<name>RestoreBlockImage</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>bkpb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>tmp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>in_use</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>has_image</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bkpb</name> <operator>=</operator> <operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>bkp_image</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bkpb</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If a backup block image is compressed, decompress it */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pglz_decompress</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>bkpb</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>data</name></name></expr></argument>,
							<argument><expr><name>BLCKSZ</name> <operator>-</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="string">"invalid compressed image at %X/%X, block %d"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
								  <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* generate page, taking into account hole if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* must zero-fill the hole */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <operator>(</operator><name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>+</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name><operator>)</operator></expr></argument>,
			   <argument><expr><name>ptr</name> <operator>+</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
			   <argument><expr><name>BLCKSZ</name> <operator>-</operator> <operator>(</operator><name><name>bkpb</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>+</operator> <name><name>bkpb</name><operator>-&gt;</operator><name>hole_length</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>

<comment type="block">/*
 * Extract the FullTransactionId from a WAL record.
 */</comment>
<function><type><name>FullTransactionId</name></type>
<name>XLogRecGetFullXid</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>,
				<decl><type ref="prev"/><name>next_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>epoch</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This function is only safe during replay, because it depends on the
	 * replay state.  See AdvanceNextFullTransactionIdPastXid() for more.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AmStartupProcess</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_xid</name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>epoch</name> <operator>=</operator> <call><name>EpochFromFullTransactionId</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If xid is numerically greater than next_xid, it has to be from the last
	 * epoch.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>xid</name> <operator>&gt;</operator> <name>next_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>--</operator><name>epoch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>FullTransactionIdFromEpochAndXid</name><argument_list>(<argument><expr><name>epoch</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
