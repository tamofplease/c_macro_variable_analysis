<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/heap/heaptoast.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * heaptoast.c
 *	  Heap-specific definitions for external and compressed storage
 *	  of variable size attributes.
 *
 * Copyright (c) 2000-2020, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/heap/heaptoast.c
 *
 *
 * INTERFACE ROUTINES
 *		heap_toast_insert_or_update -
 *			Try to make a given tuple fit into one page by compressing
 *			or moving off attributes
 *
 *		heap_toast_delete -
 *			Reclaim toast storage when a tuple is deleted
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/detoast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heaptoast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/toast_helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/toast_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>


<comment type="block">/* ----------
 * heap_toast_delete -
 *
 *	Cascaded delete toast-entries on DELETE
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>heap_toast_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_speculative</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>toast_values</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>toast_isnull</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should only ever be called for tuples of plain relations or
	 * materialized views --- recursing on a toast rel is bad news.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the tuple descriptor and break down the tuple into fields.
	 *
	 * NOTE: it's debatable whether to use heap_deform_tuple() here or just
	 * heap_getattr() only the varlena columns.  The latter could win if there
	 * are few varlena columns and many non-varlena ones. However,
	 * heap_deform_tuple costs only O(N) while the heap_getattr way would cost
	 * O(N^2) if there are many varlena columns, so it seems better to err on
	 * the side of linear cost.  (We won't even be here unless there's at
	 * least one varlena column, by the way.)
	 */</comment>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;=</operator> <name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the real work. */</comment>
	<expr_stmt><expr><call><name>toast_delete_external</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>, <argument><expr><name>is_speculative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * heap_toast_insert_or_update -
 *
 *	Delete no-longer-used toast-entries and create new ones to
 *	make the new tuple fit on INSERT or UPDATE
 *
 * Inputs:
 *	newtup: the candidate new tuple to be inserted
 *	oldtup: the old row version for UPDATE, or NULL for INSERT
 *	options: options to be passed to heap_insert() for toast rows
 * Result:
 *	either newtup if no toasting is needed, or a palloc'd modified tuple
 *	that is what should actually get stored
 *
 * NOTE: neither newtup nor oldtup will be modified.  This is a change
 * from the pre-8.1 API of this routine.
 * ----------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_toast_insert_or_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtup</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>result_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAttrs</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Size</name></type>		<name>maxDataLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hoff</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name><name>toast_isnull</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>toast_oldisnull</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>toast_values</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>toast_oldvalues</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ToastAttrInfo</name></type> <name><name>toast_attr</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ToastTupleContext</name></type> <name>ttc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ignore the INSERT_SPECULATIVE option. Speculative insertions/super
	 * deletions just normally insert/delete the toast values. It seems
	 * easiest to deal with that here, instead on, potentially, multiple
	 * callers.
	 */</comment>
	<expr_stmt><expr><name>options</name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_INSERT_SPECULATIVE</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should only ever be called for tuples of plain relations or
	 * materialized views --- recursing on a toast rel is bad news.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the tuple descriptor and break down the tuple(s) into fields.
	 */</comment>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numAttrs</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldtup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_oldvalues</name></expr></argument>, <argument><expr><name>toast_oldisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* ----------
	 * Prepare for toasting
	 * ----------
	 */</comment>
	<expr_stmt><expr><name><name>ttc</name><operator>.</operator><name>ttc_rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ttc</name><operator>.</operator><name>ttc_values</name></name> <operator>=</operator> <name>toast_values</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ttc</name><operator>.</operator><name>ttc_isnull</name></name> <operator>=</operator> <name>toast_isnull</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldtup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ttc</name><operator>.</operator><name>ttc_oldvalues</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ttc</name><operator>.</operator><name>ttc_oldisnull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>ttc</name><operator>.</operator><name>ttc_oldvalues</name></name> <operator>=</operator> <name>toast_oldvalues</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ttc</name><operator>.</operator><name>ttc_oldisnull</name></name> <operator>=</operator> <name>toast_oldisnull</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>ttc</name><operator>.</operator><name>ttc_attr</name></name> <operator>=</operator> <name>toast_attr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>toast_tuple_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ----------
	 * Compress and/or save external until data fits into target length
	 *
	 *	1: Inline compress attributes with attstorage EXTENDED, and store very
	 *	   large attributes with attstorage EXTENDED or EXTERNAL external
	 *	   immediately
	 *	2: Store attributes with attstorage EXTENDED or EXTERNAL external
	 *	3: Inline compress attributes with attstorage MAIN
	 *	4: Store attributes with attstorage MAIN external
	 * ----------
	 */</comment>

	<comment type="block">/* compute header overhead --- this should match heap_form_tuple() */</comment>
	<expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ttc</name><operator>.</operator><name>ttc_flags</name></name> <operator>&amp;</operator> <name>TOAST_HAS_NULLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hoff</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>hoff</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>hoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* now convert to a limit on the tuple data size */</comment>
	<expr_stmt><expr><name>maxDataLen</name> <operator>=</operator> <call><name>RelationGetToastTupleTarget</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>TOAST_TUPLE_TARGET</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>hoff</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look for attributes with attstorage EXTENDED to compress.  Also find
	 * large attributes with attstorage EXTENDED or EXTERNAL, and store them
	 * external.
	 */</comment>
	<while>while <condition>(<expr><call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
								  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxDataLen</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>biggest_attno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>biggest_attno</name> <operator>=</operator> <call><name>toast_tuple_find_biggest_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>biggest_attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Attempt to compress it inline, if it has attstorage EXTENDED
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>biggest_attno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attstorage</name> <operator>==</operator> <name>TYPSTORAGE_EXTENDED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>toast_tuple_try_compression</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>, <argument><expr><name>biggest_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * has attstorage EXTERNAL, ignore on subsequent compression
			 * passes
			 */</comment>
			<expr_stmt><expr><name><name>toast_attr</name><index>[<expr><name>biggest_attno</name></expr>]</index></name><operator>.</operator><name>tai_colflags</name> <operator>|=</operator> <name>TOASTCOL_INCOMPRESSIBLE</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If this value is by itself more than maxDataLen (after compression
		 * if any), push it out to the toast table immediately, if possible.
		 * This avoids uselessly compressing other fields in the common case
		 * where we have one long field and several short ones.
		 *
		 * XXX maybe the threshold should be less than maxDataLen?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>toast_attr</name><index>[<expr><name>biggest_attno</name></expr>]</index></name><operator>.</operator><name>tai_size</name> <operator>&gt;</operator> <name>maxDataLen</name> <operator>&amp;&amp;</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>toast_tuple_externalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>, <argument><expr><name>biggest_attno</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Second we look for attributes of attstorage EXTENDED or EXTERNAL that
	 * are still inline, and make them external.  But skip this if there's no
	 * toast table to push them to.
	 */</comment>
	<while>while <condition>(<expr><call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
								  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxDataLen</name> <operator>&amp;&amp;</operator>
		   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>biggest_attno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>biggest_attno</name> <operator>=</operator> <call><name>toast_tuple_find_biggest_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>biggest_attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>toast_tuple_externalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>, <argument><expr><name>biggest_attno</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Round 3 - this time we take attributes with storage MAIN into
	 * compression
	 */</comment>
	<while>while <condition>(<expr><call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
								  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxDataLen</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>biggest_attno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>biggest_attno</name> <operator>=</operator> <call><name>toast_tuple_find_biggest_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>biggest_attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>toast_tuple_try_compression</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>, <argument><expr><name>biggest_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Finally we store attributes of type MAIN externally.  At this point we
	 * increase the target tuple size, so that MAIN attributes aren't stored
	 * externally unless really necessary.
	 */</comment>
	<expr_stmt><expr><name>maxDataLen</name> <operator>=</operator> <name>TOAST_TUPLE_TARGET_MAIN</name> <operator>-</operator> <name>hoff</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
								  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxDataLen</name> <operator>&amp;&amp;</operator>
		   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>biggest_attno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>biggest_attno</name> <operator>=</operator> <call><name>toast_tuple_find_biggest_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>biggest_attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>toast_tuple_externalize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>, <argument><expr><name>biggest_attno</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * In the case we toasted any values, we need to build a new heap tuple
	 * with the changed values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ttc</name><operator>.</operator><name>ttc_flags</name></name> <operator>&amp;</operator> <name>TOAST_NEEDS_CHANGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>olddata</name> <init>= <expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>new_data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>new_header_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>new_data_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>new_tuple_len</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Calculate the new size of the tuple.
		 *
		 * Note: we used to assume here that the old tuple's t_hoff must equal
		 * the new_header_len value, but that was incorrect.  The old tuple
		 * might have a smaller-than-current natts, if there's been an ALTER
		 * TABLE ADD COLUMN since it was stored; and that would lead to a
		 * different conclusion about the size of the null bitmap, or even
		 * whether there needs to be one at all.
		 */</comment>
		<expr_stmt><expr><name>new_header_len</name> <operator>=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ttc</name><operator>.</operator><name>ttc_flags</name></name> <operator>&amp;</operator> <name>TOAST_HAS_NULLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_header_len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>new_header_len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>new_header_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
											  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_tuple_len</name> <operator>=</operator> <name>new_header_len</name> <operator>+</operator> <name>new_data_len</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Allocate and zero the space needed, and fill HeapTupleData fields.
		 */</comment>
		<expr_stmt><expr><name>result_tuple</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>new_tuple_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result_tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>new_tuple_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result_tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result_tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_data</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result_tuple</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result_tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>new_data</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Copy the existing tuple header, but adjust natts and t_hoff.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>olddata</name></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_data</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>new_header_len</name></expr>;</expr_stmt>

		<comment type="block">/* Copy over the data, and fill the null bitmap if needed */</comment>
		<expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
						<argument><expr><name>toast_values</name></expr></argument>,
						<argument><expr><name>toast_isnull</name></expr></argument>,
						<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>new_data</name> <operator>+</operator> <name>new_header_len</name></expr></argument>,
						<argument><expr><name>new_data_len</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_data</name><operator>-&gt;</operator><name>t_infomask</name></name><operator>)</operator></expr></argument>,
						<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>ttc</name><operator>.</operator><name>ttc_flags</name></name> <operator>&amp;</operator> <name>TOAST_HAS_NULLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
						<expr><name><name>new_data</name><operator>-&gt;</operator><name>t_bits</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_tuple</name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>toast_tuple_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ttc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result_tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_flatten_tuple -
 *
 *	"Flatten" a tuple to contain no out-of-line toasted fields.
 *	(This does not eliminate compressed or short-header datums.)
 *
 *	Note: we expect the caller already checked HeapTupleHasExternal(tup),
 *	so there is no need for a short-circuit path.
 * ----------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>toast_flatten_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAttrs</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>toast_values</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>toast_isnull</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>toast_free</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Break down the tuple into fields.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>toast_free</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Look at non-null varlena attributes
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>toast_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_value</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_value</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>detoast_external_attr</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Form the reconfigured tuple.
	 */</comment>
	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Be sure to copy the tuple's identity fields.  We also make a point of
	 * copying visibility info, just in case anybody looks at those fields in
	 * a syscache entry.
	 */</comment>
	<expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_choice</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_choice</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XACT_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator>
		<name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XACT_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP2_XACT_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>|=</operator>
		<name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;</operator> <name>HEAP2_XACT_MASK</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free allocated temp values
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>new_tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_flatten_tuple_to_datum -
 *
 *	"Flatten" a tuple containing out-of-line toasted fields into a Datum.
 *	The result is always palloc'd in the current memory context.
 *
 *	We have a general rule that Datums of container types (rows, arrays,
 *	ranges, etc) must not contain any external TOAST pointers.  Without
 *	this rule, we'd have to look inside each Datum when preparing a tuple
 *	for storage, which would be expensive and would fail to extend cleanly
 *	to new sorts of container types.
 *
 *	However, we don't want to say that tuples represented as HeapTuples
 *	can't contain toasted fields, so instead this routine should be called
 *	when such a HeapTuple is being converted into a Datum.
 *
 *	While we're at it, we decompress any compressed fields too.  This is not
 *	necessary for correctness, but reflects an expectation that compression
 *	will be more effective if applied to the whole tuple not individual
 *	fields.  We are not so concerned about that that we want to deconstruct
 *	and reconstruct tuples just to get rid of compressed fields, however.
 *	So callers typically won't call this unless they see that the tuple has
 *	at least one external field.
 *
 *	On the other hand, in-line short-header varlena fields are left alone.
 *	If we "untoasted" them here, they'd just get changed back to short-header
 *	format anyway within heap_fill_tuple.
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>toast_flatten_tuple_to_datum</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl></parameter>,
							 <parameter><decl><type><name>uint32</name></type> <name>tup_len</name></decl></parameter>,
							 <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>new_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>new_header_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>new_data_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>new_tuple_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAttrs</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_nulls</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>toast_values</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>toast_isnull</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>toast_free</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Build a temporary HeapTuple control structure */</comment>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name>tup_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tup</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Break down the tuple into fields.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>toast_free</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Look at non-null varlena attributes
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>toast_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>has_nulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_value</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_value</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>detoast_attr</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Calculate the new size of the tuple.
	 *
	 * This should match the reconstruction code in
	 * heap_toast_insert_or_update.
	 */</comment>
	<expr_stmt><expr><name>new_header_len</name> <operator>=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>has_nulls</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>new_header_len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>new_header_len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>new_header_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
										  <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_tuple_len</name> <operator>=</operator> <name>new_header_len</name> <operator>+</operator> <name>new_data_len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_data</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>new_tuple_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the existing tuple header, but adjust natts and t_hoff.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>numAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_data</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>new_header_len</name></expr>;</expr_stmt>

	<comment type="block">/* Set the composite-Datum header fields correctly */</comment>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>new_tuple_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy over the data, and fill the null bitmap if needed */</comment>
	<expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
					<argument><expr><name>toast_values</name></expr></argument>,
					<argument><expr><name>toast_isnull</name></expr></argument>,
					<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>new_data</name> <operator>+</operator> <name>new_header_len</name></expr></argument>,
					<argument><expr><name>new_data_len</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_data</name><operator>-&gt;</operator><name>t_infomask</name></name><operator>)</operator></expr></argument>,
					<argument><expr><ternary><condition><expr><name>has_nulls</name></expr> ?</condition><then> <expr><name><name>new_data</name><operator>-&gt;</operator><name>t_bits</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free allocated temp values
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * toast_build_flattened_tuple -
 *
 *	Build a tuple containing no out-of-line toasted fields.
 *	(This does not eliminate compressed or short-header datums.)
 *
 *	This is essentially just like heap_form_tuple, except that it will
 *	expand any external-data pointers beforehand.
 *
 *	It's not very clear whether it would be preferable to decompress
 *	in-line compressed datums while at it.  For now, we don't.
 * ----------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>toast_build_flattened_tuple</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
							<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAttrs</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_to_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>new_values</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name><name>freeable_values</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can pass the caller's isnull array directly to heap_form_tuple, but
	 * we potentially need to modify the values array.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_values</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>numAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_to_free</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Look at non-null varlena attributes
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_value</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_value</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>new_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>detoast_external_attr</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>new_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>freeable_values</name><index>[<expr><name>num_to_free</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>new_value</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Form the reconfigured tuple.
	 */</comment>
	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>new_values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free allocated temp values
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_to_free</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>freeable_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>new_tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch a TOAST slice from a heap table.
 *
 * toastrel is the relation from which chunks are to be fetched.
 * valueid identifies the TOAST value from which chunks are being fetched.
 * attrsize is the total size of the TOAST value.
 * sliceoffset is the byte offset within the TOAST value from which to fetch.
 * slicelength is the number of bytes to be fetched from the TOAST value.
 * result is the varlena into which the results should be written.
 */</comment>
<function><type><name>void</name></type>
<name>heap_fetch_toast_slice</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>toastrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valueid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attrsize</name></decl></parameter>,
					   <parameter><decl><type><name>int32</name></type> <name>sliceoffset</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>slicelength</name></decl></parameter>,
					   <parameter><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>toastidxs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>toastkey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>toasttupDesc</name> <init>= <expr><name><name>toastrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nscankeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>toastscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ttup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>expectedchunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>totalchunks</name> <init>= <expr><operator>(</operator><operator>(</operator><name>attrsize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>TOAST_MAX_CHUNK_SIZE</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>startchunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>endchunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>validIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotToast</name></decl>;</decl_stmt>

	<comment type="block">/* Look for the valid index of toast relation */</comment>
	<expr_stmt><expr><name>validIndex</name> <operator>=</operator> <call><name>toast_open_indexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
									<argument><expr><name>AccessShareLock</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>toastidxs</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startchunk</name> <operator>=</operator> <name>sliceoffset</name> <operator>/</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endchunk</name> <operator>=</operator> <operator>(</operator><name>sliceoffset</name> <operator>+</operator> <name>slicelength</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endchunk</name> <operator>&lt;=</operator> <name>totalchunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up a scan key to fetch from the index. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>toastkey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>valueid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No additional condition if fetching all chunks. Otherwise, use an
	 * equality condition for one chunk, and a range condition otherwise.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>startchunk</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>endchunk</name> <operator>==</operator> <name>totalchunks</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nscankeys</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>startchunk</name> <operator>==</operator> <name>endchunk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>toastkey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
					<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>startchunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nscankeys</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>toastkey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>,
					<argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4GE</name></expr></argument>,
					<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>startchunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>toastkey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
					<argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>,
					<argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4LE</name></expr></argument>,
					<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>endchunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nscankeys</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Prepare for scan */</comment>
	<expr_stmt><expr><call><name>init_toast_snapshot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>toastscan</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name><name>toastidxs</name><index>[<expr><name>validIndex</name></expr>]</index></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>SnapshotToast</name></expr></argument>, <argument><expr><name>nscankeys</name></expr></argument>, <argument><expr><name>toastkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the chunks by index
	 *
	 * The index is on (valueid, chunkidx) so they will come in order
	 */</comment>
	<expr_stmt><expr><name>expectedchunk</name> <operator>=</operator> <name>startchunk</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>ttup</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>curchunk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Pointer</name></type>		<name>chunk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunkdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>chunksize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>expected_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>chcpystrt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>chcpyend</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Have a chunk, extract the sequence number and the data
		 */</comment>
		<expr_stmt><expr><name>curchunk</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>ttup</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>toasttupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>ttup</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>toasttupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>chunkdata</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* could happen due to heap_form_tuple doing its thing */</comment>
			<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>chunkdata</name> <operator>=</operator> <call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found toasted toast chunk for toast value %u in %s"</literal></expr></argument>,
				 <argument><expr><name>valueid</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><name>chunkdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Some checks on the data we've found
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>curchunk</name> <operator>!=</operator> <name>expectedchunk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unexpected chunk number %d (expected %d) for toast value %u in %s"</literal></expr></argument>,
									 <argument><expr><name>curchunk</name></expr></argument>, <argument><expr><name>expectedchunk</name></expr></argument>, <argument><expr><name>valueid</name></expr></argument>,
									 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>curchunk</name> <operator>&gt;</operator> <name>endchunk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unexpected chunk number %d (out of range %d..%d) for toast value %u in %s"</literal></expr></argument>,
									 <argument><expr><name>curchunk</name></expr></argument>,
									 <argument><expr><name>startchunk</name></expr></argument>, <argument><expr><name>endchunk</name></expr></argument>, <argument><expr><name>valueid</name></expr></argument>,
									 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>expected_size</name> <operator>=</operator> <ternary><condition><expr><name>curchunk</name> <operator>&lt;</operator> <name>totalchunks</name> <operator>-</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>TOAST_MAX_CHUNK_SIZE</name></expr>
			</then><else>: <expr><name>attrsize</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>totalchunks</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>TOAST_MAX_CHUNK_SIZE</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>chunksize</name> <operator>!=</operator> <name>expected_size</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unexpected chunk size %d (expected %d) in chunk %d of %d for toast value %u in %s"</literal></expr></argument>,
									 <argument><expr><name>chunksize</name></expr></argument>, <argument><expr><name>expected_size</name></expr></argument>,
									 <argument><expr><name>curchunk</name></expr></argument>, <argument><expr><name>totalchunks</name></expr></argument>, <argument><expr><name>valueid</name></expr></argument>,
									 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Copy the data into proper place in our result
		 */</comment>
		<expr_stmt><expr><name>chcpystrt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>chcpyend</name> <operator>=</operator> <name>chunksize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>curchunk</name> <operator>==</operator> <name>startchunk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chcpystrt</name> <operator>=</operator> <name>sliceoffset</name> <operator>%</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>curchunk</name> <operator>==</operator> <name>endchunk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chcpyend</name> <operator>=</operator> <operator>(</operator><name>sliceoffset</name> <operator>+</operator> <name>slicelength</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator>
			   <operator>(</operator><name>curchunk</name> <operator>*</operator> <name>TOAST_MAX_CHUNK_SIZE</name> <operator>-</operator> <name>sliceoffset</name><operator>)</operator> <operator>+</operator> <name>chcpystrt</name></expr></argument>,
			   <argument><expr><name>chunkdata</name> <operator>+</operator> <name>chcpystrt</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>chcpyend</name> <operator>-</operator> <name>chcpystrt</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>expectedchunk</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Final checks that we successfully fetched the datum
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expectedchunk</name> <operator>!=</operator> <operator>(</operator><name>endchunk</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"missing chunk number %d for toast value %u in %s"</literal></expr></argument>,
								 <argument><expr><name>expectedchunk</name></expr></argument>, <argument><expr><name>valueid</name></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* End scan and close indexes. */</comment>
	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>toastscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>toast_close_indexes</name><argument_list>(<argument><expr><name>toastidxs</name></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
