<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/heap/vacuumlazy.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * vacuumlazy.c
 *	  Concurrent ("lazy") vacuuming.
 *
 *
 * The major space usage for LAZY VACUUM is storage for the array of dead tuple
 * TIDs.  We want to ensure we can vacuum even the very largest relations with
 * finite memory space usage.  To do that, we set upper bounds on the number of
 * tuples we will keep track of at once.
 *
 * We are willing to use at most maintenance_work_mem (or perhaps
 * autovacuum_work_mem) memory space to keep track of dead tuples.  We
 * initially allocate an array of TIDs of that size, with an upper limit that
 * depends on table size (this limit ensures we don't allocate a huge area
 * uselessly for vacuuming small tables).  If the array threatens to overflow,
 * we suspend the heap scan phase and perform a pass of index cleanup and page
 * compaction, then resume the heap scan with an empty TID array.
 *
 * If we're processing a table with no indexes, we can just vacuum each page
 * as we go; there's no need to save up multiple tuples to minimize the number
 * of index scans performed.  So we don't use maintenance_work_mem memory for
 * the TID array, just enough to hold as many heap tuples as fit on one page.
 *
 * Lazy vacuum supports parallel execution with parallel worker processes.  In
 * a parallel vacuum, we perform both index vacuum and index cleanup with
 * parallel worker processes.  Individual indexes are processed by one vacuum
 * process.  At the beginning of a lazy vacuum (at lazy_scan_heap) we prepare
 * the parallel context and initialize the DSM segment that contains shared
 * information as well as the memory space for storing dead tuples.  When
 * starting either index vacuum or index cleanup, we launch parallel worker
 * processes.  Once all indexes are processed the parallel worker processes
 * exit.  After that, the leader process re-initializes the parallel context
 * so that it can use the same DSM for multiple passes of index vacuum and
 * for performing index cleanup.  For updating the index statistics, we need
 * to update the system table and since updates are not allowed during
 * parallel mode we update the index statistics after exiting from the
 * parallel mode.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/heap/vacuumlazy.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/freespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Space/time tradeoff parameters: do these need to be user-tunable?
 *
 * To consider truncating the relation, we want there to be at least
 * REL_TRUNCATE_MINIMUM or (relsize / REL_TRUNCATE_FRACTION) (whichever
 * is less) potentially-freeable pages.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_TRUNCATE_MINIMUM</name></cpp:macro>	<cpp:value>1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_TRUNCATE_FRACTION</name></cpp:macro>	<cpp:value>16</cpp:value></cpp:define>

<comment type="block">/*
 * Timing parameters for truncate locking heuristics.
 *
 * These were not exposed as user tunable GUC values because it didn't seem
 * that the potential for improvement was great enough to merit the cost of
 * supporting them.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VACUUM_TRUNCATE_LOCK_CHECK_INTERVAL</name></cpp:macro>		<cpp:value>20</cpp:value></cpp:define>	<comment type="block">/* ms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VACUUM_TRUNCATE_LOCK_WAIT_INTERVAL</name></cpp:macro>		<cpp:value>50</cpp:value></cpp:define>	<comment type="block">/* ms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VACUUM_TRUNCATE_LOCK_TIMEOUT</name></cpp:macro>			<cpp:value>5000</cpp:value></cpp:define>	<comment type="block">/* ms */</comment>

<comment type="block">/*
 * When a table has no indexes, vacuum the FSM after every 8GB, approximately
 * (it won't be exact because we only vacuum FSM after processing a heap page
 * that has some removable tuples).  When there are indexes, this is ignored,
 * and we vacuum FSM after each index/heap cleaning pass.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VACUUM_FSM_EVERY_PAGES</name></cpp:macro> \
	<cpp:value>((BlockNumber) (((uint64) 8 * 1024 * 1024 * 1024) / BLCKSZ))</cpp:value></cpp:define>

<comment type="block">/*
 * Guesstimation of number of dead tuples per page.  This is used to
 * provide an upper limit to memory allocated when vacuuming small
 * tables.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_ALLOC_TUPLES</name></cpp:macro>		<cpp:value>MaxHeapTuplesPerPage</cpp:value></cpp:define>

<comment type="block">/*
 * Before we consider skipping a page that's marked as clean in
 * visibility map, we must've seen at least this many clean pages.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_PAGES_THRESHOLD</name></cpp:macro>	<cpp:value>((BlockNumber) 32)</cpp:value></cpp:define>

<comment type="block">/*
 * Size of the prefetch window for lazy vacuum backwards truncation scan.
 * Needs to be a power of 2.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFETCH_SIZE</name></cpp:macro>			<cpp:value>((BlockNumber) 32)</cpp:value></cpp:define>

<comment type="block">/*
 * DSM keys for parallel vacuum.  Unlike other parallel execution code, since
 * we don't need to worry about DSM keys conflicting with plan_node_id we can
 * use small integers.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_VACUUM_KEY_SHARED</name></cpp:macro>			<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_VACUUM_KEY_DEAD_TUPLES</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_VACUUM_KEY_QUERY_TEXT</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_VACUUM_KEY_BUFFER_USAGE</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_VACUUM_KEY_WAL_USAGE</name></cpp:macro>		<cpp:value>5</cpp:value></cpp:define>

<comment type="block">/*
 * Macro to check if we are in a parallel vacuum.  If true, we are in the
 * parallel mode and the DSM segment is initialized.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ParallelVacuumIsActive</name><parameter_list>(<parameter><type><name>lps</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>PointerIsValid(lps)</cpp:value></cpp:define>

<comment type="block">/* Phases of vacuum during which we report error context. */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>VACUUM_ERRCB_PHASE_UNKNOWN</name></decl>,
	<decl><name>VACUUM_ERRCB_PHASE_SCAN_HEAP</name></decl>,
	<decl><name>VACUUM_ERRCB_PHASE_VACUUM_INDEX</name></decl>,
	<decl><name>VACUUM_ERRCB_PHASE_VACUUM_HEAP</name></decl>,
	<decl><name>VACUUM_ERRCB_PHASE_INDEX_CLEANUP</name></decl>,
	<decl><name>VACUUM_ERRCB_PHASE_TRUNCATE</name></decl>
}</block></enum></type> <name>VacErrPhase</name>;</typedef>

<comment type="block">/*
 * LVDeadTuples stores the dead tuple TIDs collected during the heap scan.
 * This is allocated in the DSM segment in parallel mode and in local memory
 * in non-parallel mode.
 */</comment>
<typedef>typedef <type><struct>struct <name>LVDeadTuples</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>max_tuples</name></decl>;</decl_stmt>		<comment type="block">/* # slots allocated in array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_tuples</name></decl>;</decl_stmt>		<comment type="block">/* current # of entries */</comment>
	<comment type="block">/* List of TIDs of tuples we intend to delete */</comment>
	<comment type="block">/* NB: this list is ordered by TID address */</comment>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name><name>itemptrs</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* array of
														 * ItemPointerData */</comment>
}</block></struct></type> <name>LVDeadTuples</name>;</typedef>

<comment type="block">/* The dead tuple space consists of LVDeadTuples and dead tuple TIDs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeOfDeadTuples</name><parameter_list>(<parameter><type><name>cnt</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>add_size(offsetof(LVDeadTuples, itemptrs), \
			 mul_size(sizeof(ItemPointerData), cnt))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXDEADTUPLES</name><parameter_list>(<parameter><type><name>max_size</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>(((max_size) - offsetof(LVDeadTuples, itemptrs)) / sizeof(ItemPointerData))</cpp:value></cpp:define>

<comment type="block">/*
 * Shared information among parallel workers.  So this is allocated in the DSM
 * segment.
 */</comment>
<typedef>typedef <type><struct>struct <name>LVShared</name>
<block>{
	<comment type="block">/*
	 * Target table relid and log level.  These fields are not modified during
	 * the lazy vacuum.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * An indication for vacuum workers to perform either index vacuum or
	 * index cleanup.  first_time is true only if for_cleanup is true and
	 * bulk-deletion is not performed yet.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>for_cleanup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_time</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fields for both index vacuum and cleanup.
	 *
	 * reltuples is the total number of input heap tuples.  We set either old
	 * live tuples in the index vacuum case or the new live tuples in the
	 * index cleanup case.
	 *
	 * estimated_count is true if reltuples is an estimated value.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>estimated_count</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In single process lazy vacuum we could consume more memory during index
	 * vacuuming or cleanup apart from the memory for heap scanning.  In
	 * parallel vacuum, since individual vacuum workers can consume memory
	 * equal to maintenance_work_mem, the new maintenance_work_mem for each
	 * worker is set such that the parallel operation doesn't consume more
	 * memory than single process lazy vacuum.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maintenance_work_mem_worker</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Shared vacuum cost balance.  During parallel vacuum,
	 * VacuumSharedCostBalance points to this value and it accumulates the
	 * balance of each parallel vacuum worker.
	 */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>cost_balance</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Number of active parallel workers.  This is used for computing the
	 * minimum threshold of the vacuum cost balance before a worker sleeps for
	 * cost-based delay.
	 */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>active_nworkers</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Variables to control parallel vacuum.  We have a bitmap to indicate
	 * which index has stats in shared memory.  The set bit in the map
	 * indicates that the particular index supports a parallel vacuum.
	 */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>idx</name></decl>;</decl_stmt>		<comment type="block">/* counter for vacuuming and clean up */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>offset</name></decl>;</decl_stmt>			<comment type="block">/* sizeof header incl. bitmap */</comment>
	<decl_stmt><decl><type><name>bits8</name></type>		<name><name>bitmap</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* bit map of NULLs */</comment>

	<comment type="block">/* Shared index statistics data follows at end of struct */</comment>
}</block></struct></type> <name>LVShared</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeOfLVShared</name></cpp:macro> <cpp:value>(offsetof(LVShared, bitmap) + sizeof(bits8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetSharedIndStats</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((LVSharedIndStats *)((char *)(s) + ((LVShared *)(s))-&gt;offset))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IndStatsIsNull</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(!(((LVShared *)(s))-&gt;bitmap[(i) &gt;&gt; 3] &amp; (1 &lt;&lt; ((i) &amp; 0x07))))</cpp:value></cpp:define>

<comment type="block">/*
 * Struct for an index bulk-deletion statistic used for parallel vacuum.  This
 * is allocated in the DSM segment.
 */</comment>
<typedef>typedef <type><struct>struct <name>LVSharedIndStats</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>updated</name></decl>;</decl_stmt>		<comment type="block">/* are the stats updated? */</comment>
	<decl_stmt><decl><type><name>IndexBulkDeleteResult</name></type> <name>stats</name></decl>;</decl_stmt>
}</block></struct></type> <name>LVSharedIndStats</name>;</typedef>

<comment type="block">/* Struct for maintaining a parallel vacuum state. */</comment>
<typedef>typedef <type><struct>struct <name>LVParallelState</name>
<block>{
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Shared information among parallel vacuum workers */</comment>
	<decl_stmt><decl><type><name>LVShared</name>   <modifier>*</modifier></type><name>lvshared</name></decl>;</decl_stmt>

	<comment type="block">/* Points to buffer usage area in DSM */</comment>
	<decl_stmt><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>buffer_usage</name></decl>;</decl_stmt>

	<comment type="block">/* Points to WAL usage area in DSM */</comment>
	<decl_stmt><decl><type><name>WalUsage</name>   <modifier>*</modifier></type><name>wal_usage</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The number of indexes that support parallel index bulk-deletion and
	 * parallel index cleanup respectively.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes_parallel_bulkdel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes_parallel_cleanup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes_parallel_condcleanup</name></decl>;</decl_stmt>
}</block></struct></type> <name>LVParallelState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>LVRelStats</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<comment type="block">/* useindex = true means two-pass strategy; false means one-pass */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useindex</name></decl>;</decl_stmt>
	<comment type="block">/* Overall statistics about rel */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>old_rel_pages</name></decl>;</decl_stmt>	<comment type="block">/* previous value of pg_class.relpages */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rel_pages</name></decl>;</decl_stmt>		<comment type="block">/* total number of pages */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>scanned_pages</name></decl>;</decl_stmt>	<comment type="block">/* number of pages we examined */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pinskipped_pages</name></decl>;</decl_stmt>	<comment type="block">/* # of pages we skipped due to a pin */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>frozenskipped_pages</name></decl>;</decl_stmt>	<comment type="block">/* # of frozen pages we skipped */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>tupcount_pages</name></decl>;</decl_stmt> <comment type="block">/* pages whose tuples we counted */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>old_live_tuples</name></decl>;</decl_stmt>	<comment type="block">/* previous value of pg_class.reltuples */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>new_rel_tuples</name></decl>;</decl_stmt> <comment type="block">/* new estimated total # of tuples */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>new_live_tuples</name></decl>;</decl_stmt>	<comment type="block">/* new estimated total # of live tuples */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>new_dead_tuples</name></decl>;</decl_stmt>	<comment type="block">/* new estimated total # of dead tuples */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pages_removed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuples_deleted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nonempty_pages</name></decl>;</decl_stmt> <comment type="block">/* actually, last nonempty page + 1 */</comment>
	<decl_stmt><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_index_scans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lock_waiter_detected</name></decl>;</decl_stmt>

	<comment type="block">/* Used for error callback */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>			<comment type="block">/* used only for heap operations */</comment>
	<decl_stmt><decl><type><name>VacErrPhase</name></type> <name>phase</name></decl>;</decl_stmt>
}</block></struct></type> <name>LVRelStats</name>;</typedef>

<comment type="block">/* Struct for saving and restoring vacuum error information. */</comment>
<typedef>typedef <type><struct>struct <name>LVSavedErrInfo</name>
<block>{
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacErrPhase</name></type> <name>phase</name></decl>;</decl_stmt>
}</block></struct></type> <name>LVSavedErrInfo</name>;</typedef>

<comment type="block">/* A few variables that don't seem worth passing around as parameters */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>elevel</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>OldestXmin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>FreezeLimit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MultiXactId</name></type> <name>MultiXactCutoff</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>BufferAccessStrategy</name></type> <name>vac_strategy</name></decl>;</decl_stmt>


<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_scan_heap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
						   <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>aggressive</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_vacuum_heap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lazy_check_needs_freeze</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hastup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_vacuum_all_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>,
									<parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
									<parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_vacuum_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indrel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
							  <parameter><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>reltuples</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_cleanup_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indrel</name></decl></parameter>,
							   <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
							   <parameter><decl><type><name>double</name></type> <name>reltuples</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>estimated_count</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>lazy_vacuum_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>tupindex</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>vmbuffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>should_attempt_truncation</name><parameter_list>(<parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
									  <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_truncate_heap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BlockNumber</name></type> <name>count_nondeletable_pages</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>,
											<parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_space_alloc</name><parameter_list>(<parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>relblocks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_record_dead_tuple</name><parameter_list>(<parameter><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl></parameter>,
								   <parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lazy_tid_reaped</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>vac_cmp_itemptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>heap_page_is_all_visible</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
									 <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>visibility_cutoff_xid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>all_frozen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_parallel_vacuum_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
										 <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parallel_vacuum_index</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
								  <parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>, <parameter><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vacuum_indexes_leader</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
								  <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vacuum_one_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indrel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
							 <parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>, <parameter><decl><type><name>LVSharedIndStats</name> <modifier>*</modifier></type><name>shared_indstats</name></decl></parameter>,
							 <parameter><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lazy_cleanup_all_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
									 <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>compute_max_dead_tuples</name><parameter_list>(<parameter><decl><type><name>BlockNumber</name></type> <name>relblocks</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasindex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compute_parallel_vacuum_workers</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrequested</name></decl></parameter>,
											<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_parallel_vacuum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_index_statistics</name><parameter_list>(<parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_parallel_vacuum</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_index_statistics</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LVParallelState</name> <modifier>*</modifier></type><name>begin_parallel_vacuum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>,
											  <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>,
											  <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrequested</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>end_parallel_vacuum</name><parameter_list>(<parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
								<parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LVSharedIndStats</name> <modifier>*</modifier></type><name>get_indstats</name><parameter_list>(<parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>skip_parallel_vacuum_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indrel</name></decl></parameter>, <parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vacuum_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_vacuum_error_info</name><parameter_list>(<parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>errinfo</name></decl></parameter>, <parameter><decl><type><name>LVSavedErrInfo</name> <modifier>*</modifier></type><name>saved_err_info</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>phase</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>restore_vacuum_error_info</name><parameter_list>(<parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>errinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LVSavedErrInfo</name> <modifier>*</modifier></type><name>saved_err_info</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	heap_vacuum_rel() -- perform VACUUM for one heap relation
 *
 *		This routine vacuums a single heap, cleans out its indexes, and
 *		updates its relpages and reltuples statistics.
 *
 *		At entry, we have already established a transaction and opened
 *		and locked the relation.
 */</comment>
<function><type><name>void</name></type>
<name>heap_vacuum_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
				<parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>Irel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>starttime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalUsage</name></type>	<name>walusage_start</name> <init>= <expr><name>pgWalUsage</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalUsage</name></type>	<name>walusage</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>read_rate</name></decl>,
				<decl><type ref="prev"/><name>write_rate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>aggressive</name></decl>;</decl_stmt>		<comment type="block">/* should we scan all unfrozen pages? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>scanned_all_unfrozen</name></decl>;</decl_stmt>	<comment type="block">/* actually scanned all such pages? */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidFullScanLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>mxactFullScanLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>new_rel_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>new_rel_allvisible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>new_live_tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>new_frozen_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>new_min_multi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>params</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name> <operator>!=</operator> <name>VACOPT_TERNARY_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>truncate</name></name> <operator>!=</operator> <name>VACOPT_TERNARY_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* not every AM requires these to be valid, but heap does */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* measure elapsed time iff autovacuum logging requires it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>INFO</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pgstat_progress_start_command</name><argument_list>(<argument><expr><name>PROGRESS_COMMAND_VACUUM</name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vac_strategy</name> <operator>=</operator> <name>bstrategy</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vacuum_set_xid_limits</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>freeze_min_age</name></name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>freeze_table_age</name></name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>multixact_freeze_min_age</name></name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>multixact_freeze_table_age</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>OldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>FreezeLimit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xidFullScanLimit</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>MultiXactCutoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mxactFullScanLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We request an aggressive scan if the table's frozen Xid is now older
	 * than or equal to the requested Xid full-table scan limit; or if the
	 * table's minimum MultiXactId is older than or equal to the requested
	 * mxid full-table scan limit; or if DISABLE_PAGE_SKIPPING was specified.
	 */</comment>
	<expr_stmt><expr><name>aggressive</name> <operator>=</operator> <call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>,
											   <argument><expr><name>xidFullScanLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggressive</name> <operator>|=</operator> <call><name>MultiXactIdPrecedesOrEquals</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>,
											  <argument><expr><name>mxactFullScanLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_DISABLE_PAGE_SKIPPING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aggressive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>vacrelstats</name> <operator>=</operator> <operator>(</operator><name>LVRelStats</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LVRelStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <name>VACUUM_ERRCB_PHASE_UNKNOWN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>old_rel_pages</name></name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>old_live_tuples</name></name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>num_index_scans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>pages_removed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>lock_waiter_detected</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Open all indexes of the relation */</comment>
	<expr_stmt><expr><call><name>vac_open_indexes</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nindexes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Irel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>useindex</name></name> <operator>=</operator> <operator>(</operator><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							 <name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name> <operator>==</operator> <name>VACOPT_TERNARY_ENABLED</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport().  The idea is to set up an
	 * error context callback to display additional information on any error
	 * during a vacuum.  During different phases of vacuum (heap scan, heap
	 * vacuum, index vacuum, index clean up, heap truncate), we update the
	 * error context callback to display appropriate information.
	 *
	 * Note that the index vacuum and heap vacuum phases may be called
	 * multiple times in the middle of the heap scan phase.  So the old phase
	 * information is restored at the end of those phases.
	 */</comment>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>vacuum_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>vacrelstats</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<comment type="block">/* Do the vacuuming */</comment>
	<expr_stmt><expr><call><name>lazy_scan_heap</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>aggressive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done with indexes */</comment>
	<expr_stmt><expr><call><name>vac_close_indexes</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute whether we actually scanned the all unfrozen pages. If we did,
	 * we can adjust relfrozenxid and relminmxid.
	 *
	 * NB: We need to check this before truncating the relation, because that
	 * will change -&gt;rel_pages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>vacrelstats</name><operator>-&gt;</operator><name>scanned_pages</name></name> <operator>+</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>frozenskipped_pages</name></name><operator>)</operator>
		<operator>&lt;</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>aggressive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scanned_all_unfrozen</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>scanned_all_unfrozen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Optionally truncate the relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>should_attempt_truncation</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Update error traceback information.  This is the last phase during
		 * which we add context information to errors, so we don't need to
		 * revert to the previous phase.
		 */</comment>
		<expr_stmt><expr><call><name>update_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>VACUUM_ERRCB_PHASE_TRUNCATE</name></expr></argument>,
								 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>nonempty_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lazy_truncate_heap</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/* Report that we are now doing final cleanup */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_VACUUM_PHASE_FINAL_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update statistics in pg_class.
	 *
	 * A corner case here is that if we scanned no pages at all because every
	 * page is all-visible, we should not update relpages/reltuples, because
	 * we have no new information to contribute.  In particular this keeps us
	 * from replacing relpages=reltuples=0 (which means "unknown tuple
	 * density") with nonzero relpages and reltuples=0 (which means "zero
	 * tuple density") unless there's some actual evidence for the latter.
	 *
	 * It's important that we use tupcount_pages and not scanned_pages for the
	 * check described above; scanned_pages counts pages where we could not
	 * get cleanup lock, and which were processed only for frozenxid purposes.
	 *
	 * We do update relallvisible even in the corner case, since if the table
	 * is all-visible we'd definitely like to know that.  But clamp the value
	 * to be not more than what we're setting relpages to.
	 *
	 * Also, don't change relfrozenxid/relminmxid if we skipped any pages,
	 * since then we don't know for certain that all tuples have a newer xmin.
	 */</comment>
	<expr_stmt><expr><name>new_rel_pages</name> <operator>=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_live_tuples</name> <operator>=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>new_live_tuples</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>tupcount_pages</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>new_rel_pages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new_rel_pages</name> <operator>=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>old_rel_pages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_live_tuples</name> <operator>=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>old_live_tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>visibilitymap_count</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_rel_allvisible</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>new_rel_allvisible</name> <operator>&gt;</operator> <name>new_rel_pages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>new_rel_allvisible</name> <operator>=</operator> <name>new_rel_pages</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>new_frozen_xid</name> <operator>=</operator> <ternary><condition><expr><name>scanned_all_unfrozen</name></expr> ?</condition><then> <expr><name>FreezeLimit</name></expr> </then><else>: <expr><name>InvalidTransactionId</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_min_multi</name> <operator>=</operator> <ternary><condition><expr><name>scanned_all_unfrozen</name></expr> ?</condition><then> <expr><name>MultiXactCutoff</name></expr> </then><else>: <expr><name>InvalidMultiXactId</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
						<argument><expr><name>new_rel_pages</name></expr></argument>,
						<argument><expr><name>new_live_tuples</name></expr></argument>,
						<argument><expr><name>new_rel_allvisible</name></expr></argument>,
						<argument><expr><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>,
						<argument><expr><name>new_frozen_xid</name></expr></argument>,
						<argument><expr><name>new_min_multi</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* report results to the stats collector, too */</comment>
	<expr_stmt><expr><call><name>pgstat_report_vacuum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>,
						 <argument><expr><name>new_live_tuples</name></expr></argument>,
						 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>new_dead_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and log the action if appropriate */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>endtime</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>,
									   <argument><expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msgfmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>walusage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WalUsageAccumDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>walusage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgWalUsage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>walusage_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>read_rate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>write_rate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>secs</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>usecs</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>read_rate</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>VacuumPageMiss</name> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator>
					<operator>(</operator><name>secs</name> <operator>+</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000000.0</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>write_rate</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>VacuumPageDirty</name> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator>
					<operator>(</operator><name>secs</name> <operator>+</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000000.0</literal><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This is pretty messy, but we split it up so that we can skip
			 * emitting individual parts of the message when not applicable.
			 */</comment>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>is_wraparound</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>aggressive</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"automatic aggressive vacuum to prevent wraparound of table \"%s.%s.%s\": index scans: %d\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"automatic vacuum to prevent wraparound of table \"%s.%s.%s\": index scans: %d\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>aggressive</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"automatic aggressive vacuum of table \"%s.%s.%s\": index scans: %d\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>msgfmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"automatic vacuum of table \"%s.%s.%s\": index scans: %d\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>msgfmt</name></expr></argument>,
							 <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>num_index_scans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"pages: %u removed, %u remain, %u skipped due to pins, %u skipped frozen\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>pages_removed</name></name></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>pinskipped_pages</name></name></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>frozenskipped_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"tuples: %.0f removed, %.0f remain, %.0f are dead but not yet removable, oldest xmin: %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>tuples_deleted</name></name></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>new_rel_tuples</name></name></expr></argument>,
							 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>new_dead_tuples</name></name></expr></argument>,
							 <argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"buffer usage: %lld hits, %lld misses, %lld dirtied\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator> <name>VacuumPageHit</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator> <name>VacuumPageMiss</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator> <name>VacuumPageDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"avg read rate: %.3f MB/s, avg write rate: %.3f MB/s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>read_rate</name></expr></argument>, <argument><expr><name>write_rate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"system usage: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"WAL usage: %ld records, %ld full page images, %llu bytes"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>walusage</name><operator>.</operator><name>wal_records</name></name></expr></argument>,
							 <argument><expr><name><name>walusage</name><operator>.</operator><name>wal_fpi</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name><name>walusage</name><operator>.</operator><name>wal_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For Hot Standby we need to know the highest transaction id that will
 * be removed by any change. VACUUM proceeds in a number of passes so
 * we need to consider how each pass operates. The first phase runs
 * heap_page_prune(), which can issue XLOG_HEAP2_CLEAN records as it
 * progresses - these will have a latestRemovedXid on each record.
 * In some cases this removes all of the tuples to be removed, though
 * often we have dead tuples with index pointers so we must remember them
 * for removal in phase 3. Index records for those rows are removed
 * in phase 2 and index blocks do not have MVCC information attached.
 * So before we can allow removal of any index tuples we need to issue
 * a WAL record containing the latestRemovedXid of rows that will be
 * removed in phase three. This allows recovery queries to block at the
 * correct place, i.e. before phase two, rather than during phase three
 * which would be after the rows have become inaccessible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuum_log_cleanup_info</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Skip this for relations for which no WAL is to be written, or if we're
	 * not trying to support archive recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No need to write the record at all unless it contains a valid value
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>log_heap_cleanup_info</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	lazy_scan_heap() -- scan an open heap relation
 *
 *		This routine prunes each page in the heap, which will among other
 *		things truncate dead tuples to dead line pointers, defragment the
 *		page, and set commit status bits (see heap_page_prune).  It also builds
 *		lists of dead tuples and pages with free space, calculates statistics
 *		on the number of live tuples in the heap, and marks pages as
 *		all-visible if appropriate.  When done, or when we run low on space for
 *		dead-tuple TIDs, invoke vacuuming of indexes and call lazy_vacuum_heap
 *		to reclaim dead line pointers.
 *
 *		If the table has at least two indexes, we execute both index vacuum
 *		and index cleanup with parallel workers unless parallel vacuum is
 *		disabled.  In a parallel vacuum, we enter parallel mode and then
 *		create both the parallel context and the DSM segment before starting
 *		heap scan so that we can record dead tuples to the DSM segment.  All
 *		parallel workers are launched at beginning of index vacuuming and
 *		index cleanup and they exit once done with all indexes.  At the end of
 *		this function we exit from parallel mode.  Index bulk-deletion results
 *		are stored in the DSM segment and we update index statistics for all
 *		the indexes after exiting from parallel mode since writes are not
 *		allowed during parallel mode.
 *
 *		If there are no indexes then we can reclaim line pointers on the fly;
 *		dead line pointers need only be retained until all index pointers that
 *		reference them have been killed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_scan_heap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>,
			   <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>aggressive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>,
				<decl><type ref="prev"/><name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>relfrozenxid</name> <init>= <expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>relminmxid</name> <init>= <expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>empty_pages</name></decl>,
				<decl><type ref="prev"/><name>vacuumed_pages</name></decl>,
				<decl><type ref="prev"/><name>next_fsm_block_to_vacuum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>num_tuples</name></decl>,		<comment type="block">/* total number of nonremovable tuples */</comment>
				<decl><type ref="prev"/><name>live_tuples</name></decl>,	<comment type="block">/* live tuples (reltuples estimate) */</comment>
				<decl><type ref="prev"/><name>tups_vacuumed</name></decl>,	<comment type="block">/* tuples cleaned up by vacuum */</comment>
				<decl><type ref="prev"/><name>nkeep</name></decl>,			<comment type="block">/* dead-but-not-removable tuples */</comment>
				<decl><type ref="prev"/><name>nunused</name></decl>;</decl_stmt>		<comment type="block">/* unused line pointers */</comment>
	<decl_stmt><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>indstats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>next_unskippable_block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipping_blocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_freeze_tuple</name> <modifier>*</modifier></type><name>frozen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name><name>initprog_index</name><index>[]</index></name> <init>= <expr><block>{
		<expr><name>PROGRESS_VACUUM_PHASE</name></expr>,
		<expr><name>PROGRESS_VACUUM_TOTAL_HEAP_BLKS</name></expr>,
		<expr><name>PROGRESS_VACUUM_MAX_DEAD_TUPLES</name></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name><name>initprog_val</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>aggressive</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggressively vacuuming \"%s.%s\""</literal></expr></argument>,
						<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>,
						<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vacuuming \"%s.%s\""</literal></expr></argument>,
						<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>,
						<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>empty_pages</name> <operator>=</operator> <name>vacuumed_pages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_fsm_block_to_vacuum</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_tuples</name> <operator>=</operator> <name>live_tuples</name> <operator>=</operator> <name>tups_vacuumed</name> <operator>=</operator> <name>nkeep</name> <operator>=</operator> <name>nunused</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>indstats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name>nindexes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name> <operator>=</operator> <name>nblocks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>scanned_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>tupcount_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>nonempty_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>latestRemovedXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize state for a parallel vacuum.  As of now, only one worker can
	 * be used for an index, so we invoke parallelism only if there are at
	 * least two indexes on a table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>useindex</name></name> <operator>&amp;&amp;</operator> <name>nindexes</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Since parallel workers cannot access data in temporary tables, we
		 * can't perform parallel vacuum on them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationUsesLocalBuffers</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Give warning only if the user explicitly tries to perform a
			 * parallel vacuum on the temporary table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling parallel option of vacuum on \"%s\" --- cannot vacuum temporary tables in parallel"</literal></expr></argument>,
								<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>lps</name> <operator>=</operator> <call><name>begin_parallel_vacuum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Irel</name></expr></argument>,
										<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>,
										<argument><expr><name><name>params</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Allocate the space for dead tuples in case parallel vacuum is not
	 * initialized.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParallelVacuumIsActive</name><argument_list>(<argument><expr><name>lps</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>lazy_space_alloc</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dead_tuples</name> <operator>=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>dead_tuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>frozen</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_heap_freeze_tuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MaxHeapTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report that we're scanning the heap, advertising total # of blocks */</comment>
	<expr_stmt><expr><name><name>initprog_val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>PROGRESS_VACUUM_PHASE_SCAN_HEAP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>initprog_val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>nblocks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>initprog_val</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>dead_tuples</name><operator>-&gt;</operator><name>max_tuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_progress_update_multi_param</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>initprog_index</name></expr></argument>, <argument><expr><name>initprog_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Except when aggressive is set, we want to skip pages that are
	 * all-visible according to the visibility map, but only when we can skip
	 * at least SKIP_PAGES_THRESHOLD consecutive pages.  Since we're reading
	 * sequentially, the OS should be doing readahead for us, so there's no
	 * gain in skipping a page now and then; that's likely to disable
	 * readahead and so be counterproductive. Also, skipping even a single
	 * page means that we can't update relfrozenxid, so we only want to do it
	 * if we can skip a goodly number of pages.
	 *
	 * When aggressive is set, we can't skip pages just because they are
	 * all-visible, but we can still skip pages that are all-frozen, since
	 * such pages do not need freezing and do not affect the value that we can
	 * safely set for relfrozenxid or relminmxid.
	 *
	 * Before entering the main loop, establish the invariant that
	 * next_unskippable_block is the next block number &gt;= blkno that we can't
	 * skip based on the visibility map, either all-visible for a regular scan
	 * or all-frozen for an aggressive scan.  We set it to nblocks if there's
	 * no such block.  We also set up the skipping_blocks flag correctly at
	 * this stage.
	 *
	 * Note: The value returned by visibilitymap_get_status could be slightly
	 * out-of-date, since we make this test before reading the corresponding
	 * heap page or locking the buffer.  This is OK.  If we mistakenly think
	 * that the page is all-visible or all-frozen when in fact the flag's just
	 * been cleared, we might fail to vacuum the page.  It's easy to see that
	 * skipping a page when aggressive is not set is not a very big deal; we
	 * might leave some dead tuples lying around, but the next vacuum will
	 * find them.  But even when aggressive *is* set, it's still OK if we miss
	 * a page whose all-frozen marking has just been cleared.  Any new XIDs
	 * just added to that page are necessarily newer than the GlobalXmin we
	 * computed, so they'll have no effect on the value to which we can safely
	 * set relfrozenxid.  A similar argument applies for MXIDs and relminmxid.
	 *
	 * We will scan the table's last page, at least to the extent of
	 * determining whether it has tuples or not, even if it should be skipped
	 * according to the above rules; except when we've already determined that
	 * it's not worth trying to truncate the table.  This avoids having
	 * lazy_truncate_heap() take access-exclusive lock on the table to attempt
	 * a truncation that just fails immediately because there are tuples in
	 * the last page.  This is worth avoiding mainly because such a lock must
	 * be replayed on any hot standby, where it can be disruptive.
	 */</comment>
	<expr_stmt><expr><name>next_unskippable_block</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_DISABLE_PAGE_SKIPPING</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>next_unskippable_block</name> <operator>&lt;</operator> <name>nblocks</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint8</name></type>		<name>vmstatus</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>vmstatus</name> <operator>=</operator> <call><name>visibilitymap_get_status</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>next_unskippable_block</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aggressive</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vmstatus</name> <operator>&amp;</operator> <name>VISIBILITYMAP_ALL_FROZEN</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vmstatus</name> <operator>&amp;</operator> <name>VISIBILITYMAP_ALL_VISIBLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>next_unskippable_block</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>next_unskippable_block</name> <operator>&gt;=</operator> <name>SKIP_PAGES_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>skipping_blocks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>skipping_blocks</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>blkno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>blkno</name> <operator>&lt;</operator> <name>nblocks</name></expr>;</condition> <incr><expr><name>blkno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
					<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>tupgone</name></decl>,
					<decl><type ref="prev"/><name>hastup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>prev_dead_count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nfrozen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible_according_to_vm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>all_frozen</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* provided all_visible is also true */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_dead_tuples</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>visibility_cutoff_xid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* see note above about forcing scanning of last page */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCE_CHECK_PAGE</name><parameter_list>()</parameter_list></cpp:macro> \
		<cpp:value>(blkno == nblocks - 1 &amp;&amp; should_attempt_truncation(params, vacrelstats))</cpp:value></cpp:define>

		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_HEAP_BLKS_SCANNED</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>update_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>VACUUM_ERRCB_PHASE_SCAN_HEAP</name></expr></argument>,
								 <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>next_unskippable_block</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Time to advance next_unskippable_block */</comment>
			<expr_stmt><expr><name>next_unskippable_block</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_DISABLE_PAGE_SKIPPING</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<while>while <condition>(<expr><name>next_unskippable_block</name> <operator>&lt;</operator> <name>nblocks</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>uint8</name></type>		<name>vmskipflags</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>vmskipflags</name> <operator>=</operator> <call><name>visibilitymap_get_status</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
														   <argument><expr><name>next_unskippable_block</name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>aggressive</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vmskipflags</name> <operator>&amp;</operator> <name>VISIBILITYMAP_ALL_FROZEN</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vmskipflags</name> <operator>&amp;</operator> <name>VISIBILITYMAP_ALL_VISIBLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>next_unskippable_block</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We know we can't skip the current block.  But set up
			 * skipping_blocks to do the right thing at the following blocks.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>next_unskippable_block</name> <operator>-</operator> <name>blkno</name> <operator>&gt;</operator> <name>SKIP_PAGES_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>skipping_blocks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>skipping_blocks</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Normally, the fact that we can't skip this block must mean that
			 * it's not all-visible.  But in an aggressive vacuum we know only
			 * that it's not all-frozen, so it might still be all-visible.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>aggressive</name> <operator>&amp;&amp;</operator> <call><name>VM_ALL_VISIBLE</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>all_visible_according_to_vm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The current block is potentially skippable; if we've seen a
			 * long enough run of skippable blocks to justify skipping it, and
			 * we're not forced to check it, then go ahead and skip.
			 * Otherwise, the page must be at least all-visible if not
			 * all-frozen, so we can set all_visible_according_to_vm = true.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>skipping_blocks</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>FORCE_CHECK_PAGE</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Tricky, tricky.  If this is in aggressive vacuum, the page
				 * must have been all-frozen at the time we checked whether it
				 * was skippable, but it might not be any more.  We must be
				 * careful to count it as a skipped all-frozen page in that
				 * case, or else we'll think we can't update relfrozenxid and
				 * relminmxid.  If it's not an aggressive vacuum, we don't
				 * know whether it was all-frozen, so we have to recheck; but
				 * in this case an approximate answer is OK.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>aggressive</name> <operator>||</operator> <call><name>VM_ALL_FROZEN</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>frozenskipped_pages</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>all_visible_according_to_vm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are close to overrunning the available space for dead-tuple
		 * TIDs, pause and do a cycle of vacuuming before we tackle this page.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dead_tuples</name><operator>-&gt;</operator><name>max_tuples</name></name> <operator>-</operator> <name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name><operator>)</operator> <operator>&lt;</operator> <name>MaxHeapTuplesPerPage</name> <operator>&amp;&amp;</operator>
			<name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Before beginning index vacuuming, we release any pin we may
			 * hold on the visibility map page.  This isn't necessary for
			 * correctness, but we do it anyway to avoid holding the pin
			 * across a lengthy, unrelated operation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>vmbuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Work on all the indexes, then the heap */</comment>
			<expr_stmt><expr><call><name>lazy_vacuum_all_indexes</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>indstats</name></expr></argument>,
									<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>lps</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Remove tuples from heap */</comment>
			<expr_stmt><expr><call><name>lazy_vacuum_heap</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Forget the now-vacuumed tuples, and press on, but be careful
			 * not to reset latestRemovedXid since we want that value to be
			 * valid.
			 */</comment>
			<expr_stmt><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Vacuum the Free Space Map to make newly-freed space visible on
			 * upper-level FSM pages.  Note we have not yet processed blkno.
			 */</comment>
			<expr_stmt><expr><call><name>FreeSpaceMapVacuumRange</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>next_fsm_block_to_vacuum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>next_fsm_block_to_vacuum</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>

			<comment type="block">/* Report that we are once again scanning the heap */</comment>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_PHASE</name></expr></argument>,
										 <argument><expr><name>PROGRESS_VACUUM_PHASE_SCAN_HEAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Pin the visibility map page in case we need to mark the page
		 * all-visible.  In most cases this will be very cheap, because we'll
		 * already have the correct page pinned anyway.  However, it's
		 * possible that (a) next_unskippable_block is covered by a different
		 * VM page than the current block or (b) we released our pin and did a
		 * cycle of index vacuuming.
		 *
		 */</comment>
		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
								 <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We need buffer cleanup lock so that we can prune HOT chains. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockBufferForCleanup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we're not performing an aggressive scan to guard against XID
			 * wraparound, and we don't want to forcibly check the page, then
			 * it's OK to skip vacuuming pages we get a lock conflict on. They
			 * will be dealt with in some future vacuum.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>aggressive</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>FORCE_CHECK_PAGE</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>pinskipped_pages</name></name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Read the page with share lock to see if any xids on it need to
			 * be frozen.  If not we just skip the page, after updating our
			 * scan statistics.  If there are some, we wait for cleanup lock.
			 *
			 * We could defer the lock request further by remembering the page
			 * and coming back to it later, or we could even register
			 * ourselves for multiple buffers and then service whichever one
			 * is received first.  For now, this seems good enough.
			 *
			 * If we get here with aggressive false, then we're just forcibly
			 * checking the page, and so we don't want to insist on getting
			 * the lock; we only need to know if the page contains tuples, so
			 * that we can update nonempty_pages correctly.  It's convenient
			 * to use lazy_check_needs_freeze() for both situations, though.
			 */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lazy_check_needs_freeze</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hastup</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>scanned_pages</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>pinskipped_pages</name></name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>hastup</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>nonempty_pages</name></name> <operator>=</operator> <name>blkno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>aggressive</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Here, we must not advance scanned_pages; that would amount
				 * to claiming that the page contains no freezable tuples.
				 */</comment>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>pinskipped_pages</name></name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>hastup</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>nonempty_pages</name></name> <operator>=</operator> <name>blkno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBufferForCleanup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* drop through to normal processing */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>scanned_pages</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>tupcount_pages</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * All-zeroes pages can be left over if either a backend extends
			 * the relation by a single page, but crashes before the newly
			 * initialized page has been written out, or when bulk-extending
			 * the relation (which creates a number of empty pages at the tail
			 * end of the relation, but enters them into the FSM).
			 *
			 * Note we do not enter the page into the visibilitymap. That has
			 * the downside that we repeatedly visit this page in subsequent
			 * vacuums, but otherwise we'll never not discover the space on a
			 * promoted standby. The harm of repeated checking ought to
			 * normally not be too bad - the space usually should be used at
			 * some point, otherwise there wouldn't be any regular vacuums.
			 *
			 * Make sure these pages are in the FSM, to ensure they can be
			 * reused. Do that by testing if there's any space recorded for
			 * the page. If not, enter it. We do so after releasing the lock
			 * on the heap page, the FSM is approximate, after all.
			 */</comment>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>empty_pages</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>GetRecordedFreeSpace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>SizeOfPageHeaderData</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>empty_pages</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Empty pages are always all-visible and all-frozen (note that
			 * the same is currently not true for new pages, see above).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* mark buffer dirty before writing a WAL record */</comment>
				<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * It's possible that another backend has extended the heap,
				 * initialized the page, and then failed to WAL-log the page
				 * due to an ERROR.  Since heap extension is not WAL-logged,
				 * recovery might try to replay our record setting the page
				 * all-visible and find that the page isn't initialized, which
				 * will cause a PANIC.  To prevent that, check whether the
				 * page has been previously WAL-logged, and if not, do that
				 * now.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>log_newpage_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>PageSetAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>visibilitymap_set</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
								  <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>,
								  <argument><expr><name>VISIBILITYMAP_ALL_VISIBLE</name> <operator>|</operator> <name>VISIBILITYMAP_ALL_FROZEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Prune all HOT-update chains in this page.
		 *
		 * We count tuples removed by the pruning step as removed by VACUUM.
		 */</comment>
		<expr_stmt><expr><name>tups_vacuumed</name> <operator>+=</operator> <call><name>heap_page_prune</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>vacrelstats</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now scan the page to collect vacuumable items and check for tuples
		 * requiring freezing.
		 */</comment>
		<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>has_dead_tuples</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nfrozen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>hastup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_dead_count</name> <operator>=</operator> <name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: If you change anything in the loop below, also look at
		 * heap_page_is_all_visible to see if that needs to be changed.
		 */</comment>
		<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
			 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
			 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Unused items require no processing, but we count 'em */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nunused</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Redirect items mustn't be touched */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsRedirected</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>hastup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* this page won't be truncatable */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * DEAD line pointers are to be vacuumed normally; but we don't
			 * count them in tups_vacuumed, else we'd be double-counting (at
			 * least in the common case where heap_page_prune() just freed up
			 * a non-HOT tuple).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>lazy_record_dead_tuple</name><argument_list>(<argument><expr><name>dead_tuples</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tupgone</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * The criteria for counting a tuple as live in this block need to
			 * match what analyze.c's acquire_sample_rows() does, otherwise
			 * VACUUM and ANALYZE may produce wildly different reltuples
			 * values, e.g. when there are many recently-dead tuples.
			 *
			 * The logic here is a bit simpler than acquire_sample_rows(), as
			 * VACUUM can't run inside a transaction block, which makes some
			 * cases impossible (e.g. in-progress insert from the same
			 * transaction).
			 */</comment>
			<switch>switch <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>

					<comment type="block">/*
					 * Ordinarily, DEAD tuples would have been removed by
					 * heap_page_prune(), but it's possible that the tuple
					 * state changed since heap_page_prune() looked.  In
					 * particular an INSERT_IN_PROGRESS tuple could have
					 * changed to DEAD if the inserter aborted.  So this
					 * cannot be considered an error condition.
					 *
					 * If the tuple is HOT-updated then it must only be
					 * removed by a prune operation; so we keep it just as if
					 * it were RECENTLY_DEAD.  Also, if it's a heap-only
					 * tuple, we choose to keep it, because it'll be a lot
					 * cheaper to get rid of it in the next pruning pass than
					 * to treat it like an indexed tuple. Finally, if index
					 * cleanup is disabled, the second heap pass will not
					 * execute, and the tuple will not get removed, so we must
					 * treat it like any other dead tuple that we choose to
					 * keep.
					 *
					 * If this were to happen for a tuple that actually needed
					 * to be deleted, we'd be in trouble, because it'd
					 * possibly leave a tuple below the relation's xmin
					 * horizon alive.  heap_prepare_freeze_tuple() is prepared
					 * to detect that case and abort the transaction,
					 * preventing corruption.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHotUpdated</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name> <operator>==</operator> <name>VACOPT_TERNARY_DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>nkeep</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>tupgone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* we can delete the tuple */</comment>
					<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>

					<comment type="block">/*
					 * Count it as live.  Not only is this natural, but it's
					 * also what acquire_sample_rows() does.
					 */</comment>
					<expr_stmt><expr><name>live_tuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

					<comment type="block">/*
					 * Is the tuple definitely visible to all transactions?
					 *
					 * NB: Like with per-tuple hint bits, we can't set the
					 * PD_ALL_VISIBLE flag if the inserter committed
					 * asynchronously. See SetHintBits for more info. Check
					 * that the tuple is hinted xmin-committed because of
					 * that.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>all_visible</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderXminCommitted</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * The inserter definitely committed. But is it old
						 * enough that everyone sees it as committed?
						 */</comment>
						<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/* Track newest xmin on page. */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>visibility_cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>visibility_cutoff_xid</name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>

					<comment type="block">/*
					 * If tuple is recently deleted then we must not remove it
					 * from relation.
					 */</comment>
					<expr_stmt><expr><name>nkeep</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>

					<comment type="block">/*
					 * This is an expected case during concurrent vacuum.
					 *
					 * We do not count these rows as live, because we expect
					 * the inserting transaction to update the counters at
					 * commit, and we assume that will happen only after we
					 * report our results.  This assumption is a bit shaky,
					 * but it is what acquire_sample_rows() does, so be
					 * consistent.
					 */</comment>
					<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>
					<comment type="block">/* This is an expected case during concurrent vacuum */</comment>
					<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Count such rows as live.  As above, we assume the
					 * deleting transaction will commit and update the
					 * counters after we report.
					 */</comment>
					<expr_stmt><expr><name>live_tuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected HeapTupleSatisfiesVacuum result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><name>tupgone</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>lazy_record_dead_tuple</name><argument_list>(<argument><expr><name>dead_tuples</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>HeapTupleHeaderAdvanceLatestRemovedXid</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name><name>vacrelstats</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tups_vacuumed</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>has_dead_tuples</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>tuple_totally_frozen</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>num_tuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>hastup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Each non-removable tuple must be checked to see if it needs
				 * freezing.  Note we already have exclusive buffer lock.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>heap_prepare_freeze_tuple</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>,
											  <argument><expr><name>relfrozenxid</name></expr></argument>, <argument><expr><name>relminmxid</name></expr></argument>,
											  <argument><expr><name>FreezeLimit</name></expr></argument>, <argument><expr><name>MultiXactCutoff</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>frozen</name><index>[<expr><name>nfrozen</name></expr>]</index></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>tuple_totally_frozen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>frozen</name><index>[<expr><name>nfrozen</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuple_totally_frozen</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>all_frozen</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>						<comment type="block">/* scan along page */</comment>

		<comment type="block">/*
		 * If we froze any tuples, mark the buffer dirty, and write a WAL
		 * record recording the changes.  We must log the changes to be
		 * crash-safe against future truncation of CLOG.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nfrozen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* execute collected freezes */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfrozen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>frozen</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>heap_execute_freeze_tuple</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>frozen</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/* Now WAL-log freezing if necessary */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>log_heap_freeze</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>FreezeLimit</name></expr></argument>,
										 <argument><expr><name>frozen</name></expr></argument>, <argument><expr><name>nfrozen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there are no indexes we can vacuum the page right now instead of
		 * doing a second scan. Also we don't do that but forget dead tuples
		 * when index cleanup is disabled.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vacrelstats</name><operator>-&gt;</operator><name>useindex</name></name> <operator>&amp;&amp;</operator> <name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nindexes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Remove tuples from heap if the table has no index */</comment>
				<expr_stmt><expr><call><name>lazy_vacuum_page</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>vacuumed_pages</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>has_dead_tuples</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Here, we have indexes but index cleanup is disabled.
				 * Instead of vacuuming the dead tuples on the heap, we just
				 * forget them.
				 *
				 * Note that vacrelstats-&gt;dead_tuples could have tuples which
				 * became dead after HOT-pruning but are not marked dead yet.
				 * We do not process them because it's a very rare condition,
				 * and the next vacuum will process them anyway.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>index_cleanup</name></name> <operator>==</operator> <name>VACOPT_TERNARY_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Forget the now-vacuumed tuples, and press on, but be careful
			 * not to reset latestRemovedXid since we want that value to be
			 * valid.
			 */</comment>
			<expr_stmt><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Periodically do incremental FSM vacuuming to make newly-freed
			 * space visible on upper FSM pages.  Note: although we've cleaned
			 * the current block, we haven't yet updated its FSM entry (that
			 * happens further down), so passing end == blkno is correct.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>-</operator> <name>next_fsm_block_to_vacuum</name> <operator>&gt;=</operator> <name>VACUUM_FSM_EVERY_PAGES</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>FreeSpaceMapVacuumRange</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>next_fsm_block_to_vacuum</name></expr></argument>,
										<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>next_fsm_block_to_vacuum</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* mark page all-visible, if appropriate */</comment>
		<if_stmt><if>if <condition>(<expr><name>all_visible</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>all_visible_according_to_vm</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint8</name></type>		<name>flags</name> <init>= <expr><name>VISIBILITYMAP_ALL_VISIBLE</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>all_frozen</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>VISIBILITYMAP_ALL_FROZEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * It should never be the case that the visibility map page is set
			 * while the page-level bit is clear, but the reverse is allowed
			 * (if checksums are not enabled).  Regardless, set both bits so
			 * that we get back in sync.
			 *
			 * NB: If the heap page is all-visible but the VM bit is not set,
			 * we don't need to dirty the heap page.  However, if checksums
			 * are enabled, we do need to make sure that the heap page is
			 * dirtied before passing it to visibilitymap_set(), because it
			 * may be logged.  Given that this situation should only happen in
			 * rare cases after a crash, it is not worth optimizing.
			 */</comment>
			<expr_stmt><expr><call><name>PageSetAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>visibilitymap_set</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
							  <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>visibility_cutoff_xid</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * As of PostgreSQL 9.2, the visibility map bit should never be set if
		 * the page-level bit is clear.  However, it's possible that the bit
		 * got cleared after we checked it and before we took the buffer
		 * content lock, so we must recheck before jumping to the conclusion
		 * that something bad has happened.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>all_visible_according_to_vm</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call>
				 <operator>&amp;&amp;</operator> <call><name>VM_ALL_VISIBLE</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"page is not marked all-visible but visibility map bit is set in relation \"%s\" page %u"</literal></expr></argument>,
				 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>,
								<argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * It's possible for the value returned by GetOldestXmin() to move
		 * backwards, so it's not wrong for us to see tuples that appear to
		 * not be visible to everyone yet, while PD_ALL_VISIBLE is already
		 * set. The real safe xmin value never moves backwards, but
		 * GetOldestXmin() is conservative and sometimes returns a value
		 * that's unnecessarily small, so if we see that contradiction it just
		 * means that the tuples that we think are not visible to everyone yet
		 * actually are, and the PD_ALL_VISIBLE flag is correct.
		 *
		 * There should never be dead tuples on a page with PD_ALL_VISIBLE
		 * set, however.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>has_dead_tuples</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"page containing dead tuples is marked as all-visible in relation \"%s\" page %u"</literal></expr></argument>,
				 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>,
								<argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * If the all-visible page is all-frozen but not marked as such yet,
		 * mark it as all-frozen.  Note that all_frozen is only valid if
		 * all_visible is true, so we must check both.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>all_visible_according_to_vm</name> <operator>&amp;&amp;</operator> <name>all_visible</name> <operator>&amp;&amp;</operator> <name>all_frozen</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><call><name>VM_ALL_FROZEN</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can pass InvalidTransactionId as the cutoff XID here,
			 * because setting the all-frozen bit doesn't cause recovery
			 * conflicts.
			 */</comment>
			<expr_stmt><expr><call><name>visibilitymap_set</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
							  <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>,
							  <argument><expr><name>VISIBILITYMAP_ALL_FROZEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remember the location of the last page with nonremovable tuples */</comment>
		<if_stmt><if>if <condition>(<expr><name>hastup</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>nonempty_pages</name></name> <operator>=</operator> <name>blkno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we remembered any tuples for deletion, then the page will be
		 * visited again by lazy_vacuum_heap, which will compute and record
		 * its post-compaction free space.  If not, then we're done with this
		 * page, so remember its free space as-is.  (This path will always be
		 * taken if there are no indexes.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>==</operator> <name>prev_dead_count</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* report that everything is scanned and vacuumed */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_HEAP_BLKS_SCANNED</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear the block number information */</comment>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>frozen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save stats for use later */</comment>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>tuples_deleted</name></name> <operator>=</operator> <name>tups_vacuumed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>new_dead_tuples</name></name> <operator>=</operator> <name>nkeep</name></expr>;</expr_stmt>

	<comment type="block">/* now we can compute the new value for pg_class.reltuples */</comment>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>new_live_tuples</name></name> <operator>=</operator> <call><name>vac_estimate_reltuples</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
														  <argument><expr><name>nblocks</name></expr></argument>,
														  <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>tupcount_pages</name></name></expr></argument>,
														  <argument><expr><name>live_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* also compute total number of surviving heap entries */</comment>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>new_rel_tuples</name></name> <operator>=</operator>
		<name><name>vacrelstats</name><operator>-&gt;</operator><name>new_live_tuples</name></name> <operator>+</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>new_dead_tuples</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release any remaining pin on visibility map page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vmbuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If any tuples need to be deleted, perform final vacuum cycle */</comment>
	<comment type="block">/* XXX put a threshold on min number of tuples here? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Work on all the indexes, and then the heap */</comment>
		<expr_stmt><expr><call><name>lazy_vacuum_all_indexes</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>indstats</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>,
								<argument><expr><name>lps</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remove tuples from heap */</comment>
		<expr_stmt><expr><call><name>lazy_vacuum_heap</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Vacuum the remainder of the Free Space Map.  We must do this whether or
	 * not there were indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>&gt;</operator> <name>next_fsm_block_to_vacuum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeSpaceMapVacuumRange</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>next_fsm_block_to_vacuum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* report all blocks vacuumed */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_HEAP_BLKS_VACUUMED</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do post-vacuum cleanup */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>useindex</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>lazy_cleanup_all_indexes</name><argument_list>(<argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>indstats</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>lps</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * End parallel mode before updating index statistics as we cannot write
	 * during parallel mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ParallelVacuumIsActive</name><argument_list>(<argument><expr><name>lps</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>end_parallel_vacuum</name><argument_list>(<argument><expr><name>indstats</name></expr></argument>, <argument><expr><name>lps</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Update index statistics */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>useindex</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_index_statistics</name><argument_list>(<argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>indstats</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If no indexes, make log report that lazy_vacuum_heap would've made */</comment>
	<if_stmt><if>if <condition>(<expr><name>vacuumed_pages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": removed %.0f row versions in %u pages"</literal></expr></argument>,
						<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
						<argument><expr><name>tups_vacuumed</name></expr></argument>, <argument><expr><name>vacuumed_pages</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This is pretty messy, but we split it up so that we can skip emitting
	 * individual parts of the message when not applicable.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%.0f dead row versions cannot be removed yet, oldest xmin: %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>nkeep</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"There were %.0f unused item identifiers.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>nunused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"Skipped %u page due to buffer pins, "</literal></expr></argument>,
									<argument><expr><literal type="string">"Skipped %u pages due to buffer pins, "</literal></expr></argument>,
									<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>pinskipped_pages</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>pinskipped_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%u frozen page.\n"</literal></expr></argument>,
									<argument><expr><literal type="string">"%u frozen pages.\n"</literal></expr></argument>,
									<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>frozenskipped_pages</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>frozenskipped_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%u page is entirely empty.\n"</literal></expr></argument>,
									<argument><expr><literal type="string">"%u pages are entirely empty.\n"</literal></expr></argument>,
									<argument><expr><name>empty_pages</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>empty_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": found %.0f removable, %.0f nonremovable row versions in %u out of %u pages"</literal></expr></argument>,
					<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
					<argument><expr><name>tups_vacuumed</name></expr></argument>, <argument><expr><name>num_tuples</name></expr></argument>,
					<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>scanned_pages</name></name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	lazy_vacuum_all_indexes() -- vacuum all indexes of relation.
 *
 * We process the indexes serially unless we are doing parallel vacuum.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_vacuum_all_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>,
						<parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
						<parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log cleanup info before we touch indexes */</comment>
	<expr_stmt><expr><call><name>vacuum_log_cleanup_info</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report that we are now vacuuming indexes */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_VACUUM_PHASE_VACUUM_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform index vacuuming with parallel workers for parallel vacuum. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ParallelVacuumIsActive</name><argument_list>(<argument><expr><name>lps</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Tell parallel workers to do index vacuuming */</comment>
		<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>for_cleanup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>first_time</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can only provide an approximate value of num_heap_tuples in
		 * vacuum cases.
		 */</comment>
		<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>old_live_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>estimated_count</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>lazy_parallel_vacuum_indexes</name><argument_list>(<argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>lps</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>lazy_vacuum_index</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stats</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>dead_tuples</name></name></expr></argument>,
							  <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>old_live_tuples</name></name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Increase and report the number of index scans */</comment>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>num_index_scans</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_NUM_INDEX_VACUUMS</name></expr></argument>,
								 <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>num_index_scans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	lazy_vacuum_heap() -- second pass over the heap
 *
 *		This routine marks dead tuples as unused and compacts out free
 *		space on their pages.  Pages not having dead tuples recorded from
 *		lazy_scan_heap are not visited at all.
 *
 * Note: the reason for doing this as a second pass is we cannot remove
 * the tuples until we've removed their index entries, and we want to
 * process index entry removal in batches as large as possible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_vacuum_heap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVSavedErrInfo</name></type> <name>saved_err_info</name></decl>;</decl_stmt>

	<comment type="block">/* Report that we are now vacuuming the heap */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_VACUUM_PHASE_VACUUM_HEAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update error traceback information */</comment>
	<expr_stmt><expr><call><name>update_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_err_info</name></expr></argument>, <argument><expr><name>VACUUM_ERRCB_PHASE_VACUUM_HEAP</name></expr></argument>,
							 <argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>npages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>tupindex</name> <operator>&lt;</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>tblk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tblk</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vacrelstats</name><operator>-&gt;</operator><name>dead_tuples</name><operator>-&gt;</operator><name>itemptrs</name><index>[<expr><name>tupindex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>tblk</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>tblk</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>,
								 <argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockBufferForCleanup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>tupindex</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>tupindex</name> <operator>=</operator> <call><name>lazy_vacuum_page</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>tblk</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>tupindex</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now that we've compacted the page, record its available space */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>tblk</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>npages</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Clear the block number information */</comment>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vmbuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": removed %d row versions in %d pages"</literal></expr></argument>,
					<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
					<argument><expr><name>tupindex</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Revert to the previous phase information for error traceback */</comment>
	<expr_stmt><expr><call><name>restore_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_err_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	lazy_vacuum_page() -- free dead tuples on a page
 *					 and repair its fragmentation.
 *
 * Caller must hold pin and buffer cleanup lock on the buffer.
 *
 * tupindex is the index in vacrelstats-&gt;dead_tuples of the first dead
 * tuple for this page.  We assume the rest follow sequentially.
 * The return value is the first tupindex after the tuples of this page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lazy_vacuum_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>tupindex</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>vmbuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name> <init>= <expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>dead_tuples</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>unused</name><index>[<expr><name>MaxOffsetNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>uncnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>visibility_cutoff_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_frozen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVSavedErrInfo</name></type> <name>saved_err_info</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_HEAP_BLKS_VACUUMED</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update error traceback information */</comment>
	<expr_stmt><expr><call><name>update_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_err_info</name></expr></argument>, <argument><expr><name>VACUUM_ERRCB_PHASE_VACUUM_HEAP</name></expr></argument>,
							 <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>tupindex</name> <operator>&lt;</operator> <name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>;</condition> <incr><expr><name>tupindex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>tblk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>toff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tblk</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dead_tuples</name><operator>-&gt;</operator><name>itemptrs</name><index>[<expr><name>tupindex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tblk</name> <operator>!=</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* past end of tuples for this block */</comment>
		<expr_stmt><expr><name>toff</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dead_tuples</name><operator>-&gt;</operator><name>itemptrs</name><index>[<expr><name>tupindex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>toff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemIdSetUnused</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unused</name><index>[<expr><name>uncnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>toff</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PageRepairFragmentation</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark buffer dirty before we write WAL.
	 */</comment>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>log_heap_clean</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>unused</name></expr></argument>, <argument><expr><name>uncnt</name></expr></argument>,
								<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * End critical section, so we safely can do visibility tests (which
	 * possibly need to perform IO and allocate memory!). If we crash now the
	 * page (including the corresponding vm bit) might not be marked all
	 * visible, but that's fine. A later vacuum will fix that.
	 */</comment>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we have removed the dead tuples from the page, once again
	 * check if the page has become all-visible.  The page is already marked
	 * dirty, exclusively locked, and, if needed, a full page image has been
	 * emitted in the log_heap_clean() above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>heap_page_is_all_visible</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visibility_cutoff_xid</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>all_frozen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PageSetAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * All the changes to the heap page have been done. If the all-visible
	 * flag is now set, also set the VM all-visible bit (and, if possible, the
	 * all-frozen bit) unless this has already been done previously.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>vm_status</name> <init>= <expr><call><name>visibilitymap_get_status</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Set the VM all-frozen bit to flag, if needed */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vm_status</name> <operator>&amp;</operator> <name>VISIBILITYMAP_ALL_VISIBLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>VISIBILITYMAP_ALL_VISIBLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vm_status</name> <operator>&amp;</operator> <name>VISIBILITYMAP_ALL_FROZEN</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>all_frozen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>VISIBILITYMAP_ALL_FROZEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>visibilitymap_set</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
							  <argument><expr><operator>*</operator><name>vmbuffer</name></expr></argument>, <argument><expr><name>visibility_cutoff_xid</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Revert to the previous phase information for error traceback */</comment>
	<expr_stmt><expr><call><name>restore_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_err_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tupindex</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	lazy_check_needs_freeze() -- scan page to see if any tuples
 *					 need to be cleaned to avoid wraparound
 *
 * Returns true if the page needs to be vacuumed using cleanup lock.
 * Also returns a flag indicating whether page contains any tuples at all.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lazy_check_needs_freeze</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hastup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tupleheader</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>hastup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * New and empty pages, obviously, don't contain tuples. We could make
	 * sure that the page is registered in the FSM, but it doesn't seem worth
	 * waiting for a cleanup lock just for that, especially because it's
	 * likely that the pin holder will do so.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* this should match hastup test in count_nondeletable_pages() */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>hastup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* dead and redirect items never need freezing */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tupleheader</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>heap_tuple_needs_freeze</name><argument_list>(<argument><expr><name>tupleheader</name></expr></argument>, <argument><expr><name>FreezeLimit</name></expr></argument>,
									<argument><expr><name>MultiXactCutoff</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>							<comment type="block">/* scan along page */</comment>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform index vacuum or index cleanup with parallel workers.  This function
 * must be used by the parallel vacuum leader process.  The caller must set
 * lps-&gt;lvshared-&gt;for_cleanup to indicate whether to perform vacuum or
 * cleanup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_parallel_vacuum_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
							 <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nworkers</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ParallelVacuumIsActive</name><argument_list>(<argument><expr><name>lps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine the number of parallel workers to launch */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>for_cleanup</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>first_time</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <name><name>lps</name><operator>-&gt;</operator><name>nindexes_parallel_cleanup</name></name> <operator>+</operator>
				<name><name>lps</name><operator>-&gt;</operator><name>nindexes_parallel_condcleanup</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <name><name>lps</name><operator>-&gt;</operator><name>nindexes_parallel_cleanup</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <name><name>lps</name><operator>-&gt;</operator><name>nindexes_parallel_bulkdel</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* The leader process will participate */</comment>
	<expr_stmt><expr><name>nworkers</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * It is possible that parallel context is initialized with fewer workers
	 * than the number of indexes that need a separate worker in the current
	 * phase, so we need to consider it.  See compute_parallel_vacuum_workers.
	 */</comment>
	<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>nworkers</name></expr></argument>, <argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setup the shared cost-based vacuum delay and launch workers */</comment>
	<if_stmt><if>if <condition>(<expr><name>nworkers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>num_index_scans</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Reset the parallel index processing counter */</comment>
			<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>idx</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Reinitialize the parallel context to relaunch parallel workers */</comment>
			<expr_stmt><expr><call><name>ReinitializeParallelDSM</name><argument_list>(<argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set up shared cost balance and the number of active workers for
		 * vacuum delay.  We need to do this before launching workers as
		 * otherwise, they might not see the updated values for these
		 * parameters.
		 */</comment>
		<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>cost_balance</name></name><operator>)</operator></expr></argument>, <argument><expr><name>VacuumCostBalance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>active_nworkers</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The number of workers can vary between bulkdelete and cleanup
		 * phase.
		 */</comment>
		<expr_stmt><expr><call><name>ReinitializeParallelWorkers</name><argument_list>(<argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>, <argument><expr><name>nworkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LaunchParallelWorkers</name><argument_list>(<argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Reset the local cost values for leader backend as we have
			 * already accumulated the remaining balance of heap.
			 */</comment>
			<expr_stmt><expr><name>VacuumCostBalance</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>VacuumCostBalanceLocal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* Enable shared cost balance for leader backend */</comment>
			<expr_stmt><expr><name>VacuumSharedCostBalance</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>cost_balance</name></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>VacuumActiveNWorkers</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>active_nworkers</name></name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>for_cleanup</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"launched %d parallel vacuum worker for index cleanup (planned: %d)"</literal></expr></argument>,
									 <argument><expr><literal type="string">"launched %d parallel vacuum workers for index cleanup (planned: %d)"</literal></expr></argument>,
									 <argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr></argument>, <argument><expr><name>nworkers</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"launched %d parallel vacuum worker for index vacuuming (planned: %d)"</literal></expr></argument>,
									 <argument><expr><literal type="string">"launched %d parallel vacuum workers for index vacuuming (planned: %d)"</literal></expr></argument>,
									 <argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr></argument>, <argument><expr><name>nworkers</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process the indexes that can be processed by only leader process */</comment>
	<expr_stmt><expr><call><name>vacuum_indexes_leader</name><argument_list>(<argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>lps</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Join as a parallel worker.  The leader process alone processes all the
	 * indexes in the case where no workers are launched.
	 */</comment>
	<expr_stmt><expr><call><name>parallel_vacuum_index</name><argument_list>(<argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name></name></expr></argument>,
						  <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>dead_tuples</name></name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Next, accumulate buffer and WAL usage.  (This must wait for the workers
	 * to finish, or we might get incomplete data.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nworkers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Wait for all vacuum workers to finish */</comment>
		<expr_stmt><expr><call><name>WaitForParallelWorkersToFinish</name><argument_list>(<argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lps</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>InstrAccumParallelQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lps</name><operator>-&gt;</operator><name>buffer_usage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lps</name><operator>-&gt;</operator><name>wal_usage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Carry the shared balance value to heap scan and disable shared costing
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>VacuumSharedCostBalance</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>VacuumCostBalance</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><name>VacuumSharedCostBalance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumSharedCostBalance</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumActiveNWorkers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Index vacuum/cleanup routine used by the leader process and parallel
 * vacuum worker processes to process the indexes in parallel.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parallel_vacuum_index</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
					  <parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>, <parameter><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Increment the active worker count if we are able to launch any worker.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>VacuumActiveNWorkers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><name>VacuumActiveNWorkers</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Loop until all indexes are vacuumed */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LVSharedIndStats</name> <modifier>*</modifier></type><name>shared_indstats</name></decl>;</decl_stmt>

		<comment type="block">/* Get an index number to process */</comment>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lvshared</name><operator>-&gt;</operator><name>idx</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done for all indexes? */</comment>
		<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>nindexes</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Get the index statistics of this index from DSM */</comment>
		<expr_stmt><expr><name>shared_indstats</name> <operator>=</operator> <call><name>get_indstats</name><argument_list>(<argument><expr><name>lvshared</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Skip processing indexes that don't participate in parallel
		 * operation
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shared_indstats</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<call><name>skip_parallel_vacuum_index</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>lvshared</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Do vacuum or cleanup of the index */</comment>
		<expr_stmt><expr><call><name>vacuum_one_index</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>stats</name><index>[<expr><name>idx</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>lvshared</name></expr></argument>, <argument><expr><name>shared_indstats</name></expr></argument>,
						 <argument><expr><name>dead_tuples</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We have completed the index vacuum so decrement the active worker
	 * count.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>VacuumActiveNWorkers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><name>VacuumActiveNWorkers</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Vacuum or cleanup indexes that can be processed by only the leader process
 * because these indexes don't support parallel operation at that phase.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuum_indexes_leader</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
					  <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Increment the active worker count if we are able to launch any worker.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>VacuumActiveNWorkers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><name>VacuumActiveNWorkers</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LVSharedIndStats</name> <modifier>*</modifier></type><name>shared_indstats</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>shared_indstats</name> <operator>=</operator> <call><name>get_indstats</name><argument_list>(<argument><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process the indexes skipped by parallel workers */</comment>
		<if_stmt><if>if <condition>(<expr><name>shared_indstats</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<call><name>skip_parallel_vacuum_index</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>vacuum_one_index</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name></name></expr></argument>,
							 <argument><expr><name>shared_indstats</name></expr></argument>, <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>dead_tuples</name></name></expr></argument>,
							 <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We have completed the index vacuum so decrement the active worker
	 * count.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>VacuumActiveNWorkers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><name>VacuumActiveNWorkers</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Vacuum or cleanup index either by leader process or by one of the worker
 * process.  After processing the index this function copies the index
 * statistics returned from ambulkdelete and amvacuumcleanup to the DSM
 * segment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuum_one_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indrel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
				 <parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>, <parameter><decl><type><name>LVSharedIndStats</name> <modifier>*</modifier></type><name>shared_indstats</name></decl></parameter>,
				 <parameter><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>bulkdelete_res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shared_indstats</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the space for IndexBulkDeleteResult */</comment>
		<expr_stmt><expr><name>bulkdelete_res</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>shared_indstats</name><operator>-&gt;</operator><name>stats</name></name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update the pointer to the corresponding bulk-deletion result if
		 * someone has already updated it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared_indstats</name><operator>-&gt;</operator><name>updated</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>stats</name> <operator>=</operator> <name>bulkdelete_res</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do vacuum or cleanup of the index */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lvshared</name><operator>-&gt;</operator><name>for_cleanup</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>lazy_cleanup_index</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name><name>lvshared</name><operator>-&gt;</operator><name>reltuples</name></name></expr></argument>,
						   <argument><expr><name><name>lvshared</name><operator>-&gt;</operator><name>estimated_count</name></name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>lazy_vacuum_index</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>dead_tuples</name></expr></argument>,
						  <argument><expr><name><name>lvshared</name><operator>-&gt;</operator><name>reltuples</name></name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Copy the index bulk-deletion result returned from ambulkdelete and
	 * amvacuumcleanup to the DSM segment if it's the first cycle because they
	 * allocate locally and it's possible that an index will be vacuumed by a
	 * different vacuum process the next cycle.  Copying the result normally
	 * happens only the first time an index is vacuumed.  For any additional
	 * vacuum pass, we directly point to the result on the DSM segment and
	 * pass it to vacuum index APIs so that workers can update it directly.
	 *
	 * Since all vacuum workers write the bulk-deletion result at different
	 * slots we can write them without locking.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shared_indstats</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>shared_indstats</name><operator>-&gt;</operator><name>updated</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>stats</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bulkdelete_res</name></expr></argument>, <argument><expr><operator>*</operator><name>stats</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared_indstats</name><operator>-&gt;</operator><name>updated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now that stats[idx] points to the DSM segment, we don't need the
		 * locally allocated results.
		 */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>*</operator><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>stats</name> <operator>=</operator> <name>bulkdelete_res</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	lazy_cleanup_all_indexes() -- cleanup all indexes of relation.
 *
 * Cleanup indexes.  We process the indexes serially unless we are doing
 * parallel vacuum.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_cleanup_all_indexes</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
						 <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report that we are now cleaning up indexes */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_VACUUM_PHASE_INDEX_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If parallel vacuum is active we perform index cleanup with parallel
	 * workers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ParallelVacuumIsActive</name><argument_list>(<argument><expr><name>lps</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Tell parallel workers to do index cleanup */</comment>
		<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>for_cleanup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>first_time</name></name> <operator>=</operator>
			<operator>(</operator><name><name>vacrelstats</name><operator>-&gt;</operator><name>num_index_scans</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can provide a better estimate of total number of surviving
		 * tuples (we assume indexes are more interested in that than in the
		 * number of nominally live tuples).
		 */</comment>
		<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>new_rel_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name><operator>-&gt;</operator><name>estimated_count</name></name> <operator>=</operator>
			<operator>(</operator><name><name>vacrelstats</name><operator>-&gt;</operator><name>tupcount_pages</name></name> <operator>&lt;</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>lazy_parallel_vacuum_indexes</name><argument_list>(<argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><name>lps</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>lazy_cleanup_index</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stats</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>new_rel_tuples</name></name></expr></argument>,
							   <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>tupcount_pages</name></name> <operator>&lt;</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name></expr></argument>,
							   <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	lazy_vacuum_index() -- vacuum one index relation.
 *
 *		Delete all the index entries pointing to tuples listed in
 *		dead_tuples, and update running statistics.
 *
 *		reltuples is the number of heap tuples to be passed to the
 *		bulkdelete callback.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_vacuum_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indrel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
				  <parameter><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>reltuples</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexVacuumInfo</name></type> <name>ivinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVSavedErrInfo</name></type> <name>saved_err_info</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>indrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>analyze_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>report_progress</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>estimated_count</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>message_level</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>num_heap_tuples</name></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>strategy</name></name> <operator>=</operator> <name>vac_strategy</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update error traceback information.
	 *
	 * The index name is saved during this phase and restored immediately
	 * after this phase.  See vacuum_error_callback.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_err_info</name></expr></argument>,
							 <argument><expr><name>VACUUM_ERRCB_PHASE_VACUUM_INDEX</name></expr></argument>,
							 <argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do bulk deletion */</comment>
	<expr_stmt><expr><operator>*</operator><name>stats</name> <operator>=</operator> <call><name>index_bulk_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivinfo</name></expr></argument>, <argument><expr><operator>*</operator><name>stats</name></expr></argument>,
							   <argument><expr><name>lazy_tid_reaped</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>dead_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"scanned index \"%s\" to remove %d row versions"</literal></expr></argument>,
					<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name></expr></argument>,
					<argument><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Revert to the previous phase information for error traceback */</comment>
	<expr_stmt><expr><call><name>restore_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_err_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	lazy_cleanup_index() -- do post-vacuum cleanup for one index relation.
 *
 *		reltuples is the number of heap tuples and estimated_count is true
 *		if reltuples is an estimated value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_cleanup_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indrel</name></decl></parameter>,
				   <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
				   <parameter><decl><type><name>double</name></type> <name>reltuples</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>estimated_count</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexVacuumInfo</name></type> <name>ivinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVSavedErrInfo</name></type> <name>saved_err_info</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>indrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>analyze_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>report_progress</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>estimated_count</name></name> <operator>=</operator> <name>estimated_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>message_level</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>num_heap_tuples</name></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>strategy</name></name> <operator>=</operator> <name>vac_strategy</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update error traceback information.
	 *
	 * The index name is saved during this phase and restored immediately
	 * after this phase.  See vacuum_error_callback.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_err_info</name></expr></argument>,
							 <argument><expr><name>VACUUM_ERRCB_PHASE_INDEX_CLEANUP</name></expr></argument>,
							 <argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>stats</name> <operator>=</operator> <call><name>index_vacuum_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivinfo</name></expr></argument>, <argument><expr><operator>*</operator><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>stats</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" now contains %.0f row versions in %u pages"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><operator>(</operator><operator>*</operator><name>stats</name><operator>)</operator><operator>-&gt;</operator><name>num_index_tuples</name></name></expr></argument>,
						<argument><expr><name><operator>(</operator><operator>*</operator><name>stats</name><operator>)</operator><operator>-&gt;</operator><name>num_pages</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%.0f index row versions were removed.\n"</literal>
						   <literal type="string">"%u index pages have been deleted, %u are currently reusable.\n"</literal>
						   <literal type="string">"%s."</literal></expr></argument>,
						   <argument><expr><name><operator>(</operator><operator>*</operator><name>stats</name><operator>)</operator><operator>-&gt;</operator><name>tuples_removed</name></name></expr></argument>,
						   <argument><expr><name><operator>(</operator><operator>*</operator><name>stats</name><operator>)</operator><operator>-&gt;</operator><name>pages_deleted</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>stats</name><operator>)</operator><operator>-&gt;</operator><name>pages_free</name></name></expr></argument>,
						   <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Revert back to the old phase information for error traceback */</comment>
	<expr_stmt><expr><call><name>restore_vacuum_error_info</name><argument_list>(<argument><expr><name>vacrelstats</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_err_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>indname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * should_attempt_truncation - should we attempt to truncate the heap?
 *
 * Don't even think about it unless we have a shot at releasing a goodly
 * number of pages.  Otherwise, the time taken isn't worth it.
 *
 * Also don't attempt it if we are doing early pruning/vacuuming, because a
 * scan which cannot find a truncated heap page cannot determine that the
 * snapshot is too old to read that page.  We might be able to get away with
 * truncating all except one of the pages, setting its LSN to (at least) the
 * maximum of the truncated range if we also treated an index leaf tuple
 * pointing to a missing heap page as something to trigger the "snapshot too
 * old" error, but that seems fragile and seems like it deserves its own patch
 * if we consider it.
 *
 * This is split out so that we can test whether truncation is going to be
 * called for before we actually do it.  If you change the logic here, be
 * careful to depend only on fields that lazy_scan_heap updates on-the-fly.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_attempt_truncation</name><parameter_list>(<parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>possibly_freeable</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>truncate</name></name> <operator>==</operator> <name>VACOPT_TERNARY_DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>possibly_freeable</name> <operator>=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name> <operator>-</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>nonempty_pages</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>possibly_freeable</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>possibly_freeable</name> <operator>&gt;=</operator> <name>REL_TRUNCATE_MINIMUM</name> <operator>||</operator>
		 <name>possibly_freeable</name> <operator>&gt;=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name> <operator>/</operator> <name>REL_TRUNCATE_FRACTION</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>old_snapshot_threshold</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * lazy_truncate_heap - try to truncate off any empty pages at the end
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_truncate_heap</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>old_rel_pages</name> <init>= <expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>new_rel_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lock_retry</name></decl>;</decl_stmt>

	<comment type="block">/* Report that we are now truncating */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_VACUUM_PHASE_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop until no more truncating can be done.
	 */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need full exclusive lock on the relation in order to do
		 * truncation. If we can't get it, give up rather than waiting --- we
		 * don't want to block other backends, and we don't want to deadlock
		 * (which is quite possible considering we already hold a lower-grade
		 * lock).
		 */</comment>
		<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>lock_waiter_detected</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lock_retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ConditionalLockRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check for interrupts while trying to (re-)acquire the exclusive
			 * lock.
			 */</comment>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>lock_retry</name> <operator>&gt;</operator> <operator>(</operator><name>VACUUM_TRUNCATE_LOCK_TIMEOUT</name> <operator>/</operator>
								<name>VACUUM_TRUNCATE_LOCK_WAIT_INTERVAL</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We failed to establish the lock in the specified number of
				 * retries. This means we give up truncating.
				 */</comment>
				<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>lock_waiter_detected</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": stopping truncate due to conflicting lock request"</literal></expr></argument>,
								<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>VACUUM_TRUNCATE_LOCK_WAIT_INTERVAL</name> <operator>*</operator> <literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * Now that we have exclusive lock, look to see if the rel has grown
		 * whilst we were vacuuming with non-exclusive lock.  If so, give up;
		 * the newly added pages presumably contain non-deletable tuples.
		 */</comment>
		<expr_stmt><expr><name>new_rel_pages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>new_rel_pages</name> <operator>!=</operator> <name>old_rel_pages</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: we intentionally don't update vacrelstats-&gt;rel_pages with
			 * the new rel size here.  If we did, it would amount to assuming
			 * that the new pages are empty, which is unlikely. Leaving the
			 * numbers alone amounts to assuming that the new pages have the
			 * same tuple density as existing ones, which is less unlikely.
			 */</comment>
			<expr_stmt><expr><call><name>UnlockRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Scan backwards from the end to verify that the end pages actually
		 * contain no tuples.  This is *necessary*, not optional, because
		 * other backends could have added tuples to these pages whilst we
		 * were vacuuming.
		 */</comment>
		<expr_stmt><expr><name>new_rel_pages</name> <operator>=</operator> <call><name>count_nondeletable_pages</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>new_rel_pages</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_rel_pages</name> <operator>&gt;=</operator> <name>old_rel_pages</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* can't do anything after all */</comment>
			<expr_stmt><expr><call><name>UnlockRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Okay to truncate.
		 */</comment>
		<expr_stmt><expr><call><name>RelationTruncate</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>new_rel_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can release the exclusive lock as soon as we have truncated.
		 * Other backends can't safely access the relation until they have
		 * processed the smgr invalidation that smgrtruncate sent out ... but
		 * that should happen as part of standard invalidation processing once
		 * they acquire lock on the relation.
		 */</comment>
		<expr_stmt><expr><call><name>UnlockRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update statistics.  Here, it *is* correct to adjust rel_pages
		 * without also touching reltuples, since the tuple count wasn't
		 * changed by the truncation.
		 */</comment>
		<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>pages_removed</name></name> <operator>+=</operator> <name>old_rel_pages</name> <operator>-</operator> <name>new_rel_pages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name> <operator>=</operator> <name>new_rel_pages</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": truncated %u to %u pages"</literal></expr></argument>,
						<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
						<argument><expr><name>old_rel_pages</name></expr></argument>, <argument><expr><name>new_rel_pages</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>,
									<argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_rel_pages</name> <operator>=</operator> <name>new_rel_pages</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>new_rel_pages</name> <operator>&gt;</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>nonempty_pages</name></name> <operator>&amp;&amp;</operator>
			 <name><name>vacrelstats</name><operator>-&gt;</operator><name>lock_waiter_detected</name></name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/*
 * Rescan end pages to verify that they are (still) empty of tuples.
 *
 * Returns number of nondeletable pages (last nonempty page + 1).
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>count_nondeletable_pages</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>prefetchedUntil</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>starttime</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize the starttime if we check for conflicting lock requests */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start checking blocks at what we believe relation end to be and move
	 * backwards.  (Strange coding of loop control is needed because blkno is
	 * unsigned.)  To make the scan faster, we prefetch a few blocks at a time
	 * in forward direction, so that OS-level readahead can kick in.
	 */</comment>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>rel_pages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><operator>(</operator><name>PREFETCH_SIZE</name> <operator>&amp;</operator> <operator>(</operator><name>PREFETCH_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>,
					 <argument><expr><literal type="string">"prefetch size must be power of 2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prefetchedUntil</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>blkno</name> <operator>&gt;</operator> <name><name>vacrelstats</name><operator>-&gt;</operator><name>nonempty_pages</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
					<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hastup</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check if another process requests a lock on our relation. We are
		 * holding an AccessExclusiveLock here, so they will be waiting. We
		 * only do this once per VACUUM_TRUNCATE_LOCK_CHECK_INTERVAL, and we
		 * only check if that interval has elapsed once every 32 blocks to
		 * keep the number of system calls and actual shared lock table
		 * lookups to a minimum.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>blkno</name> <operator>%</operator> <literal type="number">32</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>instr_time</name></type>	<name>currenttime</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>instr_time</name></type>	<name>elapsed</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>currenttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>elapsed</name> <operator>=</operator> <name>currenttime</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>elapsed</name></expr></argument>, <argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>elapsed</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator>
				<operator>&gt;=</operator> <name>VACUUM_TRUNCATE_LOCK_CHECK_INTERVAL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>LockHasWaitersRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": suspending truncate due to conflicting lock request"</literal></expr></argument>,
									<argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>lock_waiter_detected</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>blkno</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>starttime</name> <operator>=</operator> <name>currenttime</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We don't insert a vacuum delay point here, because we have an
		 * exclusive lock on the table which we want to hold for as short a
		 * time as possible.  We still need to check for interrupts however.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>blkno</name><operator>--</operator></expr>;</expr_stmt>

		<comment type="block">/* If we haven't prefetched this lot yet, do so now. */</comment>
		<if_stmt><if>if <condition>(<expr><name>prefetchedUntil</name> <operator>&gt;</operator> <name>blkno</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>prefetchStart</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pblkno</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>prefetchStart</name> <operator>=</operator> <name>blkno</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>PREFETCH_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>pblkno</name> <operator>=</operator> <name>prefetchStart</name></expr>;</init> <condition><expr><name>pblkno</name> <operator>&lt;=</operator> <name>blkno</name></expr>;</condition> <incr><expr><name>pblkno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PrefetchBuffer</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>pblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>prefetchedUntil</name> <operator>=</operator> <name>prefetchStart</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
								 <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* In this phase we only need shared access to the buffer */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>hastup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
			 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
			 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Note: any non-unused item should be taken as a reason to keep
			 * this page.  We formerly thought that DEAD tuples could be
			 * thrown away, but that's not so, because we'd not have cleaned
			 * out their index entries.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>hastup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* can stop scanning */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>						<comment type="block">/* scan along page */</comment>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done scanning if we found a tuple here */</comment>
		<if_stmt><if>if <condition>(<expr><name>hastup</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>blkno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If we fall out of the loop, all the previously-thought-to-be-empty
	 * pages still are; we need not bother to look at the last known-nonempty
	 * page.
	 */</comment>
	<return>return <expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>nonempty_pages</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the maximum number of dead tuples we can record.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>compute_max_dead_tuples</name><parameter_list>(<parameter><decl><type><name>BlockNumber</name></type> <name>relblocks</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>maxtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>vac_work_mem</name> <init>= <expr><ternary><condition><expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
	<name>autovacuum_work_mem</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then>
	<expr><name>autovacuum_work_mem</name></expr> </then><else>: <expr><name>maintenance_work_mem</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>useindex</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>maxtuples</name> <operator>=</operator> <call><name>MAXDEADTUPLES</name><argument_list>(<argument><expr><name>vac_work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxtuples</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>maxtuples</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxtuples</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>maxtuples</name></expr></argument>, <argument><expr><call><name>MAXDEADTUPLES</name><argument_list>(<argument><expr><name>MaxAllocSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* curious coding here to ensure the multiplication can't overflow */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <operator>(</operator><name>maxtuples</name> <operator>/</operator> <name>LAZY_ALLOC_TUPLES</name><operator>)</operator> <operator>&gt;</operator> <name>relblocks</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxtuples</name> <operator>=</operator> <name>relblocks</name> <operator>*</operator> <name>LAZY_ALLOC_TUPLES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* stay sane if small maintenance_work_mem */</comment>
		<expr_stmt><expr><name>maxtuples</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxtuples</name></expr></argument>, <argument><expr><name>MaxHeapTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxtuples</name> <operator>=</operator> <name>MaxHeapTuplesPerPage</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>maxtuples</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lazy_space_alloc - space allocation decisions for lazy vacuum
 *
 * See the comments at the head of this file for rationale.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_space_alloc</name><parameter_list>(<parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>relblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>maxtuples</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>maxtuples</name> <operator>=</operator> <call><name>compute_max_dead_tuples</name><argument_list>(<argument><expr><name>relblocks</name></expr></argument>, <argument><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>useindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dead_tuples</name> <operator>=</operator> <operator>(</operator><name>LVDeadTuples</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>SizeOfDeadTuples</name><argument_list>(<argument><expr><name>maxtuples</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>max_tuples</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>maxtuples</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>dead_tuples</name></name> <operator>=</operator> <name>dead_tuples</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * lazy_record_dead_tuple - remember one deletable tuple
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lazy_record_dead_tuple</name><parameter_list>(<parameter><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The array shouldn't overflow under normal behavior, but perhaps it
	 * could if we are given a really small maintenance_work_mem. In that
	 * case, just forget the last few tuples (we'll get 'em next time).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>&lt;</operator> <name><name>dead_tuples</name><operator>-&gt;</operator><name>max_tuples</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>itemptrs</name><index>[<expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>itemptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_NUM_DEAD_TUPLES</name></expr></argument>,
									 <argument><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	lazy_tid_reaped() -- is a particular tid deletable?
 *
 *		This has the right signature to be an IndexBulkDeleteCallback.
 *
 *		Assumes dead_tuples array is in sorted order.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lazy_tid_reaped</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name> <init>= <expr><operator>(</operator><name>LVDeadTuples</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>itemptr</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>dead_tuples</name><operator>-&gt;</operator><name>itemptrs</name></name></expr></argument>,
								<argument><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name></expr></argument>,
								<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								<argument><expr><name>vac_cmp_itemptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>res</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparator routines for use with qsort() and bsearch().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>vac_cmp_itemptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lblk</name></decl>,
				<decl><type ref="prev"/><name>rblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>loff</name></decl>,
				<decl><type ref="prev"/><name>roff</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lblk</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rblk</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lblk</name> <operator>&lt;</operator> <name>rblk</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>lblk</name> <operator>&gt;</operator> <name>rblk</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>loff</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>roff</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>loff</name> <operator>&lt;</operator> <name>roff</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>loff</name> <operator>&gt;</operator> <name>roff</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if every tuple in the given page is visible to all current and future
 * transactions. Also return the visibility_cutoff_xid which is the highest
 * xmin amongst the visible tuples.  Set *all_frozen to true if every tuple
 * on this page is frozen.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heap_page_is_all_visible</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
						 <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>visibility_cutoff_xid</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>all_frozen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockno</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>visibility_cutoff_xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>all_frozen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is a stripped down version of the line pointer scan in
	 * lazy_scan_heap(). So if you change anything here, also check that code.
	 */</comment>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name> <operator>&amp;&amp;</operator> <name>all_visible</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Unused or redirect line pointers are of no interest */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ItemIdIsRedirected</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>blockno</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Dead line pointers can have index pointers pointing to them. So
		 * they can't be treated as visible
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>all_frozen</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>

					<comment type="block">/* Check comments in lazy_scan_heap. */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderXminCommitted</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>all_frozen</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * The inserter definitely committed. But is it old enough
					 * that everyone sees it as committed?
					 */</comment>
					<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>all_frozen</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Track newest xmin on page. */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><operator>*</operator><name>visibility_cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>visibility_cutoff_xid</name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Check whether this tuple is already frozen or not */</comment>
					<if_stmt><if>if <condition>(<expr><name>all_visible</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>all_frozen</name> <operator>&amp;&amp;</operator>
						<call><name>heap_tuple_needs_eventual_freeze</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>all_frozen</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>
			<case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>
			<case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>
			<case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>all_frozen</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected HeapTupleSatisfiesVacuum result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>							<comment type="block">/* scan along page */</comment>

	<return>return <expr><name>all_visible</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the number of parallel worker processes to request.  Both index
 * vacuum and index cleanup can be executed with parallel workers.  The index
 * is eligible for parallel vacuum iff its size is greater than
 * min_parallel_index_scan_size as invoking workers for very small indexes
 * can hurt performance.
 *
 * nrequested is the number of parallel workers that user requested.  If
 * nrequested is 0, we compute the parallel degree based on nindexes, that is
 * the number of indexes that support parallel vacuum.  This function also
 * sets can_parallel_vacuum to remember indexes that participate in parallel
 * vacuum.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compute_parallel_vacuum_workers</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrequested</name></decl></parameter>,
								<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_parallel_vacuum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes_parallel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes_parallel_bulkdel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes_parallel_cleanup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't allow performing parallel operation in standalone backend or
	 * when parallelism is disabled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name> <operator>||</operator> <name>max_parallel_maintenance_workers</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute the number of indexes that can participate in parallel vacuum.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>vacoptions</name> <init>= <expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_indam</name><operator>-&gt;</operator><name>amparallelvacuumoptions</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>vacoptions</name> <operator>==</operator> <name>VACUUM_OPTION_NO_PARALLEL</name> <operator>||</operator>
			<call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>min_parallel_index_scan_size</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>can_parallel_vacuum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_BULKDEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nindexes_parallel_bulkdel</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_CLEANUP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_COND_CLEANUP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nindexes_parallel_cleanup</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>nindexes_parallel</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>nindexes_parallel_bulkdel</name></expr></argument>,
							<argument><expr><name>nindexes_parallel_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The leader process takes one index */</comment>
	<expr_stmt><expr><name>nindexes_parallel</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* No index supports parallel vacuum */</comment>
	<if_stmt><if>if <condition>(<expr><name>nindexes_parallel</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Compute the parallel degree */</comment>
	<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nrequested</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
		<expr><call><name>Min</name><argument_list>(<argument><expr><name>nrequested</name></expr></argument>, <argument><expr><name>nindexes_parallel</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>nindexes_parallel</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Cap by max_parallel_maintenance_workers */</comment>
	<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>max_parallel_maintenance_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>parallel_workers</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize variables for shared index statistics, set NULL bitmap and the
 * size of stats for each index.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_index_statistics</name><parameter_list>(<parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_parallel_vacuum</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Currently, we don't support parallel vacuum for autovacuum */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set NULL for all indexes */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>lvshared</name><operator>-&gt;</operator><name>bitmap</name></name></expr></argument>, <argument><expr><literal type="number">0x00</literal></expr></argument>, <argument><expr><call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>can_parallel_vacuum</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Set NOT NULL as this index does support parallelism */</comment>
		<expr_stmt><expr><name><name>lvshared</name><operator>-&gt;</operator><name>bitmap</name><index>[<expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Update index statistics in pg_class if the statistics are accurate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_index_statistics</name><parameter_list>(<parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>estimated_count</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Update index statistics */</comment>
		<expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>num_pages</name></expr></argument>,
							<argument><expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>num_index_tuples</name></expr></argument>,
							<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><name>false</name></expr></argument>,
							<argument><expr><name>InvalidTransactionId</name></expr></argument>,
							<argument><expr><name>InvalidMultiXactId</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * This function prepares and returns parallel vacuum state if we can launch
 * even one worker.  This function is responsible for entering parallel mode,
 * create a parallel context, and then initialize the DSM segment.
 */</comment>
<function><type><specifier>static</specifier> <name>LVParallelState</name> <modifier>*</modifier></type>
<name>begin_parallel_vacuum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Relation</name> <modifier>*</modifier></type><name>Irel</name></decl></parameter>, <parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>vacrelstats</name></decl></parameter>,
					  <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrequested</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVShared</name>   <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>buffer_usage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalUsage</name>   <modifier>*</modifier></type><name>wal_usage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>can_parallel_vacuum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>maxtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>est_shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>est_deadtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes_mwm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>querylen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * A parallel vacuum must be requested and there must be indexes on the
	 * relation
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nrequested</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the number of parallel vacuum workers to launch
	 */</comment>
	<expr_stmt><expr><name>can_parallel_vacuum</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>compute_parallel_vacuum_workers</name><argument_list>(<argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>,
													   <argument><expr><name>nrequested</name></expr></argument>,
													   <argument><expr><name>can_parallel_vacuum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't perform vacuum in parallel */</comment>
	<if_stmt><if>if <condition>(<expr><name>parallel_workers</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>can_parallel_vacuum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>lps</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lps</name> <operator>=</operator> <operator>(</operator><name>LVParallelState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LVParallelState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnterParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pcxt</name> <operator>=</operator> <call><name>CreateParallelContext</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"parallel_vacuum_main"</literal></expr></argument>,
								 <argument><expr><name>parallel_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>

	<comment type="block">/* Estimate size for shared information -- PARALLEL_VACUUM_KEY_SHARED */</comment>
	<expr_stmt><expr><name>est_shared</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>add_size</name><argument_list>(<argument><expr><name>SizeOfLVShared</name></expr></argument>, <argument><expr><call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>vacoptions</name> <init>= <expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_indam</name><operator>-&gt;</operator><name>amparallelvacuumoptions</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Cleanup option should be either disabled, always performing in
		 * parallel or conditionally performing in parallel.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_CLEANUP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_COND_CLEANUP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vacoptions</name> <operator>&lt;=</operator> <name>VACUUM_OPTION_MAX_VALID_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip indexes that don't participate in parallel vacuum */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>can_parallel_vacuum</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>Irel</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_indam</name><operator>-&gt;</operator><name>amusemaintenanceworkmem</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nindexes_mwm</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>est_shared</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>est_shared</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LVSharedIndStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Remember the number of indexes that support parallel operation for
		 * each phase.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_BULKDEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>nindexes_parallel_bulkdel</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_CLEANUP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>nindexes_parallel_cleanup</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_COND_CLEANUP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>nindexes_parallel_condcleanup</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>est_shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate size for dead tuples -- PARALLEL_VACUUM_KEY_DEAD_TUPLES */</comment>
	<expr_stmt><expr><name>maxtuples</name> <operator>=</operator> <call><name>compute_max_dead_tuples</name><argument_list>(<argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>est_deadtuples</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>SizeOfDeadTuples</name><argument_list>(<argument><expr><name>maxtuples</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>est_deadtuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate space for BufferUsage and WalUsage --
	 * PARALLEL_VACUUM_KEY_BUFFER_USAGE and PARALLEL_VACUUM_KEY_WAL_USAGE.
	 *
	 * If there are no extensions loaded that care, we could skip this.  We
	 * have no way of knowing whether anyone's looking at pgBufferUsage or
	 * pgWalUsage, so do it unconditionally.
	 */</comment>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>,
						   <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>,
						   <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finally, estimate PARALLEL_VACUUM_KEY_QUERY_TEXT space */</comment>
	<if_stmt><if>if <condition>(<expr><name>debug_query_string</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>querylen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>querylen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>querylen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>			<comment type="block">/* keep compiler quiet */</comment>

	<expr_stmt><expr><call><name>InitializeParallelDSM</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare shared information */</comment>
	<expr_stmt><expr><name>shared</name> <operator>=</operator> <operator>(</operator><name>LVShared</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>est_shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>est_shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>maintenance_work_mem_worker</name></name> <operator>=</operator>
		<ternary><condition><expr><operator>(</operator><name>nindexes_mwm</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
		<expr><name>maintenance_work_mem</name> <operator>/</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>nindexes_mwm</name></expr></argument>)</argument_list></call></expr> </then><else>:
		<expr><name>maintenance_work_mem</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>cost_balance</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>active_nworkers</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>idx</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>add_size</name><argument_list>(<argument><expr><name>SizeOfLVShared</name></expr></argument>, <argument><expr><call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prepare_index_statistics</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>can_parallel_vacuum</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_VACUUM_KEY_SHARED</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name></name> <operator>=</operator> <name>shared</name></expr>;</expr_stmt>

	<comment type="block">/* Prepare the dead tuple space */</comment>
	<expr_stmt><expr><name>dead_tuples</name> <operator>=</operator> <operator>(</operator><name>LVDeadTuples</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>est_deadtuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>max_tuples</name></name> <operator>=</operator> <name>maxtuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>dead_tuples</name><operator>-&gt;</operator><name>itemptrs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxtuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_VACUUM_KEY_DEAD_TUPLES</name></expr></argument>, <argument><expr><name>dead_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>-&gt;</operator><name>dead_tuples</name></name> <operator>=</operator> <name>dead_tuples</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate space for each worker's BufferUsage and WalUsage; no need to
	 * initialize
	 */</comment>
	<expr_stmt><expr><name>buffer_usage</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
									<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_VACUUM_KEY_BUFFER_USAGE</name></expr></argument>, <argument><expr><name>buffer_usage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>buffer_usage</name></name> <operator>=</operator> <name>buffer_usage</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>wal_usage</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
								 <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_VACUUM_KEY_WAL_USAGE</name></expr></argument>, <argument><expr><name>wal_usage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lps</name><operator>-&gt;</operator><name>wal_usage</name></name> <operator>=</operator> <name>wal_usage</name></expr>;</expr_stmt>

	<comment type="block">/* Store query string for workers */</comment>
	<if_stmt><if>if <condition>(<expr><name>debug_query_string</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sharedquery</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sharedquery</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>querylen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sharedquery</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>, <argument><expr><name>querylen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sharedquery</name><index>[<expr><name>querylen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
					   <argument><expr><name>PARALLEL_VACUUM_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>sharedquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>can_parallel_vacuum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>lps</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Destroy the parallel context, and end parallel mode.
 *
 * Since writes are not allowed during parallel mode, copy the
 * updated index statistics from DSM into local memory and then later use that
 * to update the index statistics.  One might think that we can exit from
 * parallel mode, update the index statistics and then destroy parallel
 * context, but that won't be safe (see ExitParallelMode).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>end_parallel_vacuum</name><parameter_list>(<parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>LVParallelState</name> <modifier>*</modifier></type><name>lps</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the updated statistics */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LVSharedIndStats</name> <modifier>*</modifier></type><name>indstats</name> <init>= <expr><call><name>get_indstats</name><argument_list>(<argument><expr><name><name>lps</name><operator>-&gt;</operator><name>lvshared</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip unused slot.  The statistics of this index are already stored
		 * in local memory.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>indstats</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indstats</name><operator>-&gt;</operator><name>updated</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>indstats</name><operator>-&gt;</operator><name>stats</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>DestroyParallelContext</name><argument_list>(<argument><expr><name><name>lps</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExitParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deactivate parallel vacuum */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lps</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the Nth index statistics or NULL */</comment>
<function><type><specifier>static</specifier> <name>LVSharedIndStats</name> <modifier>*</modifier></type>
<name>get_indstats</name><parameter_list>(<parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IndStatsIsNull</name><argument_list>(<argument><expr><name>lvshared</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>GetSharedIndStats</name><argument_list>(<argument><expr><name>lvshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IndStatsIsNull</name><argument_list>(<argument><expr><name>lvshared</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LVSharedIndStats</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><operator>(</operator><name>LVSharedIndStats</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true, if the given index can't participate in parallel index vacuum
 * or parallel index cleanup, false, otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>skip_parallel_vacuum_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indrel</name></decl></parameter>, <parameter><decl><type><name>LVShared</name> <modifier>*</modifier></type><name>lvshared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>vacoptions</name> <init>= <expr><name><name>indrel</name><operator>-&gt;</operator><name>rd_indam</name><operator>-&gt;</operator><name>amparallelvacuumoptions</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* first_time must be true only if for_cleanup is true */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lvshared</name><operator>-&gt;</operator><name>for_cleanup</name></name> <operator>||</operator> <operator>!</operator><name><name>lvshared</name><operator>-&gt;</operator><name>first_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lvshared</name><operator>-&gt;</operator><name>for_cleanup</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Skip, if the index does not support parallel cleanup */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_CLEANUP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_COND_CLEANUP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Skip, if the index supports parallel cleanup conditionally, but we
		 * have already processed the index (for bulkdelete).  See the
		 * comments for option VACUUM_OPTION_PARALLEL_COND_CLEANUP to know
		 * when indexes support parallel cleanup conditionally.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lvshared</name><operator>-&gt;</operator><name>first_time</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_COND_CLEANUP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>vacoptions</name> <operator>&amp;</operator> <name>VACUUM_OPTION_PARALLEL_BULKDEL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Skip if the index does not support parallel bulk deletion */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform work within a launched parallel process.
 *
 * Since parallel vacuum workers perform only index vacuum or index cleanup,
 * we don't need to report progress information.
 */</comment>
<function><type><name>void</name></type>
<name>parallel_vacuum_main</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>onerel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>indrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVShared</name>   <modifier>*</modifier></type><name>lvshared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVDeadTuples</name> <modifier>*</modifier></type><name>dead_tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>buffer_usage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalUsage</name>   <modifier>*</modifier></type><name>wal_usage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sharedquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LVRelStats</name></type>	<name>vacrelstats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * A parallel vacuum worker must have only PROC_IN_VACUUM flag since we
	 * don't support parallel vacuum for autovacuum as of now.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>==</operator> <name>PROC_IN_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lvshared</name> <operator>=</operator> <operator>(</operator><name>LVShared</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_VACUUM_KEY_SHARED</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name><name>lvshared</name><operator>-&gt;</operator><name>elevel</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lvshared</name><operator>-&gt;</operator><name>for_cleanup</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"starting parallel vacuum worker for cleanup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"starting parallel vacuum worker for bulk delete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Set debug_query_string for individual workers */</comment>
	<expr_stmt><expr><name>sharedquery</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_VACUUM_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>sharedquery</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open table.  The lock mode is the same as the leader process.  It's
	 * okay because the lock mode does not conflict among the parallel
	 * workers.
	 */</comment>
	<expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>lvshared</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open all indexes. indrels are sorted in order by OID, which should be
	 * matched to the leader's one.
	 */</comment>
	<expr_stmt><expr><call><name>vac_open_indexes</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nindexes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Each parallel VACUUM worker gets its own access strategy */</comment>
	<expr_stmt><expr><name>vac_strategy</name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set dead tuple space */</comment>
	<expr_stmt><expr><name>dead_tuples</name> <operator>=</operator> <operator>(</operator><name>LVDeadTuples</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>,
												  <argument><expr><name>PARALLEL_VACUUM_KEY_DEAD_TUPLES</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set cost-based vacuum delay */</comment>
	<expr_stmt><expr><name>VacuumCostActive</name> <operator>=</operator> <operator>(</operator><name>VacuumCostDelay</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>VacuumCostBalance</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>VacuumPageHit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>VacuumPageMiss</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>VacuumPageDirty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>VacuumCostBalanceLocal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>VacuumSharedCostBalance</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lvshared</name><operator>-&gt;</operator><name>cost_balance</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>VacuumActiveNWorkers</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lvshared</name><operator>-&gt;</operator><name>active_nworkers</name></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name>nindexes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lvshared</name><operator>-&gt;</operator><name>maintenance_work_mem_worker</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maintenance_work_mem</name> <operator>=</operator> <name><name>lvshared</name><operator>-&gt;</operator><name>maintenance_work_mem_worker</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize vacrelstats for use as error callback arg by parallel
	 * worker.
	 */</comment>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>.</operator><name>relnamespace</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>.</operator><name>relname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>.</operator><name>indname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vacrelstats</name><operator>.</operator><name>phase</name></name> <operator>=</operator> <name>VACUUM_ERRCB_PHASE_UNKNOWN</name></expr>;</expr_stmt> <comment type="block">/* Not yet processing */</comment>

	<comment type="block">/* Setup error traceback support for ereport() */</comment>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>vacuum_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name>vacrelstats</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<comment type="block">/* Prepare to track buffer usage during parallel execution */</comment>
	<expr_stmt><expr><call><name>InstrStartParallelQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process indexes to perform vacuum/cleanup */</comment>
	<expr_stmt><expr><call><name>parallel_vacuum_index</name><argument_list>(<argument><expr><name>indrels</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>lvshared</name></expr></argument>, <argument><expr><name>dead_tuples</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>vacrelstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report buffer/WAL usage during parallel execution */</comment>
	<expr_stmt><expr><name>buffer_usage</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_VACUUM_KEY_BUFFER_USAGE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wal_usage</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_VACUUM_KEY_WAL_USAGE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InstrEndParallelQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer_usage</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>wal_usage</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vac_close_indexes</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>indrels</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeAccessStrategy</name><argument_list>(<argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error context callback for errors occurring during vacuum.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuum_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>errinfo</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>errinfo</name><operator>-&gt;</operator><name>phase</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>VACUUM_ERRCB_PHASE_SCAN_HEAP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while scanning block %u of relation \"%s.%s\""</literal></expr></argument>,
						   <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while scanning relation \"%s.%s\""</literal></expr></argument>,
						   <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>VACUUM_ERRCB_PHASE_VACUUM_HEAP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while vacuuming block %u of relation \"%s.%s\""</literal></expr></argument>,
						   <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while vacuuming relation \"%s.%s\""</literal></expr></argument>,
						   <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>VACUUM_ERRCB_PHASE_VACUUM_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while vacuuming index \"%s\" of relation \"%s.%s\""</literal></expr></argument>,
					   <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>indname</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>VACUUM_ERRCB_PHASE_INDEX_CLEANUP</name></expr>:</case>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while cleaning up index \"%s\" of relation \"%s.%s\""</literal></expr></argument>,
					   <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>indname</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>VACUUM_ERRCB_PHASE_TRUNCATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while truncating relation \"%s.%s\" to %u blocks"</literal></expr></argument>,
						   <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>errinfo</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>VACUUM_ERRCB_PHASE_UNKNOWN</name></expr>:</case>
		<default>default:</default>
			<return>return;</return>				<comment type="block">/* do nothing; the errinfo may not be
								 * initialized */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Updates the information required for vacuum error callback.  This also saves
 * the current information which can be later restored via restore_vacuum_error_info.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_vacuum_error_info</name><parameter_list>(<parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>errinfo</name></decl></parameter>, <parameter><decl><type><name>LVSavedErrInfo</name> <modifier>*</modifier></type><name>saved_err_info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>phase</name></decl></parameter>,
						 <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>saved_err_info</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>saved_err_info</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name><name>errinfo</name><operator>-&gt;</operator><name>blkno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>saved_err_info</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <name><name>errinfo</name><operator>-&gt;</operator><name>phase</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>errinfo</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errinfo</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <name>phase</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Restores the vacuum information saved via a prior call to update_vacuum_error_info.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restore_vacuum_error_info</name><parameter_list>(<parameter><decl><type><name>LVRelStats</name> <modifier>*</modifier></type><name>errinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LVSavedErrInfo</name> <modifier>*</modifier></type><name>saved_err_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>errinfo</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name><name>saved_err_info</name><operator>-&gt;</operator><name>blkno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errinfo</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <name><name>saved_err_info</name><operator>-&gt;</operator><name>phase</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
