<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/index/genam.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * genam.c
 *	  general index access method routines
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/index/genam.c
 *
 * NOTES
 *	  many of the old access method routines have been turned into
 *	  macros and moved to genam.h -cim 4/30/91
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/* ----------------------------------------------------------------
 *		general access method routines
 *
 *		All indexed access methods use an identical scan structure.
 *		We don't know how the various AMs do locking, however, so we don't
 *		do anything about that here.
 *
 *		The intent is that an AM implementor will define a beginscan routine
 *		that calls RelationGetIndexScan, to fill in the scan, and then does
 *		whatever kind of locking he wants.
 *
 *		At the end of a scan, the AM's endscan routine undoes the locking,
 *		but does *not* call IndexScanEnd --- the higher-level index_endscan
 *		routine does that.  (We can't do it in the AM because index_endscan
 *		still needs to touch the IndexScanDesc after calling the AM.)
 *
 *		Because of this, the AM does not have a choice whether to call
 *		RelationGetIndexScan or not; its beginscan routine must return an
 *		object made by RelationGetIndexScan.  This is kinda ugly but not
 *		worth cleaning up now.
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *	RelationGetIndexScan -- Create and fill an IndexScanDesc.
 *
 *		This routine creates an index scan structure and sets up initial
 *		contents for it.
 *
 *		Parameters:
 *				indexRelation -- index relation for scan.
 *				nkeys -- count of scan keys (index qual conditions).
 *				norderbys -- count of index order-by operators.
 *
 *		Returns:
 *				An initialized IndexScanDesc.
 * ----------------
 */</comment>
<function><type><name>IndexScanDesc</name></type>
<name>RelationGetIndexScan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <operator>(</operator><name>IndexScanDesc</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* may be set later */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_heapfetch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name> <operator>=</operator> <name>indexRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name> <operator>=</operator> <name>InvalidSnapshot</name></expr>;</expr_stmt>	<comment type="block">/* caller must initialize this */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>=</operator> <name>norderbys</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We allocate key workspace here, but it won't get filled until amrescan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nkeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>norderbys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>orderByData</name></name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>norderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>orderByData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* may be set later */</comment>

	<comment type="block">/*
	 * During recovery we ignore killed tuples and don't bother to kill them
	 * either. We do this because the xmin on the primary node could easily be
	 * later than the xmin on the standby node, so that what the primary
	 * thinks is killed is supposed to be visible on standby. So for correct
	 * MVCC for queries during recovery we must ignore these hints and check
	 * all tuples. Do *not* set ignore_killed_tuples to true when running in a
	 * transaction that was started during recovery. xactStartedInRecovery
	 * should not be altered by index AMs.
	 */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>kill_prior_tuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xactStartedInRecovery</name></name> <operator>=</operator> <call><name>TransactionStartedDuringRecovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>ignore_killed_tuples</name></name> <operator>=</operator> <operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>xactStartedInRecovery</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_itup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_itupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *	IndexScanEnd -- End an index scan.
 *
 *		This routine just releases the storage acquired by
 *		RelationGetIndexScan().  Any AM-level resources are
 *		assumed to already have been released by the AM's
 *		endscan routine.
 *
 *	Returns:
 *		None.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>IndexScanEnd</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>orderByData</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>orderByData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BuildIndexValueDescription
 *
 * Construct a string describing the contents of an index entry, in the
 * form "(key_name, ...)=(key_value, ...)".  This is currently used
 * for building unique-constraint and exclusion-constraint error messages,
 * so only key columns of the index are checked and printed.
 *
 * Note that if the user does not have permissions to view all of the
 * columns involved then a NULL is returned.  Returning a partial key seems
 * unlikely to be useful and we have no way to know which of the columns the
 * user provided (unlike in ExecBuildSlotValueDescription).
 *
 * The passed-in values/nulls arrays are the "raw" input to the index AM,
 * e.g. results of FormIndexDatum --- this is not necessarily what is stored
 * in the index, but it's what the user perceives to be stored.
 *
 * Note: if you change anything here, check whether
 * ExecBuildSlotPartitionKeyDescription() in execMain.c needs a similar
 * change.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>BuildIndexValueDescription</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>idxrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexrelid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indnkeyatts</name> <operator>=</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check permissions- if the user does not have access to view all of the
	 * key columns then return NULL to avoid leaking data.
	 *
	 * First check if RLS is enabled for the relation.  If so, return NULL to
	 * avoid leaking data.
	 *
	 * Next we need to check table-level SELECT access and then, if there is
	 * no access there, check column-level permissions.
	 */</comment>
	<expr_stmt><expr><name>idxrec</name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>indrelid</name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexrelid</name> <operator>==</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* RLS check- if RLS is enabled then we don't return anything. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Table-level SELECT is enough, if the user has it */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No table-level access, so step through the columns in the index and
		 * make sure the user has SELECT rights on all of them.
		 */</comment>
		<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name>indnkeyatts</name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>idxrec</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Note that if attnum == InvalidAttrNumber, then this is an index
			 * based on an expression and we return no detail rather than try
			 * to figure out what column(s) the expression includes and if the
			 * user has SELECT rights on them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name> <operator>||</operator>
				<call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* No access, so clean up and return */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s)=("</literal></expr></argument>,
					 <argument><expr><call><name>pg_get_indexdef_columns</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indnkeyatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>foutoid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * The provided data is not necessarily of the type stored in the
			 * index; rather it is of the index opclass's input type. So look
			 * at rd_opcintype not the index tupdesc.
			 *
			 * Note: this is a bit shaky for opclasses that have pseudotype
			 * input types such as ANYARRAY or RECORD.  Currently, the
			 * typoutput functions associated with the pseudotypes will work
			 * okay, but we might have to try harder in future.
			 */</comment>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>foutoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>foutoid</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the latestRemovedXid from the table entries pointed at by the index
 * tuples being deleted.
 *
 * Note: index access methods that don't consistently use the standard
 * IndexTuple + heap TID item pointer representation will need to provide
 * their own version of this function.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>index_compute_xid_horizon_for_tuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>irel</name></decl></parameter>,
									 <parameter><decl><type><name>Relation</name></type> <name>hrel</name></decl></parameter>,
									 <parameter><decl><type><name>Buffer</name></type> <name>ibuf</name></decl></parameter>,
									 <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>itemnos</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>ttids</name> <init>=
	<expr><operator>(</operator><name>ItemPointerData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nitems</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>ipage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>ibuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

	<comment type="block">/* identify what the index tuples about to be deleted point to */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>iitemid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>iitemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>ipage</name></expr></argument>, <argument><expr><name><name>itemnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>ipage</name></expr></argument>, <argument><expr><name>iitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ttids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* determine the actual xid horizon */</comment>
	<expr_stmt><expr><name>latestRemovedXid</name> <operator>=</operator>
		<call><name>table_compute_xid_horizon_for_tuples</name><argument_list>(<argument><expr><name>hrel</name></expr></argument>, <argument><expr><name>ttids</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ttids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>latestRemovedXid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		heap-or-index-scan access to system catalogs
 *
 *		These functions support system catalog accesses that normally use
 *		an index but need to be capable of being switched to heap scans
 *		if the system indexes are unavailable.
 *
 *		The specified scan keys must be compatible with the named index.
 *		Generally this means that they must constrain either all columns
 *		of the index, or the first K columns of an N-column index.
 *
 *		These routines could work with non-system tables, actually,
 *		but they're only useful when there is a known index to use with
 *		the given scan keys; so in practice they're only good for
 *		predetermined types of scans of system catalogs.
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * systable_beginscan --- set up for heap-or-index scan
 *
 *	rel: catalog to scan, already opened and suitably locked
 *	indexId: OID of index to conditionally use
 *	indexOK: if false, forces a heap scan (see notes below)
 *	snapshot: time qual to use (NULL for a recent catalog snapshot)
 *	nkeys, key: scan keys
 *
 * The attribute numbers in the scan key should be set for the heap case.
 * If we choose to index, we reset them to 1..n to reference the index
 * columns.  Note this means there must be one scankey qualification per
 * index column!  This is checked by the Asserts in the normal, index-using
 * case, but won't be checked if the heapscan path is taken.
 *
 * The routine checks the normal cases for whether an indexscan is safe,
 * but caller can make additional checks and pass indexOK=false if needed.
 * In standard case indexOK can simply be constant TRUE.
 */</comment>
<function><type><name>SysScanDesc</name></type>
<name>systable_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>indexOK</name></decl></parameter>,
				   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sysscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>irel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>indexOK</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>IgnoreSystemIndexes</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>ReindexIsProcessingIndex</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>irel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>irel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>sysscan</name> <operator>=</operator> <operator>(</operator><name>SysScanDesc</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SysScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>heap_rel</name></name> <operator>=</operator> <name>heapRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>irel</name></name> <operator>=</operator> <name>irel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Caller is responsible for any snapshot. */</comment>
		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>irel</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Change attribute numbers to be index column numbers. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>irel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>==</operator> <name><name>irel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>irel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column is not in index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name></name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>irel</name></expr></argument>,
										 <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>scan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We disallow synchronized scans when forced to use a heapscan on a
		 * catalog.  In most cases the desired rows are near the front, so
		 * that the unpredictable start point of a syncscan is a serious
		 * disadvantage; and there are no compensating advantages, because
		 * it's unlikely that such scans will occur in parallel.
		 */</comment>
		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>scan</name></name> <operator>=</operator> <call><name>table_beginscan_strat</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
											  <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>sysscan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * systable_getnext --- get next tuple in a heap-or-index scan
 *
 * Returns NULL if no more tuples available.
 *
 * Note that returned tuple is a reference to data in a disk buffer;
 * it must not be modified, and should be presumed inaccessible after
 * next getnext() or endscan() call.
 *
 * XXX: It'd probably make sense to offer a slot based interface, at least
 * optionally.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>systable_getnext</name><parameter_list>(<parameter><decl><type><name>SysScanDesc</name></type> <name>sysscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sysscan</name><operator>-&gt;</operator><name>irel</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>index_getnext_slot</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name></name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We currently don't need to support lossy index operators for
			 * any system catalog scan.  It could be done here, using the scan
			 * keys to drive the operator calls, if we arranged to save the
			 * heap attnums during systable_beginscan(); this is practical
			 * because we still wouldn't need to support indexes on
			 * expressions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"system catalog scans with lossy index conditions are not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>htup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * systable_recheck_tuple --- recheck visibility of most-recently-fetched tuple
 *
 * In particular, determine if this tuple would be visible to a catalog scan
 * that started now.  We don't handle the case of a non-MVCC scan snapshot,
 * because no caller needs that yet.
 *
 * This is useful to test whether an object was deleted while we waited to
 * acquire lock on it.
 *
 * Note: we don't actually *need* the tuple to be passed in, but it's a
 * good crosscheck that the caller is interested in the right tuple.
 */</comment>
<function><type><name>bool</name></type>
<name>systable_recheck_tuple</name><parameter_list>(<parameter><decl><type><name>SysScanDesc</name></type> <name>sysscan</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>freshsnap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tup</name> <operator>==</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Trust that table_tuple_satisfies_snapshot() and its subsidiaries
	 * (commonly LockBuffer() and HeapTupleSatisfiesMVCC()) do not themselves
	 * acquire snapshots, so we need not register the snapshot.  Those
	 * facilities are too low-level to have any business scanning tables.
	 */</comment>
	<expr_stmt><expr><name>freshsnap</name> <operator>=</operator> <call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>heap_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_satisfies_snapshot</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>heap_rel</name></name></expr></argument>,
											<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>,
											<argument><expr><name>freshsnap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * systable_endscan --- close scan, release resources
 *
 * Note that it's still up to the caller to close the heap relation.
 */</comment>
<function><type><name>void</name></type>
<name>systable_endscan</name><parameter_list>(<parameter><decl><type><name>SysScanDesc</name></type> <name>sysscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sysscan</name><operator>-&gt;</operator><name>irel</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>irel</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sysscan</name><operator>-&gt;</operator><name>snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sysscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * systable_beginscan_ordered --- set up for ordered catalog scan
 *
 * These routines have essentially the same API as systable_beginscan etc,
 * except that they guarantee to return multiple matching tuples in
 * index order.  Also, for largely historical reasons, the index to use
 * is opened and locked by the caller, not here.
 *
 * Currently we do not support non-index-based scans here.  (In principle
 * we could do a heapscan and sort, but the uses are in places that
 * probably don't need to still work with corrupted catalog indexes.)
 * For the moment, therefore, these functions are merely the thinnest of
 * wrappers around index_beginscan/index_getnext_slot.  The main reason for
 * their existence is to centralize possible future support of lossy operators
 * in catalog scans.
 */</comment>
<function><type><name>SysScanDesc</name></type>
<name>systable_beginscan_ordered</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sysscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* REINDEX can probably be a hard error here ... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ReindexIsProcessingIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot do ordered scan on index \"%s\", because it is being reindexed"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* ... but we only throw a warning about violating IgnoreSystemIndexes */</comment>
	<if_stmt><if>if <condition>(<expr><name>IgnoreSystemIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"using index \"%s\" despite IgnoreSystemIndexes"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sysscan</name> <operator>=</operator> <operator>(</operator><name>SysScanDesc</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SysScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>heap_rel</name></name> <operator>=</operator> <name>heapRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>irel</name></name> <operator>=</operator> <name>indexRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Caller is responsible for any snapshot. */</comment>
		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Change attribute numbers to be index column numbers. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>==</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column is not in index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name></name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>indexRelation</name></expr></argument>,
									 <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>scan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>sysscan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * systable_getnext_ordered --- get next tuple in an ordered catalog scan
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>systable_getnext_ordered</name><parameter_list>(<parameter><decl><type><name>SysScanDesc</name></type> <name>sysscan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>irel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>index_getnext_slot</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name></name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* See notes in systable_getnext */</comment>
	<if_stmt><if>if <condition>(<expr><name>htup</name> <operator>&amp;&amp;</operator> <name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"system catalog scans with lossy index conditions are not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>htup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * systable_endscan_ordered --- close scan, release resources
 */</comment>
<function><type><name>void</name></type>
<name>systable_endscan_ordered</name><parameter_list>(<parameter><decl><type><name>SysScanDesc</name></type> <name>sysscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sysscan</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>irel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>iscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sysscan</name><operator>-&gt;</operator><name>snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>sysscan</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sysscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
