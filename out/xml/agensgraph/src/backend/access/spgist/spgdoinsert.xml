<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/spgist/spgdoinsert.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * spgdoinsert.c
 *	  implementation of insert algorithm
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/spgist/spgdoinsert.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/*
 * SPPageDesc tracks all info about a page we are inserting into.  In some
 * situations it actually identifies a tuple, or even a specific node within
 * an inner tuple.  But any of the fields can be invalid.  If the buffer
 * field is valid, it implies we hold pin and exclusive lock on that buffer.
 * page pointer should be valid exactly when buffer is.
 */</comment>
<typedef>typedef <type><struct>struct <name>SPPageDesc</name>
<block>{
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>			<comment type="block">/* block number, or InvalidBlockNumber */</comment>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>			<comment type="block">/* page's buffer number, or InvalidBuffer */</comment>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>			<comment type="block">/* pointer to page buffer, or NULL */</comment>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>		<comment type="block">/* offset of tuple, or InvalidOffsetNumber */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>node</name></decl>;</decl_stmt>			<comment type="block">/* node number within inner tuple, or -1 */</comment>
}</block></struct></type> <name>SPPageDesc</name>;</typedef>


<comment type="block">/*
 * Set the item pointer in the nodeN'th entry in inner tuple tup.  This
 * is used to update the parent inner tuple's downlink after a move or
 * split operation.
 */</comment>
<function><type><name>void</name></type>
<name>spgUpdateNodeLink</name><parameter_list>(<parameter><decl><type><name>SpGistInnerTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeN</name></decl></parameter>,
				  <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name></decl>;</decl_stmt>

	<macro><name>SGITITERATE</name><argument_list>(<argument>tup</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>nodeN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find requested node %d in SPGiST inner tuple"</literal></expr></argument>,
		 <argument><expr><name>nodeN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Form a new inner tuple containing one more node than the given one, with
 * the specified label datum, inserted at offset "offset" in the node array.
 * The new tuple's prefix is the same as the old one's.
 *
 * Note that the new node initially has an invalid downlink.  We'll find a
 * page to point it to later.
 */</comment>
<function><type><specifier>static</specifier> <name>SpGistInnerTuple</name></type>
<name>addNode</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SpGistInnerTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>label</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* if offset is negative, insert at end */</comment>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>tuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid offset for adding node to SPGiST inner tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistNodeTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>SGITITERATE</name><argument_list>(<argument>tuple</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nodes</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>nodes</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <call><name>spgFormNodeTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>spgFormInnerTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
							 <argument><expr><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>,
							 <argument><expr><call><name>SGITDATUM</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* qsort comparator for sorting OffsetNumbers */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmpOffsetNumbers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>a</name> <operator>==</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>a</name> <operator>&gt;</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete multiple tuples from an index page, preserving tuple offset numbers.
 *
 * The first tuple in the given list is replaced with a dead tuple of type
 * "firststate" (REDIRECT/DEAD/PLACEHOLDER); the remaining tuples are replaced
 * with dead tuples of type "reststate".  If either firststate or reststate
 * is REDIRECT, blkno/offnum specify where to link to.
 *
 * NB: this is used during WAL replay, so beware of trying to make it too
 * smart.  In particular, it shouldn't use "state" except for calling
 * spgFormDeadTuple().  This is also used in a critical section, so no
 * pallocs either!
 */</comment>
<function><type><name>void</name></type>
<name>spgPageIndexMultiDelete</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
						<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>itemnos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>firststate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reststate</name></decl></parameter>,
						<parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>firstItem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>sortednos</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<comment type="block">/*
	 * For efficiency we want to use PageIndexMultiDelete, which requires the
	 * targets to be listed in sorted order, so we have to sort the itemnos
	 * array.  (This also greatly simplifies the math for reinserting the
	 * replacement tuples.)  However, we must not scribble on the caller's
	 * array, so we have to make a copy.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sortednos</name></expr></argument>, <argument><expr><name>itemnos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sortednos</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmpOffsetNumbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>sortednos</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstItem</name> <operator>=</operator> <name><name>itemnos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>itemno</name> <init>= <expr><name><name>sortednos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tupstate</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tupstate</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>itemno</name> <operator>==</operator> <name>firstItem</name><operator>)</operator></expr> ?</condition><then> <expr><name>firststate</name></expr> </then><else>: <expr><name>reststate</name></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>tuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>!=</operator> <name>tupstate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>spgFormDeadTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tupstate</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>tuple</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
						<argument><expr><name>itemno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>itemno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
				 <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>tupstate</name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nRedirection</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>tupstate</name> <operator>==</operator> <name>SPGIST_PLACEHOLDER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nPlaceholder</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Update the parent inner tuple's downlink, and mark the parent buffer
 * dirty (this must be the last change to the parent page in the current
 * WAL action).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>saveNodeLink</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
			 <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
												<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a leaf tuple to a leaf page where there is known to be room for it
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addLeafTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SpGistLeafTuple</name></type> <name>leafTuple</name></decl></parameter>,
			 <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNew</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>spgxlogAddLeaf</name></type> <name>xlrec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>newPage</name></name> <operator>=</operator> <name>isNew</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>storesNulls</name></name> <operator>=</operator> <name>isNulls</name></expr>;</expr_stmt>

	<comment type="block">/* these will be filled below as needed */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumLeaf</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumHeadLeaf</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nodeI</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name> <operator>==</operator> <name>InvalidOffsetNumber</name> <operator>||</operator>
		<call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Tuple is not part of a chain */</comment>
		<expr_stmt><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name> <operator>=</operator> <call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
											   <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumLeaf</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>

		<comment type="block">/* Must update parent's downlink if any */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nodeI</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>saveNodeLink</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Tuple must be inserted into existing chain.  We mustn't change the
		 * chain's head address, but we don't need to chase the entire chain
		 * to put the tuple at the end; we can insert it second.
		 *
		 * Also, it's possible that the "chain" consists only of a DEAD tuple,
		 * in which case we should replace the DEAD tuple in-place.
		 */</comment>
		<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>head</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>head</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
											 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>head</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * re-get head of list because it could have been moved on page,
			 * and set new second element
			 */</comment>
			<expr_stmt><expr><name>head</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
												 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumLeaf</name></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumHeadLeaf</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>head</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_DEAD</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
							<argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
							<argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
					 <argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* WAL replay distinguishes this case by equal offnums */</comment>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumLeaf</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumHeadLeaf</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>, <argument><expr><name><name>head</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlrec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>newPage</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REGBUF_WILL_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SPGIST_ID</name></expr></argument>, <argument><expr><name>XLOG_SPGIST_ADD_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* update parent only if we actually changed it */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Count the number and total size of leaf tuples in the chain starting at
 * current-&gt;offnum.  Return number into *nToSplit and total size as function
 * result.
 *
 * Klugy special case when considering the root page (i.e., root is a leaf
 * page, but we're about to split for the first time): return fake large
 * values to force spgdoinsert() to take the doPickSplit rather than
 * moveLeafs code path.  moveLeafs is not prepared to deal with root page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>checkSplitConditions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					 <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nToSplit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>totalSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* return impossible values to force split */</comment>
		<expr_stmt><expr><operator>*</operator><name>nToSplit</name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
		<return>return <expr><name>BLCKSZ</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>it</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator>
			   <name>i</name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>it</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
										   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>totalSize</name> <operator>+=</operator> <name><name>it</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_DEAD</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We could see a DEAD tuple as first/only chain item */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Don't count it in result, because it won't go to other page */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>nToSplit</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

	<return>return <expr><name>totalSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * current points to a leaf-tuple chain that we wanted to add newLeafTuple to,
 * but the chain has to be moved because there's not enough room to add
 * newLeafTuple to its page.  We use this method when the chain contains
 * very little data so a split would be inefficient.  We are sure we can
 * fit the chain plus newLeafTuple on one other page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>moveLeafs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
		  <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
		  <parameter><decl><type><name>SpGistLeafTuple</name></type> <name>newLeafTuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>nDelete</name></decl>,
				<decl><type ref="prev"/><name>nInsert</name></decl>,
				<decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>nbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>npage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>r</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>,
				<decl><type ref="prev"/><name>startOffset</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replaceDead</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogMoveLeafs</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>leafdata</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>leafptr</name></decl>;</decl_stmt>

	<comment type="block">/* This doesn't work on root page */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Locate the tuples to be moved, and count up the space needed */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>toInsert</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>newLeafTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>nDelete</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>it</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator>
			   <name>i</name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>it</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
										   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>toDelete</name><index>[<expr><name>nDelete</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>it</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>nDelete</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_DEAD</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We could see a DEAD tuple as first/only chain item */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We don't want to move it, so don't count it in size */</comment>
			<expr_stmt><expr><name><name>toDelete</name><index>[<expr><name>nDelete</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nDelete</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>replaceDead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Find a leaf page that will hold them */</comment>
	<expr_stmt><expr><name>nbuf</name> <operator>=</operator> <call><name>SpGistGetBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>GBUF_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>isNulls</name></expr> ?</condition><then> <expr><name>GBUF_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						   <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>xlrec</name><operator>.</operator><name>newPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>npage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nblkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nblkno</name> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>leafdata</name> <operator>=</operator> <name>leafptr</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy all the old tuples to new page, unless they're dead */</comment>
	<expr_stmt><expr><name>nInsert</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replaceDead</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nDelete</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>it</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
											   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>toDelete</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Update chain link (notice the chain order gets reversed, but we
			 * don't care).  We're modifying the tuple on the source page
			 * here, but it's okay since we're about to delete it.
			 */</comment>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>npage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>it</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>startOffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>toInsert</name><index>[<expr><name>nInsert</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nInsert</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* save modified tuple into leafdata as well */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>leafptr</name></expr></argument>, <argument><expr><name>it</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>leafptr</name> <operator>+=</operator> <name><name>it</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* add the new tuple as well */</comment>
	<expr_stmt><expr><name><name>newLeafTuple</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>npage</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>newLeafTuple</name></expr></argument>, <argument><expr><name><name>newLeafTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>startOffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>toInsert</name><index>[<expr><name>nInsert</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nInsert</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>leafptr</name></expr></argument>, <argument><expr><name>newLeafTuple</name></expr></argument>, <argument><expr><name><name>newLeafTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafptr</name> <operator>+=</operator> <name><name>newLeafTuple</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now delete the old tuples, leaving a redirection pointer behind for the
	 * first one, unless we're doing an index build; in which case there can't
	 * be any concurrent scan so we need not provide a redirect.
	 */</comment>
	<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name>nDelete</name></expr></argument>,
							<argument><expr><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr> ?</condition><then> <expr><name>SPGIST_PLACEHOLDER</name></expr> </then><else>: <expr><name>SPGIST_REDIRECT</name></expr></else></ternary></expr></argument>,
							<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
							<argument><expr><name>nblkno</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update parent's downlink and mark parent page dirty */</comment>
	<expr_stmt><expr><call><name>saveNodeLink</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>nblkno</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the leaf pages too */</comment>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<comment type="block">/* prepare WAL info */</comment>
		<expr_stmt><expr><call><name>STORE_STATE</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nMoves</name></name> <operator>=</operator> <name>nDelete</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>replaceDead</name></name> <operator>=</operator> <name>replaceDead</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>storesNulls</name></name> <operator>=</operator> <name>isNulls</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nodeI</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfSpgxlogMoveLeafs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>toDelete</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>toInsert</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>leafdata</name></expr></argument>, <argument><expr><name>leafptr</name> <operator>-</operator> <name>leafdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>xlrec</name><operator>.</operator><name>newPage</name></name></expr> ?</condition><then> <expr><name>REGBUF_WILL_INIT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SPGIST_ID</name></expr></argument>, <argument><expr><name>XLOG_SPGIST_MOVE_LEAFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>npage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update local free-space cache and release new buffer */</comment>
	<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update previously-created redirection tuple with appropriate destination
 *
 * We use this when it's not convenient to know the destination first.
 * The tuple should have been made with the "impossible" destination of
 * the metapage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setRedirectionTuple</name><parameter_list>(<parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>position</name></decl></parameter>,
					<parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>dt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt</name> <operator>=</operator> <operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
									   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>position</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dt</name><operator>-&gt;</operator><name>pointer</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SPGIST_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dt</name><operator>-&gt;</operator><name>pointer</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test to see if the user-defined picksplit function failed to do its job,
 * ie, it put all the leaf tuples into the same node.
 * If so, randomly divide the tuples into several nodes (all with the same
 * label) and return true to select allTheSame mode for this inner tuple.
 *
 * (This code is also used to forcibly select allTheSame mode for nulls.)
 *
 * If we know that the leaf tuples wouldn't all fit on one page, then we
 * exclude the last tuple (which is the incoming new tuple that forced a split)
 * from the check to see if more than one node is used.  The reason for this
 * is that if the existing tuples are put into only one chain, then even if
 * we move them all to an empty page, there would still not be room for the
 * new tuple, so we'd get into an infinite loop of picksplit attempts.
 * Forcing allTheSame mode dodges this problem by ensuring the old tuples will
 * be split across pages.  (Exercise for the reader: figure out why this
 * fixes the problem even when there is only one old tuple.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkAllTheSame</name><parameter_list>(<parameter><decl><type><name>spgPickSplitIn</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>spgPickSplitOut</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tooBig</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>includeNew</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>theNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>limit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* For the moment, assume we can include the new leaf tuple */</comment>
	<expr_stmt><expr><operator>*</operator><name>includeNew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* If there's only the new leaf tuple, don't select allTheSame mode */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If tuple set doesn't fit on one page, ignore the new tuple in test */</comment>
	<expr_stmt><expr><name>limit</name> <operator>=</operator> <ternary><condition><expr><name>tooBig</name></expr> ?</condition><then> <expr><name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Check to see if more than one node is populated */</comment>
	<expr_stmt><expr><name>theNode</name> <operator>=</operator> <name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>limit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>theNode</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Nope, so override the picksplit function's decisions */</comment>

	<comment type="block">/* If the new tuple is in its own node, it can't be included in split */</comment>
	<if_stmt><if>if <condition>(<expr><name>tooBig</name> <operator>&amp;&amp;</operator> <name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name><index>[<expr><name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>theNode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>includeNew</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>			<comment type="block">/* arbitrary number of child nodes */</comment>

	<comment type="block">/* Random assignment of tuples to nodes (note we include new tuple) */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>%</operator> <name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* The opclass may not use node labels, but if it does, duplicate 'em */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>-&gt;</operator><name>nodeLabels</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>theLabel</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>nodeLabels</name><index>[<expr><name>theNode</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeLabels</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeLabels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>theLabel</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We don't touch the prefix or the leaf tuple datum assignments */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * current points to a leaf-tuple chain that we wanted to add newLeafTuple to,
 * but the chain has to be split because there's not enough room to add
 * newLeafTuple to its page.
 *
 * This function splits the leaf tuple set according to picksplit's rules,
 * creating one or more new chains that are spread across the current page
 * and an additional leaf page (we assume that two leaf pages will be
 * sufficient).  A new inner tuple is created, and the parent downlink
 * pointer is updated to point to that inner tuple instead of the leaf chain.
 *
 * On exit, current contains the address of the new inner tuple.
 *
 * Returns true if we successfully inserted newLeafTuple during this function,
 * false if caller still has to do it (meaning another picksplit operation is
 * probably needed).  Failure could occur if the picksplit result is fairly
 * unbalanced, or if newLeafTuple is just plain too big to fit on a page.
 * Because we force the picksplit result to be at least two chains, each
 * cycle will get rid of at least one leaf tuple from the chain, so the loop
 * will eventually terminate if lack of balance is the issue.  If the tuple
 * is too big, we assume that repeated picksplit operations will eventually
 * make it small enough by repeated prefix-stripping.  A broken opclass could
 * make this an infinite loop, though, so spgdoinsert() checks that the
 * leaf datums get smaller each time.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>doPickSplit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
			<parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
			<parameter><decl><type><name>SpGistLeafTuple</name></type> <name>newLeafTuple</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNew</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>insertedNew</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgPickSplitIn</name></type> <name>in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgPickSplitOut</name></type> <name>out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>includeNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>max</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>newInnerBuffer</name></decl>,
				<decl><type ref="prev"/><name>newLeafBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>heapPtrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>leafPageSelect</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>leafSizes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>redirectTuplePos</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>startOffsets</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistLeafTuple</name> <modifier>*</modifier></type><name>newLeafs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spaceToDelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentFreeSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalLeafSizes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allTheSame</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogPickSplit</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>leafdata</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>leafptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPPageDesc</name></type>	<name>saveCurrent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nToDelete</name></decl>,
				<decl><type ref="prev"/><name>nToInsert</name></decl>,
				<decl><type ref="prev"/><name>maxToInclude</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>in</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate per-leaf-tuple work arrays with max possible size
	 */</comment>
	<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name>max</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>.</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>heapPtrs</name> <operator>=</operator> <operator>(</operator><name>ItemPointerData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>toInsert</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newLeafs</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistLeafTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafPageSelect</name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STORE_STATE</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Form list of leaf tuples which will be distributed as split result;
	 * also, count up the amount of space that will be freed from current.
	 * (Note that in the non-root case, we won't actually delete the old
	 * tuples, only replace them with redirects or placeholders.)
	 *
	 * Note: the SGLTDATUM calls here are safe even when dealing with a nulls
	 * page.  For a pass-by-value data type we will fetch a word that must
	 * exist even though it may contain garbage (because of the fact that leaf
	 * tuples must have size at least SGDTSIZE).  For a pass-by-reference type
	 * we are just computing a pointer that isn't going to get dereferenced.
	 * So it's not worth guarding the calls with isNulls checks.
	 */</comment>
	<expr_stmt><expr><name>nToInsert</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nToDelete</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>spaceToDelete</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We are splitting the root (which up to now is also a leaf page).
		 * Its tuples are not linked, so scan sequentially to get them all. We
		 * ignore the original value of current-&gt;offnum.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>it</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>it</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
											   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>in</name><operator>.</operator><name>datums</name><index>[<expr><name>nToInsert</name></expr>]</index></name> <operator>=</operator> <call><name>SGLTDATUM</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>heapPtrs</name><index>[<expr><name>nToInsert</name></expr>]</index></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>heapPtr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nToInsert</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toDelete</name><index>[<expr><name>nToDelete</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nToDelete</name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* we will delete the tuple altogether, so count full space */</comment>
				<expr_stmt><expr><name>spaceToDelete</name> <operator>+=</operator> <name><name>it</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>				<comment type="block">/* tuples on root should be live */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Normal case, just collect the leaf tuples in the chain */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>it</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;=</operator> <name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>it</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
											   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>in</name><operator>.</operator><name>datums</name><index>[<expr><name>nToInsert</name></expr>]</index></name> <operator>=</operator> <call><name>SGLTDATUM</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>heapPtrs</name><index>[<expr><name>nToInsert</name></expr>]</index></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>heapPtr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nToInsert</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toDelete</name><index>[<expr><name>nToDelete</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nToDelete</name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* we will not delete the tuple, only replace with dead */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <name>SGDTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>spaceToDelete</name> <operator>+=</operator> <name><name>it</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>SGDTSIZE</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_DEAD</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We could see a DEAD tuple as first/only chain item */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toDelete</name><index>[<expr><name>nToDelete</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nToDelete</name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* replacing it with redirect will save no space */</comment>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>in</name><operator>.</operator><name>nTuples</name></name> <operator>=</operator> <name>nToInsert</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We may not actually insert new tuple because another picksplit may be
	 * necessary due to too large value, but we will try to allocate enough
	 * space to include it; and in any case it has to be included in the input
	 * for the picksplit function.  So don't increment nToInsert yet.
	 */</comment>
	<expr_stmt><expr><name><name>in</name><operator>.</operator><name>datums</name><index>[<expr><name><name>in</name><operator>.</operator><name>nTuples</name></name></expr>]</index></name> <operator>=</operator> <call><name>SGLTDATUM</name><argument_list>(<argument><expr><name>newLeafTuple</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>heapPtrs</name><index>[<expr><name><name>in</name><operator>.</operator><name>nTuples</name></name></expr>]</index></name> <operator>=</operator> <name><name>newLeafTuple</name><operator>-&gt;</operator><name>heapPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>.</operator><name>nTuples</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNulls</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Perform split using user-defined method.
		 */</comment>
		<expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_PICKSPLIT_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>procinfo</name></expr></argument>,
						  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Form new leaf tuples and count up the total space needed.
		 */</comment>
		<expr_stmt><expr><name>totalLeafSizes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>.</operator><name>nTuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>newLeafs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>spgFormLeafTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>heapPtrs</name> <operator>+</operator> <name>i</name></expr></argument>,
										   <argument><expr><name><name>out</name><operator>.</operator><name>leafTupleDatums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>totalLeafSizes</name> <operator>+=</operator> <name><name>newLeafs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Perform dummy split that puts all tuples into one node.
		 * checkAllTheSame will override this and force allTheSame mode.
		 */</comment>
		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>hasPrefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>nNodes</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>nodeLabels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>mapTuplesToNodes</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>.</operator><name>nTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Form new leaf tuples and count up the total space needed.
		 */</comment>
		<expr_stmt><expr><name>totalLeafSizes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>.</operator><name>nTuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>newLeafs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>spgFormLeafTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>heapPtrs</name> <operator>+</operator> <name>i</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>totalLeafSizes</name> <operator>+=</operator> <name><name>newLeafs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Check to see if the picksplit function failed to separate the values,
	 * ie, it put them all into the same child node.  If so, select allTheSame
	 * mode and create a random split instead.  See comments for
	 * checkAllTheSame as to why we need to know if the new leaf tuples could
	 * fit on one page.
	 */</comment>
	<expr_stmt><expr><name>allTheSame</name> <operator>=</operator> <call><name>checkAllTheSame</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>,
								 <argument><expr><name>totalLeafSizes</name> <operator>&gt;</operator> <name>SPGIST_PAGE_CAPACITY</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>includeNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If checkAllTheSame decided we must exclude the new tuple, don't
	 * consider it any further.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>includeNew</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxToInclude</name> <operator>=</operator> <name><name>in</name><operator>.</operator><name>nTuples</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>maxToInclude</name> <operator>=</operator> <name><name>in</name><operator>.</operator><name>nTuples</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalLeafSizes</name> <operator>-=</operator> <name><name>newLeafs</name><index>[<expr><name><name>in</name><operator>.</operator><name>nTuples</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Allocate per-node work arrays.  Since checkAllTheSame could replace
	 * out.nNodes with a value larger than the number of tuples on the input
	 * page, we can't allocate these arrays before here.
	 */</comment>
	<expr_stmt><expr><name>nodes</name> <operator>=</operator> <operator>(</operator><name>SpGistNodeTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistNodeTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafSizes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Form nodes of inner tuple and inner tuple itself
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>label</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>labelisnull</name> <init>= <expr><operator>(</operator><name><name>out</name><operator>.</operator><name>nodeLabels</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>labelisnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>label</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>nodeLabels</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>spgFormNodeTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>labelisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <call><name>spgFormInnerTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><name><name>out</name><operator>.</operator><name>hasPrefix</name></name></expr></argument>, <argument><expr><name><name>out</name><operator>.</operator><name>prefixDatum</name></name></expr></argument>,
								   <argument><expr><name><name>out</name><operator>.</operator><name>nNodes</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>allTheSame</name></name> <operator>=</operator> <name>allTheSame</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update nodes[] array to point into the newly formed innerTuple, so that
	 * we can adjust their downlinks below.
	 */</comment>
	<macro><name>SGITITERATE</name><argument_list>(<argument>innerTuple</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Re-scan new leaf tuples and count up the space needed under each node.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxToInclude</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>mapTuplesToNodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent result of SPGiST picksplit function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>leafSizes</name><index>[<expr><name>n</name></expr>]</index></name> <operator>+=</operator> <name><name>newLeafs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * To perform the split, we must insert a new inner tuple, which can't go
	 * on a leaf page; and unless we are splitting the root page, we must then
	 * update the parent tuple's downlink to point to the inner tuple.  If
	 * there is room, we'll put the new inner tuple on the same page as the
	 * parent tuple, otherwise we need another non-leaf buffer. But if the
	 * parent page is the root, we can't add the new inner tuple there,
	 * because the root page must have only one inner tuple.
	 */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>initInner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>SpGistPageGetFreeSpace</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
		 <name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* New inner tuple will fit on parent page */</comment>
		<expr_stmt><expr><name>newInnerBuffer</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Send tuple to page with next triple parity (see README) */</comment>
		<expr_stmt><expr><name>newInnerBuffer</name> <operator>=</operator> <call><name>SpGistGetBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
										 <argument><expr><call><name>GBUF_INNER_PARITY</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>blkno</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>|</operator>
										 <operator>(</operator><ternary><condition><expr><name>isNulls</name></expr> ?</condition><then> <expr><name>GBUF_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
										 <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>xlrec</name><operator>.</operator><name>initInner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Root page split ... inner tuple will go to root page */</comment>
		<expr_stmt><expr><name>newInnerBuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The new leaf tuples converted from the existing ones should require the
	 * same or less space, and therefore should all fit onto one page
	 * (although that's not necessarily the current page, since we can't
	 * delete the old tuples but only replace them with placeholders).
	 * However, the incoming new tuple might not also fit, in which case we
	 * might need another picksplit cycle to reduce it some more.
	 *
	 * If there's not room to put everything back onto the current page, then
	 * we decide on a per-node basis which tuples go to the new page. (We do
	 * it like that because leaf tuple chains can't cross pages, so we must
	 * place all leaf tuples belonging to the same parent node on the same
	 * page.)
	 *
	 * If we are splitting the root page (turning it from a leaf page into an
	 * inner page), then no leaf tuples can go back to the current page; they
	 * must all go somewhere else.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>currentFreeSpace</name> <operator>=</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>spaceToDelete</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>currentFreeSpace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* prevent assigning any tuples to current */</comment>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>initDest</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>totalLeafSizes</name> <operator>&lt;=</operator> <name>currentFreeSpace</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* All the leaf tuples will fit on current page */</comment>
		<expr_stmt><expr><name>newLeafBuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		<comment type="block">/* mark new leaf tuple as included in insertions, if allowed */</comment>
		<if_stmt><if>if <condition>(<expr><name>includeNew</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nToInsert</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>insertedNew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nToInsert</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>leafPageSelect</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>	<comment type="block">/* signifies current page */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>in</name><operator>.</operator><name>nTuples</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>totalLeafSizes</name> <operator>&gt;</operator> <name>SPGIST_PAGE_CAPACITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're trying to split up a long value by repeated suffixing, but
		 * it's not going to fit yet.  Don't bother allocating a second leaf
		 * buffer that we won't be able to use.
		 */</comment>
		<expr_stmt><expr><name>newLeafBuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>includeNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nToInsert</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We will need another leaf page */</comment>
		<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>nodePageSelect</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>curspace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newspace</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newLeafBuffer</name> <operator>=</operator> <call><name>SpGistGetBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
										<argument><expr><name>GBUF_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>isNulls</name></expr> ?</condition><then> <expr><name>GBUF_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
										<argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>totalLeafSizes</name></expr></argument>,
											<argument><expr><name>SPGIST_PAGE_CAPACITY</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>xlrec</name><operator>.</operator><name>initDest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Attempt to assign node groups to the two pages.  We might fail to
		 * do so, even if totalLeafSizes is less than the available space,
		 * because we can't split a group across pages.
		 */</comment>
		<expr_stmt><expr><name>nodePageSelect</name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>curspace</name> <operator>=</operator> <name>currentFreeSpace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newspace</name> <operator>=</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newLeafBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>leafSizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>curspace</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>nodePageSelect</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* signifies current page */</comment>
				<expr_stmt><expr><name>curspace</name> <operator>-=</operator> <name><name>leafSizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>nodePageSelect</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* signifies new leaf page */</comment>
				<expr_stmt><expr><name>newspace</name> <operator>-=</operator> <name><name>leafSizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>curspace</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newspace</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Successful assignment, so we can include the new leaf tuple */</comment>
			<if_stmt><if>if <condition>(<expr><name>includeNew</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nToInsert</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>insertedNew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>includeNew</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We must exclude the new leaf tuple from the split */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>nodeOfNewTuple</name> <init>= <expr><name><name>out</name><operator>.</operator><name>mapTuplesToNodes</name><index>[<expr><name><name>in</name><operator>.</operator><name>nTuples</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>leafSizes</name><index>[<expr><name>nodeOfNewTuple</name></expr>]</index></name> <operator>-=</operator>
				<name><name>newLeafs</name><index>[<expr><name><name>in</name><operator>.</operator><name>nTuples</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<comment type="block">/* Repeat the node assignment process --- should succeed now */</comment>
			<expr_stmt><expr><name>curspace</name> <operator>=</operator> <name>currentFreeSpace</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newspace</name> <operator>=</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newLeafBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>leafSizes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>curspace</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>nodePageSelect</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* signifies current page */</comment>
					<expr_stmt><expr><name>curspace</name> <operator>-=</operator> <name><name>leafSizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>nodePageSelect</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* signifies new leaf page */</comment>
					<expr_stmt><expr><name>newspace</name> <operator>-=</operator> <name><name>leafSizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>curspace</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>newspace</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to divide leaf tuple groups across pages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* oops, we already excluded new tuple ... should not get here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to divide leaf tuple groups across pages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Expand the per-node assignments to be shown per leaf tuple */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nToInsert</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>mapTuplesToNodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>leafPageSelect</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>nodePageSelect</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Start preparing WAL record */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nDelete</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>initSrc</name></name> <operator>=</operator> <name>isNew</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>storesNulls</name></name> <operator>=</operator> <name>isNulls</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>isRootSplit</name></name> <operator>=</operator> <call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>leafdata</name> <operator>=</operator> <name>leafptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>totalLeafSizes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Here we begin making the changes to the target pages */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete old leaf tuples from current buffer, except when we're splitting
	 * the root; in that case there's no need because we'll re-init the page
	 * below.  We do this first to make room for reinserting new leaf tuples.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Init buffer instead of deleting individual tuples, but only if
		 * there aren't any other live tuples and only during build; otherwise
		 * we need to set a redirection tuple for concurrent scans.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name> <operator>&amp;&amp;</operator>
			<name>nToDelete</name> <operator>+</operator> <call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nPlaceholder</name> <operator>==</operator>
			<call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
							 <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>isNulls</name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>initSrc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>isNew</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't expose the freshly init'd buffer as a backup block */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nToDelete</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nDelete</name></name> <operator>=</operator> <name>nToDelete</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Need to create redirect tuple (it will point to new inner
				 * tuple) but right now the new tuple's location is not known
				 * yet.  So, set the redirection pointer to "impossible" value
				 * and remember its position to update tuple later.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>nToDelete</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>redirectTuplePos</name> <operator>=</operator> <name><name>toDelete</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
										<argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name>nToDelete</name></expr></argument>,
										<argument><expr><name>SPGIST_REDIRECT</name></expr></argument>,
										<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
										<argument><expr><name>SPGIST_METAPAGE_BLKNO</name></expr></argument>,
										<argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * During index build there is not concurrent searches, so we
				 * don't need to create redirection tuple.
				 */</comment>
				<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
										<argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name>nToDelete</name></expr></argument>,
										<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
										<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
										<argument><expr><name>InvalidBlockNumber</name></expr></argument>,
										<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Put leaf tuples on proper pages, and update downlinks in innerTuple's
	 * nodes.
	 */</comment>
	<expr_stmt><expr><name><name>startOffsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>startOffsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nToInsert</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>it</name> <init>= <expr><name><name>newLeafs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>leafBuffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leafBlock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>newoffset</name></decl>;</decl_stmt>

		<comment type="block">/* Which page is it going to? */</comment>
		<expr_stmt><expr><name>leafBuffer</name> <operator>=</operator> <ternary><condition><expr><name><name>leafPageSelect</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name>newLeafBuffer</name></expr> </then><else>: <expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>leafBlock</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>leafBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Link tuple into correct chain for its node */</comment>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>mapTuplesToNodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>t_tid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>t_tid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>leafBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>t_tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Insert it on page */</comment>
		<expr_stmt><expr><name>newoffset</name> <operator>=</operator> <call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leafBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>it</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>startOffsets</name><index>[<expr><name><name>leafPageSelect</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toInsert</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newoffset</name></expr>;</expr_stmt>

		<comment type="block">/* ... and complete the chain linking */</comment>
		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>n</name></expr>]</index></name><operator>-&gt;</operator><name>t_tid</name></expr></argument>, <argument><expr><name>leafBlock</name></expr></argument>, <argument><expr><name>newoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also copy leaf tuple into WAL data */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>leafptr</name></expr></argument>, <argument><expr><name><name>newLeafs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>newLeafs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>leafptr</name> <operator>+=</operator> <name><name>newLeafs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>size</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We're done modifying the other leaf buffer (if any), so mark it dirty.
	 * current-&gt;buffer will be marked below, after we're entirely done
	 * modifying it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newLeafBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>newLeafBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Remember current buffer, since we're about to change "current" */</comment>
	<expr_stmt><expr><name>saveCurrent</name> <operator>=</operator> <operator>*</operator><name>current</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the new innerTuple
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newInnerBuffer</name> <operator>==</operator> <name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>&amp;&amp;</operator> <name>newInnerBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * new inner tuple goes to parent page
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Repoint "current" at the new inner tuple */</comment>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>blkno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumInner</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name> <operator>=</operator>
			<call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>innerTuple</name></expr></argument>, <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update parent node link and mark parent page dirty
		 */</comment>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>innerIsParent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nodeI</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>saveNodeLink</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update redirection link (in old current buffer)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>redirectTuplePos</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>setRedirectionTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>saveCurrent</name></expr></argument>, <argument><expr><name>redirectTuplePos</name></expr></argument>,
								<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Done modifying old current buffer, mark it dirty */</comment>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * new inner tuple will be stored on a new page
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newInnerBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Repoint "current" at the new inner tuple */</comment>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>newInnerBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumInner</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name> <operator>=</operator>
			<call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>innerTuple</name></expr></argument>, <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done modifying new current buffer, mark it dirty */</comment>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update parent node link and mark parent page dirty
		 */</comment>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>innerIsParent</name></name> <operator>=</operator> <operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name><name>current</name><operator>-&gt;</operator><name>buffer</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nodeI</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>saveNodeLink</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update redirection link (in old current buffer)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>redirectTuplePos</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>setRedirectionTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>saveCurrent</name></expr></argument>, <argument><expr><name>redirectTuplePos</name></expr></argument>,
								<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Done modifying old current buffer, mark it dirty */</comment>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Splitting root page, which was a leaf but now becomes inner page
		 * (and so "current" continues to point at it)
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>redirectTuplePos</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>isNulls</name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>initInner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>innerIsParent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumInner</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name> <operator>=</operator>
			<call><name>PageAddItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>innerTuple</name></expr></argument>, <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
						<argument><expr><name>InvalidOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name> <operator>!=</operator> <name>FirstOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
				 <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* No parent link to update, nor redirection to do */</comment>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nodeI</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Done modifying new current buffer, mark it dirty */</comment>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* saveCurrent doesn't represent a different buffer */</comment>
		<expr_stmt><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nInsert</name></name> <operator>=</operator> <name>nToInsert</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfSpgxlogPickSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>toDelete</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>toInsert</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>leafPageSelect</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nInsert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>innerTuple</name></expr></argument>, <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><name>leafdata</name></expr></argument>, <argument><expr><name>leafptr</name> <operator>-</operator> <name>leafdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Old leaf page */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>initSrc</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REGBUF_WILL_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* New leaf page */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>newLeafBuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>initDest</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REGBUF_WILL_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>newLeafBuffer</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Inner page */</comment>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>initInner</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REGBUF_WILL_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Parent page, if different from inner page */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>innerIsParent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Issue the WAL record */</comment>
		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SPGIST_ID</name></expr></argument>, <argument><expr><name>XLOG_SPGIST_PICKSPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update page LSNs on all affected pages */</comment>
		<if_stmt><if>if <condition>(<expr><name>newLeafBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newLeafBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update local free-space cache and unlock buffers */</comment>
	<if_stmt><if>if <condition>(<expr><name>newLeafBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>newLeafBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>newLeafBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>insertedNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * spgMatchNode action: descend to N'th child node of current inner tuple
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgMatchNodeAction</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				   <parameter><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl></parameter>,
				   <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeN</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name></decl>;</decl_stmt>

	<comment type="block">/* Release previous parent buffer if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator>
		<name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Repoint parent to specified node of current inner tuple */</comment>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>offnum</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>nodeN</name></expr>;</expr_stmt>

	<comment type="block">/* Locate that node */</comment>
	<macro><name>SGITITERATE</name><argument_list>(<argument>innerTuple</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>nodeN</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>nodeN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find requested node %d in SPGiST inner tuple"</literal></expr></argument>,
			 <argument><expr><name>nodeN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Point current to the downlink location, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Downlink is empty, so we'll need to find a new page */</comment>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * spgAddNode action: add a node to the inner tuple at current
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgAddNodeAction</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				 <parameter><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl></parameter>,
				 <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>nodeN</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>nodeLabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>newInnerTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogAddNode</name></type> <name>xlrec</name></decl>;</decl_stmt>

	<comment type="block">/* Should not be applied to nulls */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SpGistPageStoresNulls</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct new inner tuple with additional node */</comment>
	<expr_stmt><expr><name>newInnerTuple</name> <operator>=</operator> <call><name>addNode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><name>nodeLabel</name></expr></argument>, <argument><expr><name>nodeN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare WAL record */</comment>
	<expr_stmt><expr><call><name>STORE_STATE</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>

	<comment type="block">/* we don't fill these unless we need to change the parent downlink */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>parentBlk</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nodeI</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* we don't fill these unless tuple has to be moved */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumNew</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>newPage</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
		<name><name>newInnerTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can replace the inner tuple by new version in-place
		 */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>newInnerTuple</name></expr></argument>, <argument><expr><name><name>newInnerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
						<argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
				 <argument><expr><name><name>newInnerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlrec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newInnerTuple</name></expr></argument>, <argument><expr><name><name>newInnerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SPGIST_ID</name></expr></argument>, <argument><expr><name>XLOG_SPGIST_ADD_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * move inner tuple to another page, and update parent
		 */</comment>
		<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>dt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SPPageDesc</name></type>	<name>saveCurrent</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * It should not be possible to get here for the root page, since we
		 * allow only one inner tuple on the root page, and spgFormInnerTuple
		 * always checks that inner tuples don't exceed the size of a page.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot enlarge root tuple any more"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>saveCurrent</name> <operator>=</operator> <operator>*</operator><name>current</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumParent</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nodeI</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * obtain new buffer with the same parity as current, since it will be
		 * a child of same parent tuple
		 */</comment>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>SpGistGetBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
										  <argument><expr><call><name>GBUF_INNER_PARITY</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name><name>newInnerTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>xlrec</name><operator>.</operator><name>newPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Let's just make real sure new current isn't same as old.  Right now
		 * that's impossible, but if SpGistGetBuffer ever got smart enough to
		 * delete placeholder tuples before checking space, maybe it wouldn't
		 * be impossible.  The case would appear to work except that WAL
		 * replay would be subtly wrong, so I think a mere assert isn't enough
		 * here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name> <operator>==</operator> <name><name>saveCurrent</name><operator>.</operator><name>blkno</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPGiST new buffer shouldn't be same as old buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * New current and parent buffer will both be modified; but note that
		 * parent buffer could be same as either new or old current.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>parentBlk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>parentBlk</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>parentBlk</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* insert new ... */</comment>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumNew</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name> <operator>=</operator>
			<call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>newInnerTuple</name></expr></argument>, <argument><expr><name><name>newInnerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* update parent's downlink and mark parent page dirty */</comment>
		<expr_stmt><expr><call><name>saveNodeLink</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Replace old tuple with a placeholder or redirection tuple.  Unless
		 * doing an index build, we have to insert a redirection tuple for
		 * possible concurrent scans.  We can't just delete it in any case,
		 * because that could change the offsets of other tuples on the page,
		 * breaking downlinks from their parents.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dt</name> <operator>=</operator> <call><name>spgFormDeadTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
								  <argument><expr><name>InvalidBlockNumber</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>dt</name> <operator>=</operator> <call><name>spgFormDeadTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>SPGIST_REDIRECT</name></expr></argument>,
								  <argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>saveCurrent</name><operator>.</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>page</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>dt</name></expr></argument>, <argument><expr><name><name>dt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
						<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>offnum</name></name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>saveCurrent</name><operator>.</operator><name>offnum</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
				 <argument><expr><name><name>dt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nPlaceholder</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nRedirection</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* orig page */</comment>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* new page */</comment>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>newPage</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REGBUF_WILL_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* parent page (if different from orig and new) */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>parentBlk</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlrec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newInnerTuple</name></expr></argument>, <argument><expr><name><name>newInnerTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SPGIST_ID</name></expr></argument>, <argument><expr><name>XLOG_SPGIST_ADD_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* we don't bother to check if any of these are redundant */</comment>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release saveCurrent if it's not same as current or parent */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>buffer</name></name> <operator>&amp;&amp;</operator>
			<name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name> <operator>!=</operator> <name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>saveCurrent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * spgSplitNode action: split inner tuple at current into prefix and postfix
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgSplitNodeAction</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				   <parameter><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl></parameter>,
				   <parameter><decl><type><name>SPPageDesc</name> <modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>spgChooseOut</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>prefixTuple</name></decl>,
				<decl><type ref="prev"/><name>postfixTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>postfixBlkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>postfixOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogSplitTuple</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>newBuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Should not be applied to nulls */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SpGistPageStoresNulls</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check opclass gave us sane values */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNNodes</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNNodes</name></name> <operator>&gt;</operator> <name>SGITMAXNNODES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid number of prefix nodes: %d"</literal></expr></argument>,
			 <argument><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>childNodeN</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>childNodeN</name></name> <operator>&gt;=</operator>
		<name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNNodes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid child node number: %d"</literal></expr></argument>,
			 <argument><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>childNodeN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Construct new prefix tuple with requested number of nodes.  We'll fill
	 * in the childNodeN'th node's downlink below.
	 */</comment>
	<expr_stmt><expr><name>nodes</name> <operator>=</operator> <operator>(</operator><name>SpGistNodeTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistNodeTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
									   <name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>label</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>labelisnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>labelisnull</name> <operator>=</operator> <operator>(</operator><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNodeLabels</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>labelisnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>label</name> <operator>=</operator> <name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNodeLabels</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>spgFormNodeTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>labelisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>prefixTuple</name> <operator>=</operator> <call><name>spgFormInnerTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									<argument><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixHasPrefix</name></name></expr></argument>,
									<argument><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixPrefixDatum</name></name></expr></argument>,
									<argument><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNNodes</name></name></expr></argument>,
									<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* it must fit in the space that innerTuple now occupies */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>prefixTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPGiST inner-tuple split must not produce longer prefix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Construct new postfix tuple, containing all nodes of innerTuple with
	 * same node datums, but with the prefix specified by the picksplit
	 * function.
	 */</comment>
	<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistNodeTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>SGITITERATE</name><argument_list>(<argument>innerTuple</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>postfixTuple</name> <operator>=</operator> <call><name>spgFormInnerTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									 <argument><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>postfixHasPrefix</name></name></expr></argument>,
									 <argument><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>postfixPrefixDatum</name></name></expr></argument>,
									 <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Postfix tuple is allTheSame if original tuple was */</comment>
	<expr_stmt><expr><name><name>postfixTuple</name><operator>-&gt;</operator><name>allTheSame</name></name> <operator>=</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>allTheSame</name></name></expr>;</expr_stmt>

	<comment type="block">/* prep data for WAL record */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>newPage</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we can't fit both tuples on the current page, get a new page for the
	 * postfix tuple.  In particular, can't split to the root page.
	 *
	 * For the space calculation, note that prefixTuple replaces innerTuple
	 * but postfixTuple will be a new entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>SpGistPageGetFreeSpace</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator>
		<name><name>prefixTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <name><name>postfixTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Choose page with next triple parity, because postfix tuple is a
		 * child of prefix one
		 */</comment>
		<expr_stmt><expr><name>newBuffer</name> <operator>=</operator> <call><name>SpGistGetBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
									<argument><expr><call><name>GBUF_INNER_PARITY</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>blkno</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>postfixTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>xlrec</name><operator>.</operator><name>newPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace old tuple by prefix tuple
	 */</comment>
	<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumPrefix</name></name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
									 <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>prefixTuple</name></expr></argument>, <argument><expr><name><name>prefixTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
									 <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>offnumPrefix</name></name> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
			 <argument><expr><name><name>prefixTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * put postfix tuple into appropriate page
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newBuffer</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>postfixBlkno</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>blkno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumPostfix</name></name> <operator>=</operator> <name>postfixOffset</name> <operator>=</operator>
			<call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>postfixTuple</name></expr></argument>, <argument><expr><name><name>postfixTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>postfixBlkSame</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>postfixBlkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>newBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnumPostfix</name></name> <operator>=</operator> <name>postfixOffset</name> <operator>=</operator>
			<call><name>SpGistPageAddNewItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>postfixTuple</name></expr></argument>, <argument><expr><name><name>postfixTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>newBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>postfixBlkSame</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * And set downlink pointer in the prefix tuple to point to postfix tuple.
	 * (We can't avoid this step by doing the above two steps in opposite
	 * order, because there might not be enough space on the page to insert
	 * the postfix tuple first.)  We have to update the local copy of the
	 * prefixTuple too, because that's what will be written to WAL.
	 */</comment>
	<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>prefixTuple</name></expr></argument>, <argument><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>childNodeN</name></name></expr></argument>,
					  <argument><expr><name>postfixBlkno</name></expr></argument>, <argument><expr><name>postfixOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prefixTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
												 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>prefixTuple</name></expr></argument>, <argument><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>childNodeN</name></name></expr></argument>,
					  <argument><expr><name>postfixBlkno</name></expr></argument>, <argument><expr><name>postfixOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlrec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>prefixTuple</name></expr></argument>, <argument><expr><name><name>prefixTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>postfixTuple</name></expr></argument>, <argument><expr><name><name>postfixTuple</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>newPage</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REGBUF_WILL_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>newBuffer</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SPGIST_ID</name></expr></argument>, <argument><expr><name>XLOG_SPGIST_SPLIT_TUPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update local free-space cache and release buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>newBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>newBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>newBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert one item into the index.
 *
 * Returns true on success, false if we failed to complete the insertion
 * (typically because of conflict with a concurrent insert).  In the latter
 * case, caller should re-call spgdoinsert() with the same args.
 */</comment>
<function><type><name>bool</name></type>
<name>spgdoinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
			<parameter><decl><type><name>ItemPointer</name></type> <name>heapPtr</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>leafDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>leafSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bestLeafSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numNoProgressCycles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPPageDesc</name></type>	<name>current</name></decl>,
				<decl><type ref="prev"/><name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look up FmgrInfo of the user-defined choose function once, to save
	 * cycles in the loop below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_CHOOSE_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Prepare the leaf datum to insert.
	 *
	 * If an optional "compress" method is provided, then call it to form the
	 * leaf datum from the input datum.  Otherwise store the input datum as
	 * is.  Since we don't use index_form_tuple in this AM, we have to make
	 * sure value to be inserted is not toasted; FormIndexDatum doesn't
	 * guarantee that.  But we assume the "compress" method to return an
	 * untoasted value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>index_getprocid</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_COMPRESS_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>compressProcinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>compressProcinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_COMPRESS_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>leafDatum</name> <operator>=</operator> <call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><name>compressProcinfo</name></expr></argument>,
										  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
										  <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>attLeafType</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>attType</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>attType</name><operator>.</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>leafDatum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>leafDatum</name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>leafDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Compute space needed for a leaf tuple containing the given datum.
	 *
	 * If it isn't gonna fit, and the opclass can't reduce the datum size by
	 * suffixing, bail out now rather than doing a lot of useless work.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leafSize</name> <operator>=</operator> <name>SGLTHDRSZ</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
			<call><name>SpGistGetTypeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>attLeafType</name></name></expr></argument>, <argument><expr><name>leafDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>leafSize</name> <operator>=</operator> <name>SGDTSIZE</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>leafSize</name> <operator>&gt;</operator> <name>SPGIST_PAGE_CAPACITY</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>isnull</name> <operator>||</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>longValuesOK</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum %zu for index \"%s\""</literal></expr></argument>,
						<argument><expr><name>leafSize</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						<argument><expr><name>SPGIST_PAGE_CAPACITY</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Values larger than a buffer page cannot be indexed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>bestLeafSize</name> <operator>=</operator> <name>leafSize</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize "current" to the appropriate root page */</comment>
	<expr_stmt><expr><name><name>current</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name>SPGIST_NULL_BLKNO</name></expr> </then><else>: <expr><name>SPGIST_ROOT_BLKNO</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current</name><operator>.</operator><name>page</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* "parent" is invalid for the moment */</comment>
	<expr_stmt><expr><name><name>parent</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>.</operator><name>page</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before entering the loop, try to clear any pending interrupt condition.
	 * If a query cancel is pending, we might as well accept it now not later;
	 * while if a non-canceling condition is pending, servicing it here avoids
	 * having to restart the insertion and redo all the work so far.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNew</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Bail out if query cancel is pending.  We must have this somewhere
		 * in the loop since a broken opclass could produce an infinite
		 * picksplit loop.  However, because we'll be holding buffer lock(s)
		 * after the first iteration, ProcessInterrupts() wouldn't be able to
		 * throw a cancel error here.  Hence, if we see that an interrupt is
		 * pending, break out of the loop and deal with the situation below.
		 * Set result = false because we must restart the insertion if the
		 * interrupt isn't a query-cancel-or-die case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>INTERRUPTS_PENDING_CONDITION</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>.</operator><name>blkno</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Create a leaf page.  If leafSize is too large to fit on a page,
			 * we won't actually use the page yet, but it simplifies the API
			 * for doPickSplit to always have a leaf page at hand; so just
			 * quietly limit our request to a page size.
			 */</comment>
			<expr_stmt><expr><name><name>current</name><operator>.</operator><name>buffer</name></name> <operator>=</operator>
				<call><name>SpGistGetBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
								<argument><expr><name>GBUF_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name>GBUF_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
								<argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>leafSize</name></expr></argument>, <argument><expr><name>SPGIST_PAGE_CAPACITY</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>current</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>parent</name><operator>.</operator><name>buffer</name></name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we hold no parent-page lock, so no deadlock is possible */</comment>
			<expr_stmt><expr><name><name>current</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>current</name><operator>.</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>current</name><operator>.</operator><name>blkno</name></name> <operator>!=</operator> <name><name>parent</name><operator>.</operator><name>blkno</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* descend to a new child page */</comment>
			<expr_stmt><expr><name><name>current</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>current</name><operator>.</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Attempt to acquire lock on child page.  We must beware of
			 * deadlock against another insertion process descending from that
			 * page to our parent page (see README).  If we fail to get lock,
			 * abandon the insertion and tell our caller to start over.
			 *
			 * XXX this could be improved, because failing to get lock on a
			 * buffer is not proof of a deadlock situation; the lock might be
			 * held by a reader, or even just background writer/checkpointer
			 * process.  Perhaps it'd be worth retrying after sleeping a bit?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockBuffer</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>parent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* inner tuple can be stored on the same page as parent one */</comment>
			<expr_stmt><expr><name><name>current</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name><name>parent</name><operator>.</operator><name>buffer</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>current</name><operator>.</operator><name>page</name></name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* should not arrive at a page of the wrong type */</comment>
		<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>!</operator><call><name>SpGistPageStoresNulls</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
			<expr><call><name>SpGistPageStoresNulls</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPGiST index page %u has wrong nulls flag"</literal></expr></argument>,
				 <argument><expr><name><name>current</name><operator>.</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SpGistPageIsLeaf</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>leafTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nToSplit</name></decl>,
						<decl><type ref="prev"/><name>sizeToSplit</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>leafTuple</name> <operator>=</operator> <call><name>spgFormLeafTuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>heapPtr</name></expr></argument>, <argument><expr><name>leafDatum</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>leafTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator>
				<call><name>SpGistPageGetFreeSpace</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>page</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* it fits on page, so insert it and we're done */</comment>
				<expr_stmt><expr><call><name>addLeafTuple</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>current</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>isNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>sizeToSplit</name> <operator>=</operator>
					  <call><name>checkSplitConditions</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>nToSplit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name>SPGIST_PAGE_CAPACITY</name> <operator>/</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
					 <name>nToSplit</name> <operator>&lt;</operator> <literal type="number">64</literal> <operator>&amp;&amp;</operator>
					 <name><name>leafTuple</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>sizeToSplit</name> <operator>&lt;=</operator> <name>SPGIST_PAGE_CAPACITY</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * the amount of data is pretty small, so just move the whole
				 * chain to another leaf page rather than splitting it.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>moveLeafs</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* we're done */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* picksplit */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>doPickSplit</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>,
								<argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>isNew</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* doPickSplit installed new tuples */</comment>

				<comment type="block">/* leaf tuple will not be inserted yet */</comment>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>leafTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * current now describes new inner tuple, go insert into it
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SpGistPageIsLeaf</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>process_inner_tuple</name>;</goto>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else					<comment type="block">/* non-leaf page */</comment>
		<block>{<block_content>
			<comment type="block">/*
			 * Apply the opclass choose function to figure out how to insert
			 * the given datum into the current inner tuple.
			 */</comment>
			<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>spgChooseIn</name></type> <name>in</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>spgChooseOut</name></type> <name>out</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * spgAddNode and spgSplitTuple cases will loop back to here to
			 * complete the insertion operation.  Just in case the choose
			 * function is broken and produces add or split requests
			 * repeatedly, check for query cancel (see comments above).
			 */</comment>
	<label><name>process_inner_tuple</name>:</label>
			<if_stmt><if>if <condition>(<expr><call><name>INTERRUPTS_PENDING_CONDITION</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>page</name></name></expr></argument>,
														<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>.</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>in</name><operator>.</operator><name>datum</name></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>.</operator><name>leafDatum</name></name> <operator>=</operator> <name>leafDatum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>.</operator><name>allTheSame</name></name> <operator>=</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>allTheSame</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>.</operator><name>hasPrefix</name></name> <operator>=</operator> <operator>(</operator><name><name>innerTuple</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>.</operator><name>prefixDatum</name></name> <operator>=</operator> <call><name>SGITDATUM</name><argument_list>(<argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>.</operator><name>nNodes</name></name> <operator>=</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>in</name><operator>.</operator><name>nodeLabels</name></name> <operator>=</operator> <call><name>spgExtractNodeLabels</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* use user-defined choose method */</comment>
				<expr_stmt><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>procinfo</name></expr></argument>,
								  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* force "match" action (to insert to random subnode) */</comment>
				<expr_stmt><expr><name><name>out</name><operator>.</operator><name>resultType</name></name> <operator>=</operator> <name>spgMatchNode</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>innerTuple</name><operator>-&gt;</operator><name>allTheSame</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * It's not allowed to do an AddNode at an allTheSame tuple.
				 * Opclass must say "match", in which case we choose a random
				 * one of the nodes to descend into, or "split".
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>.</operator><name>resultType</name></name> <operator>==</operator> <name>spgAddNode</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot add a node to an allTheSame inner tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>out</name><operator>.</operator><name>resultType</name></name> <operator>==</operator> <name>spgMatchNode</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>out</name><operator>.</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>nodeN</name></name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call> <operator>%</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<switch>switch <condition>(<expr><name><name>out</name><operator>.</operator><name>resultType</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>spgMatchNode</name></expr>:</case>
					<comment type="block">/* Descend to N'th child node */</comment>
					<expr_stmt><expr><call><name>spgMatchNodeAction</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>current</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>,
									   <argument><expr><name><name>out</name><operator>.</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>nodeN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Adjust level as per opclass request */</comment>
					<expr_stmt><expr><name>level</name> <operator>+=</operator> <name><name>out</name><operator>.</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>levelAdd</name></name></expr>;</expr_stmt>
					<comment type="block">/* Replace leafDatum and recompute leafSize */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>leafDatum</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>restDatum</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>leafSize</name> <operator>=</operator> <name>SGLTHDRSZ</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
							<call><name>SpGistGetTypeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>attLeafType</name></name></expr></argument>, <argument><expr><name>leafDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Check new tuple size; fail if it can't fit, unless the
					 * opclass says it can handle the situation by suffixing.
					 *
					 * A buggy opclass might not ever make the leaf datum
					 * small enough, causing an infinite loop.  To detect such
					 * a loop, check to see if we are making progress by
					 * reducing the leafSize in each pass.  This is a bit
					 * tricky though.  Because of alignment considerations,
					 * the total tuple size might not decrease on every pass.
					 * Also, there are edge cases where the choose method
					 * might seem to not make progress for a cycle or two.
					 * Somewhat arbitrarily, we allow up to 10 no-progress
					 * iterations before failing.  (This limit should be more
					 * than MAXALIGN, to accommodate opclasses that trim one
					 * byte from the leaf datum per pass.)
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>leafSize</name> <operator>&gt;</operator> <name>SPGIST_PAGE_CAPACITY</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>longValuesOK</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isnull</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>leafSize</name> <operator>&lt;</operator> <name>bestLeafSize</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>bestLeafSize</name> <operator>=</operator> <name>leafSize</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>numNoProgressCycles</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
							</block_content>}</block></if>
							<if type="elseif">else if <condition>(<expr><operator>++</operator><name>numNoProgressCycles</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum %zu for index \"%s\""</literal></expr></argument>,
											<argument><expr><name>leafSize</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
											<argument><expr><name>SPGIST_PAGE_CAPACITY</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
											<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Values larger than a buffer page cannot be indexed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Loop around and attempt to insert the new leafDatum at
					 * "current" (which might reference an existing child
					 * tuple, or might be invalid to force us to find a new
					 * page for the tuple).
					 */</comment>
					<break>break;</break>
				<case>case <expr><name>spgAddNode</name></expr>:</case>
					<comment type="block">/* AddNode is not sensible if nodes don't have labels */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>in</name><operator>.</operator><name>nodeLabels</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot add a node to an inner tuple without node labels"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* Add node to inner tuple, per request */</comment>
					<expr_stmt><expr><call><name>spgAddNodeAction</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>current</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>,
									 <argument><expr><name><name>out</name><operator>.</operator><name>result</name><operator>.</operator><name>addNode</name><operator>.</operator><name>nodeN</name></name></expr></argument>,
									 <argument><expr><name><name>out</name><operator>.</operator><name>result</name><operator>.</operator><name>addNode</name><operator>.</operator><name>nodeLabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Retry insertion into the enlarged node.  We assume that
					 * we'll get a MatchNode result this time.
					 */</comment>
					<goto>goto <name>process_inner_tuple</name>;</goto>
					<break>break;</break>
				<case>case <expr><name>spgSplitTuple</name></expr>:</case>
					<comment type="block">/* Split inner tuple, per request */</comment>
					<expr_stmt><expr><call><name>spgSplitNodeAction</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>current</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Retry insertion into the split node */</comment>
					<goto>goto <name>process_inner_tuple</name>;</goto>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized SPGiST choose result: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>out</name><operator>.</operator><name>resultType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>							<comment type="block">/* end loop */</comment>

	<comment type="block">/*
	 * Release any buffers we're still holding.  Beware of possibility that
	 * current and parent reference same buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>.</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>current</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>current</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>.</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator>
		<name><name>parent</name><operator>.</operator><name>buffer</name></name> <operator>!=</operator> <name><name>current</name><operator>.</operator><name>buffer</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>parent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>parent</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We do not support being called while some outer function is holding a
	 * buffer lock (or any other reason to postpone query cancels).  If that
	 * were the case, telling the caller to retry would create an infinite
	 * loop.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>INTERRUPTS_CAN_BE_PROCESSED</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally, check for interrupts again.  If there was a query cancel,
	 * ProcessInterrupts() will be able to throw the error here.  If it was
	 * some other kind of interrupt that can just be cleared, return false to
	 * tell our caller to retry.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
