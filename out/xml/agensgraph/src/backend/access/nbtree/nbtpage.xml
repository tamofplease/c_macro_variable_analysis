<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/nbtree/nbtpage.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtpage.c
 *	  BTree-specific page management code for the Postgres btree access
 *	  method.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/nbtree/nbtpage.c
 *
 *	NOTES
 *	   Postgres btree pages look like ordinary relation pages.  The opaque
 *	   data at high addresses includes pointers to left and right siblings
 *	   and flag data describing page state.  The first page in a btree, page
 *	   zero, is special -- it stores meta-information describing the tree.
 *	   Pages one and higher store the actual tree data.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/indexfsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>BTMetaPageData</name> <modifier>*</modifier></type><name>_bt_getmeta</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_log_reuse_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>,
							   <parameter><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>_bt_xid_horizon</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
									 <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>deletable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndeletable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_mark_page_halfdead</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>leafbuf</name></decl></parameter>,
								   <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_unlink_halfdead_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>leafbuf</name></decl></parameter>,
									 <parameter><decl><type><name>BlockNumber</name></type> <name>scanblkno</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>rightsib_empty</name></decl></parameter>,
									 <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>oldestBtpoXact</name></decl></parameter>,
									 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>ndeleted</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_lock_subtree_parent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>child</name></decl></parameter>,
									<parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
									<parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>subtreeparent</name></decl></parameter>,
									<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>poffset</name></decl></parameter>,
									<parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>topparent</name></decl></parameter>,
									<parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>topparentrightsib</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 *	_bt_initmetapage() -- Fill a page buffer with a correct metapage image
 */</comment>
<function><type><name>void</name></type>
<name>_bt_initmetapage</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>rootbknum</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>allequalimage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>metaopaque</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>=</operator> <name>BTREE_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>=</operator> <name>BTREE_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>=</operator> <name>rootbknum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>=</operator> <name>rootbknum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name> <operator>=</operator> <name>allequalimage</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>metaopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metaopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_META</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set pd_lower just past the end of the metadata.  This is essential,
	 * because without doing so, metadata will be lost if xlog.c compresses
	 * the page.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metad</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_upgrademetapage() -- Upgrade a meta-page from an old format to version
 *		3, the last version that can be updated without broadly affecting
 *		on-disk compatibility.  (A REINDEX is required to upgrade to v4.)
 *
 *		This routine does purely in-memory image upgrade.  Caller is
 *		responsible for locking, WAL-logging etc.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_upgrademetapage</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name> <name>metaopaque</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metaopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It must be really a meta page of upgradable version */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metaopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;</operator> <name>BTP_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_NOVAC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_MIN_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set version number and fill extra fields added into version 3 */</comment>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>=</operator> <name>BTREE_NOVAC_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>
	<comment type="block">/* Only a REINDEX can set this field */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Adjust pd_lower (see _bt_initmetapage() for details) */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metad</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get metadata from share-locked buffer containing metapage, while performing
 * standard sanity checks.
 *
 * Callers that cache data returned here in local cache should note that an
 * on-the-fly upgrade using _bt_upgrademetapage() can change the version field
 * and BTREE_NOVAC_VERSION specific fields without invalidating local cache.
 */</comment>
<function><type><specifier>static</specifier> <name>BTMetaPageData</name> <modifier>*</modifier></type>
<name>_bt_getmeta</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>metaopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metaopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sanity-check the metapage */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISMETA</name><argument_list>(<argument><expr><name>metaopaque</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>metad</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>!=</operator> <name>BTREE_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not a btree"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_MIN_VERSION</name> <operator>||</operator>
		<name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;</operator> <name>BTREE_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version mismatch in index \"%s\": file version %d, "</literal>
						<literal type="string">"current version %d, minimal supported version %d"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name></expr></argument>, <argument><expr><name>BTREE_VERSION</name></expr></argument>, <argument><expr><name>BTREE_MIN_VERSION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>metad</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_update_meta_cleanup_info() -- Update cleanup-related information in
 *									  the metapage.
 *
 *		This routine checks if provided cleanup-related information is matching
 *		to those written in the metapage.  On mismatch, metapage is overwritten.
 *
 *		Postgres 13 ignores btm_last_cleanup_num_heap_tuples value here
 *		following backbranch disabling of vacuum_cleanup_index_scale_factor.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_update_meta_cleanup_info</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>oldestBtpoXact</name></decl></parameter>,
							 <parameter><decl><type><name>float8</name></type> <name>numHeapTuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

	<comment type="block">/* read the metapage and check if it needs rewrite */</comment>
	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't miss chance to upgrade index/metapage when BTREE_MIN_VERSION */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_NOVAC_VERSION</name> <operator>&amp;&amp;</operator>
		<name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name> <operator>==</operator> <name>oldestBtpoXact</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* trade in our read lock for a write lock */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* upgrade meta-page if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_NOVAC_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_upgrademetapage</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* update cleanup-related information */</comment>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name> <operator>=</operator> <name>oldestBtpoXact</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* write wal record if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_btree_metadata</name></type> <name>md</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_NOVAC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>fastroot</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>fastlevel</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>oldest_btpo_xact</name></name> <operator>=</operator> <name>oldestBtpoXact</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* Disabled */</comment>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>allequalimage</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>md</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_btree_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>XLOG_BTREE_META_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_getroot() -- Get the root page of the btree.
 *
 *		Since the root page can move around the btree file, we have to read
 *		its location from the metadata page, and then read the root page
 *		itself.  If no root page exists yet, we have to create one.
 *
 *		The access type parameter (BT_READ or BT_WRITE) controls whether
 *		a new root page will be created or not.  If access = BT_READ,
 *		and no root page exists, we just return InvalidBuffer.  For
 *		BT_WRITE, we try to create the root page if it doesn't exist.
 *		NOTE that the returned root page will have only a read lock set
 *		on it even if access = BT_WRITE!
 *
 *		The returned page is not necessarily the true root --- it could be
 *		a "fast root" (a page that is alone in its level due to deletions).
 *		Also, if the root page is split while we are "in flight" to it,
 *		what we will return is the old root, which is now just the leftmost
 *		page on a probably-not-very-wide level.  For most purposes this is
 *		as good as or better than the true root, so we do not bother to
 *		insist on finding the true root.  We do, however, guarantee to
 *		return a live (not deleted or half-dead) page.
 *
 *		On successful return, the root page is pinned and read-locked.
 *		The metadata page is not locked or pinned on exit.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_bt_getroot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rootbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>rootpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>rootopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rootblkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>rootlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Try to use previously-cached metapage data to find the root.  This
	 * normally saves one buffer access per index search, which is a very
	 * helpful savings in bufmgr traffic and hence contention.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>metad</name> <operator>=</operator> <operator>(</operator><name>BTMetaPageData</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>;</expr_stmt>
		<comment type="block">/* We shouldn't have cached it if any of these fail */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>==</operator> <name>BTREE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_MIN_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;=</operator> <name>BTREE_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name> <operator>||</operator>
			   <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;</operator> <name>BTREE_NOVAC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>!=</operator> <name>P_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rootblkno</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rootblkno</name> <operator>!=</operator> <name>P_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootlevel</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rootblkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since the cache might be stale, we check the page more carefully
		 * here than normal.  We *must* check that it's not deleted. If it's
		 * not alone on its level, then we reject too --- this may be overly
		 * paranoid but better safe than sorry.  Note we don't check P_ISROOT,
		 * because that's not set in a "fast root".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>rootopaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>==</operator> <name>rootlevel</name> <operator>&amp;&amp;</operator>
			<call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>rootopaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>rootopaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK, accept cached page as the root */</comment>
			<return>return <expr><name>rootbuf</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Cache is stale, throw it away */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>_bt_getmeta</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if no root page initialized yet, do it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>==</operator> <name>P_NONE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name></decl>;</decl_stmt>

		<comment type="block">/* If access = BT_READ, caller doesn't want us to create root yet */</comment>
		<if_stmt><if>if <condition>(<expr><name>access</name> <operator>==</operator> <name>BT_READ</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidBuffer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* trade in our read lock for a write lock */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Race condition:	if someone else initialized the metadata between
		 * the time we released the read lock and acquired the write lock, we
		 * must avoid doing it again.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Metadata initialized by someone else.  In order to guarantee no
			 * deadlocks, we have to release the metadata page and start all
			 * over again.  (Is that really true? But it's hardly worth trying
			 * to optimize this case.)
			 */</comment>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>_bt_getroot</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get, initialize, write, and leave a lock of the appropriate type on
		 * the new root page.  Since this is the first page in the tree, it's
		 * a leaf as well as the root.
		 */</comment>
		<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootblkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <operator>(</operator><name>BTP_LEAF</name> <operator>|</operator> <name>BTP_ROOT</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Get raw page pointer for metapage */</comment>
		<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* NO ELOG(ERROR) till meta is updated */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* upgrade metapage if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_NOVAC_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_upgrademetapage</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>=</operator> <name>rootblkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>=</operator> <name>rootblkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XLOG stuff */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_btree_newroot</name></type> <name>xlrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xl_btree_metadata</name></type> <name>md</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rootbuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_NOVAC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>md</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>md</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>rootblkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>md</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>md</name><operator>.</operator><name>fastroot</name></name> <operator>=</operator> <name>rootblkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>md</name><operator>.</operator><name>fastlevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>md</name><operator>.</operator><name>oldest_btpo_xact</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>md</name><operator>.</operator><name>last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>md</name><operator>.</operator><name>allequalimage</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>md</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_btree_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>rootblk</name></name> <operator>=</operator> <name>rootblkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBtreeNewroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>XLOG_BTREE_NEWROOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * swap root write lock for read lock.  There is no danger of anyone
		 * else accessing the new root page while it's unlocked, since no one
		 * else knows where it is yet.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* okay, metadata is correct, release lock on it without caching */</comment>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rootblkno</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rootblkno</name> <operator>!=</operator> <name>P_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootlevel</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Cache the metapage data for next time
		 */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr></argument>, <argument><expr><name>metad</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are done with the metapage; arrange to release it via first
		 * _bt_relandgetbuf call
		 */</comment>
		<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <name>metabuf</name></expr>;</expr_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rootbuf</name></expr></argument>, <argument><expr><name>rootblkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rootpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rootopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>rootopaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* it's dead, Jim.  step right one page */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>rootopaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no live root page found in index \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>rootblkno</name> <operator>=</operator> <name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Note: can't check btpo.level on deleted pages */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>!=</operator> <name>rootlevel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"root page %u of index \"%s\" has level %u, expected %u"</literal></expr></argument>,
				 <argument><expr><name>rootblkno</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><name>rootlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * By here, we have a pin and read lock on the root page, and no lock set
	 * on the metadata page.  Return the root page's buffer.
	 */</comment>
	<return>return <expr><name>rootbuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_gettrueroot() -- Get the true root page of the btree.
 *
 *		This is the same as the BT_READ case of _bt_getroot(), except
 *		we follow the true-root link not the fast-root link.
 *
 * By the time we acquire lock on the root page, it might have been split and
 * not be the true root anymore.  This is okay for the present uses of this
 * routine; we only really need to be able to move up at least one tree level
 * from whatever non-root page we were at.  If we ever do need to lock the
 * one true root page, we could loop here, re-reading the metapage on each
 * failure.  (Note that it wouldn't do to hold the lock on the metapage while
 * moving to the root --- that'd deadlock against any concurrent root split.)
 */</comment>
<function><type><name>Buffer</name></type>
<name>_bt_gettrueroot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>metaopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rootbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>rootpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>rootopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rootblkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>rootlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't try to use cached metapage data here, since (a) this path is
	 * not performance-critical, and (b) if we are here it suggests our cache
	 * is out-of-date anyway.  In light of point (b), it's probably safest to
	 * actively flush any cached metapage info.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metaopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISMETA</name><argument_list>(<argument><expr><name>metaopaque</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>metad</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>!=</operator> <name>BTREE_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not a btree"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_MIN_VERSION</name> <operator>||</operator>
		<name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;</operator> <name>BTREE_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version mismatch in index \"%s\": file version %d, "</literal>
						<literal type="string">"current version %d, minimal supported version %d"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name></expr></argument>, <argument><expr><name>BTREE_VERSION</name></expr></argument>, <argument><expr><name>BTREE_MIN_VERSION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if no root page initialized yet, fail */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>==</operator> <name>P_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidBuffer</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rootblkno</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rootlevel</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We are done with the metapage; arrange to release it via first
	 * _bt_relandgetbuf call
	 */</comment>
	<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <name>metabuf</name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rootbuf</name></expr></argument>, <argument><expr><name>rootblkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>rootopaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* it's dead, Jim.  step right one page */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>rootopaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no live root page found in index \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rootblkno</name> <operator>=</operator> <name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Note: can't check btpo.level on deleted pages */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>!=</operator> <name>rootlevel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"root page %u of index \"%s\" has level %u, expected %u"</literal></expr></argument>,
			 <argument><expr><name>rootblkno</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><name>rootlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>rootbuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_getrootheight() -- Get the height of the btree search tree.
 *
 *		We return the level (counting from zero) of the current fast root.
 *		This represents the number of tree levels we'd have to descend through
 *		to start any btree index search.
 *
 *		This is used by the planner for cost-estimation purposes.  Since it's
 *		only an estimate, slightly-stale data is fine, hence we don't worry
 *		about updating previously cached data.
 */</comment>
<function><type><name>int</name></type>
<name>_bt_getrootheight</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>_bt_getmeta</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there's no root page yet, _bt_getroot() doesn't expect a cache
		 * to be made, so just stop here and report the index height is zero.
		 * (XXX perhaps _bt_getroot() should be changed to allow this case.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>==</operator> <name>P_NONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Cache the metapage data for next time
		 */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr></argument>, <argument><expr><name>metad</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get cached page */</comment>
	<expr_stmt><expr><name>metad</name> <operator>=</operator> <operator>(</operator><name>BTMetaPageData</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>;</expr_stmt>
	<comment type="block">/* We shouldn't have cached it if any of these fail */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>==</operator> <name>BTREE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_MIN_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;=</operator> <name>BTREE_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name> <operator>||</operator>
		   <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;</operator> <name>BTREE_NOVAC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>!=</operator> <name>P_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_metaversion() -- Get version/status info from metapage.
 *
 *		Sets caller's *heapkeyspace and *allequalimage arguments using data
 *		from the B-Tree metapage (could be locally-cached version).  This
 *		information needs to be stashed in insertion scankey, so we provide a
 *		single function that fetches both at once.
 *
 *		This is used to determine the rules that must be used to descend a
 *		btree.  Version 4 indexes treat heap TID as a tiebreaker attribute.
 *		pg_upgrade'd version 3 indexes need extra steps to preserve reasonable
 *		performance when inserting a new BTScanInsert-wise duplicate tuple
 *		among many leaf pages already full of such duplicates.
 *
 *		Also sets allequalimage field, which indicates whether or not it is
 *		safe to apply deduplication.  We rely on the assumption that
 *		btm_allequalimage will be zero'ed on heapkeyspace indexes that were
 *		pg_upgrade'd from Postgres 12.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_metaversion</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>heapkeyspace</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allequalimage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>_bt_getmeta</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there's no root page yet, _bt_getroot() doesn't expect a cache
		 * to be made, so just stop here.  (XXX perhaps _bt_getroot() should
		 * be changed to allow this case.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>==</operator> <name>P_NONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>heapkeyspace</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;</operator> <name>BTREE_NOVAC_VERSION</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>allequalimage</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Cache the metapage data for next time
		 *
		 * An on-the-fly version upgrade performed by _bt_upgrademetapage()
		 * can change the nbtree version for an index without invalidating any
		 * local cache.  This is okay because it can only happen when moving
		 * from version 2 to version 3, both of which are !heapkeyspace
		 * versions.
		 */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr></argument>, <argument><expr><name>metad</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get cached page */</comment>
	<expr_stmt><expr><name>metad</name> <operator>=</operator> <operator>(</operator><name>BTMetaPageData</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>;</expr_stmt>
	<comment type="block">/* We shouldn't have cached it if any of these fail */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>==</operator> <name>BTREE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_MIN_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;=</operator> <name>BTREE_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name> <operator>||</operator>
		   <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;</operator> <name>BTREE_NOVAC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>!=</operator> <name>P_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>heapkeyspace</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;</operator> <name>BTREE_NOVAC_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>allequalimage</name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_checkpage() -- Verify that a freshly-read page looks sane.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_checkpage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * ReadBuffer verifies that every newly-read page passes
	 * PageHeaderIsValid, which means it either contains a reasonably sane
	 * page header or is all-zero.  We have to defend against the all-zero
	 * case, however.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains unexpected zero page at block %u"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Additionally check that the special area looks sane.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageGetSpecialSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains corrupted page at block %u"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Log the reuse of a page from the FSM.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_log_reuse_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_btree_reuse_page</name></type> <name>xlrec_reuse</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note that we don't register the buffer with the record, because this
	 * operation doesn't modify the page. This record only exists to provide a
	 * conflict point for Hot Standby.
	 */</comment>

	<comment type="block">/* XLOG stuff */</comment>
	<expr_stmt><expr><name><name>xlrec_reuse</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec_reuse</name><operator>.</operator><name>block</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec_reuse</name><operator>.</operator><name>latestRemovedXid</name></name> <operator>=</operator> <name>latestRemovedXid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec_reuse</name></expr></argument>, <argument><expr><name>SizeOfBtreeReusePage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>XLOG_BTREE_REUSE_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_getbuf() -- Get a buffer by block number for read or write.
 *
 *		blkno == P_NEW means to get an unallocated index page.  The page
 *		will be initialized before returning it.
 *
 *		When this routine returns, the appropriate lock is set on the
 *		requested buffer and its reference count has been incremented
 *		(ie, the buffer is "locked and pinned").  Also, we apply
 *		_bt_checkpage to sanity-check the page (except in P_NEW case).
 */</comment>
<function><type><name>Buffer</name></type>
<name>_bt_getbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>!=</operator> <name>P_NEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Read an existing block of the relation */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>needLock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>access</name> <operator>==</operator> <name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * First see if the FSM knows of any free pages.
		 *
		 * We can't trust the FSM's report unreservedly; we have to check that
		 * the page is still free.  (For example, an already-free page could
		 * have been re-used between the time the last VACUUM scanned it and
		 * the time the VACUUM made its FSM updates.)
		 *
		 * In fact, it's worse than that: we can't even assume that it's safe
		 * to take a lock on the reported page.  If somebody else has a lock
		 * on it, or even worse our own caller does, we could deadlock.  (The
		 * own-caller scenario is actually not improbable. Consider an index
		 * on a serial or timestamp column.  Nearly all splits will be at the
		 * rightmost page, so it's entirely likely that _bt_split will call us
		 * while holding a lock on the page most recently acquired from FSM. A
		 * VACUUM running concurrently with the previous split could well have
		 * placed that page back in FSM.)
		 *
		 * To get around that, we ask for only a conditional lock on the
		 * reported page.  If we fail, then someone else is using the page,
		 * and we may reasonably assume it's not free.  (If we happen to be
		 * wrong, the worst consequence is the page will be lost to use till
		 * the next VACUUM, which is no big problem.)
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>GetFreeIndexPage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ConditionalLockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>_bt_page_recyclable</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If we are generating WAL for Hot Standby then create a
					 * WAL record that will allow us to conflict with queries
					 * running on standby, in case they have snapshots older
					 * than btpo.xact.  This can only apply if the page does
					 * have a valid btpo.xact value, ie not if it's new.  (We
					 * must check that because an all-zero page has no special
					 * space.)
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>XLogStandbyInfoActive</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>_bt_log_reuse_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>xact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Okay to use page.  Re-initialize and return it */</comment>
					<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>buf</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"FSM returned nonrecyclable page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"FSM returned nonlockable page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* couldn't get lock, so just drop pin */</comment>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Extend the relation by one page.
		 *
		 * We have to use a lock to ensure no one else is extending the rel at
		 * the same time, else we will both try to initialize the same new
		 * page.  We can skip locking for new or temp relations, however,
		 * since no one else could be accessing them.
		 */</comment>
		<expr_stmt><expr><name>needLock</name> <operator>=</operator> <operator>!</operator><call><name>RELATION_IS_LOCAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Acquire buffer lock on new page */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Release the file-extension lock; it's now OK for someone else to
		 * extend the relation some more.  Note that we cannot release this
		 * lock before we have buffer lock on the new page, or we risk a race
		 * condition against btvacuumscan --- see comments therein.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Initialize the new page before returning it */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* ref count and lock type are correct */</comment>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_relandgetbuf() -- release a locked buffer and get another one.
 *
 * This is equivalent to _bt_relbuf followed by _bt_getbuf, with the
 * exception that blkno may not be P_NEW.  Also, if obuf is InvalidBuffer
 * then it reduces to just _bt_getbuf; allowing this case simplifies some
 * callers.
 *
 * The original motivation for using this was to avoid two entries to the
 * bufmgr when one would do.  However, now it's mainly just a notational
 * convenience.  The only case where it saves work over _bt_relbuf/_bt_getbuf
 * is when the target page is the same one already in the buffer.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_bt_relandgetbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>obuf</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blkno</name> <operator>!=</operator> <name>P_NEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>obuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReleaseAndReadBuffer</name><argument_list>(<argument><expr><name>obuf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_relbuf() -- release a locked buffer.
 *
 * Lock and pin (refcount) are both dropped.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_relbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_pageinit() -- Initialize a new page.
 *
 * On return, the page header is initialized; data space is empty;
 * special space is zeroed out.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_pageinit</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_page_recyclable() -- Is an existing page recyclable?
 *
 * This exists to make sure _bt_getbuf and btvacuumscan have the same
 * policy about whether a page is safe to re-use.  But note that _bt_getbuf
 * knows enough to distinguish the PageIsNew condition from the other one.
 * At some point it might be appropriate to redesign this to have a three-way
 * result value.
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_page_recyclable</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It's possible to find an all-zeroes page in an index --- for example, a
	 * backend might successfully extend the relation one page and then crash
	 * before it is able to make a WAL entry for adding the page. If we find a
	 * zeroed page then reclaim it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, recycle if deleted and too old to have any processes
	 * interested in it.
	 */</comment>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>xact</name></name></expr></argument>, <argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete item(s) from a btree leaf page during VACUUM.
 *
 * This routine assumes that the caller has a super-exclusive write lock on
 * the buffer.  Also, the given deletable and updatable arrays *must* be
 * sorted in ascending order.
 *
 * Routine deals with deleting TIDs when some (but not all) of the heap TIDs
 * in an existing posting list item are to be removed by VACUUM.  This works
 * by updating/overwriting an existing item with caller's new version of the
 * item (a version that lacks the TIDs that are to be deleted).
 *
 * We record VACUUMs and b-tree deletes differently in WAL.  Deletes must
 * generate their own latestRemovedXid by accessing the heap directly, whereas
 * VACUUMs rely on the initial heap scan taking care of it indirectly.  Also,
 * only VACUUM can perform granular deletes of individual TIDs in posting list
 * tuples.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_delitems_vacuum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
					<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>deletable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndeletable</name></decl></parameter>,
					<parameter><decl><type><name>BTVacuumPosting</name> <modifier>*</modifier></type><name>updatable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nupdatable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>updatedbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>updatedbuflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>updatedoffsets</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't be called unless there's something to do */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndeletable</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>nupdatable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nupdatable</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Replace work area IndexTuple with updated version */</comment>
		<expr_stmt><expr><call><name>_bt_update_posting</name><argument_list>(<argument><expr><name><name>updatable</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Maintain array of updatable page offsets for WAL record */</comment>
		<expr_stmt><expr><name><name>updatedoffsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>updatable</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>updatedoffset</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* XLOG stuff -- allocate and fill buffer before critical section */</comment>
	<if_stmt><if>if <condition>(<expr><name>nupdatable</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nupdatable</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTVacuumPosting</name></type> <name>vacposting</name> <init>= <expr><name><name>updatable</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <name>SizeOfBtreeUpdate</name> <operator>+</operator>
				<name><name>vacposting</name><operator>-&gt;</operator><name>ndeletedtids</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>updatedbuflen</name> <operator>+=</operator> <name>itemsz</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>updatedbuf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>updatedbuflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nupdatable</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTVacuumPosting</name></type> <name>vacposting</name> <init>= <expr><name><name>updatable</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xl_btree_update</name></type> <name>update</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>update</name><operator>.</operator><name>ndeletedtids</name></name> <operator>=</operator> <name><name>vacposting</name><operator>-&gt;</operator><name>ndeletedtids</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>updatedbuf</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>update</name><operator>.</operator><name>ndeletedtids</name></name></expr></argument>,
				   <argument><expr><name>SizeOfBtreeUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>SizeOfBtreeUpdate</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <name><name>update</name><operator>.</operator><name>ndeletedtids</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>updatedbuf</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name><name>vacposting</name><operator>-&gt;</operator><name>deletetids</name></name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>itemsz</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No ereport(ERROR) until changes are logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Handle posting tuple updates.
	 *
	 * Deliberately do this before handling simple deletes.  If we did it the
	 * other way around (i.e. WAL record order -- simple deletes before
	 * updates) then we'd have to make compensating changes to the 'updatable'
	 * array of offset numbers.
	 *
	 * PageIndexTupleOverwrite() won't unset each item's LP_DEAD bit when it
	 * happens to already be set.  Although we unset the BTP_HAS_GARBAGE page
	 * level flag, unsetting individual LP_DEAD bits should still be avoided.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nupdatable</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>updatedoffset</name> <init>= <expr><name><name>updatedoffsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itup</name> <operator>=</operator> <name><name>updatable</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>itup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIndexTupleOverwrite</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>updatedoffset</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>,
									 <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to update partially dead item in block %u of index \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Now handle simple deletes of entire tuples */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndeletable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>deletable</name></expr></argument>, <argument><expr><name>ndeletable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can clear the vacuum cycle ID since this page has certainly been
	 * processed by the current vacuum scan.
	 */</comment>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the page as not containing any LP_DEAD items.  This is not
	 * certainly true (there might be some that have recently been marked, but
	 * weren't targeted by VACUUM's heap scan), but it will be true often
	 * enough.  VACUUM does not delete items purely because they have their
	 * LP_DEAD bit set, since doing so would necessitate explicitly logging a
	 * latestRemovedXid cutoff (this is how _bt_delitems_delete works).
	 *
	 * The consequences of falsely unsetting BTP_HAS_GARBAGE should be fairly
	 * limited, since we never falsely unset an LP_DEAD bit.  Workloads that
	 * are particularly dependent on LP_DEAD bits being set quickly will
	 * usually manage to set the BTP_HAS_GARBAGE flag before the page fills up
	 * again anyway.  Furthermore, attempting a deduplication pass will remove
	 * all LP_DEAD items, regardless of whether the BTP_HAS_GARBAGE hint bit
	 * is set or not.
	 */</comment>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_btree_vacuum</name></type> <name>xlrec_vacuum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec_vacuum</name><operator>.</operator><name>ndeleted</name></name> <operator>=</operator> <name>ndeletable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec_vacuum</name><operator>.</operator><name>nupdated</name></name> <operator>=</operator> <name>nupdatable</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec_vacuum</name></expr></argument>, <argument><expr><name>SizeOfBtreeVacuum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ndeletable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>deletable</name></expr></argument>,
								<argument><expr><name>ndeletable</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>nupdatable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>updatedoffsets</name></expr></argument>,
								<argument><expr><name>nupdatable</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>updatedbuf</name></expr></argument>, <argument><expr><name>updatedbuflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>XLOG_BTREE_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* can't leak memory here */</comment>
	<if_stmt><if>if <condition>(<expr><name>updatedbuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>updatedbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* free tuples generated by calling _bt_update_posting() */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nupdatable</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>updatable</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Delete item(s) from a btree leaf page during single-page cleanup.
 *
 * This routine assumes that the caller has pinned and write locked the
 * buffer.  Also, the given deletable array *must* be sorted in ascending
 * order.
 *
 * This is nearly the same as _bt_delitems_vacuum as far as what it does to
 * the page, but it needs to generate its own latestRemovedXid by accessing
 * the heap.  This is used by the REDO routine to generate recovery conflicts.
 * Also, it doesn't handle posting list tuples unless the entire tuple can be
 * deleted as a whole (since there is only one LP_DEAD bit per line pointer).
 */</comment>
<function><type><name>void</name></type>
<name>_bt_delitems_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
					<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>deletable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndeletable</name></decl></parameter>,
					<parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't be called unless there's something to do */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndeletable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogStandbyInfoActive</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>latestRemovedXid</name> <operator>=</operator>
			<call><name>_bt_xid_horizon</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>deletable</name></expr></argument>, <argument><expr><name>ndeletable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* No ereport(ERROR) until changes are logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fix the page */</comment>
	<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>deletable</name></expr></argument>, <argument><expr><name>ndeletable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unlike _bt_delitems_vacuum, we *must not* clear the vacuum cycle ID,
	 * because this is not called by VACUUM.  Just clear the BTP_HAS_GARBAGE
	 * page flag, since we deleted all items with their LP_DEAD bit set.
	 */</comment>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_btree_delete</name></type> <name>xlrec_delete</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec_delete</name><operator>.</operator><name>latestRemovedXid</name></name> <operator>=</operator> <name>latestRemovedXid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec_delete</name><operator>.</operator><name>ndeleted</name></name> <operator>=</operator> <name>ndeletable</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec_delete</name></expr></argument>, <argument><expr><name>SizeOfBtreeDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The deletable array is not in the buffer, but pretend that it is.
		 * When XLogInsert stores the whole buffer, the array need not be
		 * stored too.
		 */</comment>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>deletable</name></expr></argument>,
							<argument><expr><name>ndeletable</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>XLOG_BTREE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the latestRemovedXid from the table entries pointed to by the non-pivot
 * tuples being deleted.
 *
 * This is a specialized version of index_compute_xid_horizon_for_tuples().
 * It's needed because btree tuples don't always store table TID using the
 * standard index tuple header field.
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>_bt_xid_horizon</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
				<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>deletable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndeletable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spacenhtids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nhtids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>htids</name></decl>;</decl_stmt>

	<comment type="block">/* Array will grow iff there are posting list tuples to consider */</comment>
	<expr_stmt><expr><name>spacenhtids</name> <operator>=</operator> <name>ndeletable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nhtids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>htids</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>spacenhtids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndeletable</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>deletable</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BTreeTupleIsPivot</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nhtids</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>spacenhtids</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>spacenhtids</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>htids</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator>
					<call><name>repalloc</name><argument_list>(<argument><expr><name>htids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>spacenhtids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htids</name><index>[<expr><name>nhtids</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nhtids</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nposting</name> <init>= <expr><call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>nhtids</name> <operator>+</operator> <name>nposting</name> <operator>&gt;</operator> <name>spacenhtids</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>spacenhtids</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>spacenhtids</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>nhtids</name> <operator>+</operator> <name>nposting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>htids</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator>
					<call><name>repalloc</name><argument_list>(<argument><expr><name>htids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>spacenhtids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nposting</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ItemPointer</name></type> <name>htid</name> <init>= <expr><call><name>BTreeTupleGetPostingN</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>htid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><name>htid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htids</name><index>[<expr><name>nhtids</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nhtids</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nhtids</name> <operator>&gt;=</operator> <name>ndeletable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>latestRemovedXid</name> <operator>=</operator>
		<call><name>table_compute_xid_horizon_for_tuples</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>htids</name></expr></argument>, <argument><expr><name>nhtids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>htids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>latestRemovedXid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check that leftsib page (the btpo_prev of target page) is not marked with
 * INCOMPLETE_SPLIT flag.  Used during page deletion.
 *
 * Returning true indicates that page flag is set in leftsib (which is
 * definitely still the left sibling of target).  When that happens, the
 * target doesn't have a downlink in parent, and the page deletion algorithm
 * isn't prepared to handle that.  Deletion of the target page (or the whole
 * subtree that contains the target page) cannot take place.
 *
 * Caller should not have a lock on the target page itself, since pages on the
 * same level must always be locked left to right to avoid deadlocks.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_leftsib_splitflag</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>leftsib</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Easy case: No left sibling */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftsib</name> <operator>==</operator> <name>P_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leftsib</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the left sibling was concurrently split, so that its next-pointer
	 * doesn't point to the current page anymore, the split that created
	 * target must be completed.  Caller can reasonably expect that there will
	 * be a downlink to the target page that it can relocate using its stack.
	 * (We don't allow splitting an incompletely split page again until the
	 * previous split has been completed.)
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>==</operator> <name>target</name> <operator>&amp;&amp;</operator> <call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check that leafrightsib page (the btpo_next of target leaf page) is not
 * marked with ISHALFDEAD flag.  Used during page deletion.
 *
 * Returning true indicates that page flag is set in leafrightsib, so page
 * deletion cannot go ahead.  Our caller is not prepared to deal with the case
 * where the parent page does not have a pivot tuples whose downlink points to
 * leafrightsib (due to an earlier interrupted VACUUM operation).  It doesn't
 * seem worth going to the trouble of teaching our caller to deal with it.
 * The situation will be resolved after VACUUM finishes the deletion of the
 * half-dead page (when a future VACUUM operation reaches the target page
 * again).
 *
 * _bt_leftsib_splitflag() is called for both leaf pages and internal pages.
 * _bt_rightsib_halfdeadflag() is only called for leaf pages, though.  This is
 * okay because of the restriction on deleting pages that are the rightmost
 * page of their parent (i.e. that such deletions can only take place when the
 * entire subtree must be deleted).  The leaf level check made here will apply
 * to a right "cousin" leaf page rather than a simple right sibling leaf page
 * in cases where caller actually goes on to attempt deleting pages that are
 * above the leaf page.  The right cousin leaf page is representative of the
 * left edge of the subtree to the right of the to-be-deleted subtree as a
 * whole, which is exactly the condition that our caller cares about.
 * (Besides, internal pages are never marked half-dead, so it isn't even
 * possible to _directly_ assess if an internal page is part of some other
 * to-be-deleted subtree.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_rightsib_halfdeadflag</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>leafrightsib</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leafrightsib</name> <operator>!=</operator> <name>P_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafrightsib</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_pagedel() -- Delete a leaf page from the b-tree, if legal to do so.
 *
 * This action unlinks the leaf page from the b-tree structure, removing all
 * pointers leading to it --- but not touching its own left and right links.
 * The page cannot be physically reclaimed right away, since other processes
 * may currently be trying to follow links leading to the page; they have to
 * be allowed to use its right-link to recover.  See nbtree/README.
 *
 * On entry, the target buffer must be pinned and locked (either read or write
 * lock is OK).  The page must be an empty leaf page, which may be half-dead
 * already (a half-dead page should only be passed to us when an earlier
 * VACUUM operation was interrupted, though).  Note in particular that caller
 * should never pass a buffer containing an existing deleted page here.  The
 * lock and pin on caller's buffer will be dropped before we return.
 *
 * Returns the number of pages successfully deleted (zero if page cannot
 * be deleted now; could be more than one if parent or right sibling pages
 * were deleted too).  Note that this does not include pages that we delete
 * that the btvacuumscan scan has yet to reach; they'll get counted later
 * instead.
 *
 * Maintains *oldestBtpoXact for any pages that get deleted.  Caller is
 * responsible for maintaining *oldestBtpoXact in the case of pages that were
 * deleted by a previous VACUUM.
 *
 * NOTE: this leaks memory.  Rather than trying to clean up everything
 * carefully, it's better to run it in a temp context that can be reset
 * frequently.
 */</comment>
<function><type><name>uint32</name></type>
<name>_bt_pagedel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>leafbuf</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>oldestBtpoXact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>ndeleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rightsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rightsib_empty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Save original leafbuf block number from caller.  Only deleted blocks
	 * that are &lt;= scanblkno get counted in ndeleted return value.
	 */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>scanblkno</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * "stack" is a search stack leading (approximately) to the target page.
	 * It is initially NULL, but when iterating, we keep it to avoid
	 * duplicated search effort.
	 *
	 * Also, when "stack" is not NULL, we have already checked that the
	 * current page is not the right half of an incomplete split, i.e. the
	 * left sibling does not have its INCOMPLETE_SPLIT flag set, including
	 * when the current target page is to the right of caller's initial page
	 * (the scanblkno page).
	 */</comment>
	<decl_stmt><decl><type><name>BTStack</name></type>		<name>stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Internal pages are never deleted directly, only as part of deleting
		 * the whole subtree all the way down to leaf level.
		 *
		 * Also check for deleted pages here.  Caller never passes us a fully
		 * deleted page.  Only VACUUM can delete pages, so there can't have
		 * been a concurrent deletion.  Assume that we reached any deleted
		 * page encountered here by following a sibling link, and that the
		 * index is corrupt.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Pre-9.4 page deletion only marked internal pages as half-dead,
			 * but now we only use that flag on leaf pages. The old algorithm
			 * was never supposed to leave half-dead pages in the tree, it was
			 * just a transient state, but it was nevertheless possible in
			 * error scenarios. We don't know how to deal with them here. They
			 * are harmless as far as searches are considered, but inserts
			 * into the deleted keyspace could add out-of-order downlinks in
			 * the upper levels. Log a notice, hopefully the admin will notice
			 * and reindex.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains a half-dead internal page"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This can be caused by an interrupted VACUUM in version 9.3 or older, before upgrade. Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"found deleted block %u while following right link from block %u in index \"%s\""</literal></expr></argument>,
										 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>scanblkno</name></expr></argument>,
										 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>ndeleted</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We can never delete rightmost pages nor root pages.  While at it,
		 * check that page is empty, since it's possible that the leafbuf page
		 * was empty a moment ago, but has since had some inserts.
		 *
		 * To keep the algorithm simple, we also never delete an incompletely
		 * split page (they should be rare enough that this doesn't make any
		 * meaningful difference to disk usage):
		 *
		 * The INCOMPLETE_SPLIT flag on the page tells us if the page is the
		 * left half of an incomplete split, but ensuring that it's not the
		 * right half is more complicated.  For that, we have to check that
		 * the left sibling doesn't have its INCOMPLETE_SPLIT flag set using
		 * _bt_leftsib_splitflag().  On the first iteration, we temporarily
		 * release the lock on scanblkno/leafbuf, check the left sibling, and
		 * construct a search stack to scanblkno.  On subsequent iterations,
		 * we know we stepped right from a page that passed these tests, so
		 * it's OK.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>P_ISROOT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Should never fail to delete a half-dead page */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>ndeleted</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * First, remove downlink pointing to the page (or a parent of the
		 * page, if we are going to delete a taller subtree), and mark the
		 * leafbuf page half-dead
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We need an approximate pointer to the page's parent page.  We
			 * use a variant of the standard search mechanism to search for
			 * the page's high key; this will give us a link to either the
			 * current parent or someplace to its left (if there are multiple
			 * equal high keys, which is possible with !heapkeyspace indexes).
			 *
			 * Also check if this is the right-half of an incomplete split
			 * (see comment above).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stack</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>itup_key</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>targetkey</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftsib</name></decl>,
							<decl><type ref="prev"/><name>leafblkno</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Buffer</name></type>		<name>sleafbuf</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>targetkey</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>leftsib</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>leafblkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * To avoid deadlocks, we'd better drop the leaf page lock
				 * before going further.
				 */</comment>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Check that the left sibling of leafbuf (if any) is not
				 * marked with INCOMPLETE_SPLIT flag before proceeding
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leafblkno</name> <operator>==</operator> <name>scanblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>_bt_leftsib_splitflag</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leftsib</name></expr></argument>, <argument><expr><name>leafblkno</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>ndeleted</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* we need an insertion scan key for the search, so build one */</comment>
				<expr_stmt><expr><name>itup_key</name> <operator>=</operator> <call><name>_bt_mkscankey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>targetkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* find the leftmost leaf page with matching pivot/high key */</comment>
				<expr_stmt><expr><name><name>itup_key</name><operator>-&gt;</operator><name>pivotsearch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>_bt_search</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sleafbuf</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* won't need a second lock or pin on leafbuf */</comment>
				<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sleafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Re-lock the leaf page, and start over to use our stack
				 * within _bt_mark_page_halfdead.  We must do it that way
				 * because it's possible that leafbuf can no longer be
				 * deleted.  We need to recheck.
				 *
				 * Note: We can't simply hold on to the sleafbuf lock instead,
				 * because it's barely possible that sleafbuf is not the same
				 * page as leafbuf.  This happens when leafbuf split after our
				 * original lock was dropped, but before _bt_search finished
				 * its descent.  We rely on the assumption that we'll find
				 * leafbuf isn't safe to delete anymore in this scenario.
				 * (Page deletion can cope with the stack being to the left of
				 * leafbuf, but not to the right of leafbuf.)
				 */</comment>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * See if it's safe to delete the leaf page, and determine how
			 * many parent/internal pages above the leaf level will be
			 * deleted.  If it's safe then _bt_mark_page_halfdead will also
			 * perform the first phase of deletion, which includes marking the
			 * leafbuf page half-dead.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_mark_page_halfdead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>ndeleted</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Then unlink it from its siblings.  Each call to
		 * _bt_unlink_halfdead_page unlinks the topmost page from the subtree,
		 * making it shallower.  Iterate until the leafbuf page is deleted.
		 *
		 * _bt_unlink_halfdead_page should never fail, since we established
		 * that deletion is generally safe in _bt_mark_page_halfdead.
		 */</comment>
		<expr_stmt><expr><name>rightsib_empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check for interrupts in _bt_unlink_halfdead_page */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_unlink_halfdead_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>, <argument><expr><name>scanblkno</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>rightsib_empty</name></expr></argument>, <argument><expr><name>oldestBtpoXact</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>ndeleted</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* _bt_unlink_halfdead_page failed, released buffer */</comment>
				<return>return <expr><name>ndeleted</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>xact</name></name></expr></argument>,
											<argument><expr><operator>*</operator><name>oldestBtpoXact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rightsib</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check here, as calling loops will have locks held, preventing
		 * interrupts from being processed.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The page has now been deleted. If its right sibling is completely
		 * empty, it's possible that the reason we haven't deleted it earlier
		 * is that it was the rightmost child of the parent. Now that we
		 * removed the downlink for this page, the right sibling might now be
		 * the only child of the parent, and could be removed. It would be
		 * picked up by the next vacuum anyway, but might as well try to
		 * remove it now, so loop back to process the right sibling.
		 *
		 * Note: This relies on the assumption that _bt_getstackbuf() will be
		 * able to reuse our original descent stack with a different child
		 * block (provided that the child block is to the right of the
		 * original leaf page reached by _bt_search()). It will even update
		 * the descent stack each time we loop around, avoiding repeated work.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rightsib_empty</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>leafbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rightsib</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>ndeleted</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * First stage of page deletion.
 *
 * Establish the height of the to-be-deleted subtree with leafbuf at its
 * lowest level, remove the downlink to the subtree, and mark leafbuf
 * half-dead.  The final to-be-deleted subtree is usually just leafbuf itself,
 * but may include additional internal pages (at most one per level of the
 * tree below the root).
 *
 * Returns 'false' if leafbuf is unsafe to delete, usually because leafbuf is
 * the rightmost child of its parent (and parent has more than one downlink).
 * Returns 'true' when the first stage of page deletion completed
 * successfully.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_mark_page_halfdead</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>leafbuf</name></decl></parameter>, <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leafblkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leafrightsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>topparent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>topparentrightsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>subtreeparent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>poffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>nextoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTupleData</name></type> <name>trunctuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISROOT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save info about the leaf page.
	 */</comment>
	<expr_stmt><expr><name>leafblkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafrightsib</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before attempting to lock the parent page, check that the right sibling
	 * is not in half-dead state.  A half-dead right sibling would have no
	 * downlink in the parent, which would be highly confusing later when we
	 * delete the downlink.  It would fail the "right sibling of target page
	 * is also the next child in parent page" cross-check below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>_bt_rightsib_halfdeadflag</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafrightsib</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"could not delete page %u because its right sibling %u is half-dead"</literal></expr></argument>,
			 <argument><expr><name>leafblkno</name></expr></argument>, <argument><expr><name>leafrightsib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We cannot delete a page that is the rightmost child of its immediate
	 * parent, unless it is the only child --- in which case the parent has to
	 * be deleted too, and the same condition applies recursively to it. We
	 * have to check this condition all the way up before trying to delete,
	 * and lock the parent of the root of the to-be-deleted subtree (the
	 * "subtree parent").  _bt_lock_subtree_parent() locks the subtree parent
	 * for us.  We remove the downlink to the "top parent" page (subtree root
	 * page) from the subtree parent page below.
	 *
	 * Initialize topparent to be leafbuf page now.  The final to-be-deleted
	 * subtree is often a degenerate one page subtree consisting only of the
	 * leafbuf page.  When that happens, the leafbuf page is the final subtree
	 * root page/top parent page.
	 */</comment>
	<expr_stmt><expr><name>topparent</name> <operator>=</operator> <name>leafblkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>topparentrightsib</name> <operator>=</operator> <name>leafrightsib</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_lock_subtree_parent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafblkno</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>subtreeparent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>poffset</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>topparent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>topparentrightsib</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the parent-page index items we're about to delete/overwrite
	 * in subtree parent page contain what we expect.  This can fail if the
	 * index has become corrupt for some reason.  We want to throw any error
	 * before entering the critical section --- otherwise it'd be a PANIC.
	 */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>subtreeparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

	<comment type="block">/*
	 * This is just an assertion because _bt_lock_subtree_parent should have
	 * guaranteed tuple has the expected contents
	 */</comment>
	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>topparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>nextoffset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>nextoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BTreeTupleGetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>topparentrightsib</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"right sibling %u of block %u is not next child %u of block %u in index \"%s\""</literal></expr></argument>,
								 <argument><expr><name>topparentrightsib</name></expr></argument>, <argument><expr><name>topparent</name></expr></argument>,
								 <argument><expr><call><name>BTreeTupleGetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>subtreeparent</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Any insert which would have gone on the leaf block will now go to its
	 * right sibling.  In other words, the key space moves right.
	 */</comment>
	<expr_stmt><expr><call><name>PredicateLockPageCombine</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafblkno</name></expr></argument>, <argument><expr><name>leafrightsib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No ereport(ERROR) until changes are logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update parent of subtree.  We want to delete the downlink to the top
	 * parent page/root of the subtree, and the *following* key.  Easiest way
	 * is to copy the right sibling's downlink over the downlink that points
	 * to top parent page, and then delete the right sibling's original pivot
	 * tuple.
	 *
	 * Lanin and Shasha make the key space move left when deleting a page,
	 * whereas the key space moves right here.  That's why we cannot simply
	 * delete the pivot tuple with the downlink to the top parent page.  See
	 * nbtree/README.
	 */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>subtreeparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTreeTupleSetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>topparentrightsib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nextoffset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>nextoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the leaf page as half-dead, and stamp it with a link to the top
	 * parent page.  When the leaf page is also the top parent page, the link
	 * is set to InvalidBlockNumber.
	 */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_HALF_DEAD</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trunctuple</name><operator>.</operator><name>t_info</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>topparent</name> <operator>!=</operator> <name>leafblkno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTreeTupleSetTopParent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><name>topparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTreeTupleSetTopParent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIndexTupleOverwrite</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <operator>&amp;</operator><name>trunctuple</name></expr></argument>,
								 <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not overwrite high key in half-dead page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Must mark buffers dirty before XLogInsert */</comment>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>subtreeparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_btree_mark_page_halfdead</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>poffset</name></name> <operator>=</operator> <name>poffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>leafblk</name></name> <operator>=</operator> <name>leafblkno</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>topparent</name> <operator>!=</operator> <name>leafblkno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>topparent</name></name> <operator>=</operator> <name>topparent</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>topparent</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>subtreeparent</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>leftblk</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>rightblk</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBtreeMarkPageHalfDead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>XLOG_BTREE_MARK_PAGE_HALFDEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>subtreeparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subtreeparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Second stage of page deletion.
 *
 * Unlinks a single page (in the subtree undergoing deletion) from its
 * siblings.  Also marks the page deleted.
 *
 * To get rid of the whole subtree, including the leaf page itself, call here
 * until the leaf page is deleted.  The original "top parent" established in
 * the first stage of deletion is deleted in the first call here, while the
 * leaf page is deleted in the last call here.  Note that the leaf page itself
 * is often the initial top parent page.
 *
 * Returns 'false' if the page could not be unlinked (shouldn't happen).  If
 * the right sibling of the current target page is empty, *rightsib_empty is
 * set to true, allowing caller to delete the target's right sibling page in
 * passing.  Note that *rightsib_empty is only actually used by caller when
 * target page is leafbuf, following last call here for leafbuf/the subtree
 * containing leafbuf.  (We always set *rightsib_empty for caller, just to be
 * consistent.)
 *
 * We maintain *oldestBtpoXact for pages that are deleted by the current
 * VACUUM operation here.  This must be handled here because we conservatively
 * assume that there needs to be a new call to ReadNewTransactionId() each
 * time a page gets deleted.  See comments about the underlying assumption
 * below.
 *
 * Must hold pin and lock on leafbuf at entry (read or write doesn't matter).
 * On success exit, we'll be holding pin and write lock.  On failure exit,
 * we'll release both pin and lock before returning (we define it that way
 * to avoid having to reacquire a lock we already released).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_unlink_halfdead_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>leafbuf</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>scanblkno</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>rightsib_empty</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>oldestBtpoXact</name></decl></parameter>,
						 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>ndeleted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leafblkno</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leafleftsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leafrightsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rightsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>lbuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rightsib_is_rightmost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>targetlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>leafhikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nextchild</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember some information about the leaf page.
	 */</comment>
	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafhikey</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>BTreeTupleGetTopParent</name><argument_list>(<argument><expr><name>leafhikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafleftsib</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafrightsib</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check here, as calling loops will have locks held, preventing
	 * interrupts from being processed.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unlink the current top parent of the subtree */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Target is leaf page (or leaf page is top parent, if you prefer) */</comment>
		<expr_stmt><expr><name>target</name> <operator>=</operator> <name>leafblkno</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>leafbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>leftsib</name> <operator>=</operator> <name>leafleftsib</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetlevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Target is the internal page taken from leaf's top parent link */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>target</name> <operator>!=</operator> <name>leafblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fetch the block number of the target's left sibling */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>leftsib</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetlevel</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetlevel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * To avoid deadlocks, we'd better drop the target page lock before
		 * going further.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We have to lock the pages we need to modify in the standard order:
	 * moving right, then up.  Else we will deadlock against other writers.
	 *
	 * So, first lock the leaf page, if it's not the target.  Then find and
	 * write-lock the current left sibling of the target page.  The sibling
	 * that was current a moment ago could have split, so we may have to move
	 * right.  This search could fail if either the sibling or the target page
	 * was deleted by someone else meanwhile; if so, give up.  (Right now,
	 * that should never happen, since page deletion is only done in VACUUM
	 * and there shouldn't be multiple VACUUMs concurrently on the same
	 * table.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>leafblkno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>leftsib</name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leftsib</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>!=</operator> <name>target</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* step right one page */</comment>
			<expr_stmt><expr><name>leftsib</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * It'd be good to check for interrupts here, but it's not easy to
			 * do so because a lock is always held. This block isn't
			 * frequently reached, so hopefully the consequences of not
			 * checking interrupts aren't too bad.
			 */</comment>

			<if_stmt><if>if <condition>(<expr><name>leftsib</name> <operator>==</operator> <name>P_NONE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"no left sibling (concurrent deletion?) of block %u in \"%s\""</literal></expr></argument>,
					 <argument><expr><name>target</name></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>leafblkno</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* we have only a pin on target, but pin+lock on leafbuf */</comment>
					<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* we have only a pin on leafbuf */</comment>
					<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>lbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leftsib</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Next write-lock the target page itself.  It's okay to take a write lock
	 * rather than a superexclusive lock, since no scan will stop on an empty
	 * page.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check page is still empty etc, else abandon deletion.  This is just for
	 * paranoia's sake; a half-dead page cannot resurrect because there can be
	 * only one vacuum process running at a time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>P_ISROOT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"half-dead page changed status unexpectedly in block %u of index \"%s\""</literal></expr></argument>,
			 <argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>!=</operator> <name>leftsib</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"left link changed unexpectedly in block %u of index \"%s\""</literal></expr></argument>,
								 <argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>target</name> <operator>==</operator> <name>leafblkno</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"half-dead page changed status unexpectedly in block %u of index \"%s\""</literal></expr></argument>,
				 <argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>nextchild</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"half-dead page changed status unexpectedly in block %u of index \"%s\""</literal></expr></argument>,
				 <argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Remember the next non-leaf child down in the subtree */</comment>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextchild</name> <operator>=</operator> <call><name>BTreeTupleGetDownLink</name><argument_list>(<argument><expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nextchild</name> <operator>==</operator> <name>leafblkno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextchild</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * And next write-lock the (current) right sibling.
	 */</comment>
	<expr_stmt><expr><name>rightsib</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rightsib</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>!=</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"right sibling's left-link doesn't match: "</literal>
								 <literal type="string">"block %u links to %u instead of expected %u in index \"%s\""</literal></expr></argument>,
								 <argument><expr><name>rightsib</name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rightsib_is_rightmost</name> <operator>=</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>rightsib_empty</name> <operator>=</operator> <operator>(</operator><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are deleting the next-to-last page on the target's level, then
	 * the rightsib is a candidate to become the new fast root. (In theory, it
	 * might be possible to push the fast root even further down, but the odds
	 * of doing so are slim, and the locking considerations daunting.)
	 *
	 * We can safely acquire a lock on the metapage here --- see comments for
	 * _bt_newroot().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftsib</name> <operator>==</operator> <name>P_NONE</name> <operator>&amp;&amp;</operator> <name>rightsib_is_rightmost</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* rightsib will be the only one left on the level */</comment>
			<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The expected case here is btm_fastlevel == targetlevel+1; if
			 * the fastlevel is &lt;= targetlevel, something is wrong, and we
			 * choose to overwrite it to fix it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>&gt;</operator> <name>targetlevel</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no update wanted */</comment>
				<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Here we begin doing the deletion.
	 */</comment>

	<comment type="block">/* No ereport(ERROR) until changes are logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update siblings' side-links.  Note the target page's side-links will
	 * continue to point to the siblings.  Asserts here are just rechecking
	 * things we already verified above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>==</operator> <name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rightsib</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>==</operator> <name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>leftsib</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we deleted a parent of the targeted leaf page, instead of the leaf
	 * itself, update the leaf to point to the next remaining child in the
	 * subtree.
	 *
	 * Note: We rely on the fact that a buffer pin on the leaf page has been
	 * held since leafhikey was initialized.  This is safe, though only
	 * because the page was already half-dead at that point.  The leaf page
	 * cannot have been modified by any other backend during the period when
	 * no lock was held.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>leafblkno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BTreeTupleSetTopParent</name><argument_list>(<argument><expr><name>leafhikey</name></expr></argument>, <argument><expr><name>nextchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Mark the page itself deleted.  It can be recycled when all current
	 * transactions are gone.  Storing GetTopTransactionId() would work, but
	 * we're in VACUUM and would not otherwise have an XID.  Having already
	 * updated links to the target, ReadNewTransactionId() suffices as an
	 * upper bound.  Any scan having retained a now-stale link is advertising
	 * in its PGXACT an xmin less than or equal to the value we read here.  It
	 * will continue to do so, holding back RecentGlobalXmin, for the duration
	 * of that scan.
	 */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_HALF_DEAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_DELETED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>xact</name></name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And update the metapage, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* upgrade metapage if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_NOVAC_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_upgrademetapage</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>=</operator> <name>rightsib</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>=</operator> <name>targetlevel</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Must mark buffers dirty before XLogInsert */</comment>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>leafblkno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_btree_unlink_page</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_btree_metadata</name></type> <name>xlmeta</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>xlinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>lbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>leafblkno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>leafbuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* information on the unlinked block */</comment>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>leftsib</name></name> <operator>=</operator> <name>leftsib</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>rightsib</name></name> <operator>=</operator> <name>rightsib</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>btpo_xact</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>xact</name></name></expr>;</expr_stmt>

		<comment type="block">/* information needed to recreate the leaf block (if not the target) */</comment>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>leafleftsib</name></name> <operator>=</operator> <name>leafleftsib</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>leafrightsib</name></name> <operator>=</operator> <name>leafrightsib</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>topparent</name></name> <operator>=</operator> <name>nextchild</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBtreeUnlinkPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_NOVAC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>fastroot</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>fastlevel</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>oldest_btpo_xact</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>allequalimage</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlmeta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_btree_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <name>XLOG_BTREE_UNLINK_PAGE_META</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <name>XLOG_BTREE_UNLINK_PAGE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>xlinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>leafblkno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leafbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release metapage */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* release siblings */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>oldestBtpoXact</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>xact</name></name></expr></argument>, <argument><expr><operator>*</operator><name>oldestBtpoXact</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>oldestBtpoXact</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>xact</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If btvacuumscan won't revisit this page in a future btvacuumpage call
	 * and count it as deleted then, we count it as deleted by current
	 * btvacuumpage call
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>target</name> <operator>&lt;=</operator> <name>scanblkno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>ndeleted</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If the target is not leafbuf, we're done with it now -- release it */</comment>
	<if_stmt><if>if <condition>(<expr><name>target</name> <operator>!=</operator> <name>leafblkno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Establish how tall the to-be-deleted subtree will be during the first stage
 * of page deletion.
 *
 * Caller's child argument is the block number of the page caller wants to
 * delete (this is leafbuf's block number, except when we're called
 * recursively).  stack is a search stack leading to it.  Note that we will
 * update the stack entry(s) to reflect current downlink positions --- this is
 * similar to the corresponding point in page split handling.
 *
 * If "first stage" caller cannot go ahead with deleting _any_ pages, returns
 * false.  Returns true on success, in which case caller can use certain
 * details established here to perform the first stage of deletion.  This
 * function is the last point at which page deletion may be deemed unsafe
 * (barring index corruption, or unexpected concurrent page deletions).
 *
 * We write lock the parent of the root of the to-be-deleted subtree for
 * caller on success (i.e. we leave our lock on the *subtreeparent buffer for
 * caller).  Caller will have to remove a downlink from *subtreeparent.  We
 * also set a *subtreeparent offset number in *poffset, to indicate the
 * location of the pivot tuple that contains the relevant downlink.
 *
 * The root of the to-be-deleted subtree is called the "top parent".  Note
 * that the leafbuf page is often the final "top parent" page (you can think
 * of the leafbuf page as a degenerate single page subtree when that happens).
 * Caller should initialize *topparent to the target leafbuf page block number
 * (while *topparentrightsib should be set to leafbuf's right sibling block
 * number).  We will update *topparent (and *topparentrightsib) for caller
 * here, though only when it turns out that caller will delete at least one
 * internal page (i.e. only when caller needs to store a valid link to the top
 * parent block in the leafbuf page using BTreeTupleSetTopParent()).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_lock_subtree_parent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
						<parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>subtreeparent</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>poffset</name></decl></parameter>,
						<parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>topparent</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>topparentrightsib</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>parent</name></decl>,
				<decl><type ref="prev"/><name>leftsibparent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>parentoffset</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>pbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Locate the pivot tuple whose downlink points to "child".  Write lock
	 * the parent page itself.
	 */</comment>
	<expr_stmt><expr><name>pbuf</name> <operator>=</operator> <call><name>_bt_getstackbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pbuf</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"failed to re-find parent key in index \"%s\" for deletion target page %u"</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_blkno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parentoffset</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftsibparent</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * _bt_getstackbuf() completes page splits on returned parent buffer when
	 * required.
	 *
	 * In general it's a bad idea for VACUUM to use up more disk space, which
	 * is why page deletion does not finish incomplete page splits most of the
	 * time.  We allow this limited exception because the risk is much lower,
	 * and the potential downside of not proceeding is much higher:  A single
	 * internal page with the INCOMPLETE_SPLIT flag set might otherwise
	 * prevent us from deleting hundreds of empty leaf pages from one level
	 * down.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>parentoffset</name> <operator>&lt;</operator> <name>maxoff</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Child is not the rightmost child in parent, so it's safe to delete
		 * the subtree whose root/topparent is child page
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>subtreeparent</name> <operator>=</operator> <name>pbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>poffset</name> <operator>=</operator> <name>parentoffset</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Child is the rightmost child of parent.
	 *
	 * Since it's the rightmost child of parent, deleting the child (or
	 * deleting the subtree whose root/topparent is the child page) is only
	 * safe when it's also possible to delete the parent.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parentoffset</name> <operator>==</operator> <name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parentoffset</name> <operator>!=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Child isn't parent's only child, or parent is rightmost on its
		 * entire level.  Definitely cannot delete any pages.
		 */</comment>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now make sure that the parent deletion is itself safe by examining the
	 * child's grandparent page.  Recurse, passing the parent page as the
	 * child page (child's grandparent is the parent on the next level up). If
	 * parent deletion is unsafe, then child deletion must also be unsafe (in
	 * which case caller cannot delete any pages at all).
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>topparent</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>topparentrightsib</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release lock on parent before recursing.
	 *
	 * It's OK to release page locks on parent before recursive call locks
	 * grandparent.  An internal page can only acquire an entry if the child
	 * is split, but that cannot happen as long as we still hold a lock on the
	 * leafbuf page.
	 */</comment>
	<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before recursing, check that the left sibling of parent (if any) is not
	 * marked with INCOMPLETE_SPLIT flag first (must do so after we drop the
	 * parent lock).
	 *
	 * Note: We deliberately avoid completing incomplete splits here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>_bt_leftsib_splitflag</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>leftsibparent</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Recurse to examine child page's grandparent page */</comment>
	<return>return <expr><call><name>_bt_lock_subtree_parent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_parent</name></name></expr></argument>,
								   <argument><expr><name>subtreeparent</name></expr></argument>, <argument><expr><name>poffset</name></expr></argument>,
								   <argument><expr><name>topparent</name></expr></argument>, <argument><expr><name>topparentrightsib</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
