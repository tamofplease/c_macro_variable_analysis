<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/nbtree/nbtdedup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtdedup.c
 *	  Deduplicate items in Postgres btrees.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/nbtree/nbtdedup.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_do_singleval</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BTDedupState</name></type> <name>state</name></decl></parameter>,
							 <parameter><decl><type><name>OffsetNumber</name></type> <name>minoff</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>newitem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_singleval_fillfactor</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BTDedupState</name></type> <name>state</name></decl></parameter>,
									 <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_posting_valid</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>posting</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Deduplicate items on a leaf page.  The page will have to be split by caller
 * if we cannot successfully free at least newitemsz (we also need space for
 * newitem's line pointer, which isn't included in caller's newitemsz).
 *
 * The general approach taken here is to perform as much deduplication as
 * possible to free as much space as possible.  Note, however, that "single
 * value" strategy is sometimes used for !checkingunique callers, in which
 * case deduplication will leave a few tuples untouched at the end of the
 * page.  The general idea is to prepare the page for an anticipated page
 * split that uses nbtsplitloc.c's "single value" strategy to determine a
 * split point.  (There is no reason to deduplicate items that will end up on
 * the right half of the page after the anticipated page split; better to
 * handle those if and when the anticipated right half page gets its own
 * deduplication pass, following further inserts of duplicates.)
 *
 * This function should be called during insertion, when the page doesn't have
 * enough space to fit an incoming newitem.  If the BTP_HAS_GARBAGE page flag
 * was set, caller should have removed any LP_DEAD items by calling
 * _bt_vacuum_one_page() before calling here.  We may still have to kill
 * LP_DEAD items here when the page's BTP_HAS_GARBAGE hint is falsely unset,
 * but that should be rare.  Also, _bt_vacuum_one_page() won't unset the
 * BTP_HAS_GARBAGE flag when it finds no LP_DEAD items, so a successful
 * deduplication pass will always clear it, just to keep things tidy.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_dedup_one_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
				   <parameter><decl><type><name>IndexTuple</name></type> <name>newitem</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkingunique</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>minoff</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>newpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>deletable</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTDedupState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndeletable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name>		<name>pagesaving</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>singlevalstrat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeyatts</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can't assume that there are no LP_DEAD items.  For one thing, VACUUM
	 * will clear the BTP_HAS_GARBAGE hint without reliably removing items
	 * that are marked LP_DEAD.  We don't want to unnecessarily unset LP_DEAD
	 * bits when deduplicating items.  Allowing it would be correct, though
	 * wasteful.
	 */</comment>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>minoff</name></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>deletable</name><index>[<expr><name>ndeletable</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>ndeletable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_bt_delitems_delete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>deletable</name></expr></argument>, <argument><expr><name>ndeletable</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Return when a split will be avoided.  This is equivalent to
		 * avoiding a split using the usual _bt_vacuum_one_page() path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>newitemsz</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Reconsider number of items on page, in case _bt_delitems_delete()
		 * managed to delete an item or two
		 */</comment>
		<expr_stmt><expr><name>minoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Passed-in newitemsz is MAXALIGNED but does not include line pointer */</comment>
	<expr_stmt><expr><name>newitemsz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * By here, it's clear that deduplication will definitely be attempted.
	 * Initialize deduplication state.
	 *
	 * It would be possible for maxpostingsize (limit on posting list tuple
	 * size) to be set to one third of the page.  However, it seems like a
	 * good idea to limit the size of posting lists to one sixth of a page.
	 * That ought to leave us with a good split point when pages full of
	 * duplicates can be split several times.
	 */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>BTDedupState</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTDedupStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>deduplicate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nmaxitems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxpostingsize</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>INDEX_SIZE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Metadata about base tuple of current pending posting list */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>baseoff</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>basetupsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Metadata about current pending posting list TIDs */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>htids</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>maxpostingsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Size of all physical tuples to be replaced by pending posting list */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>phystupsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* nintervals should be initialized to zero */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nintervals</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Determine if "single value" strategy should be used */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>checkingunique</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>singlevalstrat</name> <operator>=</operator> <call><name>_bt_do_singleval</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Deduplicate items from page, and write them to newpage.
	 *
	 * Copy the original page's LSN into newpage copy.  This will become the
	 * updated version of the page.  We need this because XLogInsert will
	 * examine the LSN and possibly dump it in a page image.
	 */</comment>
	<expr_stmt><expr><name>newpage</name> <operator>=</operator> <call><name>PageGetTempPageCopySpecial</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy high key, if any */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>hitemid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>hitemsz</name> <init>= <expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>hitem</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>hitem</name></expr></argument>, <argument><expr><name>hitemsz</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"deduplication failed to add highkey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>minoff</name></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>==</operator> <name>minoff</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No previous/base tuple for the data item -- use the data item
			 * as base tuple of pending posting list
			 */</comment>
			<expr_stmt><expr><call><name>_bt_dedup_start_pending</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>deduplicate</name></name> <operator>&amp;&amp;</operator>
				 <call><name>_bt_keep_natts_fast</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>nkeyatts</name> <operator>&amp;&amp;</operator>
				 <call><name>_bt_dedup_save_htid</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Tuple is equal to base tuple of pending posting list.  Heap
			 * TID(s) for itup have been saved in state.
			 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Tuple is not equal to pending posting list tuple, or
			 * _bt_dedup_save_htid() opted to not merge current item into
			 * pending posting list for some other reason (e.g., adding more
			 * TIDs would have caused posting list to exceed current
			 * maxpostingsize).
			 *
			 * If state contains pending posting list with more than one item,
			 * form new posting tuple, and actually update the page.  Else
			 * reset the state and move on without modifying the page.
			 */</comment>
			<expr_stmt><expr><name>pagesaving</name> <operator>+=</operator> <call><name>_bt_dedup_finish_pending</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>singlevalstrat</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Single value strategy's extra steps.
				 *
				 * Lower maxpostingsize for sixth and final large posting list
				 * tuple at the point where 5 maxpostingsize-capped tuples
				 * have either been formed or observed.
				 *
				 * When a sixth maxpostingsize-capped item is formed/observed,
				 * stop merging together tuples altogether.  The few tuples
				 * that remain at the end of the page won't be merged together
				 * at all (at least not until after a future page split takes
				 * place).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nmaxitems</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>_bt_singleval_fillfactor</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nmaxitems</name></name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>deduplicate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>singlevalstrat</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* won't be back here */</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* itup starts new pending posting list */</comment>
			<expr_stmt><expr><call><name>_bt_dedup_start_pending</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Handle the last item */</comment>
	<expr_stmt><expr><name>pagesaving</name> <operator>+=</operator> <call><name>_bt_dedup_finish_pending</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If no items suitable for deduplication were found, newpage must be
	 * exactly the same as the original page, so just return from function.
	 *
	 * We could determine whether or not to proceed on the basis the space
	 * savings being sufficient to avoid an immediate page split instead.  We
	 * don't do that because there is some small value in nbtsplitloc.c always
	 * operating against a page that is fully deduplicated (apart from
	 * newitem).  Besides, most of the cost has already been paid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nintervals</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cannot leak memory here */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>htids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * By here, it's clear that deduplication will definitely go ahead.
	 *
	 * Clear the BTP_HAS_GARBAGE page flag in the unlikely event that it is
	 * still falsely set, just to keep things tidy.  (We can't rely on
	 * _bt_vacuum_one_page() having done this already, and we can't rely on a
	 * page split or VACUUM getting to it in the near future.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_HAS_GARBAGE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>nopaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageRestoreTempPage</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_btree_dedup</name></type> <name>xlrec_dedup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec_dedup</name><operator>.</operator><name>nintervals</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>nintervals</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec_dedup</name></expr></argument>, <argument><expr><name>SizeOfBtreeDedup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The intervals array is not in the buffer, but pretend that it is.
		 * When XLogInsert stores the whole buffer, the array need not be
		 * stored too.
		 */</comment>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>intervals</name></name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nintervals</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTDedupInterval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>XLOG_BTREE_DEDUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Local space accounting should agree with page accounting */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pagesaving</name> <operator>&lt;</operator> <name>newitemsz</name> <operator>||</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>newitemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cannot leak memory here */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>htids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new pending posting list tuple based on caller's base tuple.
 *
 * Every tuple processed by deduplication either becomes the base tuple for a
 * posting list, or gets its heap TID(s) accepted into a pending posting list.
 * A tuple that starts out as the base tuple for a posting list will only
 * actually be rewritten within _bt_dedup_finish_pending() when it turns out
 * that there are duplicates that can be merged into the base tuple.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_dedup_start_pending</name><parameter_list>(<parameter><decl><type><name>BTDedupState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>base</name></decl></parameter>,
						<parameter><decl><type><name>OffsetNumber</name></type> <name>baseoff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nitems</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BTreeTupleIsPivot</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy heap TID(s) from new base tuple for new candidate posting list
	 * into working state's array
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>htids</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>basetupsize</name></name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nposting</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nposting</name> <operator>=</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>htids</name></name></expr></argument>, <argument><expr><call><name>BTreeTupleGetPosting</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nposting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name> <operator>=</operator> <name>nposting</name></expr>;</expr_stmt>
		<comment type="block">/* basetupsize should not include existing posting list */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>basetupsize</name></name> <operator>=</operator> <call><name>BTreeTupleGetPostingOffset</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Save new base tuple itself -- it'll be needed if we actually create a
	 * new posting list from new pending posting list.
	 *
	 * Must maintain physical size of all existing tuples (including line
	 * pointer overhead) so that we can calculate space savings on page.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>baseoff</name></name> <operator>=</operator> <name>baseoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>phystupsize</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<comment type="block">/* Also save baseoff in pending state for interval */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>intervals</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>nintervals</name></name></expr>]</index></name><operator>.</operator><name>baseoff</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>baseoff</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Save itup heap TID(s) into pending posting list where possible.
 *
 * Returns bool indicating if the pending posting list managed by state now
 * includes itup's heap TID(s).
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_dedup_save_htid</name><parameter_list>(<parameter><decl><type><name>BTDedupState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nhtids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>htids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>mergedtupsz</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BTreeTupleIsPivot</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nhtids</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>htids</name> <operator>=</operator> <operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nhtids</name> <operator>=</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>htids</name> <operator>=</operator> <call><name>BTreeTupleGetPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Don't append (have caller finish pending posting list as-is) if
	 * appending heap TID(s) from itup would put us over maxpostingsize limit.
	 *
	 * This calculation needs to match the code used within _bt_form_posting()
	 * for new posting list tuples.
	 */</comment>
	<expr_stmt><expr><name>mergedtupsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>basetupsize</name></name> <operator>+</operator>
						   <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name> <operator>+</operator> <name>nhtids</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mergedtupsz</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>maxpostingsize</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Count this as an oversized item for single value strategy, though
		 * only when there are 50 TIDs in the final posting list tuple.  This
		 * limit (which is fairly arbitrary) avoids confusion about how many
		 * 1/6 of a page tuples have been encountered/created by the current
		 * deduplication pass.
		 *
		 * Note: We deliberately don't consider which deduplication pass
		 * merged together tuples to create this item (could be a previous
		 * deduplication pass, or current pass).  See _bt_do_singleval()
		 * comments.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name> <operator>&gt;</operator> <literal type="number">50</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nmaxitems</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Save heap TIDs to pending posting list tuple -- itup can be merged into
	 * pending posting list
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nitems</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>htids</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name></expr></argument>, <argument><expr><name>htids</name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nhtids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name> <operator>+=</operator> <name>nhtids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>phystupsize</name></name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Finalize pending posting list tuple, and add it to the page.  Final tuple
 * is based on saved base tuple, and saved list of heap TIDs.
 *
 * Returns space saving from deduplicating to make a new posting list tuple.
 * Note that this includes line pointer overhead.  This is zero in the case
 * where no deduplication was possible.
 */</comment>
<function><type><name>Size</name></type>
<name>_bt_dedup_finish_pending</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>newpage</name></decl></parameter>, <parameter><decl><type><name>BTDedupState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>tupoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>tuplesz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>spacesaving</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nitems</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nitems</name></name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>intervals</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>nintervals</name></name></expr>]</index></name><operator>.</operator><name>baseoff</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>baseoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nitems</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use original, unchanged base tuple */</comment>
		<expr_stmt><expr><name>tuplesz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>tuplesz</name></expr></argument>, <argument><expr><name>tupoff</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"deduplication failed to add tuple to page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>spacesaving</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>final</name></decl>;</decl_stmt>

		<comment type="block">/* Form a tuple with a posting list */</comment>
		<expr_stmt><expr><name>final</name> <operator>=</operator> <call><name>_bt_form_posting</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>htids</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuplesz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplesz</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>maxpostingsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Save final number of items for posting list */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>intervals</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>nintervals</name></name></expr>]</index></name><operator>.</operator><name>nitems</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplesz</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>final</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>final</name></expr></argument>, <argument><expr><name>tuplesz</name></expr></argument>, <argument><expr><name>tupoff</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"deduplication failed to add tuple to page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>spacesaving</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>phystupsize</name></name> <operator>-</operator> <operator>(</operator><name>tuplesz</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* Increment nintervals, since we wrote a new posting list tuple */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nintervals</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>spacesaving</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>spacesaving</name> <operator>&lt;</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Reset state for next pending posting list */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nhtids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>phystupsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>spacesaving</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine if page non-pivot tuples (data items) are all duplicates of the
 * same value -- if they are, deduplication's "single value" strategy should
 * be applied.  The general goal of this strategy is to ensure that
 * nbtsplitloc.c (which uses its own single value strategy) will find a useful
 * split point as further duplicates are inserted, and successive rightmost
 * page splits occur among pages that store the same duplicate value.  When
 * the page finally splits, it should end up BTREE_SINGLEVAL_FILLFACTOR% full,
 * just like it would if deduplication were disabled.
 *
 * We expect that affected workloads will require _several_ single value
 * strategy deduplication passes (over a page that only stores duplicates)
 * before the page is finally split.  The first deduplication pass should only
 * find regular non-pivot tuples.  Later deduplication passes will find
 * existing maxpostingsize-capped posting list tuples, which must be skipped
 * over.  The penultimate pass is generally the first pass that actually
 * reaches _bt_singleval_fillfactor(), and so will deliberately leave behind a
 * few untouched non-pivot tuples.  The final deduplication pass won't free
 * any space -- it will skip over everything without merging anything (it
 * retraces the steps of the penultimate pass).
 *
 * Fortunately, having several passes isn't too expensive.  Each pass (after
 * the first pass) won't spend many cycles on the large posting list tuples
 * left by previous passes.  Each pass will find a large contiguous group of
 * smaller duplicate tuples to merge together at the end of the page.
 *
 * Note: We deliberately don't bother checking if the high key is a distinct
 * value (prior to the TID tiebreaker column) before proceeding, unlike
 * nbtsplitloc.c.  Its single value strategy only gets applied on the
 * rightmost page of duplicates of the same value (other leaf pages full of
 * duplicates will get a simple 50:50 page split instead of splitting towards
 * the end of the page).  There is little point in making the same distinction
 * here.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_do_singleval</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BTDedupState</name></type> <name>state</name></decl></parameter>,
				 <parameter><decl><type><name>OffsetNumber</name></type> <name>minoff</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>newitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeyatts</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>_bt_keep_natts_fast</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>nkeyatts</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>_bt_keep_natts_fast</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>nkeyatts</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Lower maxpostingsize when using "single value" strategy, to avoid a sixth
 * and final maxpostingsize-capped tuple.  The sixth and final posting list
 * tuple will end up somewhat smaller than the first five.  (Note: The first
 * five tuples could actually just be very large duplicate tuples that
 * couldn't be merged together at all.  Deduplication will simply not modify
 * the page when that happens.)
 *
 * When there are six posting lists on the page (after current deduplication
 * pass goes on to create/observe a sixth very large tuple), caller should end
 * its deduplication pass.  It isn't useful to try to deduplicate items that
 * are supposed to end up on the new right sibling page following the
 * anticipated page split.  A future deduplication pass of future right
 * sibling page might take care of it.  (This is why the first single value
 * strategy deduplication pass for a given leaf page will generally find only
 * plain non-pivot tuples -- see _bt_do_singleval() comments.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_singleval_fillfactor</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BTDedupState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>leftfree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>reduction</name></decl>;</decl_stmt>

	<comment type="block">/* This calculation needs to match nbtsplitloc.c */</comment>
	<expr_stmt><expr><name>leftfree</name> <operator>=</operator> <call><name>PageGetPageSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>SizeOfPageHeaderData</name> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Subtract size of new high key (includes pivot heap TID space) */</comment>
	<expr_stmt><expr><name>leftfree</name> <operator>-=</operator> <name>newitemsz</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reduce maxpostingsize by an amount equal to target free space on left
	 * half of page
	 */</comment>
	<expr_stmt><expr><name>reduction</name> <operator>=</operator> <name>leftfree</name> <operator>*</operator> <operator>(</operator><operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name>BTREE_SINGLEVAL_FILLFACTOR</name><operator>)</operator> <operator>/</operator> <literal type="number">100.0</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>maxpostingsize</name></name> <operator>&gt;</operator> <name>reduction</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxpostingsize</name></name> <operator>-=</operator> <name>reduction</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxpostingsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a posting list tuple based on caller's "base" index tuple and list of
 * heap TIDs.  When nhtids == 1, builds a standard non-pivot tuple without a
 * posting list. (Posting list tuples can never have a single heap TID, partly
 * because that ensures that deduplication always reduces final MAXALIGN()'d
 * size of entire tuple.)
 *
 * Convention is that posting list starts at a MAXALIGN()'d offset (rather
 * than a SHORTALIGN()'d offset), in line with the approach taken when
 * appending a heap TID to new pivot tuple/high key during suffix truncation.
 * This sometimes wastes a little space that was only needed as alignment
 * padding in the original tuple.  Following this convention simplifies the
 * space accounting used when deduplicating a page (the same convention
 * simplifies the accounting for choosing a point to split a page at).
 *
 * Note: Caller's "htids" array must be unique and already in ascending TID
 * order.  Any existing heap TIDs from "base" won't automatically appear in
 * returned posting list tuple (they must be included in htids array.)
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>_bt_form_posting</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>htids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nhtids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>keysize</name></decl>,
				<decl><type ref="prev"/><name>newsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>keysize</name> <operator>=</operator> <call><name>BTreeTupleGetPostingOffset</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>keysize</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BTreeTupleIsPivot</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nhtids</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nhtids</name> <operator>&lt;=</operator> <name>PG_UINT16_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>keysize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine final size of new tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name>nhtids</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>keysize</name> <operator>+</operator>
						   <name>nhtids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>keysize</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newsize</name> <operator>&lt;=</operator> <name>INDEX_SIZE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newsize</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate memory using palloc0() (matches index_form_tuple()) */</comment>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>keysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;=</operator> <operator>~</operator><name>INDEX_SIZE_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>|=</operator> <name>newsize</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nhtids</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Form posting list tuple */</comment>
		<expr_stmt><expr><call><name>BTreeTupleSetPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>nhtids</name></expr></argument>, <argument><expr><name>keysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>BTreeTupleGetPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>htids</name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nhtids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_bt_posting_valid</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Form standard non-pivot tuple */</comment>
		<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;=</operator> <operator>~</operator><name>INDEX_ALT_TID_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><name>htids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>itup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a replacement tuple by "updating" a posting list tuple so that it
 * no longer has TIDs that need to be deleted.
 *
 * Used by VACUUM.  Caller's vacposting argument points to the existing
 * posting list tuple to be updated.
 *
 * On return, caller's vacposting argument will point to final "updated"
 * tuple, which will be palloc()'d in caller's memory context.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_update_posting</name><parameter_list>(<parameter><decl><type><name>BTVacuumPosting</name></type> <name>vacposting</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>origtuple</name> <init>= <expr><name><name>vacposting</name><operator>-&gt;</operator><name>itup</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>keysize</name></decl>,
				<decl><type ref="prev"/><name>newsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nhtids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ui</name></decl>,
				<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>htids</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nhtids</name> <operator>=</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>origtuple</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>vacposting</name><operator>-&gt;</operator><name>ndeletedtids</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_bt_posting_valid</name><argument_list>(<argument><expr><name>origtuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nhtids</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nhtids</name> <operator>&lt;</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>origtuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine final size of new tuple.
	 *
	 * This calculation needs to match the code used within _bt_form_posting()
	 * for new posting list tuples.  We avoid calling _bt_form_posting() here
	 * to save ourselves a second memory allocation for a htids workspace.
	 */</comment>
	<expr_stmt><expr><name>keysize</name> <operator>=</operator> <call><name>BTreeTupleGetPostingOffset</name><argument_list>(<argument><expr><name>origtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nhtids</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>keysize</name> <operator>+</operator>
						   <name>nhtids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>keysize</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newsize</name> <operator>&lt;=</operator> <name>INDEX_SIZE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newsize</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate memory using palloc0() (matches index_form_tuple()) */</comment>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>origtuple</name></expr></argument>, <argument><expr><name>keysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;=</operator> <operator>~</operator><name>INDEX_SIZE_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>|=</operator> <name>newsize</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nhtids</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Form posting list tuple */</comment>
		<expr_stmt><expr><call><name>BTreeTupleSetPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>nhtids</name></expr></argument>, <argument><expr><name>keysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>htids</name> <operator>=</operator> <call><name>BTreeTupleGetPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Form standard non-pivot tuple */</comment>
		<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;=</operator> <operator>~</operator><name>INDEX_ALT_TID_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>htids</name> <operator>=</operator> <operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ui</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>origtuple</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <name><name>vacposting</name><operator>-&gt;</operator><name>ndeletedtids</name></name> <operator>&amp;&amp;</operator> <name><name>vacposting</name><operator>-&gt;</operator><name>deletetids</name><index>[<expr><name>d</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>d</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>htids</name><index>[<expr><name>ui</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><call><name>BTreeTupleGetPostingN</name><argument_list>(<argument><expr><name>origtuple</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ui</name> <operator>==</operator> <name>nhtids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>d</name> <operator>==</operator> <name><name>vacposting</name><operator>-&gt;</operator><name>ndeletedtids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nhtids</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>_bt_posting_valid</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nhtids</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* vacposting arg's itup will now point to updated version */</comment>
	<expr_stmt><expr><name><name>vacposting</name><operator>-&gt;</operator><name>itup</name></name> <operator>=</operator> <name>itup</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare for a posting list split by swapping heap TID in newitem with heap
 * TID from original posting list (the 'oposting' heap TID located at offset
 * 'postingoff').  Modifies newitem, so caller should pass their own private
 * copy that can safely be modified.
 *
 * Returns new posting list tuple, which is palloc()'d in caller's context.
 * This is guaranteed to be the same size as 'oposting'.  Modified newitem is
 * what caller actually inserts. (This happens inside the same critical
 * section that performs an in-place update of old posting list using new
 * posting list returned here.)
 *
 * While the keys from newitem and oposting must be opclass equal, and must
 * generate identical output when run through the underlying type's output
 * function, it doesn't follow that their representations match exactly.
 * Caller must avoid assuming that there can't be representational differences
 * that make datums from oposting bigger or smaller than the corresponding
 * datums from newitem.  For example, differences in TOAST input state might
 * break a faulty assumption about tuple size (the executor is entitled to
 * apply TOAST compression based on its own criteria).  It also seems possible
 * that further representational variation will be introduced in the future,
 * in order to support nbtree features like page-level prefix compression.
 *
 * See nbtree/README for details on the design of posting list splits.
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>_bt_swap_posting</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>newitem</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>oposting</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>postingoff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nhtids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>replacepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>replaceposright</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nmovebytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>nposting</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nhtids</name> <operator>=</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>oposting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_bt_posting_valid</name><argument_list>(<argument><expr><name>oposting</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The postingoff argument originated as a _bt_binsrch_posting() return
	 * value.  It will be 0 in the event of corruption that makes a leaf page
	 * contain a non-pivot tuple that's somehow identical to newitem (no two
	 * non-pivot tuples should ever have the same TID).  This has been known
	 * to happen in the field from time to time.
	 *
	 * Perform a basic sanity check to catch this case now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>postingoff</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>postingoff</name> <operator>&lt;</operator> <name>nhtids</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"posting list tuple with %d items cannot be split at offset %d"</literal></expr></argument>,
			 <argument><expr><name>nhtids</name></expr></argument>, <argument><expr><name>postingoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Move item pointers in posting list to make a gap for the new item's
	 * heap TID.  We shift TIDs one place to the right, losing original
	 * rightmost TID. (nmovebytes must not include TIDs to the left of
	 * postingoff, nor the existing rightmost/max TID that gets overwritten.)
	 */</comment>
	<expr_stmt><expr><name>nposting</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>oposting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replacepos</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>BTreeTupleGetPostingN</name><argument_list>(<argument><expr><name>nposting</name></expr></argument>, <argument><expr><name>postingoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replaceposright</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>BTreeTupleGetPostingN</name><argument_list>(<argument><expr><name>nposting</name></expr></argument>, <argument><expr><name>postingoff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nmovebytes</name> <operator>=</operator> <operator>(</operator><name>nhtids</name> <operator>-</operator> <name>postingoff</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>replaceposright</name></expr></argument>, <argument><expr><name>replacepos</name></expr></argument>, <argument><expr><name>nmovebytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill the gap at postingoff with TID of new item (original new TID) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BTreeTupleIsPivot</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newitem</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <name>replacepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now copy oposting's rightmost/max TID into new item (final new TID) */</comment>
	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><call><name>BTreeTupleGetMaxHeapTID</name><argument_list>(<argument><expr><name>oposting</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newitem</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerCompare</name><argument_list>(<argument><expr><call><name>BTreeTupleGetMaxHeapTID</name><argument_list>(<argument><expr><name>nposting</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>BTreeTupleGetHeapTID</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_bt_posting_valid</name><argument_list>(<argument><expr><name>nposting</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nposting</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify posting list invariants for "posting", which must be a posting list
 * tuple.  Used within assertions.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_posting_valid</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>posting</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>last</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>htid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>posting</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>posting</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Remember first heap TID for loop */</comment>
	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><call><name>BTreeTupleGetHeapTID</name><argument_list>(<argument><expr><name>posting</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Iterate, starting from second TID */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>posting</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>htid</name> <operator>=</operator> <call><name>BTreeTupleGetPostingN</name><argument_list>(<argument><expr><name>posting</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>htid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>htid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><name>htid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
