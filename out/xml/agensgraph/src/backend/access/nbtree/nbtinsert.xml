<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/nbtree/nbtinsert.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtinsert.c
 *	  Item insertion in Lehman and Yao btrees for Postgres.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/nbtree/nbtinsert.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>

<comment type="block">/* Minimum tree height for application of fastpath optimization */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTREE_FASTPATH_MIN_LEVEL</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>BTStack</name></type> <name>_bt_search_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTInsertState</name></type> <name>insertstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>_bt_check_unique</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTInsertState</name></type> <name>insertstate</name></decl></parameter>,
									  <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
									  <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_unique</name></decl></parameter>,
									  <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>speculativeToken</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OffsetNumber</name></type> <name>_bt_findinsertloc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									  <parameter><decl><type><name>BTInsertState</name></type> <name>insertstate</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>checkingunique</name></decl></parameter>,
									  <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
									  <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_stepright</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTInsertState</name></type> <name>insertstate</name></decl></parameter>, <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_insertonpg</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>itup_key</name></decl></parameter>,
						   <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
						   <parameter><decl><type><name>Buffer</name></type> <name>cbuf</name></decl></parameter>,
						   <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
						   <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
						   <parameter><decl><type><name>Size</name></type> <name>itemsz</name></decl></parameter>,
						   <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>postingoff</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>split_only_page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Buffer</name></type> <name>_bt_split</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>itup_key</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
						<parameter><decl><type><name>Buffer</name></type> <name>cbuf</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>,
						<parameter><decl><type><name>IndexTuple</name></type> <name>newitem</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>orignewitem</name></decl></parameter>,
						<parameter><decl><type><name>IndexTuple</name></type> <name>nposting</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>postingoff</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_insert_parent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>rbuf</name></decl></parameter>,
							  <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_only</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Buffer</name></type> <name>_bt_newroot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lbuf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>rbuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>_bt_pgaddtup</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>itemsize</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
								<parameter><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newfirstdataitem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_vacuum_one_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 *	_bt_doinsert() -- Handle insertion of a single index tuple in the tree.
 *
 *		This routine is called by the public interface routine, btinsert.
 *		By here, itup is filled in, including the TID.
 *
 *		If checkUnique is UNIQUE_CHECK_NO or UNIQUE_CHECK_PARTIAL, this
 *		will allow duplicates.  Otherwise (UNIQUE_CHECK_YES or
 *		UNIQUE_CHECK_EXISTING) it will throw error for a duplicate.
 *		For UNIQUE_CHECK_EXISTING we merely run the duplicate check, and
 *		don't actually insert.
 *
 *		The result value is only significant for UNIQUE_CHECK_PARTIAL:
 *		it must be true if the entry is known unique, else false.
 *		(In the current implementation we'll also return true after a
 *		successful UNIQUE_CHECK_YES or UNIQUE_CHECK_EXISTING call, but
 *		that's just a coding artifact.)
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_doinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			 <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_unique</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTInsertStateData</name></type> <name>insertstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>itup_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTStack</name></type>		<name>stack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checkingunique</name> <init>= <expr><operator>(</operator><name>checkUnique</name> <operator>!=</operator> <name>UNIQUE_CHECK_NO</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we need an insertion scan key to do our search, so build one */</comment>
	<expr_stmt><expr><name>itup_key</name> <operator>=</operator> <call><name>_bt_mkscankey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>checkingunique</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>itup_key</name><operator>-&gt;</operator><name>anynullkeys</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No (heapkeyspace) scantid until uniqueness established */</comment>
			<expr_stmt><expr><name><name>itup_key</name><operator>-&gt;</operator><name>scantid</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Scan key for new tuple contains NULL key values.  Bypass
			 * checkingunique steps.  They are unnecessary because core code
			 * considers NULL unequal to every value, including NULL.
			 *
			 * This optimization avoids O(N^2) behavior within the
			 * _bt_findinsertloc() heapkeyspace path when a unique index has a
			 * large number of "duplicates" with NULL key values.
			 */</comment>
			<expr_stmt><expr><name>checkingunique</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* Tuple is unique in the sense that core code cares about */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>checkUnique</name> <operator>!=</operator> <name>UNIQUE_CHECK_EXISTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_unique</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Fill in the BTInsertState working area, to track the current page and
	 * position within the page to insert on.
	 *
	 * Note that itemsz is passed down to lower level code that deals with
	 * inserting the item.  It must be MAXALIGN()'d.  This ensures that space
	 * accounting code consistently considers the alignment overhead that we
	 * expect PageAddItem() will add later.  (Actually, index_form_tuple() is
	 * already conservative about alignment, but we don't rely on that from
	 * this distance.  Besides, preserving the "true" tuple size in index
	 * tuple headers for the benefit of nbtsplitloc.c might happen someday.
	 * Note that heapam does not MAXALIGN() each heap tuple's lp_len field.)
	 */</comment>
	<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>itup</name></name> <operator>=</operator> <name>itup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>itemsz</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>itup_key</name></name> <operator>=</operator> <name>itup_key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>bounds_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>postingoff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>search</name>:</label>

	<comment type="block">/*
	 * Find and lock the leaf page that the tuple should be added to by
	 * searching from the root page.  insertstate.buf will hold a buffer that
	 * is locked in exclusive mode afterwards.
	 */</comment>
	<expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>_bt_search_insert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insertstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * checkingunique inserts are not allowed to go ahead when two tuples with
	 * equal key attribute values would be visible to new MVCC snapshots once
	 * the xact commits.  Check for conflicts in the locked page/buffer (if
	 * needed) here.
	 *
	 * It might be necessary to check a page to the right in _bt_check_unique,
	 * though that should be very rare.  In practice the first page the value
	 * could be on (with scantid omitted) is almost always also the only page
	 * that a matching tuple might be found on.  This is due to the behavior
	 * of _bt_findsplitloc with duplicate tuples -- a group of duplicates can
	 * only be allowed to cross a page boundary when there is no candidate
	 * leaf page split point that avoids it.  Also, _bt_check_unique can use
	 * the leaf page high key to determine that there will be no duplicates on
	 * the right sibling without actually visiting it (it uses the high key in
	 * cases where the new item happens to belong at the far right of the leaf
	 * page).
	 *
	 * NOTE: obviously, _bt_check_unique can only detect keys that are already
	 * in the index; so it cannot defend against concurrent insertions of the
	 * same key.  We protect against that by means of holding a write lock on
	 * the first page the value could be on, with omitted/-inf value for the
	 * implicit heap TID tiebreaker attribute.  Any other would-be inserter of
	 * the same key must acquire a write lock on the same page, so only one
	 * would-be inserter can be making the check at one time.  Furthermore,
	 * once we are past the check we hold write locks continuously until we
	 * have performed our insertion, so no later inserter can fail to see our
	 * insertion.  (This requires some care in _bt_findinsertloc.)
	 *
	 * If we must wait for another xact, we release the lock while waiting,
	 * and then must perform a new search.
	 *
	 * For a partial uniqueness check, we don't wait for the other xact. Just
	 * let the tuple in and return false for possibly non-unique, or true for
	 * definitely unique.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>checkingunique</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>speculativeToken</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>xwait</name> <operator>=</operator> <call><name>_bt_check_unique</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insertstate</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>checkUnique</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>is_unique</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>speculativeToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Have to wait for the other guy ... */</comment>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If it's a speculative insertion, wait for it to finish (ie. to
			 * go ahead with the insertion, or kill the tuple).  Otherwise
			 * wait for the transaction to finish as usual.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>speculativeToken</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SpeculativeInsertionWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>speculativeToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><name>XLTW_InsertIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* start over... */</comment>
			<if_stmt><if>if <condition>(<expr><name>stack</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_bt_freestack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<goto>goto <name>search</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Uniqueness is established -- restore heap tid as scantid */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>itup_key</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>itup_key</name><operator>-&gt;</operator><name>scantid</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>checkUnique</name> <operator>!=</operator> <name>UNIQUE_CHECK_EXISTING</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The only conflict predicate locking cares about for indexes is when
		 * an index tuple insert conflicts with an existing lock.  We don't
		 * know the actual page we're going to insert on for sure just yet in
		 * checkingunique and !heapkeyspace cases, but it's okay to use the
		 * first page the value could be on (with scantid omitted) instead.
		 */</comment>
		<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do the insertion.  Note that insertstate contains cached binary
		 * search bounds established within _bt_check_unique when insertion is
		 * checkingunique.
		 */</comment>
		<expr_stmt><expr><name>newitemoff</name> <operator>=</operator> <call><name>_bt_findinsertloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insertstate</name></expr></argument>, <argument><expr><name>checkingunique</name></expr></argument>,
									   <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_insertonpg</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>,
					   <argument><expr><name>itup</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>.</operator><name>itemsz</name></name></expr></argument>, <argument><expr><name>newitemoff</name></expr></argument>,
					   <argument><expr><name><name>insertstate</name><operator>.</operator><name>postingoff</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* just release the buffer */</comment>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* be tidy */</comment>
	<if_stmt><if>if <condition>(<expr><name>stack</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_freestack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itup_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>is_unique</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_search_insert() -- _bt_search() wrapper for inserts
 *
 * Search the tree for a particular scankey, or more precisely for the first
 * leaf page it could be on.  Try to make use of the fastpath optimization's
 * rightmost leaf page cache before actually searching the tree from the root
 * page, though.
 *
 * Return value is a stack of parent-page pointers (though see notes about
 * fastpath optimization and page splits below).  insertstate-&gt;buf is set to
 * the address of the leaf-page buffer, which is write-locked and pinned in
 * all cases (if necessary by creating a new empty root page for caller).
 *
 * The fastpath optimization avoids most of the work of searching the tree
 * repeatedly when a single backend inserts successive new tuples on the
 * rightmost leaf page of an index.  A backend cache of the rightmost leaf
 * page is maintained within _bt_insertonpg(), and used here.  The cache is
 * invalidated here when an insert of a non-pivot tuple must take place on a
 * non-rightmost leaf page.
 *
 * The optimization helps with indexes on an auto-incremented field.  It also
 * helps with indexes on datetime columns, as well as indexes with lots of
 * NULL values.  (NULLs usually get inserted in the rightmost page for single
 * column indexes, since they usually get treated as coming after everything
 * else in the key space.  Individual NULL tuples will generally be placed on
 * the rightmost leaf page due to the influence of the heap TID column.)
 *
 * Note that we avoid applying the optimization when there is insufficient
 * space on the rightmost page to fit caller's new item.  This is necessary
 * because we'll need to return a real descent stack when a page split is
 * expected (actually, caller can cope with a leaf page split that uses a NULL
 * stack, but that's very slow and so must be avoided).  Note also that the
 * fastpath optimization acquires the lock on the page conditionally as a way
 * of reducing extra contention when there are concurrent insertions into the
 * rightmost page (we give up if we'd have to wait for the lock).  We assume
 * that it isn't useful to apply the optimization when there is contention,
 * since each per-backend cache won't stay valid for long.
 */</comment>
<function><type><specifier>static</specifier> <name>BTStack</name></type>
<name>_bt_search_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTInsertState</name></type> <name>insertstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>postingoff</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Simulate a _bt_getbuf() call with conditional locking */</comment>
		<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ConditionalLockBuffer</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>_bt_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check if the page is still the rightmost leaf page and has
			 * enough free space to accommodate the new tuple.  Also check
			 * that the insertion scan key is strictly greater than the first
			 * non-pivot tuple on the page.  (Note that we expect itup_key's
			 * scantid to be unset when our caller is a checkingunique
			 * inserter.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>itemsz</name></name> <operator>&amp;&amp;</operator>
				<call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>P_HIKEY</name> <operator>&amp;&amp;</operator>
				<call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>itup_key</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Caller can use the fastpath optimization because cached
				 * block is still rightmost leaf page, which can fit caller's
				 * new tuple without splitting.  Keep block in local cache for
				 * next insert, and have caller use NULL stack.
				 *
				 * Note that _bt_insert_parent() has an assertion that catches
				 * leaf page splits that somehow follow from a fastpath insert
				 * (it should only be passed a NULL stack when it must deal
				 * with a concurrent root page split, and never because a NULL
				 * stack was returned here).
				 */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Page unsuitable for caller, drop lock and pin */</comment>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Lock unavailable, drop pin */</comment>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Forget block, since cache doesn't appear to be useful */</comment>
		<expr_stmt><expr><call><name>RelationSetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Cannot use optimization -- descend tree, return proper descent stack */</comment>
	<return>return <expr><call><name>_bt_search</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>itup_key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_check_unique() -- Check for violation of unique index constraint
 *
 * Returns InvalidTransactionId if there is no conflict, else an xact ID
 * we must wait for to see if it commits a conflicting tuple.   If an actual
 * conflict is detected, no return --- just ereport().  If an xact ID is
 * returned, and the conflicting tuple still has a speculative insertion in
 * progress, *speculativeToken is set to non-zero, and the caller can wait for
 * the verdict on the insertion using SpeculativeInsertionWait().
 *
 * However, if checkUnique == UNIQUE_CHECK_PARTIAL, we always return
 * InvalidTransactionId because we don't want to wait.  In this case we
 * set *is_unique to false if there is a potential conflict, and the
 * core code must redo the uniqueness check later.
 *
 * As a side-effect, sets state in insertstate that can later be used by
 * _bt_findinsertloc() to reuse most of the binary search work we do
 * here.
 *
 * Do not call here when there are NULL values in scan key.  NULL should be
 * considered unequal to NULL when checking for duplicates, but we are not
 * prepared to handle that correctly.
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>_bt_check_unique</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTInsertState</name></type> <name>insertstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
				 <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_unique</name></decl></parameter>,
				 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>speculativeToken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name> <init>= <expr><name><name>insertstate</name><operator>-&gt;</operator><name>itup</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>curitup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>curitemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>itup_key</name> <init>= <expr><name><name>insertstate</name><operator>-&gt;</operator><name>itup_key</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotDirty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>nbuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inposting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prevalldead</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curposti</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Assume unique until we find a duplicate */</comment>
	<expr_stmt><expr><operator>*</operator><name>is_unique</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitDirtySnapshot</name><argument_list>(<argument><expr><name>SnapshotDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the first tuple with the same key.
	 *
	 * This also saves the binary search bounds in insertstate.  We use them
	 * in the fastpath below, but also in the _bt_findinsertloc() call later.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>_bt_binsrch_insert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>insertstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan over all equal tuples, looking for live conflicts.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>||</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>low</name></name> <operator>==</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>itup_key</name><operator>-&gt;</operator><name>anynullkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>itup_key</name><operator>-&gt;</operator><name>scantid</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Each iteration of the loop processes one heap TID, not one index
		 * tuple.  Current offset number for page isn't usually advanced on
		 * iterations that process heap TIDs from posting list tuples.
		 *
		 * "inposting" state is set when _inside_ a posting list --- not when
		 * we're at the start (or end) of a posting list.  We advance curposti
		 * at the end of the iteration when inside a posting list tuple.  In
		 * general, every loop iteration either advances the page offset or
		 * advances curposti --- an iteration that handles the rightmost/max
		 * heap TID in a posting list finally advances the page offset (and
		 * unsets "inposting").
		 *
		 * Make sure the offset points to an actual index tuple before trying
		 * to examine it...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Fastpath: In most cases, we can use cached search bounds to
			 * limit our consideration to items that are definitely
			 * duplicates.  This fastpath doesn't apply when the original page
			 * is empty, or when initial offset is past the end of the
			 * original page, which may indicate that we need to examine a
			 * second or subsequent page.
			 *
			 * Note that this optimization allows us to avoid calling
			 * _bt_compare() directly when there are no duplicates, as long as
			 * the offset where the key will go is not at the end of the page.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>==</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>stricthigh</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>low</name></name> <operator>&gt;=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>low</name></name> <operator>&lt;=</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>stricthigh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We can skip items that are already marked killed.
			 *
			 * In the presence of heavy update activity an index may contain
			 * many killed items with the same key; running _bt_compare() on
			 * each killed item gets expensive.  Just advance over killed
			 * items as quickly as we can.  We only apply _bt_compare() when
			 * we get to a non-killed item.  We could reuse the bounds to
			 * avoid _bt_compare() calls for known equal tuples, but it
			 * doesn't seem worth it.  Workloads with heavy update activity
			 * tend to have many deduplication passes, so we'll often avoid
			 * most of those comparisons, too (we call _bt_compare() when the
			 * posting list tuple is initially encountered, though not when
			 * processing later TIDs from the same tuple).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inposting</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>curitemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>inposting</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>curitemid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>htid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>all_dead</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inposting</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Plain tuple, or first TID in posting list tuple */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* we're past all the equal tuples */</comment>

					<comment type="block">/* Advanced curitup */</comment>
					<expr_stmt><expr><name>curitup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>curitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BTreeTupleIsPivot</name><argument_list>(<argument><expr><name>curitup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* okay, we gotta fetch the heap tuple using htid ... */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>curitup</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* ... htid is from simple non-pivot tuple */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>inposting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>htid</name> <operator>=</operator> <name><name>curitup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>inposting</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* ... htid is first TID in new posting list */</comment>
					<expr_stmt><expr><name>inposting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>prevalldead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>curposti</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>htid</name> <operator>=</operator> <operator>*</operator><call><name>BTreeTupleGetPostingN</name><argument_list>(<argument><expr><name>curitup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* ... htid is second or subsequent TID in posting list */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>curposti</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>htid</name> <operator>=</operator> <operator>*</operator><call><name>BTreeTupleGetPostingN</name><argument_list>(<argument><expr><name>curitup</name></expr></argument>, <argument><expr><name>curposti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * If we are doing a recheck, we expect to find the tuple we
				 * are rechecking.  It's not a duplicate, but we have to keep
				 * scanning.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>checkUnique</name> <operator>==</operator> <name>UNIQUE_CHECK_EXISTING</name> <operator>&amp;&amp;</operator>
					<call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>htid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>

				<comment type="block">/*
				 * Check if there's any table tuples for this index entry
				 * satisfying SnapshotDirty. This is necessary because for AMs
				 * with optimizations like heap's HOT, we have just a single
				 * index entry for the entire chain.
				 */</comment>
				<if type="elseif">else if <condition>(<expr><call><name>table_index_fetch_tuple_check</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>htid</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>SnapshotDirty</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>all_dead</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * It is a duplicate. If we are only doing a partial
					 * check, then don't bother checking if the tuple is being
					 * updated in another transaction. Just return the fact
					 * that it is a potential conflict and leave the full
					 * check till later. Don't invalidate binary search
					 * bounds.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>checkUnique</name> <operator>==</operator> <name>UNIQUE_CHECK_PARTIAL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>is_unique</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<return>return <expr><name>InvalidTransactionId</name></expr>;</return>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If this tuple is being updated by other transaction
					 * then we have to wait for its commit/abort.
					 */</comment>
					<expr_stmt><expr><name>xwait</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmin</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
						<expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmin</name></name></expr> </then><else>: <expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></else></ternary></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<comment type="block">/* Tell _bt_doinsert to wait... */</comment>
						<expr_stmt><expr><operator>*</operator><name>speculativeToken</name> <operator>=</operator> <name><name>SnapshotDirty</name><operator>.</operator><name>speculativeToken</name></name></expr>;</expr_stmt>
						<comment type="block">/* Caller releases lock on buf immediately */</comment>
						<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<return>return <expr><name>xwait</name></expr>;</return>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Otherwise we have a definite conflict.  But before
					 * complaining, look to see if the tuple we want to insert
					 * is itself now committed dead --- if so, don't complain.
					 * This is a waste of time in normal scenarios but we must
					 * do it to support CREATE INDEX CONCURRENTLY.
					 *
					 * We must follow HOT-chains here because during
					 * concurrent index build, we insert the root TID though
					 * the actual tuple may be somewhere in the HOT-chain.
					 * While following the chain we might not stop at the
					 * exact tuple which triggered the insert, but that's OK
					 * because if we find a live tuple anywhere in this chain,
					 * we have a unique key conflict.  The other live tuple is
					 * not part of this chain because it had a different index
					 * entry.
					 */</comment>
					<expr_stmt><expr><name>htid</name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>table_index_fetch_tuple_check</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>htid</name></expr></argument>,
													  <argument><expr><name>SnapshotSelf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Normal case --- it's still live */</comment>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * It's been deleted, so no error, and no need to
						 * continue searching
						 */</comment>
						<break>break;</break>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * Check for a conflict-in as we would if we were going to
					 * write to this page.  We aren't actually going to write,
					 * but we want a chance to report SSI conflicts that would
					 * otherwise be masked by this unique constraint
					 * violation.
					 */</comment>
					<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * This is a definite conflict.  Break the tuple down into
					 * datums and report the error.  But first, make sure we
					 * release the buffer locks we're holding ---
					 * BuildIndexValueDescription could make catalog accesses,
					 * which in the worst case might touch this same index and
					 * cause deadlocks.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<block>{<block_content>
						<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key_desc</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>index_deform_tuple</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>key_desc</name> <operator>=</operator> <call><name>BuildIndexValueDescription</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
															  <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNIQUE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate key value violates unique constraint \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <ternary><condition><expr><name>key_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key %s already exists."</literal></expr></argument>,
													  <argument><expr><name>key_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
								 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>,
													<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>all_dead</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>inposting</name> <operator>||</operator>
									  <operator>(</operator><name>prevalldead</name> <operator>&amp;&amp;</operator>
									   <name>curposti</name> <operator>==</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>curitup</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The conflicting tuple (or all HOT chains pointed to by
					 * all posting list TIDs) is dead to everyone, so mark the
					 * index entry killed.
					 */</comment>
					<expr_stmt><expr><call><name>ItemIdMarkDead</name><argument_list>(<argument><expr><name>curitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Mark buffer with a dirty hint, since state is not
					 * crucial. Be sure to mark the proper buffer dirty.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Remember if posting list tuple has even a single HOT chain
				 * whose members are not all dead
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all_dead</name> <operator>&amp;&amp;</operator> <name>inposting</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>prevalldead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>inposting</name> <operator>&amp;&amp;</operator> <name>curposti</name> <operator>&lt;</operator> <call><name>BTreeTupleGetNPosting</name><argument_list>(<argument><expr><name>curitup</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Advance to next TID in same posting list */</comment>
			<expr_stmt><expr><name>curposti</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>maxoff</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Advance to next tuple */</comment>
			<expr_stmt><expr><name>curposti</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>inposting</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>highkeycmp</name></decl>;</decl_stmt>

			<comment type="block">/* If scankey == hikey we gotta check the next page too */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>highkeycmp</name> <operator>=</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>highkeycmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>highkeycmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* Advance to next non-dead page --- there must be one */</comment>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblkno</name> <init>= <expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>nbuf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>nblkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fell off the end of index \"%s\""</literal></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<comment type="block">/* Will also advance to next tuple */</comment>
			<expr_stmt><expr><name>curposti</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>inposting</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Don't invalidate binary search bounds */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we are doing a recheck then we should have found the tuple we are
	 * checking.  Otherwise there's something very wrong --- probably, the
	 * index is on a non-immutable expression.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>checkUnique</name> <operator>==</operator> <name>UNIQUE_CHECK_EXISTING</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to re-find tuple within index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This may be because of a non-immutable index expression."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>InvalidTransactionId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	_bt_findinsertloc() -- Finds an insert location for a tuple
 *
 *		On entry, insertstate buffer contains the page the new tuple belongs
 *		on.  It is exclusive-locked and pinned by the caller.
 *
 *		If 'checkingunique' is true, the buffer on entry is the first page
 *		that contains duplicates of the new key.  If there are duplicates on
 *		multiple pages, the correct insertion position might be some page to
 *		the right, rather than the first page.  In that case, this function
 *		moves right to the correct target page.
 *
 *		(In a !heapkeyspace index, there can be multiple pages with the same
 *		high key, where the new tuple could legitimately be placed on.  In
 *		that case, the caller passes the first page containing duplicates,
 *		just like when checkingunique=true.  If that page doesn't have enough
 *		room for the new tuple, this function moves right, trying to find a
 *		legal page that does.)
 *
 *		On exit, insertstate buffer contains the chosen insertion page, and
 *		the offset within that page is returned.  If _bt_findinsertloc needed
 *		to move right, the lock and pin on the original page are released, and
 *		the new buffer is exclusively locked and pinned instead.
 *
 *		If insertstate contains cached binary search bounds, we will take
 *		advantage of them.  This avoids repeating comparisons that we made in
 *		_bt_check_unique() already.
 *
 *		If there is not enough room on the page for the new tuple, we try to
 *		make room by removing any LP_DEAD tuples.
 */</comment>
<function><type><specifier>static</specifier> <name>OffsetNumber</name></type>
<name>_bt_findinsertloc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>BTInsertState</name></type> <name>insertstate</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>checkingunique</name></decl></parameter>,
				  <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>itup_key</name> <init>= <expr><name><name>insertstate</name><operator>-&gt;</operator><name>itup_key</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check 1/3 of a page restriction */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>itemsz</name></name> <operator>&gt;</operator> <call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_check_third_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name><name>itup_key</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
							 <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>itup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>||</operator> <name>checkingunique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>itup_key</name><operator>-&gt;</operator><name>heapkeyspace</name></name> <operator>||</operator> <name><name>itup_key</name><operator>-&gt;</operator><name>scantid</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>itup_key</name><operator>-&gt;</operator><name>heapkeyspace</name></name> <operator>||</operator> <name><name>itup_key</name><operator>-&gt;</operator><name>scantid</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>itup_key</name><operator>-&gt;</operator><name>allequalimage</name></name> <operator>||</operator> <name><name>itup_key</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>itup_key</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Keep track of whether checkingunique duplicate seen */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>uniquedup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we're inserting into a unique index, we may have to walk right
		 * through leaf pages to find the one leaf page that we must insert on
		 * to.
		 *
		 * This is needed for checkingunique callers because a scantid was not
		 * used when we called _bt_search().  scantid can only be set after
		 * _bt_check_unique() has checked for duplicates.  The buffer
		 * initially stored in insertstate-&gt;buf has the page where the first
		 * duplicate key might be found, which isn't always the page that new
		 * tuple belongs on.  The heap TID attribute for new tuple (scantid)
		 * could force us to insert on a sibling page, though that should be
		 * very rare in practice.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>checkingunique</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>insertstate</name><operator>-&gt;</operator><name>low</name></name> <operator>&lt;</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>stricthigh</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Encountered a duplicate in _bt_check_unique() */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>uniquedup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<comment type="block">/*
				 * Does the new tuple belong on this page?
				 *
				 * The earlier _bt_check_unique() call may well have
				 * established a strict upper bound on the offset for the new
				 * item.  If it's not the last item of the page (i.e. if there
				 * is at least one tuple on the page that goes after the tuple
				 * we're inserting) then we know that the tuple belongs on
				 * this page.  We can skip the high key check.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>&amp;&amp;</operator>
					<name><name>insertstate</name><operator>-&gt;</operator><name>low</name></name> <operator>&lt;=</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>stricthigh</name></name> <operator>&amp;&amp;</operator>
					<name><name>insertstate</name><operator>-&gt;</operator><name>stricthigh</name></name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<comment type="block">/* Test '&lt;=', not '!=', since scantid is set now */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>_bt_stepright</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>insertstate</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Update local state after stepping right */</comment>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Assume duplicates (if checkingunique) */</comment>
				<expr_stmt><expr><name>uniquedup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the target page is full, see if we can obtain enough space by
		 * erasing LP_DEAD items.  If that fails to free enough space, see if
		 * we can avoid a page split by performing a deduplication pass over
		 * the page.
		 *
		 * We only perform a deduplication pass for a checkingunique caller
		 * when the incoming item is a duplicate of an existing item on the
		 * leaf page.  This heuristic avoids wasting cycles -- we only expect
		 * to benefit from deduplicating a unique index page when most or all
		 * recently added items are duplicates.  See nbtree/README.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>itemsz</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>P_HAS_GARBAGE</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>_bt_vacuum_one_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* Might as well assume duplicates (if checkingunique) */</comment>
				<expr_stmt><expr><name>uniquedup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>itup_key</name><operator>-&gt;</operator><name>allequalimage</name></name> <operator>&amp;&amp;</operator> <call><name>BTGetDeduplicateItems</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>!</operator><name>checkingunique</name> <operator>||</operator> <name>uniquedup</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>itemsz</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>_bt_dedup_one_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>,
								   <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>itup</name></name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>itemsz</name></name></expr></argument>,
								   <argument><expr><name>checkingunique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*----------
		 * This is a !heapkeyspace (version 2 or 3) index.  The current page
		 * is the first page that we could insert the new tuple to, but there
		 * may be other pages to the right that we could opt to use instead.
		 *
		 * If the new key is equal to one or more existing keys, we can
		 * legitimately place it anywhere in the series of equal keys.  In
		 * fact, if the new key is equal to the page's "high key" we can place
		 * it on the next page.  If it is equal to the high key, and there's
		 * not room to insert the new tuple on the current page without
		 * splitting, then we move right hoping to find more free space and
		 * avoid a split.
		 *
		 * Keep scanning right until we
		 *		(a) find a page with enough free space,
		 *		(b) reach the last page where the tuple can legally go, or
		 *		(c) get tired of searching.
		 * (c) is not flippant; it is important because if there are many
		 * pages' worth of equal keys, it's better to split one of the early
		 * pages than to scan all the way to the end of the run of equal keys
		 * on every insert.  We implement "get tired" as a random choice,
		 * since stopping after scanning a fixed number of pages wouldn't work
		 * well (we'd never reach the right-hand side of previously split
		 * pages).  The probability of moving right is set at 0.99, which may
		 * seem too high to change the behavior much, but it does an excellent
		 * job of preventing O(N^2) behavior with many equal keys.
		 *----------
		 */</comment>
		<while>while <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>itemsz</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Before considering moving right, see if we can obtain enough
			 * space by erasing LP_DEAD items
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>P_HAS_GARBAGE</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>_bt_vacuum_one_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>itemsz</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* OK, now we have enough space */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Nope, so check conditions (b) and (c) enumerated above
			 *
			 * The earlier _bt_check_unique() call may well have established a
			 * strict upper bound on the offset for the new item.  If it's not
			 * the last item of the page (i.e. if there is at least one tuple
			 * on the page that's greater than the tuple we're inserting to)
			 * then we know that the tuple belongs on this page.  We can skip
			 * the high key check.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>&amp;&amp;</operator>
				<name><name>insertstate</name><operator>-&gt;</operator><name>low</name></name> <operator>&lt;=</operator> <name><name>insertstate</name><operator>-&gt;</operator><name>stricthigh</name></name> <operator>&amp;&amp;</operator>
				<name><name>insertstate</name><operator>-&gt;</operator><name>stricthigh</name></name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>random</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>MAX_RANDOM_VALUE</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>_bt_stepright</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>insertstate</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Update local state after stepping right */</comment>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We should now be on the correct page.  Find the offset within the page
	 * for the new tuple. (Possibly reusing earlier search bounds.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newitemoff</name> <operator>=</operator> <call><name>_bt_binsrch_insert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>insertstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>insertstate</name><operator>-&gt;</operator><name>postingoff</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There is an overlapping posting list tuple with its LP_DEAD bit
		 * set.  We don't want to unnecessarily unset its LP_DEAD bit while
		 * performing a posting list split, so delete all LP_DEAD items early.
		 * This is the only case where LP_DEAD deletes happen even though
		 * there is space for newitem on the page.
		 */</comment>
		<expr_stmt><expr><call><name>_bt_vacuum_one_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do new binary search.  New insert location cannot overlap with any
		 * posting list now.
		 */</comment>
		<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>postingoff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>newitemoff</name> <operator>=</operator> <call><name>_bt_binsrch_insert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>insertstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>postingoff</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>newitemoff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Step right to next non-dead page, during insertion.
 *
 * This is a bit more complicated than moving right in a search.  We must
 * write-lock the target page before releasing write lock on current page;
 * else someone else's _bt_check_unique scan could fail to see our insertion.
 * Write locks on intermediate dead pages won't do because we don't know when
 * they will get de-linked from the tree.
 *
 * This is more aggressive than it needs to be for non-unique !heapkeyspace
 * indexes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_stepright</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTInsertState</name></type> <name>insertstate</name></decl></parameter>, <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rblkno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rblkno</name> <operator>=</operator> <name><name>lpageop</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>rblkno</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this page was incompletely split, finish the split now.  We do
		 * this while holding a lock on the left sibling, which is not good
		 * because finishing the split could be a fairly lengthy operation.
		 * But this should happen very seldom.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bt_finish_split</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fell off the end of index \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rblkno</name> <operator>=</operator> <name><name>lpageop</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* rbuf locked; unlock buf, update state for caller */</comment>
	<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>rbuf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertstate</name><operator>-&gt;</operator><name>bounds_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 *	_bt_insertonpg() -- Insert a tuple on a particular page in the index.
 *
 *		This recursive procedure does the following things:
 *
 *			+  if postingoff != 0, splits existing posting list tuple
 *			   (since it overlaps with new 'itup' tuple).
 *			+  if necessary, splits the target page, using 'itup_key' for
 *			   suffix truncation on leaf pages (caller passes NULL for
 *			   non-leaf pages).
 *			+  inserts the new tuple (might be split from posting list).
 *			+  if the page was split, pops the parent stack, and finds the
 *			   right place to insert the new child pointer (by walking
 *			   right using information stored in the parent stack).
 *			+  invokes itself with the appropriate tuple for the right
 *			   child page on the parent.
 *			+  updates the metapage if a true root or fast root is split.
 *
 *		On entry, we must have the correct buffer in which to do the
 *		insertion, and the buffer must be pinned and write-locked.  On return,
 *		we will have dropped both the pin and the lock on the buffer.
 *
 *		This routine only performs retail tuple insertions.  'itup' should
 *		always be either a non-highkey leaf item, or a downlink (new high
 *		key items are created indirectly, when a page is split).  When
 *		inserting to a non-leaf page, 'cbuf' is the left-sibling of the page
 *		we're inserting the downlink for.  This function will clear the
 *		INCOMPLETE_SPLIT flag on it, and release the buffer.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_insertonpg</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
			   <parameter><decl><type><name>BTScanInsert</name></type> <name>itup_key</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name></type> <name>cbuf</name></decl></parameter>,
			   <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
			   <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			   <parameter><decl><type><name>Size</name></type> <name>itemsz</name></decl></parameter>,
			   <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>postingoff</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>split_only_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>oposting</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>origitup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>nposting</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* child buffer must be given iff inserting on an internal page */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* tuple must have appropriate number of attributes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator>
		   <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
		   <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Every internal page should have exactly one negative infinity item at
	 * all times.  Only _bt_split() and _bt_newroot() should add items that
	 * become negative infinity items through truncation, since they're the
	 * only routines that allocate new internal pages.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>newitemoff</name> <operator>&gt;</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The caller should've finished any incomplete splits already. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot insert to incompletely split page %u"</literal></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do we need to split an existing posting list item?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>postingoff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>newitemoff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The new tuple is a duplicate with a heap TID that falls inside the
		 * range of an existing posting list tuple on a leaf page.  Prepare to
		 * split an existing posting list.  Overwriting the posting list with
		 * its post-split version is treated as an extra step in either the
		 * insert or page split critical section.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <name><name>itup_key</name><operator>-&gt;</operator><name>heapkeyspace</name></name> <operator>&amp;&amp;</operator> <name><name>itup_key</name><operator>-&gt;</operator><name>allequalimage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oposting</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * postingoff value comes from earlier call to _bt_binsrch_posting().
		 * Its binary search might think that a plain tuple must be a posting
		 * list tuple that needs to be split.  This can happen with corruption
		 * involving an existing plain tuple that is a duplicate of the new
		 * item, up to and including its table TID.  Check for that here in
		 * passing.
		 *
		 * Also verify that our caller has made sure that the existing posting
		 * list tuple does not have its LP_DEAD bit set.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>oposting</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"table tid from new index tuple (%u,%u) overlaps with invalid duplicate tuple at offset %u of block %u in index \"%s\""</literal></expr></argument>,
									 <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>newitemoff</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* use a mutable copy of itup as our itup from here on */</comment>
		<expr_stmt><expr><name>origitup</name> <operator>=</operator> <name>itup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>origitup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nposting</name> <operator>=</operator> <call><name>_bt_swap_posting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>oposting</name></expr></argument>, <argument><expr><name>postingoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* itup now contains rightmost/max TID from oposting */</comment>

		<comment type="block">/* Alter offset so that newitem goes after posting list */</comment>
		<expr_stmt><expr><name>newitemoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>newitemoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do we need to split the page to fit the item on it?
	 *
	 * Note: PageGetFreeSpace() subtracts sizeof(ItemIdData) from its result,
	 * so this comparison is correct even though we appear to be accounting
	 * only for the item and not for its line pointer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>itemsz</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_root</name> <init>= <expr><call><name>P_ISROOT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_only</name> <init>= <expr><call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>split_only_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* split the buffer into left and right halves */</comment>
		<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>_bt_split</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>newitemoff</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>,
						 <argument><expr><name>origitup</name></expr></argument>, <argument><expr><name>nposting</name></expr></argument>, <argument><expr><name>postingoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PredicateLockPageSplit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*----------
		 * By here,
		 *
		 *		+  our target page has been split;
		 *		+  the original tuple has been inserted;
		 *		+  we have write locks on both the old (left half)
		 *		   and new (right half) buffers, after the split; and
		 *		+  we know the key we want to insert into the parent
		 *		   (it's the "high key" on the left child page).
		 *
		 * We're ready to do the parent insertion.  We need to hold onto the
		 * locks for the child pages until we locate the parent, but we can
		 * at least release the lock on the right child before doing the
		 * actual insertion.  The lock on the left child will be released
		 * last of all by parent insertion, where it is the 'cbuf' of parent
		 * page.
		 *----------
		 */</comment>
		<expr_stmt><expr><call><name>_bt_insert_parent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>is_root</name></expr></argument>, <argument><expr><name>is_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isleaf</name> <init>= <expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isrightmost</name> <init>= <expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockcache</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we are doing this insert because we split a page that was the
		 * only one on its tree level, but was not the root, it may have been
		 * the "fast root".  We need to ensure that the fast root link points
		 * at or above the current page.  We can safely acquire a lock on the
		 * metapage here --- see comments for _bt_newroot().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>split_only_page</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isleaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>&gt;=</operator> <name><name>lpageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no update wanted */</comment>
				<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Do the update.  No ereport(ERROR) until changes are logged */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>postingoff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>oposting</name></expr></argument>, <argument><expr><name>nposting</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>nposting</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>newitemoff</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to block %u in index \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* upgrade meta-page if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_NOVAC_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_bt_upgrademetapage</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>=</operator> <name><name>lpageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Clear INCOMPLETE_SPLIT flag on child if inserting the new item
		 * finishes a split
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>cpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>cpageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>cpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>cpageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cpageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* XLOG stuff */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_btree_insert</name></type> <name>xlrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xl_btree_metadata</name></type> <name>xlmeta</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint8</name></type>		<name>xlinfo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>upostingoff</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <name>newitemoff</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBtreeInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>isleaf</name> <operator>&amp;&amp;</operator> <name>postingoff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Simple leaf insert */</comment>
				<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <name>XLOG_BTREE_INSERT_LEAF</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>postingoff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Leaf insert with posting list split.  Must include
				 * postingoff field before newitem/orignewitem.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>isleaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <name>XLOG_BTREE_INSERT_POST</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Internal page insert, which finishes a split on cbuf */</comment>
				<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <name>XLOG_BTREE_INSERT_UPPER</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Actually, it's an internal page insert + meta update */</comment>
					<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <name>XLOG_BTREE_INSERT_META</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_NOVAC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>fastroot</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>fastlevel</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>oldest_btpo_xact</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>last_cleanup_num_heap_tuples</name></name> <operator>=</operator>
						<name><name>metad</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>allequalimage</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>,
									   <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlmeta</name></expr></argument>,
										<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_btree_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>postingoff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Just log itup from caller */</comment>
				<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Insert with posting list split (XLOG_BTREE_INSERT_POST
				 * record) case.
				 *
				 * Log postingoff.  Also log origitup, not itup.  REDO routine
				 * must reconstruct final itup (as well as nposting) using
				 * _bt_swap_posting().
				 */</comment>
				<expr_stmt><expr><name>upostingoff</name> <operator>=</operator> <name>postingoff</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>upostingoff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>origitup</name></expr></argument>,
									<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>origitup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>xlinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release subsidiary buffers */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Cache the block number if this is the rightmost leaf page.  Cache
		 * may be used by a future inserter within _bt_search_insert().
		 */</comment>
		<expr_stmt><expr><name>blockcache</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isrightmost</name> <operator>&amp;&amp;</operator> <name>isleaf</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISROOT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>blockcache</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Release buffer for insertion target block */</comment>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we decided to cache the insertion target block before releasing
		 * its buffer lock, then cache it now.  Check the height of the tree
		 * first, though.  We don't go for the optimization with small
		 * indexes.  Defer final check to this point to ensure that we don't
		 * call _bt_getrootheight while holding a buffer lock.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blockcache</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>_bt_getrootheight</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>BTREE_FASTPATH_MIN_LEVEL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RelationSetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blockcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* be tidy */</comment>
	<if_stmt><if>if <condition>(<expr><name>postingoff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* itup is actually a modified copy of caller's original */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nposting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_split() -- split a page in the btree.
 *
 *		On entry, buf is the page to split, and is pinned and write-locked.
 *		newitemoff etc. tell us about the new item that must be inserted
 *		along with the data from the original page.
 *
 *		itup_key is used for suffix truncation on leaf pages (internal
 *		page callers pass NULL).  When splitting a non-leaf page, 'cbuf'
 *		is the left-sibling of the page we're inserting the downlink for.
 *		This function will clear the INCOMPLETE_SPLIT flag on it, and
 *		release the buffer.
 *
 *		orignewitem, nposting, and postingoff are needed when an insert of
 *		orignewitem results in both a posting list split and a page split.
 *		These extra posting list split details are used here in the same
 *		way as they are used in the more common case where a posting list
 *		split does not coincide with a page split.  We need to deal with
 *		posting list splits directly in order to ensure that everything
 *		that follows from the insert of orignewitem is handled as a single
 *		atomic operation (though caller's insert of a new pivot/downlink
 *		into parent page will still be a separate operation).  See
 *		nbtree/README for details on the design of posting list splits.
 *
 *		Returns the new right sibling of buf, pinned and write-locked.
 *		The pin and lock on buf are maintained.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>_bt_split</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>itup_key</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>cbuf</name></decl></parameter>,
		  <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>newitem</name></decl></parameter>,
		  <parameter><decl><type><name>IndexTuple</name></type> <name>orignewitem</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>nposting</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>postingoff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>origpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>leftpage</name></decl>,
				<decl><type ref="prev"/><name>rightpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>origpagenumber</name></decl>,
				<decl><type ref="prev"/><name>rightpagenumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>ropaque</name></decl>,
				<decl><type ref="prev"/><name>lopaque</name></decl>,
				<decl><type ref="prev"/><name>oopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>sbuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>spage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>sopaque</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>firstright</name></decl>,
				<decl><type ref="prev"/><name>lefthighkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>firstrightoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>afterleftoff</name></decl>,
				<decl><type ref="prev"/><name>afterrightoff</name></decl>,
				<decl><type ref="prev"/><name>minusinfoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>origpagepostingoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newitemonleft</name></decl>,
				<decl><type ref="prev"/><name>isleaf</name></decl>,
				<decl><type ref="prev"/><name>isrightmost</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * origpage is the original page to be split.  leftpage is a temporary
	 * buffer that receives the left-sibling data, which will be copied back
	 * into origpage on success.  rightpage is the new page that will receive
	 * the right-sibling data.
	 *
	 * leftpage is allocated after choosing a split point.  rightpage's new
	 * buffer isn't acquired until after leftpage is initialized and has new
	 * high key, the last point where splitting the page may fail (barring
	 * corruption).  Failing before acquiring new buffer won't have lasting
	 * consequences, since origpage won't have been modified and leftpage is
	 * only workspace.
	 */</comment>
	<expr_stmt><expr><name>origpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isleaf</name> <operator>=</operator> <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isrightmost</name> <operator>=</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>origpagenumber</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Choose a point to split origpage at.
	 *
	 * A split point can be thought of as a point _between_ two existing data
	 * items on origpage (the lastleft and firstright tuples), provided you
	 * pretend that the new item that didn't fit is already on origpage.
	 *
	 * Since origpage does not actually contain newitem, the representation of
	 * split points needs to work with two boundary cases: splits where
	 * newitem is lastleft, and splits where newitem is firstright.
	 * newitemonleft resolves the ambiguity that would otherwise exist when
	 * newitemoff == firstrightoff.  In all other cases it's clear which side
	 * of the split every tuple goes on from context.  newitemonleft is
	 * usually (but not always) redundant information.
	 *
	 * firstrightoff is supposed to be an origpage offset number, but it's
	 * possible that its value will be maxoff+1, which is "past the end" of
	 * origpage.  This happens in the rare case where newitem goes after all
	 * existing items (i.e. newitemoff is maxoff+1) and we end up splitting
	 * origpage at the point that leaves newitem alone on new right page.  Any
	 * "!newitemonleft &amp;&amp; newitemoff == firstrightoff" split point makes
	 * newitem the firstright tuple, though, so this case isn't a special
	 * case.
	 */</comment>
	<expr_stmt><expr><name>firstrightoff</name> <operator>=</operator> <call><name>_bt_findsplitloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>newitemoff</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>,
									 <argument><expr><name>newitem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newitemonleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate temp buffer for leftpage */</comment>
	<expr_stmt><expr><name>leftpage</name> <operator>=</operator> <call><name>PageGetTempPage</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * leftpage won't be the root when we're done.  Also, clear the SPLIT_END
	 * and HAS_GARBAGE flags.
	 */</comment>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTP_ROOT</name> <operator>|</operator> <name>BTP_SPLIT_END</name> <operator>|</operator> <name>BTP_HAS_GARBAGE</name><operator>)</operator></expr>;</expr_stmt>
	<comment type="block">/* set flag in leftpage indicating that rightpage has no downlink yet */</comment>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>;</expr_stmt>
	<comment type="block">/* handle btpo_next after rightpage buffer acquired */</comment>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
	<comment type="block">/* handle btpo_cycleid after rightpage buffer acquired */</comment>

	<comment type="block">/*
	 * Copy the original page's LSN into leftpage, which will become the
	 * updated version of the page.  We need this because XLogInsert will
	 * examine the LSN and possibly dump it in a page image.
	 */</comment>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine page offset number of existing overlapped-with-orignewitem
	 * posting list when it is necessary to perform a posting list split in
	 * passing.  Note that newitem was already changed by caller (newitem no
	 * longer has the orignewitem TID).
	 *
	 * This page offset number (origpagepostingoff) will be used to pretend
	 * that the posting split has already taken place, even though the
	 * required modifications to origpage won't occur until we reach the
	 * critical section.  The lastleft and firstright tuples of our page split
	 * point should, in effect, come from an imaginary version of origpage
	 * that has the nposting tuple instead of the original posting list tuple.
	 *
	 * Note: _bt_findsplitloc() should have compensated for coinciding posting
	 * list splits in just the same way, at least in theory.  It doesn't
	 * bother with that, though.  In practice it won't affect its choice of
	 * split point.
	 */</comment>
	<expr_stmt><expr><name>origpagepostingoff</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>postingoff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>isleaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>orignewitem</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>newitem</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>nposting</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>origpagepostingoff</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>newitemoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The high key for the new left page is a possibly-truncated copy of
	 * firstright on the leaf level (it's "firstright itself" on internal
	 * pages; see !isleaf comments below).  This may seem to be contrary to
	 * Lehman &amp; Yao's approach of using a copy of lastleft as the new high key
	 * when splitting on the leaf level.  It isn't, though.
	 *
	 * Suffix truncation will leave the left page's high key fully equal to
	 * lastleft when lastleft and firstright are equal prior to heap TID (that
	 * is, the tiebreaker TID value comes from lastleft).  It isn't actually
	 * necessary for a new leaf high key to be a copy of lastleft for the L&amp;Y
	 * "subtree" invariant to hold.  It's sufficient to make sure that the new
	 * leaf high key is strictly less than firstright, and greater than or
	 * equal to (not necessarily equal to) lastleft.  In other words, when
	 * suffix truncation isn't possible during a leaf page split, we take
	 * L&amp;Y's exact approach to generating a new high key for the left page.
	 * (Actually, that is slightly inaccurate.  We don't just use a copy of
	 * lastleft.  A tuple with all the keys from firstright but the max heap
	 * TID from lastleft is used, to avoid introducing a special case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newitemonleft</name> <operator>&amp;&amp;</operator> <name>newitemoff</name> <operator>==</operator> <name>firstrightoff</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* incoming tuple becomes firstright */</comment>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <name>newitemsz</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstright</name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* existing item at firstrightoff becomes firstright */</comment>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>firstrightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstright</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>firstrightoff</name> <operator>==</operator> <name>origpagepostingoff</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>firstright</name> <operator>=</operator> <name>nposting</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isleaf</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>lastleft</name></decl>;</decl_stmt>

		<comment type="block">/* Attempt suffix truncation for leaf page splits */</comment>
		<if_stmt><if>if <condition>(<expr><name>newitemonleft</name> <operator>&amp;&amp;</operator> <name>newitemoff</name> <operator>==</operator> <name>firstrightoff</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* incoming tuple becomes lastleft */</comment>
			<expr_stmt><expr><name>lastleft</name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>lastleftoff</name></decl>;</decl_stmt>

			<comment type="block">/* existing item before firstrightoff becomes lastleft */</comment>
			<expr_stmt><expr><name>lastleftoff</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>firstrightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lastleftoff</name> <operator>&gt;=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>lastleftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastleft</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>lastleftoff</name> <operator>==</operator> <name>origpagepostingoff</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lastleft</name> <operator>=</operator> <name>nposting</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>lefthighkey</name> <operator>=</operator> <call><name>_bt_truncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lastleft</name></expr></argument>, <argument><expr><name>firstright</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>lefthighkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Don't perform suffix truncation on a copy of firstright to make
		 * left page high key for internal page splits.  Must use firstright
		 * as new high key directly.
		 *
		 * Each distinct separator key value originates as a leaf level high
		 * key; all other separator keys/pivot tuples are copied from one
		 * level down.  A separator key in a grandparent page must be
		 * identical to high key in rightmost parent page of the subtree to
		 * its left, which must itself be identical to high key in rightmost
		 * child page of that same subtree (this even applies to separator
		 * from grandparent's high key).  There must always be an unbroken
		 * "seam" of identical separator keys that guide index scans at every
		 * level, starting from the grandparent.  That's why suffix truncation
		 * is unsafe here.
		 *
		 * Internal page splits will truncate firstright into a "negative
		 * infinity" data item when it gets inserted on the new right page
		 * below, though.  This happens during the call to _bt_pgaddtup() for
		 * the new first data item for right page.  Do not confuse this
		 * mechanism with suffix truncation.  It is just a convenient way of
		 * implementing page splits that split the internal page "inside"
		 * firstright.  The lefthighkey separator key cannot appear a second
		 * time in the right page (only firstright's downlink goes in right
		 * page).
		 */</comment>
		<expr_stmt><expr><name>lefthighkey</name> <operator>=</operator> <name>firstright</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Add new high key to leftpage
	 */</comment>
	<expr_stmt><expr><name>afterleftoff</name> <operator>=</operator> <name>P_HIKEY</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>lefthighkey</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>lefthighkey</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
		   <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemsz</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>lefthighkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>lefthighkey</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>afterleftoff</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add high key to the left sibling"</literal>
			 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
			 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>afterleftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>afterleftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Acquire a new right page to split into, now that left page has a new
	 * high key.  From here on, it's not okay to throw an error without
	 * zeroing rightpage first.  This coding rule ensures that we won't
	 * confuse future VACUUM operations, which might otherwise try to re-find
	 * a downlink to a leftover junk page as the page undergoes deletion.
	 *
	 * It would be reasonable to start the critical section just after the new
	 * rightpage buffer is acquired instead; that would allow us to avoid
	 * leftover junk pages without bothering to zero rightpage.  We do it this
	 * way because it avoids an unnecessary PANIC when either origpage or its
	 * existing sibling page are corrupt.
	 */</comment>
	<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightpagenumber</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* rightpage was initialized by _bt_getbuf */</comment>
	<expr_stmt><expr><name>ropaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finish off remaining leftpage special area fields.  They cannot be set
	 * before both origpage (leftpage) and rightpage buffers are acquired and
	 * locked.
	 *
	 * btpo_cycleid is only used with leaf pages, though we set it here in all
	 * cases just to be consistent.
	 */</comment>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rightpagenumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <call><name>_bt_vacuum_cycleid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * rightpage won't be the root when we're done.  Also, clear the SPLIT_END
	 * and HAS_GARBAGE flags.
	 */</comment>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTP_ROOT</name> <operator>|</operator> <name>BTP_SPLIT_END</name> <operator>|</operator> <name>BTP_HAS_GARBAGE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>origpagenumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <name><name>lopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add new high key to rightpage where necessary.
	 *
	 * If the page we're splitting is not the rightmost page at its level in
	 * the tree, then the first entry on the page is the high key from
	 * origpage.
	 */</comment>
	<expr_stmt><expr><name>afterrightoff</name> <operator>=</operator> <name>P_HIKEY</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isrightmost</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>righthighkey</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>righthighkey</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>righthighkey</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>righthighkey</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
			   <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>righthighkey</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>afterrightoff</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add high key to the right sibling"</literal>
				 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
				 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>afterrightoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>afterrightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Internal page splits truncate first data item on right page -- it
	 * becomes "minus infinity" item for the page.  Set this up here.
	 */</comment>
	<expr_stmt><expr><name>minusinfoff</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minusinfoff</name> <operator>=</operator> <name>afterrightoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now transfer all the data items (non-pivot tuples in isleaf case, or
	 * additional pivot tuples in !isleaf case) to the appropriate page.
	 *
	 * Note: we *must* insert at least the right page's items in item-number
	 * order, for the benefit of _bt_restore_page().
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>dataitem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dataitem</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* replace original item with nposting due to posting split? */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>origpagepostingoff</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleIsPosting</name><argument_list>(<argument><expr><name>dataitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemsz</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>nposting</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dataitem</name> <operator>=</operator> <name>nposting</name></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/* does new item belong before this one? */</comment>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>newitemoff</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>newitemonleft</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newitemoff</name> <operator>&lt;=</operator> <name>firstrightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>afterleftoff</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to the left sibling"</literal>
						 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
						 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>afterleftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>afterleftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newitemoff</name> <operator>&gt;=</operator> <name>firstrightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>afterrightoff</name></expr></argument>,
								  <argument><expr><name>afterrightoff</name> <operator>==</operator> <name>minusinfoff</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to the right sibling"</literal>
						 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
						 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>afterrightoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>afterrightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* decide which page to put it on */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>firstrightoff</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>dataitem</name></expr></argument>, <argument><expr><name>afterleftoff</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add old item to the left sibling"</literal>
					 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
					 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>afterleftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>afterleftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>dataitem</name></expr></argument>, <argument><expr><name>afterrightoff</name></expr></argument>,
							  <argument><expr><name>afterrightoff</name> <operator>==</operator> <name>minusinfoff</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add old item to the right sibling"</literal>
					 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
					 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>afterrightoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>afterrightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Handle case where newitem goes at the end of rightpage */</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name>newitemoff</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Can't have newitemonleft here; that would imply we were told to put
		 * *everything* on the left page, which cannot fit (if it could, we'd
		 * not be splitting the page).
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>newitemonleft</name> <operator>&amp;&amp;</operator> <name>newitemoff</name> <operator>==</operator> <name>maxoff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>afterrightoff</name></expr></argument>,
						  <argument><expr><name>afterrightoff</name> <operator>==</operator> <name>minusinfoff</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to the right sibling"</literal>
				 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
				 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>afterrightoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>afterrightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have to grab the right sibling (if any) and fix the prev pointer
	 * there. We are guaranteed that this is deadlock-free since no other
	 * writer will be holding a lock on that page and trying to move left, and
	 * all readers release locks on a page before trying to fetch its
	 * neighbors.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isrightmost</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>oopaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>spage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>spage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>sopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>!=</operator> <name>origpagenumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"right sibling's left-link doesn't match: "</literal>
									 <literal type="string">"block %u links to %u instead of expected %u in index \"%s\""</literal></expr></argument>,
									 <argument><expr><name><name>oopaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr></argument>, <argument><expr><name><name>sopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr></argument>, <argument><expr><name>origpagenumber</name></expr></argument>,
									 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check to see if we can set the SPLIT_END flag in the right-hand
		 * split page; this can save some I/O for vacuum since it need not
		 * proceed to the right sibling.  We can set the flag if the right
		 * sibling has a different cycleid: that means it could not be part of
		 * a group of pages that were all split off from the same ancestor
		 * page.  If you're confused, imagine that page A splits to A B and
		 * then again, yielding A C B, while vacuum is in progress.  Tuples
		 * originally in A could now be in either B or C, hence vacuum must
		 * examine both pages.  But if D, our right sibling, has a different
		 * cycleid then it could not contain any tuples that were in A when
		 * the vacuum started.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>!=</operator> <name><name>ropaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_SPLIT_END</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Right sibling is locked, new siblings are prepared, but original page
	 * is not updated yet.
	 *
	 * NO EREPORT(ERROR) till right sibling is updated.  We can get away with
	 * not starting the critical section till here because we haven't been
	 * scribbling on the original page yet; see comments above.
	 */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * By here, the original data page has been split into two new halves, and
	 * these are correct.  The algorithm requires that the left page never
	 * move during a split, so we copy the new left page back on top of the
	 * original.  We need to do this before writing the WAL record, so that
	 * XLogInsert can WAL log an image of the page if necessary.
	 */</comment>
	<expr_stmt><expr><call><name>PageRestoreTempPage</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* leftpage, lopaque must not be used below here */</comment>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isrightmost</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>rightpagenumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clear INCOMPLETE_SPLIT flag on child if inserting the new item finishes
	 * a split
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>cpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>cpageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>cpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cpageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_btree_split</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>xlinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>ropaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
		<comment type="block">/* See comments below on newitem, orignewitem, and posting lists */</comment>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>firstrightoff</name></name> <operator>=</operator> <name>firstrightoff</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>newitemoff</name></name> <operator>=</operator> <name>newitemoff</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>postingoff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>postingoff</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>origpagepostingoff</name> <operator>&lt;</operator> <name>firstrightoff</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>postingoff</name></name> <operator>=</operator> <name>postingoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBtreeSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Log original right sibling, since we've changed its prev-pointer */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isrightmost</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Log the new item, if it was inserted on the left page. (If it was
		 * put on the right page, we don't need to explicitly WAL log it
		 * because it's included with all the other items on the right page.)
		 * Show the new item as belonging to the left page buffer, so that it
		 * is not stored if XLogInsert decides it needs a full-page image of
		 * the left page.  We always store newitemoff in the record, though.
		 *
		 * The details are sometimes slightly different for page splits that
		 * coincide with a posting list split.  If both the replacement
		 * posting list and newitem go on the right page, then we don't need
		 * to log anything extra, just like the simple !newitemonleft
		 * no-posting-split case (postingoff is set to zero in the WAL record,
		 * so recovery doesn't need to process a posting list split at all).
		 * Otherwise, we set postingoff and log orignewitem instead of
		 * newitem, despite having actually inserted newitem.  REDO routine
		 * must reconstruct nposting and newitem using _bt_swap_posting().
		 *
		 * Note: It's possible that our page split point is the point that
		 * makes the posting list lastleft and newitem firstright.  This is
		 * the only case where we log orignewitem/newitem despite newitem
		 * going on the right page.  If XLogInsert decides that it can omit
		 * orignewitem due to logging a full-page image of the left page,
		 * everything still works out, since recovery only needs to log
		 * orignewitem for items on the left page (just like the regular
		 * newitem-logged case).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>newitemonleft</name> <operator>&amp;&amp;</operator> <name><name>xlrec</name><operator>.</operator><name>postingoff</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newitem</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>postingoff</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>isleaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newitemonleft</name> <operator>||</operator> <name>firstrightoff</name> <operator>==</operator> <name>newitemoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newitemsz</name> <operator>==</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>orignewitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>orignewitem</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Log the left page's new high key */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* lefthighkey isn't local copy, get current pointer */</comment>
			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lefthighkey</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>lefthighkey</name></expr></argument>,
							<argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>lefthighkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Log the contents of the right page in the format understood by
		 * _bt_restore_page().  The whole right page will be recreated.
		 *
		 * Direct access to page is not good but faster - we should implement
		 * some new func in page API.  Note we only store the tuples
		 * themselves, knowing that they were inserted in item-number order
		 * and so the line pointers can be reconstructed.  See comments for
		 * _bt_restore_page().
		 */</comment>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rightpage</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rightpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></argument>,
							<argument><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rightpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_special</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rightpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <ternary><condition><expr><name>newitemonleft</name></expr> ?</condition><then> <expr><name>XLOG_BTREE_SPLIT_L</name></expr> </then><else>: <expr><name>XLOG_BTREE_SPLIT_R</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>xlinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isrightmost</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>spage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release the old right sibling */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isrightmost</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* release the child */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* be tidy */</comment>
	<if_stmt><if>if <condition>(<expr><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lefthighkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* split's done */</comment>
	<return>return <expr><name>rbuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_insert_parent() -- Insert downlink into parent, completing split.
 *
 * On entry, buf and rbuf are the left and right split pages, which we
 * still hold write locks on.  Both locks will be released here.  We
 * release the rbuf lock once we have a write lock on the page that we
 * intend to insert a downlink to rbuf on (i.e. buf's current parent page).
 * The lock on buf is released at the same point as the lock on the parent
 * page, since buf's INCOMPLETE_SPLIT flag must be cleared by the same
 * atomic operation that completes the split by inserting a new downlink.
 *
 * stack - stack showing how we got here.  Will be NULL when splitting true
 *			root, or during concurrent root split, where we can be inefficient
 * is_root - we split the true root
 * is_only - we split a page alone on its level (might have been fast root)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_insert_parent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
				  <parameter><decl><type><name>Buffer</name></type> <name>rbuf</name></decl></parameter>,
				  <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_root</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Here we have to do something Lehman and Yao don't talk about: deal with
	 * a root split and construction of a new root.  If our stack is empty
	 * then we have just split a node on what had been the root level when we
	 * descended the tree.  If it was still the root then we perform a
	 * new-root construction.  If it *wasn't* the root anymore, search to find
	 * the next higher level that someone constructed meanwhile, and find the
	 * right place to insert as for the normal case.
	 *
	 * If we have to search for the parent level, we do so by re-descending
	 * from the root.  This is not super-efficient, but it's rare enough not
	 * to matter.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_root</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>rootbuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stack</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* create a new root node and update the metapage */</comment>
		<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <call><name>_bt_newroot</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* release the split buffers */</comment>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>bknum</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rbknum</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>new_item</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTStackData</name></type> <name>fakestack</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>ritem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>pbuf</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>stack</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"concurrent ROOT page split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We should never reach here when a leaf page split takes place
			 * despite the insert of newitem being able to apply the fastpath
			 * optimization.  Make sure of that with an assertion.
			 *
			 * This is more of a performance issue than a correctness issue.
			 * The fastpath won't have a descent stack.  Using a phony stack
			 * here works, but never rely on that.  The fastpath should be
			 * rejected within _bt_search_insert() when the rightmost leaf
			 * page will split, since it's faster to go through _bt_search()
			 * and get a stack in the usual way.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Find the leftmost page at the next level up */</comment>
			<expr_stmt><expr><name>pbuf</name> <operator>=</operator> <call><name>_bt_get_endpoint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>lpageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Set up a phony stack entry pointing there */</comment>
			<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>&amp;</operator><name>fakestack</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* get high key from left, a strict lower bound for new right page */</comment>
		<expr_stmt><expr><name>ritem</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
										 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* form an index tuple that points at the new right page */</comment>
		<expr_stmt><expr><name>new_item</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>ritem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTreeTupleSetDownLink</name><argument_list>(<argument><expr><name>new_item</name></expr></argument>, <argument><expr><name>rbknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Re-find and write lock the parent of buf.
		 *
		 * It's possible that the location of buf's downlink has changed since
		 * our initial _bt_search() descent.  _bt_getstackbuf() will detect
		 * and recover from this, updating the stack, which ensures that the
		 * new downlink will be inserted at the correct offset. Even buf's
		 * parent may have changed.
		 */</comment>
		<expr_stmt><expr><name>pbuf</name> <operator>=</operator> <call><name>_bt_getstackbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>bknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Unlock the right child.  The left child will be unlocked in
		 * _bt_insertonpg().
		 *
		 * Unlocking the right child must be delayed until here to ensure that
		 * no concurrent VACUUM operation can become confused.  Page deletion
		 * cannot be allowed to fail to re-find a downlink for the rbuf page.
		 * (Actually, this is just a vestige of how things used to work.  The
		 * page deletion code is expected to check for the INCOMPLETE_SPLIT
		 * flag on the left child.  It won't attempt deletion of the right
		 * child until the split is complete.  Despite all this, we opt to
		 * conservatively delay unlocking the right child until here.)
		 */</comment>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pbuf</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"failed to re-find parent key in index \"%s\" for split pages %u/%u"</literal></expr></argument>,
									 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bknum</name></expr></argument>, <argument><expr><name>rbknum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Recursively insert into the parent */</comment>
		<expr_stmt><expr><call><name>_bt_insertonpg</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_parent</name></name></expr></argument>,
					   <argument><expr><name>new_item</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>new_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>is_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* be tidy */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_finish_split() -- Finish an incomplete split
 *
 * A crash or other failure can leave a split incomplete.  The insertion
 * routines won't allow to insert on a page that is incompletely split.
 * Before inserting on such a page, call _bt_finish_split().
 *
 * On entry, 'lbuf' must be locked in write-mode.  On exit, it is unlocked
 * and unpinned.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_finish_split</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lbuf</name></decl></parameter>, <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>rpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>rpageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_only</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lock right sibling, the one missing the downlink */</comment>
	<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>lpageop</name><operator>-&gt;</operator><name>btpo_next</name></name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Could this be a root split? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stack</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

		<comment type="block">/* acquire lock on the metapage */</comment>
		<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>was_root</name> <operator>=</operator> <operator>(</operator><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>==</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>was_root</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Was this the only page on the level before split? */</comment>
	<expr_stmt><expr><name>was_only</name> <operator>=</operator> <operator>(</operator><call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>rpageop</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"finishing incomplete split of %u/%u"</literal></expr></argument>,
		 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_insert_parent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lbuf</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>was_root</name></expr></argument>, <argument><expr><name>was_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_getstackbuf() -- Walk back up the tree one step, and find the pivot
 *						 tuple whose downlink points to child page.
 *
 *		Caller passes child's block number, which is used to identify
 *		associated pivot tuple in parent page using a linear search that
 *		matches on pivot's downlink/block number.  The expected location of
 *		the pivot tuple is taken from the stack one level above the child
 *		page.  This is used as a starting point.  Insertions into the
 *		parent level could cause the pivot tuple to move right; deletions
 *		could cause it to move left, but not left of the page we previously
 *		found it on.
 *
 *		Caller can use its stack to relocate the pivot tuple/downlink for
 *		any same-level page to the right of the page found by its initial
 *		descent.  This is necessary because of the possibility that caller
 *		moved right to recover from a concurrent page split.  It's also
 *		convenient for certain callers to be able to step right when there
 *		wasn't a concurrent page split, while still using their original
 *		stack.  For example, the checkingunique _bt_doinsert() case may
 *		have to step right when there are many physical duplicates, and its
 *		scantid forces an insertion to the right of the "first page the
 *		value could be on".  (This is also relied on by all of our callers
 *		when dealing with !heapkeyspace indexes.)
 *
 *		Returns write-locked parent page buffer, or InvalidBuffer if pivot
 *		tuple not found (should not happen).  Adjusts bts_blkno &amp;
 *		bts_offset if changed.  Page split caller should insert its new
 *		pivot tuple for its new right sibling page on parent page, at the
 *		offset number bts_offset + 1.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_bt_getstackbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>child</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>start</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_blkno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bt_finish_split</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
						<decl><type ref="prev"/><name>minoff</name></decl>,
						<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>item</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>minoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * start = InvalidOffsetNumber means "search the whole page". We
			 * need this test anyway due to possibility that page has a high
			 * key now when it didn't before.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <name>minoff</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <name>minoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Need this check too, to guard against possibility that page
			 * split since we visited it originally.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>maxoff</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * These loops will check every item on the page --- but in an
			 * order that's attuned to the probability of where it actually
			 * is.  Scan to the right first, then to the left.
			 */</comment>
			<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>start</name></expr>;</init>
				 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
				 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>BTreeTupleGetDownLink</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>child</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Return accurate pointer to where link is now */</comment>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
					<return>return <expr><name>buf</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</init>
				 <condition><expr><name>offnum</name> <operator>&gt;=</operator> <name>minoff</name></expr>;</condition>
				 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>BTreeTupleGetDownLink</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>child</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Return accurate pointer to where link is now */</comment>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
					<return>return <expr><name>buf</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The item we're looking for moved right at least one page.
		 *
		 * Lehman and Yao couple/chain locks when moving right here, which we
		 * can avoid.  See nbtree/README.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidBuffer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_newroot() -- Create a new root page for the index.
 *
 *		We've just split the old root page and need to create a new one.
 *		In order to do this, we add a new root page to the file, then lock
 *		the metadata page and update it.  This is guaranteed to be deadlock-
 *		free, because all readers release their locks on the metadata page
 *		before trying to lock the root, and all writers lock the root before
 *		trying to lock the metadata page.  We have a write lock on the old
 *		root page, so we have not introduced any cycles into the waits-for
 *		graph.
 *
 *		On entry, lbuf (the old root) and rbuf (its new peer) are write-
 *		locked. On exit, a new root page exists with entries for the
 *		two new children, metapage is updated and unlocked/unpinned.
 *		The new root buffer is returned to caller which has to unlock/unpin
 *		lbuf, rbuf &amp; rootbuf.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>_bt_newroot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lbuf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>rbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rootbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lpage</name></decl>,
				<decl><type ref="prev"/><name>rootpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lbkno</name></decl>,
				<decl><type ref="prev"/><name>rbkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rootblknum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>rootopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>left_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>left_item_sz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>right_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>right_item_sz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lbkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rbkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get a new root page */</comment>
	<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rootpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rootblknum</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* acquire lock on the metapage */</comment>
	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create downlink item for left page (old root).  The key value used is
	 * "minus infinity", a sentinel value that's reliably less than any real
	 * key value that could appear in the left page.
	 */</comment>
	<expr_stmt><expr><name>left_item_sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>left_item_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>left_item</name><operator>-&gt;</operator><name>t_info</name></name> <operator>=</operator> <name>left_item_sz</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTreeTupleSetDownLink</name><argument_list>(<argument><expr><name>left_item</name></expr></argument>, <argument><expr><name>lbkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTreeTupleSetNAtts</name><argument_list>(<argument><expr><name>left_item</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create downlink item for right page.  The key for it is obtained from
	 * the "high key" position in the left page.
	 */</comment>
	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_item_sz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_item</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTreeTupleSetDownLink</name><argument_list>(<argument><expr><name>right_item</name></expr></argument>, <argument><expr><name>rbkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NO EREPORT(ERROR) from here till newroot op is logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* upgrade metapage if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_NOVAC_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_upgrademetapage</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* set btree special data */</comment>
	<expr_stmt><expr><name>rootopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_ROOT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>btpo</name><operator>.</operator><name>level</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* update metapage data */</comment>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name> <operator>=</operator> <name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>=</operator> <name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert the left page pointer into the new root page.  The root page is
	 * the rightmost page on its level so there is no "high key" in it; the
	 * two items will go into positions P_HIKEY and P_FIRSTKEY.
	 *
	 * Note: we *must* insert the two items in item-number order, for the
	 * benefit of _bt_restore_page().
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>left_item</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>left_item</name></expr></argument>, <argument><expr><name>left_item_sz</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add leftkey to new root page"</literal>
			 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * insert the right page pointer into the new root page.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>right_item</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>right_item</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
		   <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>right_item</name></expr></argument>, <argument><expr><name>right_item_sz</name></expr></argument>, <argument><expr><name>P_FIRSTKEY</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add rightkey to new root page"</literal>
			 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clear the incomplete-split flag in the left child */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lopaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_btree_newroot</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_btree_metadata</name></type> <name>md</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>rootblk</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBtreeNewroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rootbuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>lbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;=</operator> <name>BTREE_NOVAC_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>fastroot</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>fastlevel</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>oldest_btpo_xact</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>allequalimage</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_allequalimage</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>md</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_btree_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Direct access to page is not good but faster - we should implement
		 * some new func in page API.
		 */</comment>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rootpage</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rootpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></argument>,
							<argument><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rootpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_special</name> <operator>-</operator>
							<operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rootpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>XLOG_BTREE_NEWROOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* done with metapage */</comment>
	<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>left_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>right_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rootbuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_pgaddtup() -- add a data item to a particular page during split.
 *
 *		The difference between this routine and a bare PageAddItem call is
 *		that this code can deal with the first data item on an internal btree
 *		page in passing.  This data item (which is called "firstright" within
 *		_bt_split()) has a key that must be treated as minus infinity after
 *		the split.  Therefore, we truncate away all attributes when caller
 *		specifies it's the first data item on page (downlink is not changed,
 *		though).  This extra step is only needed for the right page of an
 *		internal page split.  There is no need to do this for the first data
 *		item on the existing/left page, since that will already have been
 *		truncated during an earlier page split.
 *
 *		See _bt_split() for a high level explanation of why we truncate here.
 *		Note that this routine has nothing to do with suffix truncation,
 *		despite using some of the same infrastructure.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>_bt_pgaddtup</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
			 <parameter><decl><type><name>Size</name></type> <name>itemsize</name></decl></parameter>,
			 <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			 <parameter><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>newfirstdataitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTupleData</name></type> <name>trunctuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>newfirstdataitem</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>trunctuple</name> <operator>=</operator> <operator>*</operator><name>itup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trunctuple</name><operator>.</operator><name>t_info</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTreeTupleSetNAtts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>&amp;</operator><name>trunctuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>, <argument><expr><name>itup_off</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_vacuum_one_page - vacuum just one index page.
 *
 * Try to remove LP_DEAD items from the given page.  The passed buffer
 * must be exclusive-locked, but unlike a real VACUUM, we don't need a
 * super-exclusive "cleanup" lock (see nbtree/README).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_vacuum_one_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>deletable</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndeletable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>minoff</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan over all items to see which ones need to be deleted according to
	 * LP_DEAD flags.
	 */</comment>
	<expr_stmt><expr><name>minoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>minoff</name></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemId</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>deletable</name><index>[<expr><name>ndeletable</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>ndeletable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_delitems_delete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>deletable</name></expr></argument>, <argument><expr><name>ndeletable</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: if we didn't find any LP_DEAD items, then the page's
	 * BTP_HAS_GARBAGE hint bit is falsely set.  We do not bother expending a
	 * separate write to clear it, however.  We will clear it when we split
	 * the page, or when deduplication runs.
	 */</comment>
</block_content>}</block></function>
</unit>
