<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/access/hash/hashsearch.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * hashsearch.c
 *	  search code for postgres hash tables
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/hash/hashsearch.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_hash_readpage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufP</name></decl></parameter>,
						   <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_hash_load_qualified_items</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
									   <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_hash_saveitem</name><parameter_list>(<parameter><decl><type><name>HashScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>,
								  <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_hash_readnext</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufp</name></decl></parameter>,
						   <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pagep</name></decl></parameter>, <parameter><decl><type><name>HashPageOpaque</name> <modifier>*</modifier></type><name>opaquep</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 *	_hash_next() -- Get the next item in a scan.
 *
 *		On entry, so-&gt;currPos describes the current page, which may
 *		be pinned but not locked, and so-&gt;currPos.itemIndex identifies
 *		which item was previously returned.
 *
 *		On successful exit, scan-&gt;xs_ctup.t_self is set to the TID
 *		of the next heap tuple. so-&gt;currPos is updated as needed.
 *
 *		On failure exit (no more tuples), we return false with pin
 *		held on bucket page but no pins or locks held on overflow
 *		page.
 */</comment>
<function><type><name>bool</name></type>
<name>_hash_next</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashScanPosItem</name> <modifier>*</modifier></type><name>currItem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>end_of_scan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Advance to the next tuple on the current page; or if done, try to read
	 * data from the next or previous page based on the scan direction. Before
	 * moving to the next or previous page make sure that we deal with all the
	 * killed items.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name> <operator>&gt;</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_hash_kill_items</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextPage</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_hash_readpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>end_of_scan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>end_of_scan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_hash_kill_items</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>prevPage</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>,
								   <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We always maintain the pin on bucket page for whole scan
				 * operation, so releasing the additional pin we have acquired
				 * here.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator>
					<name>buf</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_hash_readpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>end_of_scan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>end_of_scan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>end_of_scan</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_hash_dropscanbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HashScanPosInvalidate</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK, itemIndex says what to return */</comment>
	<expr_stmt><expr><name>currItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_heaptid</name></name> <operator>=</operator> <name><name>currItem</name><operator>-&gt;</operator><name>heapTid</name></name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance to next page in a bucket, if any.  If we are scanning the bucket
 * being populated during split operation then this function advances to the
 * bucket being split after the last bucket page of bucket being populated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_hash_readnext</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufp</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pagep</name></decl></parameter>, <parameter><decl><type><name>HashPageOpaque</name> <modifier>*</modifier></type><name>opaquep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>block_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>opaquep</name><operator>)</operator><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Retain the pin on primary bucket page till the end of scan.  Refer the
	 * comments in _hash_first to know the reason of retaining pin.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator> <operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<comment type="block">/* check for interrupts while we're not holding any buffer lock */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>block_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * end of bucket, scan bucket being split if there was a split in
		 * progress at the start of scan.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * buffer for bucket being split must be valid as we acquire the pin
		 * on it before the start of scan and retain it till end of scan.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PredicateLockPage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * setting hashso_buc_split to true indicates that we are scanning
		 * bucket being split.
		 */</comment>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>block_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>block_found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pagep</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>opaquep</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Advance to previous page in a bucket, if any.  If the current scan has
 * started during split operation then this function advances to bucket
 * being populated after the first bucket page of bucket being split.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_hash_readprev</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufp</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>pagep</name></decl></parameter>, <parameter><decl><type><name>HashPageOpaque</name> <modifier>*</modifier></type><name>opaquep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveprevblk</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>opaquep</name><operator>)</operator><operator>-&gt;</operator><name>hasho_prevblkno</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Retain the pin on primary bucket page till the end of scan.  Refer the
	 * comments in _hash_first to know the reason of retaining pin.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator> <operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>haveprevblk</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>haveprevblk</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<comment type="block">/* check for interrupts while we're not holding any buffer lock */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>haveprevblk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>,
							 <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pagep</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>opaquep</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We always maintain the pin on bucket page for whole scan operation,
		 * so releasing the additional pin we have acquired here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator> <operator>*</operator><name>bufp</name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * end of bucket, scan bucket being populated if there was a split in
		 * progress at the start of scan.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * buffer for bucket being populated must be valid as we acquire the
		 * pin on it before the start of scan and retain it till end of scan.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pagep</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>opaquep</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><operator>*</operator><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* move to the end of bucket chain */</comment>
		<while>while <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>opaquep</name><operator>)</operator><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_hash_readnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>opaquep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * setting hashso_buc_split to false indicates that we are scanning
		 * bucket being populated.
		 */</comment>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_hash_first() -- Find the first item in a scan.
 *
 *		We find the first item (or, if backward scan, the last item) in the
 *		index that satisfies the qualification associated with the scan
 *		descriptor.
 *
 *		On successful exit, if the page containing current index tuple is an
 *		overflow page, both pin and lock are released whereas if it is a bucket
 *		page then it is pinned but not locked and data about the matching
 *		tuple(s) on the page has been loaded into so-&gt;currPos,
 *		scan-&gt;xs_ctup.t_self is set to the heap TID of the current tuple.
 *
 *		On failure exit (no more tuples), we return false, with pin held on
 *		bucket page but no pins or locks held on overflow page.
 */</comment>
<function><type><name>bool</name></type>
<name>_hash_first</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bucket</name></type>		<name>bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashScanPosItem</name> <modifier>*</modifier></type><name>currItem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pgstat_count_index_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We do not support hash scans with no index qualification, because we
	 * would have to read the whole index rather than just one bucket. That
	 * creates a whole raft of problems, since we haven't got a practical way
	 * to lock all the buckets against splits or compactions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hash indexes do not support whole-index scans"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* There may be more than one index qual, but we hash only the first */</comment>
	<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* We support only single-column hash indexes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And there's only one operator strategy, too */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the constant in the index qual is NULL, assume it cannot match any
	 * items in the index.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Okay to compute the hash key.  We want to do this before acquiring any
	 * locks, in case a user-defined hash function happens to be slow.
	 *
	 * If scankey operator is not a cross-type comparison, we can use the
	 * cached hash function; otherwise gotta look it up in the catalogs.
	 *
	 * We support the convention that sk_subtype == InvalidOid means the
	 * opclass input type; this is a hack to simplify life for ScanKeyInit().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
		<name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_datum2hashkey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_datum2hashkey_type</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
										   <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name> <operator>=</operator> <name>hashkey</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_getbucketbuf_from_hashkey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PredicateLockPage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bucket</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a bucket split is in progress, then while scanning the bucket being
	 * populated, we need to skip tuples that were copied from bucket being
	 * split.  We also need to maintain a pin on the bucket being split to
	 * ensure that split-cleanup work done by vacuum doesn't remove tuples
	 * from it till this scan is done.  We need to maintain a pin on the
	 * bucket being populated to ensure that vacuum doesn't squeeze that
	 * bucket till this scan is complete; otherwise, the ordering of tuples
	 * can't be maintained during forward and backward scans.  Here, we have
	 * to be cautious about locking order: first, acquire the lock on bucket
	 * being split; then, release the lock on it but not the pin; then,
	 * acquire a lock on bucket being populated and again re-verify whether
	 * the bucket split is still in progress.  Acquiring the lock on bucket
	 * being split first ensures that the vacuum waits for this scan to
	 * finish.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>H_BUCKET_BEING_POPULATED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>old_blkno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>old_buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>old_blkno</name> <operator>=</operator> <call><name>_hash_get_oldblock_from_newbucket</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * release the lock on new bucket and re-acquire it after acquiring
		 * the lock on old bucket.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>old_buf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>old_blkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>old_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * remember the split bucket buffer so as to use it later for
		 * scanning.
		 */</comment>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name> <operator>=</operator> <name>old_buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>old_buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name> <operator>==</operator> <name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>H_BUCKET_BEING_POPULATED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If a backwards scan is requested, move to the end of the chain */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Backward scans that start during split needs to start from end of
		 * bucket being split.
		 */</comment>
		<while>while <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			   <operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_hash_readnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* remember which buffer we have pinned, if any */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<comment type="block">/* Now find all the tuples satisfying the qualification from a page */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_hash_readpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OK, itemIndex says what to return */</comment>
	<expr_stmt><expr><name>currItem</name> <operator>=</operator> <operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_heaptid</name></name> <operator>=</operator> <name><name>currItem</name><operator>-&gt;</operator><name>heapTid</name></name></expr>;</expr_stmt>

	<comment type="block">/* if we're here, _hash_readpage found a valid tuples */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_hash_readpage() -- Load data from current index page into so-&gt;currPos
 *
 *	We scan all the items in the current index page and save them into
 *	so-&gt;currPos if it satisfies the qualification. If no matching items
 *	are found in the current page, we move to the next or previous page
 *	in a bucket chain as indicated by the direction.
 *
 *	Return true if any matching items are found else return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_hash_readpage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufP</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>itemIndex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>*</operator><name>bufP</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>prev_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<comment type="block">/* new page, locate starting position by binary search */</comment>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>_hash_binsearch</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>itemIndex</name> <operator>=</operator> <call><name>_hash_load_qualified_items</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>itemIndex</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Could not find any matching tuples in the current page, move to
			 * the next page. Before leaving the current page, deal with any
			 * killed items.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_hash_kill_items</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If this is a primary bucket page, hasho_prevblkno is not a real
			 * block number.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator>
				<name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>prev_blkno</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>prev_blkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>_hash_readnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Remember next and previous block numbers for scrollable
				 * cursors to know the start position and return false
				 * indicating that no more matching tuples were found. Also,
				 * don't reset currPage or lsn, because we expect
				 * _hash_kill_items to be called for the old page after this
				 * function returns.
				 */</comment>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>prevPage</name></name> <operator>=</operator> <name>prev_blkno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextPage</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name> <operator>=</operator> <name>itemIndex</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>next_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<comment type="block">/* new page, locate starting position by binary search */</comment>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>_hash_binsearch_last</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>itemIndex</name> <operator>=</operator> <call><name>_hash_load_qualified_items</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>itemIndex</name> <operator>!=</operator> <name>MaxIndexTuplesPerPage</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Could not find any matching tuples in the current page, move to
			 * the previous page. Before leaving the current page, deal with
			 * any killed items.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_hash_kill_items</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator>
				<name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>next_blkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>_hash_readprev</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Remember next and previous block numbers for scrollable
				 * cursors to know the start position and return false
				 * indicating that no more matching tuples were found. Also,
				 * don't reset currPage or lsn, because we expect
				 * _hash_kill_items to be called for the old page after this
				 * function returns.
				 */</comment>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>prevPage</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextPage</name></name> <operator>=</operator> <name>next_blkno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name> <operator>=</operator> <name>itemIndex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name> <operator>=</operator> <name>MaxIndexTuplesPerPage</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>itemIndex</name></name> <operator>=</operator> <name>MaxIndexTuplesPerPage</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>||</operator>
		<name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>hashso_split_bucket_buf</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>prevPage</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextPage</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>prevPage</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>nextPage</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name> <operator>&lt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Load all the qualified items from a current index page
 * into so-&gt;currPos. Helper function for _hash_readpage.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_hash_load_qualified_items</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
						   <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* load items[] in ascending order */</comment>
		<expr_stmt><expr><name>itemIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offnum</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * skip the tuples that are moved by split operation for the scan
			 * that has started when split was in progress. Also, skip the
			 * tuples that are marked as dead.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;</operator> <name>INDEX_MOVED_BY_SPLIT_MASK</name><operator>)</operator><operator>)</operator> <operator>||</operator>
				<operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>ignore_killed_tuples</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* move forward */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name> <operator>==</operator> <call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>_hash_checkqual</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* tuple is qualified, so remember it */</comment>
				<expr_stmt><expr><call><name>_hash_saveitem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>itemIndex</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>itemIndex</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * No more matching tuples exist in this page. so, exit while
				 * loop.
				 */</comment>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&lt;=</operator> <name>MaxIndexTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>itemIndex</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* load items[] in descending order */</comment>
		<expr_stmt><expr><name>itemIndex</name> <operator>=</operator> <name>MaxIndexTuplesPerPage</name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>offnum</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * skip the tuples that are moved by split operation for the scan
			 * that has started when split was in progress. Also, skip the
			 * tuples that are marked as dead.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_populated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>hashso_buc_split</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;</operator> <name>INDEX_MOVED_BY_SPLIT_MASK</name><operator>)</operator><operator>)</operator> <operator>||</operator>
				<operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>ignore_killed_tuples</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* move back */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_sk_hash</name></name> <operator>==</operator> <call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>_hash_checkqual</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>itemIndex</name><operator>--</operator></expr>;</expr_stmt>
				<comment type="block">/* tuple is qualified, so remember it */</comment>
				<expr_stmt><expr><call><name>_hash_saveitem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>itemIndex</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * No more matching tuples exist in this page. so, exit while
				 * loop.
				 */</comment>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>itemIndex</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Save an index item into so-&gt;currPos.items[itemIndex] */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>_hash_saveitem</name><parameter_list>(<parameter><decl><type><name>HashScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>,
			   <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashScanPosItem</name> <modifier>*</modifier></type><name>currItem</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name>itemIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>currItem</name><operator>-&gt;</operator><name>heapTid</name></name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currItem</name><operator>-&gt;</operator><name>indexOffset</name></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
