<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/rewrite/rewriteDefine.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * rewriteDefine.c
 *	  routines for defining a rewrite rule
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/rewrite/rewriteDefine.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_rewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteSupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkRuleResultList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>isSelect</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>requireColumnNameMatch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>setRuleCheckAsUser_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setRuleCheckAsUser_Query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * InsertRule -
 *	  takes the arguments and inserts them as a row into the system
 *	  relation "pg_rewrite"
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>InsertRule</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rulname</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>evtype</name></decl></parameter>,
		   <parameter><decl><type><name>Oid</name></type> <name>eventrel_oid</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>evinstead</name></decl></parameter>,
		   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>event_qual</name></decl></parameter>,
		   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>action</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>evqual</name> <init>= <expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>event_qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>actiontree</name> <init>= <expr><call><name>nodeToString</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_rewrite</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_rewrite</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_rewrite</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>rname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_rewrite_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>,
				<decl><type ref="prev"/><name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rewriteObjectId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_update</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set up *nulls and *values arrays
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rname</name></expr></argument>, <argument><expr><name>rulname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_rewrite_rulename</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_rewrite_ev_class</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>eventrel_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_rewrite_ev_type</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>evtype</name> <operator>+</operator> <literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_rewrite_ev_enabled</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>RULE_FIRES_ON_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_rewrite_is_instead</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>evinstead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_rewrite_ev_qual</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>evqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_rewrite_ev_action</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>actiontree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ready to store new pg_rewrite tuple
	 */</comment>
	<expr_stmt><expr><name>pg_rewrite_desc</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to see if we are replacing an existing tuple
	 */</comment>
	<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>RULERELNAME</name></expr></argument>,
							 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>eventrel_oid</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>rulname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rule \"%s\" for relation \"%s\" already exists"</literal></expr></argument>,
							<argument><expr><name>rulname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>eventrel_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * When replacing, we don't need to replace every attribute
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_rewrite_ev_type</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_rewrite_is_instead</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_rewrite_ev_qual</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_rewrite_ev_action</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_rewrite_desc</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_rewrite_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rewriteObjectId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_rewrite</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rewriteObjectId</name> <operator>=</operator> <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>pg_rewrite_desc</name></expr></argument>,
											 <argument><expr><name>RewriteOidIndexId</name></expr></argument>,
											 <argument><expr><name>Anum_pg_rewrite_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_rewrite_oid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>rewriteObjectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>pg_rewrite_desc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_rewrite_desc</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>


	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If replacing, get rid of old dependencies and make new ones */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_update</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>rewriteObjectId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Install dependency on rule's relation to ensure it will go away on
	 * relation deletion.  If the rule is ON SELECT, make the dependency
	 * implicit --- this prevents deleting a view's SELECT rule.  Other kinds
	 * of rules can be AUTO.
	 */</comment>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RewriteRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>rewriteObjectId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>eventrel_oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>,
					   <argument><expr><ternary><condition><expr><operator>(</operator><name>evtype</name> <operator>==</operator> <name>CMD_SELECT</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEPENDENCY_INTERNAL</name></expr> </then><else>: <expr><name>DEPENDENCY_AUTO</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also install dependencies on objects referenced in action and qual.
	 */</comment>
	<expr_stmt><expr><call><name>recordDependencyOnExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>action</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
						   <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>event_qual</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Find query containing OLD/NEW rtable entries */</comment>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>getInsertSelectQuery</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOnExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>event_qual</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
							   <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Post creation hook for new rule */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>rewriteObjectId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_rewrite_desc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rewriteObjectId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DefineRule
 *		Execute a CREATE RULE command.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineRule</name><parameter_list>(<parameter><decl><type><name>RuleStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>actions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>whereClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relId</name></decl>;</decl_stmt>

	<comment type="block">/* Parse analysis. */</comment>
	<expr_stmt><expr><call><name>transformRuleStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>actions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find and lock the relation.  Lock level should match
	 * DefineQueryRewrite.
	 */</comment>
	<expr_stmt><expr><name>relId</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and execute */</comment>
	<return>return <expr><call><name>DefineQueryRewrite</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rulename</name></name></expr></argument>,
							  <argument><expr><name>relId</name></expr></argument>,
							  <argument><expr><name>whereClause</name></expr></argument>,
							  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>event</name></name></expr></argument>,
							  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>instead</name></name></expr></argument>,
							  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>,
							  <argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DefineQueryRewrite
 *		Create a rule
 *
 * This is essentially the same as DefineRule() except that the rule's
 * action and qual have already been passed through parse analysis.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineQueryRewrite</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>event_relid</name></decl></parameter>,
				   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>event_qual</name></decl></parameter>,
				   <parameter><decl><type><name>CmdType</name></type> <name>event_type</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>is_instead</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>event_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>RelisBecomingView</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ruleId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we are installing an ON SELECT rule, we had better grab
	 * AccessExclusiveLock to ensure no SELECTs are currently running on the
	 * event relation. For other types of rules, it would be sufficient to
	 * grab ShareRowExclusiveLock to lock out insert/update/delete actions and
	 * to ensure that we lock out current CREATE RULE statements; but because
	 * of race conditions in access to catalog entries, we can't do that yet.
	 *
	 * Note that this lock level should match the one used in DefineRule.
	 */</comment>
	<expr_stmt><expr><name>event_relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>event_relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify relation is of a type that rules can sensibly be applied to.
	 * Internal callers can target materialized views, but transformRuleStmt()
	 * blocks them for users.  Don't mention them in the error message.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or view"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check user has permission to apply rules to this relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>event_relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No rule actions that modify OLD or NEW
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>action</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Don't be fooled by INSERT/SELECT */</comment>
		<if_stmt><if>if <condition>(<expr><name>query</name> <operator>!=</operator> <call><name>getInsertSelectQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <name>PRS2_OLD_VARNO</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rule actions on OLD are not implemented"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use views or triggers instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <name>PRS2_NEW_VARNO</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rule actions on NEW are not implemented"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use triggers instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>event_type</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Rules ON SELECT are restricted to view definitions
		 *
		 * So there cannot be INSTEAD NOTHING, ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSTEAD NOTHING rules on SELECT are not implemented"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use views instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * ... there cannot be multiple actions, ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple actions for rules on SELECT are not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * ... the one action must be a SELECT, ...
		 */</comment>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_instead</name> <operator>||</operator>
			<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rules on SELECT must have action INSTEAD SELECT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * ... it cannot contain data-modifying WITH ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rules on SELECT must not contain data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * ... there can be no rule qual, ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>event_qual</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event qualifications are not implemented for rules on SELECT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * ... the targetlist of the SELECT action must exactly match the
		 * event relation, ...
		 */</comment>
		<expr_stmt><expr><call><name>checkRuleResultList</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>true</name></expr></argument>,
							<argument><expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator>
							<name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * ... there must not be another ON SELECT rule already ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replace</name> <operator>&amp;&amp;</operator> <name><name>event_relation</name><operator>-&gt;</operator><name>rd_rules</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>event_relation</name><operator>-&gt;</operator><name>rd_rules</name><operator>-&gt;</operator><name>numLocks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rule</name> <operator>=</operator> <name><name>event_relation</name><operator>-&gt;</operator><name>rd_rules</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rule</name><operator>-&gt;</operator><name>event</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a view"</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * ... and finally the rule must be named _RETURN.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rulename</name></expr></argument>, <argument><expr><name>ViewSelectRuleName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In versions before 7.3, the expected name was _RETviewname. For
			 * backwards compatibility with old pg_dump output, accept that
			 * and silently change it to _RETURN.  Since this is just a quick
			 * backwards-compatibility hack, limit the number of characters
			 * checked to a few less than NAMEDATALEN; this saves having to
			 * worry about where a multibyte character might have gotten
			 * truncated.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>rulename</name></expr></argument>, <argument><expr><literal type="string">"_RET"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strncmp</name><argument_list>(<argument><expr><name>rulename</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">4</literal> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"view rule for \"%s\" must be named \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>ViewSelectRuleName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>rulename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>ViewSelectRuleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Are we converting a relation to a view?
		 *
		 * If so, check that the relation is empty because the storage for the
		 * relation is going to be deleted.  Also insist that the rel not be
		 * involved in partitioning, nor have any triggers, indexes, child or
		 * parent tables, RLS policies, or RLS enabled.  (Note: some of these
		 * tests are too strict, because they will reject relations that once
		 * had such but don't anymore.  But we don't really care, because this
		 * whole business of converting relations to views is just an obsolete
		 * kluge to allow dump/reload of views that participate in circular
		 * dependencies.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
			<name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scanDesc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert partitioned table \"%s\" to a view"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* only case left: */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert partition \"%s\" to a view"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scanDesc</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert table \"%s\" to a view because it is not empty"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert table \"%s\" to a view because it has triggers"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"In particular, the table cannot be involved in any foreign key relationships."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert table \"%s\" to a view because it has indexes"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert table \"%s\" to a view because it has child tables"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>has_superclass</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert table \"%s\" to a view because it has parent tables"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert table \"%s\" to a view because it has row security enabled"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>relation_has_policies</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert table \"%s\" to a view because it has row security policies"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>RelisBecomingView</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For non-SELECT rules, a RETURNING list can appear in at most one of
		 * the actions ... and there can't be any RETURNING list at all in a
		 * conditional or non-INSTEAD rule.  (Actually, there can be at most
		 * one RETURNING list across all rules on the same event, but it seems
		 * best to enforce that at rule expansion time.)  If there is a
		 * RETURNING list, it must match the event relation.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>haveReturning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>action</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>haveReturning</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have multiple RETURNING lists in a rule"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>haveReturning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>event_qual</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURNING lists are not supported in conditional rules"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_instead</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURNING lists are not supported in non-INSTEAD rules"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>checkRuleResultList</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * This rule is allowed - prepare to install it.
	 */</comment>

	<comment type="block">/* discard rule if it's null action and not INSTEAD; it's a no-op */</comment>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name>is_instead</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ruleId</name> <operator>=</operator> <call><name>InsertRule</name><argument_list>(<argument><expr><name>rulename</name></expr></argument>,
							<argument><expr><name>event_type</name></expr></argument>,
							<argument><expr><name>event_relid</name></expr></argument>,
							<argument><expr><name>is_instead</name></expr></argument>,
							<argument><expr><name>event_qual</name></expr></argument>,
							<argument><expr><name>action</name></expr></argument>,
							<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set pg_class 'relhasrules' field true for event relation.
		 *
		 * Important side effect: an SI notice is broadcast to force all
		 * backends (including me!) to update relcache entries with the new
		 * rule.
		 */</comment>
		<expr_stmt><expr><call><name>SetRelationRuleStatus</name><argument_list>(<argument><expr><name>event_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ---------------------------------------------------------------------
	 * If the relation is becoming a view:
	 * - delete the associated storage files
	 * - get rid of any system attributes in pg_attribute; a view shouldn't
	 *	 have any of those
	 * - remove the toast table; there is no need for it anymore, and its
	 *	 presence would make vacuum slightly more complicated
	 * - set relkind to RELKIND_VIEW, and adjust other pg_class fields
	 *	 to be appropriate for a view
	 *
	 * NB: we had better have AccessExclusiveLock to do this ...
	 * ---------------------------------------------------------------------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>RelisBecomingView</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relationRelation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>toastrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>toastrelid</name> <operator>=</operator> <name><name>event_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>

		<comment type="block">/* drop storage while table still looks like a table  */</comment>
		<expr_stmt><expr><call><name>RelationDropStorage</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DeleteSystemAttributeTuples</name><argument_list>(<argument><expr><name>event_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Drop the toast table if any.  (This won't take care of updating the
		 * toast fields in the relation's own pg_class entry; we handle that
		 * below.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toastrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>toastobject</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Delete the dependency of the toast relation on the main
			 * relation so we can drop the former without dropping the latter.
			 */</comment>
			<expr_stmt><expr><call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>toastrelid</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Make deletion of dependency record visible */</comment>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Now drop toast table, including its index */</comment>
			<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>toastrelid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastobject</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>,
							<argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * SetRelationRuleStatus may have updated the pg_class row, so we must
		 * advance the command counter before trying to update it again.
		 */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fix pg_class entry to look like a normal view's, including setting
		 * the correct relkind and removal of reltoastrelid of the toast table
		 * we potentially removed above.
		 */</comment>
		<expr_stmt><expr><name>classTup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>event_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>event_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relam</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_VIEW</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>=</operator> <name>InvalidMultiXactId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>=</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>classTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>ruleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close rel, but keep lock till commit... */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>event_relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * checkRuleResultList
 *		Verify that targetList produces output compatible with a tupledesc
 *
 * The targetList might be either a SELECT targetlist, or a RETURNING list;
 * isSelect tells which.  This is used for choosing error messages.
 *
 * A SELECT targetlist may optionally require that column names match.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkRuleResultList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isSelect</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>requireColumnNameMatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tllist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Only a SELECT may require a column name match. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>isSelect</name> <operator>||</operator> <operator>!</operator><name>requireColumnNameMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>tllist</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tllist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tletypid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>tletypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<comment type="block">/* resjunk entries may be ignored */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>isSelect</name></expr> ?</condition><then>
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT rule's target list has too many entries"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURNING list has too many entries"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Disallow dropped columns in the relation.  This is not really
		 * expected to happen when creating an ON SELECT rule.  It'd be
		 * possible if someone tried to convert a relation with dropped
		 * columns to a view, but the only case we care about supporting
		 * table-to-view conversion for is pg_dump, and pg_dump won't do that.
		 *
		 * Unfortunately, the situation is also possible when adding a rule
		 * with RETURNING to a regular table, and rejecting that case is
		 * altogether more annoying.  In principle we could support it by
		 * modifying the targetlist to include dummy NULL columns
		 * corresponding to the dropped columns in the tupdesc.  However,
		 * places like ruleutils.c would have to be fixed to not process such
		 * entries, and that would take an uncertain and possibly rather large
		 * amount of work.  (Note we could not dodge that by marking the dummy
		 * columns resjunk, since it's precisely the non-resjunk tlist columns
		 * that are expected to correspond to table columns.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>isSelect</name></expr> ?</condition><then>
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert relation containing dropped columns to view"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create a RETURNING list for a relation containing dropped columns"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Check name match if required; no need for two error texts here */</comment>
		<if_stmt><if>if <condition>(<expr><name>requireColumnNameMatch</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT rule's target entry %d has different column name from column \"%s\""</literal></expr></argument>,
							<argument><expr><name>i</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"SELECT target entry is named \"%s\"."</literal></expr></argument>,
							   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Check type match. */</comment>
		<expr_stmt><expr><name>tletypid</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>tletypid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>isSelect</name></expr> ?</condition><then>
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT rule's target entry %d has different type from column \"%s\""</literal></expr></argument>,
							<argument><expr><name>i</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURNING list's entry %d has different type from column \"%s\""</literal></expr></argument>,
							<argument><expr><name>i</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
					 <ternary><condition><expr><name>isSelect</name></expr> ?</condition><then>
					 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"SELECT target entry has type %s, but column has type %s."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>tletypid</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"RETURNING list entry has type %s, but column has type %s."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>tletypid</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Allow typmods to be different only if one of them is -1, ie,
		 * "unspecified".  This is necessary for cases like "numeric", where
		 * the table will have a filled-in default length but the select
		 * rule's expression will probably have typmod = -1.
		 */</comment>
		<expr_stmt><expr><name>tletypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name>tletypmod</name> <operator>&amp;&amp;</operator>
			<name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>tletypmod</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>isSelect</name></expr> ?</condition><then>
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT rule's target entry %d has different size from column \"%s\""</literal></expr></argument>,
							<argument><expr><name>i</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURNING list's entry %d has different size from column \"%s\""</literal></expr></argument>,
							<argument><expr><name>i</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
					 <ternary><condition><expr><name>isSelect</name></expr> ?</condition><then>
					 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"SELECT target entry has type %s, but column has type %s."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>tletypid</name></expr></argument>, <argument><expr><name>tletypmod</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
														<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"RETURNING list entry has type %s, but column has type %s."</literal></expr></argument>,
							   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>tletypid</name></expr></argument>, <argument><expr><name>tletypmod</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
														<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>isSelect</name></expr> ?</condition><then>
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SELECT rule's target list has too few entries"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETURNING list has too few entries"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setRuleCheckAsUser
 *		Recursively scan a query or expression tree and set the checkAsUser
 *		field to the given userid in all rtable entries.
 *
 * Note: for a view (ON SELECT rule), the checkAsUser field of the OLD
 * RTE entry will be overridden when the view rule is expanded, and the
 * checkAsUser field of the NEW entry is irrelevant because that entry's
 * requiredPerms bits will always be zero.  However, for other types of rules
 * it's important to set these fields to match the rule owner.  So we just set
 * them always.
 */</comment>
<function><type><name>void</name></type>
<name>setRuleCheckAsUser</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>setRuleCheckAsUser_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>userid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>setRuleCheckAsUser_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setRuleCheckAsUser_Query</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><operator>*</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>setRuleCheckAsUser_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setRuleCheckAsUser_Query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Set all the RTEs in this query node */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>qry-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Recurse into subquery in FROM */</comment>
			<expr_stmt><expr><call><name>setRuleCheckAsUser_Query</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Recurse into subquery-in-WITH */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>qry-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>setRuleCheckAsUser_Query</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* If there are sublinks, search for them and process their RTEs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>setRuleCheckAsUser_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>userid</name></expr></argument>,
						  <argument><expr><name>QTW_IGNORE_RC_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Change the firing semantics of an existing rule.
 */</comment>
<function><type><name>void</name></type>
<name>EnableDisableRule</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>,
				  <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_rewrite_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>owningRel</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>eventRelationOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ruletup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_rewrite</name></type> <name>ruleform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find the rule tuple to change.
	 */</comment>
	<expr_stmt><expr><name>pg_rewrite_desc</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ruletup</name> <operator>=</operator> <call><name>SearchSysCacheCopy2</name><argument_list>(<argument><expr><name>RULERELNAME</name></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>owningRel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>rulename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rule \"%s\" for relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>rulename</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>owningRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ruleform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_rewrite</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that the user has appropriate permissions.
	 */</comment>
	<expr_stmt><expr><name>eventRelationOid</name> <operator>=</operator> <name><name>ruleform</name><operator>-&gt;</operator><name>ev_class</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>eventRelationOid</name> <operator>==</operator> <name>owningRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>eventRelationOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>eventRelationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>eventRelationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Change ev_enabled if it is different from the desired new state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DatumGetChar</name><argument_list>(<argument><expr><name><name>ruleform</name><operator>-&gt;</operator><name>ev_enabled</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<name>fires_when</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ruleform</name><operator>-&gt;</operator><name>ev_enabled</name></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>fires_when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_rewrite_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ruletup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>ruletup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name><name>ruleform</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_rewrite_desc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we changed anything, broadcast a SI inval message to force each
	 * backend (including our own!) to rebuild relation's relcache entry.
	 * Otherwise they will fail to apply the change promptly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Perform permissions and integrity checks before acquiring a relation lock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForRenameRule</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>form</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped */</comment>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* only tables and views can have rules */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>form</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>form</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name><name>form</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or view"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* you must own the table to rename one of its rules */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Rename an existing rewrite rule.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>RenameRewriteRule</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldName</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_rewrite_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ruletup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_rewrite</name></type> <name>ruleform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ruleOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look up name, check permissions, and acquire lock (which we will NOT
	 * release until end of transaction).
	 */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>,
									 <argument><expr><name>RangeVarCallbackForRenameRule</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Have lock already, so just need to build relcache entry. */</comment>
	<expr_stmt><expr><name>targetrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare to modify pg_rewrite */</comment>
	<expr_stmt><expr><name>pg_rewrite_desc</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch the rule's entry (it had better exist) */</comment>
	<expr_stmt><expr><name>ruletup</name> <operator>=</operator> <call><name>SearchSysCacheCopy2</name><argument_list>(<argument><expr><name>RULERELNAME</name></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>oldName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rule \"%s\" for relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>oldName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>ruleform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_rewrite</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ruleOid</name> <operator>=</operator> <name><name>ruleform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

	<comment type="block">/* rule with the new name should not already exist */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsDefinedRewriteRule</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rule \"%s\" for relation \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name>newName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We disallow renaming ON SELECT rules, because they should always be
	 * named "_RETURN".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ruleform</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>+</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"renaming an ON SELECT rule is not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, do the update */</comment>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ruleform</name><operator>-&gt;</operator><name>rulename</name></name><operator>)</operator></expr></argument>, <argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_rewrite_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ruletup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>ruletup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>ruleOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_rewrite_desc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invalidate relation's relcache entry so that other backends (and this
	 * one too!) are sent SI message to make them rebuild relcache entries.
	 * (Ideally this should happen automatically...)
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>ruleOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close rel, but keep exclusive lock!
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>
</unit>
