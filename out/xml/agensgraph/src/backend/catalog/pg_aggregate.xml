<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/catalog/pg_aggregate.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_aggregate.c
 *	  routines to support manipulation of the pg_aggregate relation
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/catalog/pg_aggregate.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>lookup_agg_function</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fnName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>input_types</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>variadicArgType</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * AggregateCreate
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AggregateCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggName</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>aggNamespace</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>aggKind</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>numArgs</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>numDirectArgs</name></decl></parameter>,
				<parameter><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>allParameterTypes</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>parameterModes</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>parameterNames</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parameterDefaults</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>variadicArgType</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggtransfnName</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggfinalfnName</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggcombinefnName</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggserialfnName</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggdeserialfnName</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggmtransfnName</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggminvtransfnName</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggmfinalfnName</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>finalfnExtraArgs</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>mfinalfnExtraArgs</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>finalfnModify</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>mfinalfnModify</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggsortopName</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>aggTransType</name></decl></parameter>,
				<parameter><decl><type><name>int32</name></type> <name>aggTransSpace</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>aggmTransType</name></decl></parameter>,
				<parameter><decl><type><name>int32</name></type> <name>aggmTransSpace</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>agginitval</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggminitval</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>proparallel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>aggdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_aggregate</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_aggregate</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_aggregate</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>transfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>finalfn</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* can be omitted */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>combinefn</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt> <comment type="block">/* can be omitted */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>serialfn</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* can be omitted */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>deserialfn</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* can be omitted */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>mtransfn</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* can be omitted */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>minvtransfn</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* can be omitted */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>mfinalfn</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* can be omitted */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sortop</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* can be omitted */</comment>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>aggArgTypes</name> <init>= <expr><name><name>parameterTypes</name><operator>-&gt;</operator><name>values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mtransIsStrict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>finaltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>fnArgs</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs_transfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs_finalfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>detailmsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks (caller should have caught these) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>aggName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no aggregate name supplied"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>aggtransfnName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate must have a transition function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>numDirectArgs</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>numDirectArgs</name></expr></argument> &gt;</argument_list></name> <name>numArgs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incorrect number of direct arguments for aggregate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Aggregates can have at most FUNC_MAX_ARGS-1 args, else the transfn
	 * and/or finalfn will be unrepresentable in pg_proc.  We must check now
	 * to protect fixed-size arrays here and possibly in called functions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>numArgs</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>numArgs</name></expr></argument> &gt;</argument_list></name> <name>FUNC_MAX_ARGS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"aggregates cannot have more than %d argument"</literal></expr></argument>,
							   <argument><expr><literal type="string">"aggregates cannot have more than %d arguments"</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If transtype is polymorphic, must have polymorphic argument also; else
	 * we will have no way to deduce the actual transtype.
	 */</comment>
	<expr_stmt><expr><name>detailmsg</name> <operator>=</operator> <call><name>check_valid_polymorphic_signature</name><argument_list>(<argument><expr><name>aggTransType</name></expr></argument>,
												  <argument><expr><name>aggArgTypes</name></expr></argument>,
												  <argument><expr><name>numArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>detailmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot determine transition data type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>detailmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Likewise for moving-aggregate transtype, if any
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggmTransType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>detailmsg</name> <operator>=</operator> <call><name>check_valid_polymorphic_signature</name><argument_list>(<argument><expr><name>aggmTransType</name></expr></argument>,
													  <argument><expr><name>aggArgTypes</name></expr></argument>,
													  <argument><expr><name>numArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>detailmsg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot determine transition data type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>detailmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * An ordered-set aggregate that is VARIADIC must be VARIADIC ANY.  In
	 * principle we could support regular variadic types, but it would make
	 * things much more complicated because we'd have to assemble the correct
	 * subsets of arguments into array values.  Since no standard aggregates
	 * have use for such a case, we aren't bothering for now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name>aggKind</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>variadicArgType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>variadicArgType</name> <operator>!=</operator> <name>ANYOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a variadic ordered-set aggregate must use VARIADIC type ANY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's a hypothetical-set aggregate, there must be at least as many
	 * direct arguments as aggregated ones, and the last N direct arguments
	 * must match the aggregated ones in type.  (We have to check this again
	 * when the aggregate is called, in case ANY is involved, but it makes
	 * sense to reject the aggregate definition now if the declared arg types
	 * don't match up.)  It's unconditionally OK if numDirectArgs == numArgs,
	 * indicating that the grammar merged identical VARIADIC entries from both
	 * lists.  Otherwise, if the agg is VARIADIC, then we had VARIADIC only on
	 * the aggregated side, which is not OK.  Otherwise, insist on the last N
	 * parameter types on each side matching exactly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggKind</name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name> <operator>&amp;&amp;</operator>
		<name>numDirectArgs</name> <operator>&lt;</operator> <name>numArgs</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numAggregatedArgs</name> <init>= <expr><name>numArgs</name> <operator>-</operator> <name>numDirectArgs</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>variadicArgType</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>numDirectArgs</name> <operator>&lt;</operator> <name>numAggregatedArgs</name> <operator>||</operator>
			<call><name>memcmp</name><argument_list>(<argument><expr><name>aggArgTypes</name> <operator>+</operator> <operator>(</operator><name>numDirectArgs</name> <operator>-</operator> <name>numAggregatedArgs</name><operator>)</operator></expr></argument>,
				   <argument><expr><name>aggArgTypes</name> <operator>+</operator> <name>numDirectArgs</name></expr></argument>,
				   <argument><expr><name>numAggregatedArgs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a hypothetical-set aggregate must have direct arguments matching its aggregated arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the transfn.  For ordinary aggs, it takes the transtype plus all
	 * aggregate arguments.  For ordered-set aggs, it takes the transtype plus
	 * all aggregated args, but not direct args.  However, we have to treat
	 * specially the case where a trailing VARIADIC item is considered to
	 * cover both direct and aggregated args.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name>aggKind</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>numDirectArgs</name> <operator>&lt;</operator> <name>numArgs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nargs_transfn</name> <operator>=</operator> <name>numArgs</name> <operator>-</operator> <name>numDirectArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* special case with VARIADIC last arg */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>variadicArgType</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nargs_transfn</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>aggTransType</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fnArgs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>aggArgTypes</name> <operator>+</operator> <operator>(</operator><name>numArgs</name> <operator>-</operator> <operator>(</operator><name>nargs_transfn</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>,
			   <argument><expr><operator>(</operator><name>nargs_transfn</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nargs_transfn</name> <operator>=</operator> <name>numArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>aggTransType</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fnArgs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>aggArgTypes</name></expr></argument>, <argument><expr><name>numArgs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>transfn</name> <operator>=</operator> <call><name>lookup_agg_function</name><argument_list>(<argument><expr><name>aggtransfnName</name></expr></argument>, <argument><expr><name>nargs_transfn</name></expr></argument>,
								  <argument><expr><name>fnArgs</name></expr></argument>, <argument><expr><name>variadicArgType</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return type of transfn (possibly after refinement by
	 * enforce_generic_type_consistency, if transtype isn't polymorphic) must
	 * exactly match declared transtype.
	 *
	 * In the non-polymorphic-transtype case, it might be okay to allow a
	 * rettype that's binary-coercible to transtype, but I'm not quite
	 * convinced that it's either safe or useful.  When transtype is
	 * polymorphic we *must* demand exact equality.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>!=</operator> <name>aggTransType</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type of transition function %s is not %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>aggtransfnName</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>aggTransType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>transfn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>transfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the transfn is strict and the initval is NULL, make sure first input
	 * type and transtype are the same (or at least binary-compatible), so
	 * that it's OK to use the first input value as the initial transValue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>proisstrict</name></name> <operator>&amp;&amp;</operator> <name>agginitval</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>numArgs</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator>
			<operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>aggArgTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aggTransType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must not omit initial value when transition function is strict and transition type is not compatible with input type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* handle moving-aggregate transfn, if supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggmtransfnName</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The arguments are the same as for the regular transfn, except that
		 * the transition data type might be different.  So re-use the fnArgs
		 * values set up above, except for that one.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggmTransType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>aggmTransType</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>mtransfn</name> <operator>=</operator> <call><name>lookup_agg_function</name><argument_list>(<argument><expr><name>aggmtransfnName</name></expr></argument>, <argument><expr><name>nargs_transfn</name></expr></argument>,
									   <argument><expr><name>fnArgs</name></expr></argument>, <argument><expr><name>variadicArgType</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* As above, return type must exactly match declared mtranstype. */</comment>
		<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>!=</operator> <name>aggmTransType</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type of transition function %s is not %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>aggmtransfnName</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>aggmTransType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>mtransfn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>mtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the mtransfn is strict and the minitval is NULL, check first
		 * input type and mtranstype are binary-compatible.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>proisstrict</name></name> <operator>&amp;&amp;</operator> <name>aggminitval</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>numArgs</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator>
				<operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>aggArgTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>aggmTransType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must not omit initial value when transition function is strict and transition type is not compatible with input type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember if mtransfn is strict; we may need this below */</comment>
		<expr_stmt><expr><name>mtransIsStrict</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>proisstrict</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* handle minvtransfn, if supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggminvtransfnName</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This must have the same number of arguments with the same types as
		 * the forward transition function, so just re-use the fnArgs data.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aggmtransfnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>minvtransfn</name> <operator>=</operator> <call><name>lookup_agg_function</name><argument_list>(<argument><expr><name>aggminvtransfnName</name></expr></argument>, <argument><expr><name>nargs_transfn</name></expr></argument>,
										  <argument><expr><name>fnArgs</name></expr></argument>, <argument><expr><name>variadicArgType</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* As above, return type must exactly match declared mtranstype. */</comment>
		<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>!=</operator> <name>aggmTransType</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type of inverse transition function %s is not %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>aggminvtransfnName</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>aggmTransType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>minvtransfn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>minvtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We require the strictness settings of the forward and inverse
		 * transition functions to agree.  This saves having to handle
		 * assorted special cases at execution time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>proisstrict</name></name> <operator>!=</operator> <name>mtransIsStrict</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"strictness of aggregate's forward and inverse transition functions must match"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* handle finalfn, if supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggfinalfnName</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If finalfnExtraArgs is specified, the transfn takes the transtype
		 * plus all args; otherwise, it just takes the transtype plus any
		 * direct args.  (Non-direct args are useless at runtime, and are
		 * actually passed as NULLs, but we may need them in the function
		 * signature to allow resolution of a polymorphic agg's result type.)
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ffnVariadicArgType</name> <init>= <expr><name>variadicArgType</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>aggTransType</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fnArgs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>aggArgTypes</name></expr></argument>, <argument><expr><name>numArgs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>finalfnExtraArgs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nargs_finalfn</name> <operator>=</operator> <name>numArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>nargs_finalfn</name> <operator>=</operator> <name>numDirectArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>numDirectArgs</name> <operator>&lt;</operator> <name>numArgs</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* variadic argument doesn't affect finalfn */</comment>
				<expr_stmt><expr><name>ffnVariadicArgType</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>finalfn</name> <operator>=</operator> <call><name>lookup_agg_function</name><argument_list>(<argument><expr><name>aggfinalfnName</name></expr></argument>, <argument><expr><name>nargs_finalfn</name></expr></argument>,
									  <argument><expr><name>fnArgs</name></expr></argument>, <argument><expr><name>ffnVariadicArgType</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>finaltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When finalfnExtraArgs is specified, the finalfn will certainly be
		 * passed at least one null argument, so complain if it's strict.
		 * Nothing bad would happen at runtime (you'd just get a null result),
		 * but it's surely not what the user wants, so let's complain now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>finalfnExtraArgs</name> <operator>&amp;&amp;</operator> <call><name>func_strict</name><argument_list>(<argument><expr><name>finalfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"final function with extra arguments must not be declared STRICT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If no finalfn, aggregate result type is type of the state value
		 */</comment>
		<expr_stmt><expr><name>finaltype</name> <operator>=</operator> <name>aggTransType</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>finaltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* handle the combinefn, if supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggcombinefnName</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>combineType</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Combine function must have 2 arguments, each of which is the trans
		 * type.  VARIADIC doesn't affect it.
		 */</comment>
		<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>aggTransType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>aggTransType</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>combinefn</name> <operator>=</operator> <call><name>lookup_agg_function</name><argument_list>(<argument><expr><name>aggcombinefnName</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										<argument><expr><name>fnArgs</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>combineType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ensure the return type matches the aggregate's trans type */</comment>
		<if_stmt><if>if <condition>(<expr><name>combineType</name> <operator>!=</operator> <name>aggTransType</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type of combine function %s is not %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>aggcombinefnName</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>aggTransType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * A combine function to combine INTERNAL states must accept nulls and
		 * ensure that the returned state is in the correct memory context. We
		 * cannot directly check the latter, but we can check the former.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>aggTransType</name> <operator>==</operator> <name>INTERNALOID</name> <operator>&amp;&amp;</operator> <call><name>func_strict</name><argument_list>(<argument><expr><name>combinefn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"combine function with transition type %s must not be declared STRICT"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>aggTransType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Validate the serialization function, if present.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggserialfnName</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* signature is always serialize(internal) returns bytea */</comment>
		<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>serialfn</name> <operator>=</operator> <call><name>lookup_agg_function</name><argument_list>(<argument><expr><name>aggserialfnName</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>fnArgs</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>!=</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type of serialization function %s is not %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>aggserialfnName</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>BYTEAOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Validate the deserialization function, if present.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggdeserialfnName</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* signature is always deserialize(bytea, internal) returns internal */</comment>
		<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>BYTEAOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>	<comment type="block">/* dummy argument for type safety */</comment>

		<expr_stmt><expr><name>deserialfn</name> <operator>=</operator> <call><name>lookup_agg_function</name><argument_list>(<argument><expr><name>aggdeserialfnName</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										 <argument><expr><name>fnArgs</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>!=</operator> <name>INTERNALOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type of deserialization function %s is not %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>aggdeserialfnName</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>INTERNALOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If finaltype (i.e. aggregate return type) is polymorphic, inputs must
	 * be polymorphic also, else parser will fail to deduce result type.
	 * (Note: given the previous test on transtype and inputs, this cannot
	 * happen, unless someone has snuck a finalfn definition into the catalogs
	 * that itself violates the rule against polymorphic result with no
	 * polymorphic input.)
	 */</comment>
	<expr_stmt><expr><name>detailmsg</name> <operator>=</operator> <call><name>check_valid_polymorphic_signature</name><argument_list>(<argument><expr><name>finaltype</name></expr></argument>,
												  <argument><expr><name>aggArgTypes</name></expr></argument>,
												  <argument><expr><name>numArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>detailmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot determine result data type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>detailmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also, the return type can't be INTERNAL unless there's at least one
	 * INTERNAL argument.  This is the same type-safety restriction we enforce
	 * for regular functions, but at the level of aggregates.  We must test
	 * this explicitly because we allow INTERNAL as the transtype.
	 */</comment>
	<expr_stmt><expr><name>detailmsg</name> <operator>=</operator> <call><name>check_valid_internal_signature</name><argument_list>(<argument><expr><name>finaltype</name></expr></argument>,
											   <argument><expr><name>aggArgTypes</name></expr></argument>,
											   <argument><expr><name>numArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>detailmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsafe use of pseudo-type \"internal\""</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>detailmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If a moving-aggregate implementation is supplied, look up its finalfn
	 * if any, and check that the implied aggregate result type matches the
	 * plain implementation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggmTransType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* handle finalfn, if supplied */</comment>
		<if_stmt><if>if <condition>(<expr><name>aggmfinalfnName</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The arguments are figured the same way as for the regular
			 * finalfn, but using aggmTransType and mfinalfnExtraArgs.
			 */</comment>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ffnVariadicArgType</name> <init>= <expr><name>variadicArgType</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>fnArgs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>aggmTransType</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fnArgs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>aggArgTypes</name></expr></argument>, <argument><expr><name>numArgs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>mfinalfnExtraArgs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nargs_finalfn</name> <operator>=</operator> <name>numArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>nargs_finalfn</name> <operator>=</operator> <name>numDirectArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>numDirectArgs</name> <operator>&lt;</operator> <name>numArgs</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* variadic argument doesn't affect finalfn */</comment>
					<expr_stmt><expr><name>ffnVariadicArgType</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>mfinalfn</name> <operator>=</operator> <call><name>lookup_agg_function</name><argument_list>(<argument><expr><name>aggmfinalfnName</name></expr></argument>, <argument><expr><name>nargs_finalfn</name></expr></argument>,
										   <argument><expr><name>fnArgs</name></expr></argument>, <argument><expr><name>ffnVariadicArgType</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* As above, check strictness if mfinalfnExtraArgs is given */</comment>
			<if_stmt><if>if <condition>(<expr><name>mfinalfnExtraArgs</name> <operator>&amp;&amp;</operator> <call><name>func_strict</name><argument_list>(<argument><expr><name>mfinalfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"final function with extra arguments must not be declared STRICT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If no finalfn, aggregate result type is type of the state value
			 */</comment>
			<expr_stmt><expr><name>rettype</name> <operator>=</operator> <name>aggmTransType</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>!=</operator> <name>finaltype</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"moving-aggregate implementation returns type %s, but plain implementation returns type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>finaltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* handle sortop, if supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggsortopName</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>numArgs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sort operator can only be specified for single-argument aggregates"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>LookupOperName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>aggsortopName</name></expr></argument>,
								<argument><expr><name><name>aggArgTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>aggArgTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * permission checks on used types
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numArgs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name><name>aggArgTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name><name>aggArgTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>aggTransType</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>aggTransType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aggmTransType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>aggmTransType</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>aggmTransType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>finaltype</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>finaltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/*
	 * Everything looks okay.  Try to create the pg_proc entry for the
	 * aggregate.  (This could fail if there's already a conflicting entry.)
	 */</comment>

	<expr_stmt><expr><name>myself</name> <operator>=</operator> <call><name>ProcedureCreate</name><argument_list>(<argument><expr><name>aggName</name></expr></argument>,
							 <argument><expr><name>aggNamespace</name></expr></argument>,
							 <argument><expr><name>replace</name></expr></argument>,	<comment type="block">/* maybe replacement */</comment>
							 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* doesn't return a set */</comment>
							 <argument><expr><name>finaltype</name></expr></argument>, <comment type="block">/* returnType */</comment>
							 <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,	<comment type="block">/* proowner */</comment>
							 <argument><expr><name>INTERNALlanguageId</name></expr></argument>,	<comment type="block">/* languageObjectId */</comment>
							 <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no validator */</comment>
							 <argument><expr><literal type="string">"aggregate_dummy"</literal></expr></argument>, <comment type="block">/* placeholder proc */</comment>
							 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* probin */</comment>
							 <argument><expr><name>PROKIND_AGGREGATE</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* security invoker (currently not
									 * definable for agg) */</comment>
							 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* isLeakProof */</comment>
							 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* isStrict (not needed for agg) */</comment>
							 <argument><expr><name>PROVOLATILE_IMMUTABLE</name></expr></argument>, <comment type="block">/* volatility (not needed
													 * for agg) */</comment>
							 <argument><expr><name>proparallel</name></expr></argument>,
							 <argument><expr><name>parameterTypes</name></expr></argument>,	<comment type="block">/* paramTypes */</comment>
							 <argument><expr><name>allParameterTypes</name></expr></argument>, <comment type="block">/* allParamTypes */</comment>
							 <argument><expr><name>parameterModes</name></expr></argument>,	<comment type="block">/* parameterModes */</comment>
							 <argument><expr><name>parameterNames</name></expr></argument>,	<comment type="block">/* parameterNames */</comment>
							 <argument><expr><name>parameterDefaults</name></expr></argument>, <comment type="block">/* parameterDefaults */</comment>
							 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* trftypes */</comment>
							 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* proconfig */</comment>
							 <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no prosupport */</comment>
							 <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* procost */</comment>
							 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* prorows */</comment>
	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <name><name>myself</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Okay to create the pg_aggregate entry.
	 */</comment>
	<expr_stmt><expr><name>aggdesc</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AggregateRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>aggdesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

	<comment type="block">/* initialize nulls and values */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pg_aggregate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggfnoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggkind</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>aggKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggnumdirectargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>numDirectArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggtransfn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>transfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggfinalfn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>finalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggcombinefn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>combinefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggserialfn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>serialfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggdeserialfn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>deserialfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggmtransfn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>mtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggminvtransfn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>minvtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggmfinalfn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>mfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggfinalextra</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>finalfnExtraArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggmfinalextra</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>mfinalfnExtraArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggfinalmodify</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>finalfnModify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggmfinalmodify</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>mfinalfnModify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggsortop</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggtranstype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>aggTransType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggtransspace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>aggTransSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggmtranstype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>aggmTransType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggmtransspace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>aggmTransSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>agginitval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_agginitval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>agginitval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_aggregate_agginitval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggminitval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aggregate_aggminitval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>aggminitval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_aggregate_aggminitval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>oldagg</name> <init>= <expr><operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we're replacing an existing entry, we need to validate that
		 * we're not changing anything that would break callers. Specifically
		 * we must not change aggkind or aggnumdirectargs, which affect how an
		 * aggregate call is treated in parse analysis.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>aggKind</name> <operator>!=</operator> <name><name>oldagg</name><operator>-&gt;</operator><name>aggkind</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change routine kind"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <operator>(</operator><ternary><condition><expr><name><name>oldagg</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>==</operator> <name>AGGKIND_NORMAL</name></expr> ?</condition><then>
					  <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is an ordinary aggregate function."</literal></expr></argument>, <argument><expr><name>aggName</name></expr></argument>)</argument_list></call></expr> </then><else>:
					  <expr><ternary><condition><expr><name><name>oldagg</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>==</operator> <name>AGGKIND_ORDERED_SET</name></expr> ?</condition><then>
					  <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is an ordered-set aggregate."</literal></expr></argument>, <argument><expr><name>aggName</name></expr></argument>)</argument_list></call></expr> </then><else>:
					  <expr><ternary><condition><expr><name><name>oldagg</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name></expr> ?</condition><then>
					  <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a hypothetical-set aggregate."</literal></expr></argument>, <argument><expr><name>aggName</name></expr></argument>)</argument_list></call></expr> </then><else>:
					  <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>numDirectArgs</name> <operator>!=</operator> <name><name>oldagg</name><operator>-&gt;</operator><name>aggnumdirectargs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change number of direct arguments of an aggregate function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_aggregate_aggfnoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_aggregate_aggkind</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_aggregate_aggnumdirectargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>aggdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>aggdesc</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>aggdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create dependencies for the aggregate (above and beyond those already
	 * made by ProcedureCreate).  Note: we don't need an explicit dependency
	 * on aggTransType since we depend on it indirectly through transfn.
	 * Likewise for aggmTransType using the mtransfn, if it exists.
	 *
	 * If we're replacing an existing definition, ProcedureCreate deleted all
	 * our existing dependencies, so we have to do the same things here either
	 * way.
	 */</comment>

	<comment type="block">/* Depends on transition function */</comment>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>transfn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Depends on final function, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>finalfn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>finalfn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Depends on combine function, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>combinefn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>combinefn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Depends on serialization function, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>serialfn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>serialfn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Depends on deserialization function, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>deserialfn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>deserialfn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Depends on forward transition function, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>mtransfn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>mtransfn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Depends on inverse transition function, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>minvtransfn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>minvtransfn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Depends on final function, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>mfinalfn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>mfinalfn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Depends on sort operator, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lookup_agg_function
 * common code for finding aggregate support functions
 *
 * fnName: possibly-schema-qualified function name
 * nargs, input_types: expected function argument types
 * variadicArgType: type of variadic argument if any, else InvalidOid
 *
 * Returns OID of function, and stores its return type into *rettype
 *
 * NB: must not scribble on input_types[], as we may re-use those
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>lookup_agg_function</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fnName</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>input_types</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>variadicArgType</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>fnOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>vatype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>true_oid_array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncDetailCode</name></type> <name>fdresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * func_get_detail looks up the function in the catalogs, does
	 * disambiguation for polymorphic functions, handles inheritance, and
	 * returns the funcid and type and set or singleton status of the
	 * function's return value.  it also returns the true argument types to
	 * the function.
	 */</comment>
	<expr_stmt><expr><name>fdresult</name> <operator>=</operator> <call><name>func_get_detail</name><argument_list>(<argument><expr><name>fnName</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
							   <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>input_types</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>fnOid</name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retset</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>nvargs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vatype</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>true_oid_array</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* only valid case is a normal function not returning a set */</comment>
	<if_stmt><if>if <condition>(<expr><name>fdresult</name> <operator>!=</operator> <name>FUNCDETAIL_NORMAL</name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>fnOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>fnName</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>input_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>retset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s returns a set"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>fnName</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>input_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the agg is declared to take VARIADIC ANY, the underlying functions
	 * had better be declared that way too, else they may receive too many
	 * parameters; but func_get_detail would have been happy with plain ANY.
	 * (Probably nothing very bad would happen, but it wouldn't work as the
	 * user expects.)  Other combinations should work without any special
	 * pushups, given that we told func_get_detail not to expand VARIADIC.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>variadicArgType</name> <operator>==</operator> <name>ANYOID</name> <operator>&amp;&amp;</operator> <name>vatype</name> <operator>!=</operator> <name>ANYOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s must accept VARIADIC ANY to be used in this aggregate"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>fnName</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>input_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there are any polymorphic types involved, enforce consistency, and
	 * possibly refine the result type.  It's OK if the result is still
	 * polymorphic at this point, though.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>rettype</name> <operator>=</operator> <call><name>enforce_generic_type_consistency</name><argument_list>(<argument><expr><name>input_types</name></expr></argument>,
												<argument><expr><name>true_oid_array</name></expr></argument>,
												<argument><expr><name>nargs</name></expr></argument>,
												<argument><expr><operator>*</operator><name>rettype</name></expr></argument>,
												<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * func_get_detail will find functions requiring run-time argument type
	 * coercion, but nodeAgg.c isn't prepared to deal with that
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>input_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>true_oid_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s requires run-time type coercion"</literal></expr></argument>,
							<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>fnName</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
												  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>true_oid_array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Check aggregate creator has permission to call the function */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>fnOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>fnOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>fnOid</name></expr>;</return>
</block_content>}</block></function>
</unit>
