<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/catalog/pg_proc.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_proc.c
 *	  routines to support manipulation of the pg_proc relation
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/catalog/pg_proc.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/functions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>
}</block></struct></type> <name>parse_error_callback_arg</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sql_function_parse_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>match_prosrc_to_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prosrc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryText</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>cursorpos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>match_prosrc_to_literal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prosrc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>literal</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>cursorpos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newcursorpos</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *		ProcedureCreate
 *
 * Note: allParameterTypes, parameterModes, parameterNames, trftypes, and proconfig
 * are either arrays of the proper types or NULL.  We declare them Datum,
 * not "ArrayType *", to avoid importing array.h into pg_proc.h.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>ProcedureCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>procedureName</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>procNamespace</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>returnsSet</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>returnType</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>proowner</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>languageObjectId</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>languageValidator</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prosrc</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>probin</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>prokind</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>security_definer</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>isLeakProof</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>isStrict</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>volatility</name></decl></parameter>,
				<parameter><decl><type><name>char</name></type> <name>parallel</name></decl></parameter>,
				<parameter><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>allParameterTypes</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>parameterModes</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>parameterNames</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parameterDefaults</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>trftypes</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>proconfig</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>prosupport</name></decl></parameter>,
				<parameter><decl><type><name>float4</name></type> <name>procost</name></decl></parameter>,
				<parameter><decl><type><name>float4</name></type> <name>prorows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parameterCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>allParamCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>allParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>paramModes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>variadicType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>proacl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>procname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_update</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>detailmsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>trfid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>parameterCount</name> <operator>=</operator> <name><name>parameterTypes</name><operator>-&gt;</operator><name>dim1</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parameterCount</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>parameterCount</name></expr></argument> &gt;</argument_list></name> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"functions cannot have more than %d argument"</literal></expr></argument>,
							   <argument><expr><literal type="string">"functions cannot have more than %d arguments"</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* note: the above is correct, we do NOT count output arguments */</comment>

	<comment type="block">/* Deconstruct array inputs */</comment>
	<if_stmt><if>if <condition>(<expr><name>allParameterTypes</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We expect the array to be a 1-D OID array; verify that. We don't
		 * need to use deconstruct_array() since the array data is just going
		 * to look like a C array of OID values.
		 */</comment>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>allParamArray</name> <init>= <expr><operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>allParameterTypes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>allParamCount</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>allParamArray</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>allParamArray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<name>allParamCount</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>allParamArray</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>allParamArray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"allParameterTypes is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>allParams</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>allParamArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allParamCount</name> <operator>&gt;=</operator> <name>parameterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we assume caller got the contents right */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>allParamCount</name> <operator>=</operator> <name>parameterCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>allParams</name> <operator>=</operator> <name><name>parameterTypes</name><operator>-&gt;</operator><name>values</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>parameterModes</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We expect the array to be a 1-D CHAR array; verify that. We don't
		 * need to use deconstruct_array() since the array data is just going
		 * to look like a C array of char values.
		 */</comment>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>modesArray</name> <init>= <expr><operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>parameterModes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>modesArray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
			<call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>modesArray</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <name>allParamCount</name> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>modesArray</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>modesArray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CHAROID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parameterModes is not a 1-D char array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>paramModes</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>modesArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do not allow polymorphic return type unless there is a polymorphic
	 * input argument that we can use to deduce the actual return type.
	 */</comment>
	<expr_stmt><expr><name>detailmsg</name> <operator>=</operator> <call><name>check_valid_polymorphic_signature</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>,
												  <argument><expr><name><name>parameterTypes</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
												  <argument><expr><name>parameterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>detailmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot determine result data type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>detailmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also, do not allow return type INTERNAL unless at least one input
	 * argument is INTERNAL.
	 */</comment>
	<expr_stmt><expr><name>detailmsg</name> <operator>=</operator> <call><name>check_valid_internal_signature</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>,
											   <argument><expr><name><name>parameterTypes</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
											   <argument><expr><name>parameterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>detailmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsafe use of pseudo-type \"internal\""</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>detailmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Apply the same tests to any OUT arguments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>allParameterTypes</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>allParamCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>paramModes</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<name><name>paramModes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_IN</name> <operator>||</operator>
				<name><name>paramModes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_VARIADIC</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore input-only params */</comment>

			<expr_stmt><expr><name>detailmsg</name> <operator>=</operator> <call><name>check_valid_polymorphic_signature</name><argument_list>(<argument><expr><name><name>allParams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
														  <argument><expr><name><name>parameterTypes</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
														  <argument><expr><name>parameterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>detailmsg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot determine result data type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>detailmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>detailmsg</name> <operator>=</operator> <call><name>check_valid_internal_signature</name><argument_list>(<argument><expr><name><name>allParams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
													   <argument><expr><name><name>parameterTypes</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
													   <argument><expr><name>parameterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>detailmsg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsafe use of pseudo-type \"internal\""</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>detailmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Identify variadic argument type, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>paramModes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Only the last input parameter can be variadic; if it is, save its
		 * element type.  Errors here are just elog since caller should have
		 * checked this already.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>allParamCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>paramModes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PROARGMODE_IN</name></expr>:</case>
				<case>case <expr><name>PROARGMODE_INOUT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>variadicType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"variadic parameter must be last"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>PROARGMODE_OUT</name></expr>:</case>
				<case>case <expr><name>PROARGMODE_TABLE</name></expr>:</case>
					<comment type="block">/* okay */</comment>
					<break>break;</break>
				<case>case <expr><name>PROARGMODE_VARIADIC</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>variadicType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"variadic parameter must be last"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<switch>switch <condition>(<expr><name><name>allParams</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>ANYOID</name></expr>:</case>
							<expr_stmt><expr><name>variadicType</name> <operator>=</operator> <name>ANYOID</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>ANYARRAYOID</name></expr>:</case>
							<expr_stmt><expr><name>variadicType</name> <operator>=</operator> <name>ANYELEMENTOID</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>ANYCOMPATIBLEARRAYOID</name></expr>:</case>
							<expr_stmt><expr><name>variadicType</name> <operator>=</operator> <name>ANYCOMPATIBLEOID</name></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><name>variadicType</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name><name>allParams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>variadicType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"variadic parameter is not an array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid parameter mode '%c'"</literal></expr></argument>, <argument><expr><name><name>paramModes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * All seems OK; prepare the data to be inserted into pg_proc.
	 */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pg_proc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>procname</name></expr></argument>, <argument><expr><name>procedureName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>procname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_pronamespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>procNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>proowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prolang</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>languageObjectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_procost</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>procost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prorows</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>prorows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_provariadic</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>variadicType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prosupport</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>prosupport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prokind</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>prokind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prosecdef</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>security_definer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proleakproof</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>isLeakProof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proisstrict</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>isStrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proretset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>returnsSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_provolatile</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>volatility</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proparallel</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>parallel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_pronargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt16GetDatum</name><argument_list>(<argument><expr><name>parameterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_pronargdefaults</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt16GetDatum</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>parameterDefaults</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prorettype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proargtypes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>parameterTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>allParameterTypes</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proallargtypes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>allParameterTypes</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proallargtypes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>parameterModes</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proargmodes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>parameterModes</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proargmodes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>parameterNames</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proargnames</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>parameterNames</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proargnames</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>parameterDefaults</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proargdefaults</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>parameterDefaults</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proargdefaults</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>trftypes</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_protrftypes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>trftypes</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_protrftypes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_prosrc</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>probin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_probin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>probin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_probin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>proconfig</name> <operator>!=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>proconfig</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<comment type="block">/* proacl will be determined later */</comment>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for pre-existing definition */</comment>
	<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>,
							 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>procedureName</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>parameterTypes</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>procNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* There is one; okay to replace it? */</comment>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>oldproc</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>proargnames</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dropcmd</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" already exists with same argument types"</literal></expr></argument>,
							<argument><expr><name>procedureName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name><name>oldproc</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>proowner</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
						   <argument><expr><name>procedureName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Not okay to change routine kind */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>oldproc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>!=</operator> <name>prokind</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change routine kind"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <operator>(</operator><ternary><condition><expr><name><name>oldproc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_AGGREGATE</name></expr> ?</condition><then>
					  <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is an aggregate function."</literal></expr></argument>, <argument><expr><name>procedureName</name></expr></argument>)</argument_list></call></expr> </then><else>:
					  <expr><ternary><condition><expr><name><name>oldproc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_FUNCTION</name></expr> ?</condition><then>
					  <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a function."</literal></expr></argument>, <argument><expr><name>procedureName</name></expr></argument>)</argument_list></call></expr> </then><else>:
					  <expr><ternary><condition><expr><name><name>oldproc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr> ?</condition><then>
					  <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a procedure."</literal></expr></argument>, <argument><expr><name>procedureName</name></expr></argument>)</argument_list></call></expr> </then><else>:
					  <expr><ternary><condition><expr><name><name>oldproc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_WINDOW</name></expr> ?</condition><then>
					  <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a window function."</literal></expr></argument>, <argument><expr><name>procedureName</name></expr></argument>)</argument_list></call></expr> </then><else>:
					  <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>dropcmd</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>prokind</name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr> ?</condition><then> <expr><literal type="string">"DROP PROCEDURE"</literal></expr> </then><else>:
				   <expr><ternary><condition><expr><name>prokind</name> <operator>==</operator> <name>PROKIND_AGGREGATE</name></expr> ?</condition><then> <expr><literal type="string">"DROP AGGREGATE"</literal></expr> </then><else>:
				   <expr><literal type="string">"DROP FUNCTION"</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Not okay to change the return type of the existing proc, since
		 * existing rules, views, etc may depend on the return type.
		 *
		 * In case of a procedure, a changing return type means that whether
		 * the procedure has output parameters was changed.  Since there is no
		 * user visible return type, we produce a more specific error message.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>returnType</name> <operator>!=</operator> <name><name>oldproc</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>||</operator>
			<name>returnsSet</name> <operator>!=</operator> <name><name>oldproc</name><operator>-&gt;</operator><name>proretset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>prokind</name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr>
					 ?</condition><then> <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change whether a procedure has output parameters"</literal></expr></argument>)</argument_list></call></expr>
					 </then><else>: <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change return type of existing function"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>

			<comment type="block">/*
			 * translator: first %s is DROP FUNCTION, DROP PROCEDURE, or DROP
			 * AGGREGATE
			 */</comment>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use %s %s first."</literal></expr></argument>,
							 <argument><expr><name>dropcmd</name></expr></argument>,
							 <argument><expr><call><name>format_procedure</name><argument_list>(<argument><expr><name><name>oldproc</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it returns RECORD, check for possible change of record type
		 * implied by OUT parameters
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>returnType</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>olddesc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>newdesc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>olddesc</name> <operator>=</operator> <call><name>build_function_result_tupdesc_t</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newdesc</name> <operator>=</operator> <call><name>build_function_result_tupdesc_d</name><argument_list>(<argument><expr><name>prokind</name></expr></argument>,
													  <argument><expr><name>allParameterTypes</name></expr></argument>,
													  <argument><expr><name>parameterModes</name></expr></argument>,
													  <argument><expr><name>parameterNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>olddesc</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>newdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* ok, both are runtime-defined RECORDs */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>olddesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>newdesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
					 <operator>!</operator><call><name>equalTupleDescs</name><argument_list>(<argument><expr><name>olddesc</name></expr></argument>, <argument><expr><name>newdesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change return type of existing function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Row type defined by OUT parameters is different."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: first %s is DROP FUNCTION or DROP PROCEDURE */</comment>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use %s %s first."</literal></expr></argument>,
								 <argument><expr><name>dropcmd</name></expr></argument>,
								 <argument><expr><call><name>format_procedure</name><argument_list>(<argument><expr><name><name>oldproc</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there were any named input parameters, check to make sure the
		 * names have not been changed, as this could break existing calls. We
		 * allow adding names to formerly unnamed parameters, though.
		 */</comment>
		<expr_stmt><expr><name>proargnames</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>, <argument><expr><name>oldtup</name></expr></argument>,
									  <argument><expr><name>Anum_pg_proc_proargnames</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>proargmodes</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>old_arg_names</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>new_arg_names</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>n_old_arg_names</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>n_new_arg_names</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>proargmodes</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>, <argument><expr><name>oldtup</name></expr></argument>,
										  <argument><expr><name>Anum_pg_proc_proargmodes</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>proargmodes</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* just to be sure */</comment>

			<expr_stmt><expr><name>n_old_arg_names</name> <operator>=</operator> <call><name>get_func_input_arg_names</name><argument_list>(<argument><expr><name>proargnames</name></expr></argument>,
													   <argument><expr><name>proargmodes</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>old_arg_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n_new_arg_names</name> <operator>=</operator> <call><name>get_func_input_arg_names</name><argument_list>(<argument><expr><name>parameterNames</name></expr></argument>,
													   <argument><expr><name>parameterModes</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>new_arg_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n_old_arg_names</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>old_arg_names</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>n_new_arg_names</name> <operator>||</operator> <name><name>new_arg_names</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>old_arg_names</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>new_arg_names</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change name of input parameter \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>old_arg_names</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
					<comment type="block">/* translator: first %s is DROP FUNCTION or DROP PROCEDURE */</comment>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use %s %s first."</literal></expr></argument>,
									 <argument><expr><name>dropcmd</name></expr></argument>,
									 <argument><expr><call><name>format_procedure</name><argument_list>(<argument><expr><name><name>oldproc</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there are existing defaults, check compatibility: redefinition
		 * must not remove any defaults nor change their types.  (Removing a
		 * default might cause a function to fail to satisfy an existing call.
		 * Changing type would only be possible if the associated parameter is
		 * polymorphic, and in such cases a change of default type might alter
		 * the resolved output type of existing calls.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>oldproc</name><operator>-&gt;</operator><name>pronargdefaults</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>proargdefaults</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oldDefaults</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>oldlc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>newlc</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>parameterDefaults</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>oldproc</name><operator>-&gt;</operator><name>pronargdefaults</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot remove parameter defaults from existing function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: first %s is DROP FUNCTION or DROP PROCEDURE */</comment>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use %s %s first."</literal></expr></argument>,
								 <argument><expr><name>dropcmd</name></expr></argument>,
								 <argument><expr><call><name>format_procedure</name><argument_list>(<argument><expr><name><name>oldproc</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>proargdefaults</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>, <argument><expr><name>oldtup</name></expr></argument>,
											 <argument><expr><name>Anum_pg_proc_proargdefaults</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldDefaults</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>proargdefaults</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>oldDefaults</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>oldproc</name><operator>-&gt;</operator><name>pronargdefaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* new list can have more defaults than old, advance over 'em */</comment>
			<expr_stmt><expr><name>newlc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name>parameterDefaults</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>parameterDefaults</name></expr></argument>)</argument_list></call> <operator>-</operator>
								  <name><name>oldproc</name><operator>-&gt;</operator><name>pronargdefaults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>oldlc</argument>, <argument>oldDefaults</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>oldDef</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>oldlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newDef</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>newlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>oldDef</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>newDef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change data type of existing parameter default value"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<comment type="block">/* translator: first %s is DROP FUNCTION or DROP PROCEDURE */</comment>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use %s %s first."</literal></expr></argument>,
									 <argument><expr><name>dropcmd</name></expr></argument>,
									 <argument><expr><call><name>format_procedure</name><argument_list>(<argument><expr><name><name>oldproc</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>newlc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>parameterDefaults</name></expr></argument>, <argument><expr><name>newlc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Do not change existing oid, ownership or permissions, either.  Note
		 * dependency-update code below has to agree with this decision.
		 */</comment>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_proc_oid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_proc_proowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_proc_proacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Okay, do it... */</comment>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Creating a new procedure */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>newOid</name></decl>;</decl_stmt>

		<comment type="block">/* First, get default permissions and set up proacl */</comment>
		<expr_stmt><expr><name>proacl</name> <operator>=</operator> <call><name>get_user_default_acl</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>proowner</name></expr></argument>,
									  <argument><expr><name>procNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>proacl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>proacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_proc_proacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>newOid</name> <operator>=</operator> <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ProcedureOidIndexId</name></expr></argument>,
									<argument><expr><name>Anum_pg_proc_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_oid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_update</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>


	<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create dependencies for the new function.  If we are updating an
	 * existing function, first delete any existing pg_depend entries.
	 * (However, since we are not changing ownership or permissions, the
	 * shared dependencies do *not* need to change, and we leave them alone.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_update</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>retval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* dependency on namespace */</comment>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>NamespaceRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>procNamespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dependency on implementation language */</comment>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>LanguageRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>languageObjectId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dependency on return type */</comment>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>returnType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dependency on transform used by return type, if any */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>trfid</name> <operator>=</operator> <call><name>get_transform_oid</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>, <argument><expr><name>languageObjectId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TransformRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>trfid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* dependency on parameter types */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>allParamCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>allParams</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* dependency on transform used by parameter type, if any */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>trfid</name> <operator>=</operator> <call><name>get_transform_oid</name><argument_list>(<argument><expr><name><name>allParams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>languageObjectId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TransformRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>trfid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* dependency on parameter default expressions */</comment>
	<if_stmt><if>if <condition>(<expr><name>parameterDefaults</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>recordDependencyOnExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parameterDefaults</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* dependency on support function, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>prosupport</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>prosupport</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* dependency on owner */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_update</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>recordDependencyOnOwner</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>, <argument><expr><name>proowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* dependency on any roles mentioned in ACL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_update</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>recordDependencyOnNewAcl</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>proowner</name></expr></argument>, <argument><expr><name>proacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* dependency on extension */</comment>
	<expr_stmt><expr><call><name>recordDependencyOnCurrentExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>is_update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Post creation hook for new function */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify function body */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>languageValidator</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>set_items</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Advance command counter so new tuple can be seen by validator */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set per-function configuration parameters so that the validation is
		 * done with the environment the function expects.  However, if
		 * check_function_bodies is off, we don't do this, because that would
		 * create dump ordering hazards that pg_dump doesn't know how to deal
		 * with.  (For example, a SET clause might refer to a not-yet-created
		 * text search configuration.)	This means that the validator
		 * shouldn't complain about anything that might depend on a GUC
		 * parameter when check_function_bodies is off.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>check_function_bodies</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>set_items</name> <operator>=</operator> <operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>proconfig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>set_items</name></expr>)</condition>		<comment type="block">/* Need a new GUC nesting level */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ProcessGUCArray</name><argument_list>(<argument><expr><name>set_items</name></expr></argument>,
								<argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
								<argument><expr><name>PGC_S_SESSION</name></expr></argument>,
								<argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>languageValidator</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>set_items</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Validator for internal functions
 *
 * Check that the given internal function name (the "prosrc" value) is
 * a known builtin function.
 */</comment>
<function><type><name>Datum</name></type>
<name>fmgr_internal_validator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckFunctionValidatorAccess</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We do not honor check_function_bodies since it's unlikely the function
	 * name will be found later if it isn't there now.
	 */</comment>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>prosrc</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fmgr_internal_function</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no built-in function named \"%s\""</literal></expr></argument>,
						<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * Validator for C language functions
 *
 * Make sure that the library file exists, is loadable, and contains
 * the specified link symbol. Also check for a valid function
 * information record.
 */</comment>
<function><type><name>Datum</name></type>
<name>fmgr_c_validator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>libraryhandle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>probin</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckFunctionValidatorAccess</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It'd be most consistent to skip the check if !check_function_bodies,
	 * but the purpose of that switch is to be helpful for pg_dump loading,
	 * and for pg_dump loading it's much better if we *do* check.
	 */</comment>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc for C function %u"</literal></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>prosrc</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_probin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null probin for C function %u"</literal></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>probin</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>load_external_function</name><argument_list>(<argument><expr><name>probin</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>libraryhandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fetch_finfo_record</name><argument_list>(<argument><expr><name>libraryhandle</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Validator for SQL language functions
 *
 * Parse it here in order to be sure that it contains no syntax errors.
 */</comment>
<function><type><name>Datum</name></type>
<name>fmgr_sql_validator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>parse_error_callback_arg</name></type> <name>callback_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>sqlerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haspolyarg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckFunctionValidatorAccess</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Disallow pseudotype result */</comment>
	<comment type="block">/* except for RECORD, VOID, or polymorphic */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_PSEUDO</name> <operator>&amp;&amp;</operator>
		<name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
		<name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>VOIDOID</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SQL functions cannot return type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Disallow pseudotypes in arguments */</comment>
	<comment type="block">/* except for polymorphic */</comment>
	<expr_stmt><expr><name>haspolyarg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>proc</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>haspolyarg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SQL functions cannot have arguments of type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Postpone body checks if !check_function_bodies */</comment>
	<if_stmt><if>if <condition>(<expr><name>check_function_bodies</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>prosrc</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Setup error traceback support for ereport().
		 */</comment>
		<expr_stmt><expr><name><name>callback_arg</name><operator>.</operator><name>proname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callback_arg</name><operator>.</operator><name>prosrc</name></name> <operator>=</operator> <name>prosrc</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>sql_function_parse_error_callback</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>callback_arg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>sqlerrcontext</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can't do full prechecking of the function definition if there
		 * are any polymorphic input types, because actual datatypes of
		 * expression results will be unresolvable.  The check will be done at
		 * runtime instead.
		 *
		 * We can run the text through the raw parser though; this will at
		 * least catch silly syntactic errors.
		 */</comment>
		<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haspolyarg</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * OK to do full precheck: analyze and rewrite the queries, then
			 * verify the result type.
			 */</comment>
			<decl_stmt><decl><type><name>SQLFunctionParseInfoPtr</name></type> <name>pinfo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rettupdesc</name></decl>;</decl_stmt>

			<comment type="block">/* But first, set up parameter information */</comment>
			<expr_stmt><expr><name>pinfo</name> <operator>=</operator> <call><name>prepare_sql_fn_parse_info</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_sublist</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>querytree_sublist</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite_params</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
																  <argument><expr><name>prosrc</name></expr></argument>,
																  <argument><expr><operator>(</operator><name>ParserSetupHook</name><operator>)</operator> <name>sql_fn_parser_setup</name></expr></argument>,
																  <argument><expr><name>pinfo</name></expr></argument>,
																  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
										 <argument><expr><name>querytree_sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>check_sql_fn_statements</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_func_result_type</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>check_sql_fn_retval</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
									   <argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>rettupdesc</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>sqlerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Error context callback for handling errors in SQL function definitions
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sql_function_parse_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>parse_error_callback_arg</name> <modifier>*</modifier></type><name>callback_arg</name> <init>= <expr><operator>(</operator><name>parse_error_callback_arg</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* See if it's a syntax error; if so, transpose to CREATE FUNCTION */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>function_parse_error_transpose</name><argument_list>(<argument><expr><name><name>callback_arg</name><operator>-&gt;</operator><name>prosrc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If it's not a syntax error, push info onto context stack */</comment>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"SQL function \"%s\""</literal></expr></argument>, <argument><expr><name><name>callback_arg</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust a syntax error occurring inside the function body of a CREATE
 * FUNCTION or DO command.  This can be used by any function validator or
 * anonymous-block handler, not only for SQL-language functions.
 * It is assumed that the syntax error position is initially relative to the
 * function body string (as passed in).  If possible, we adjust the position
 * to reference the original command text; if we can't manage that, we set
 * up an "internal query" syntax error instead.
 *
 * Returns true if a syntax error was processed, false if not.
 */</comment>
<function><type><name>bool</name></type>
<name>function_parse_error_transpose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prosrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>origerrposition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newerrposition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryText</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Nothing to do unless we are dealing with a syntax error that has a
	 * cursor position.
	 *
	 * Some PLs may prefer to report the error position as an internal error
	 * to begin with, so check that too.
	 */</comment>
	<expr_stmt><expr><name>origerrposition</name> <operator>=</operator> <call><name>geterrposition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>origerrposition</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>origerrposition</name> <operator>=</operator> <call><name>getinternalerrposition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>origerrposition</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We can get the original query text from the active portal (hack...) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ActivePortal</name> <operator>&amp;&amp;</operator> <name><name>ActivePortal</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>PORTAL_ACTIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>queryText</name> <operator>=</operator> <name><name>ActivePortal</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>

	<comment type="block">/* Try to locate the prosrc in the original text */</comment>
	<expr_stmt><expr><name>newerrposition</name> <operator>=</operator> <call><name>match_prosrc_to_query</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>origerrposition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newerrposition</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Successful, so fix error position to reference original query */</comment>
		<expr_stmt><expr><call><name>errposition</name><argument_list>(<argument><expr><name>newerrposition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Get rid of any report of the error as an "internal query" */</comment>
		<expr_stmt><expr><call><name>internalerrposition</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrquery</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If unsuccessful, convert the position to an internal position
		 * marker and give the function text as the internal query.
		 */</comment>
		<expr_stmt><expr><call><name>errposition</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrposition</name><argument_list>(<argument><expr><name>origerrposition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>internalerrquery</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to locate the string literal containing the function body in the
 * given text of the CREATE FUNCTION or DO command.  If successful, return
 * the character (not byte) index within the command corresponding to the
 * given character index within the literal.  If not successful, return 0.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>match_prosrc_to_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prosrc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryText</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>cursorpos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Rather than fully parsing the original command, we just scan the
	 * command looking for $prosrc$ or 'prosrc'.  This could be fooled (though
	 * not in any very probable scenarios), so fail if we find more than one
	 * match.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>prosrclen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>querylen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>queryText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>matchpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newcursorpos</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>curpos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>curpos</name> <operator>&lt;</operator> <name>querylen</name> <operator>-</operator> <name>prosrclen</name></expr>;</condition> <incr><expr><name>curpos</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>queryText</name><index>[<expr><name>curpos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>queryText</name><index>[<expr><name>curpos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>prosrclen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>queryText</name><index>[<expr><name>curpos</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>prosrclen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Found a $foo$ match.  Since there are no embedded quoting
			 * characters in a dollar-quoted literal, we don't have to do any
			 * fancy arithmetic; just offset by the starting position.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>matchpos</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* multiple matches, fail */</comment>
			<expr_stmt><expr><name>matchpos</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>curpos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>
				<operator>+</operator> <name>cursorpos</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>queryText</name><index>[<expr><name>curpos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator>
				 <call><name>match_prosrc_to_literal</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>queryText</name><index>[<expr><name>curpos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
										 <argument><expr><name>cursorpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newcursorpos</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Found a 'foo' match.  match_prosrc_to_literal() has adjusted
			 * for any quotes or backslashes embedded in the literal.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>matchpos</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* multiple matches, fail */</comment>
			<expr_stmt><expr><name>matchpos</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>curpos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>
				<operator>+</operator> <name>newcursorpos</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>matchpos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to match the given source text to a single-quoted literal.
 * If successful, adjust newcursorpos to correspond to the character
 * (not byte) index corresponding to cursorpos in the source text.
 *
 * At entry, literal points just past a ' character.  We must check for the
 * trailing quote.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>match_prosrc_to_literal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prosrc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>literal</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>cursorpos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newcursorpos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newcp</name> <init>= <expr><name>cursorpos</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>chlen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This implementation handles backslashes and doubled quotes in the
	 * string literal.  It does not handle the SQL syntax for literals
	 * continued across line boundaries.
	 *
	 * We do the comparison a character at a time, not a byte at a time, so
	 * that we can do the correct cursorpos math.
	 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>prosrc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cursorpos</name><operator>--</operator></expr>;</expr_stmt>			<comment type="block">/* characters left before cursor */</comment>

		<comment type="block">/*
		 * Check for backslashes and doubled quotes in the literal; adjust
		 * newcp when one is found before the cursor.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>literal</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>literal</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cursorpos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newcp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>literal</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>literal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>literal</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cursorpos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newcp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>chlen</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>literal</name></expr></argument>, <argument><expr><name>chlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>prosrc</name> <operator>+=</operator> <name>chlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>literal</name> <operator>+=</operator> <name>chlen</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>literal</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name><name>literal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* success */</comment>
		<expr_stmt><expr><operator>*</operator><name>newcursorpos</name> <operator>=</operator> <name>newcp</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

<label><name>fail</name>:</label>
	<comment type="block">/* Must set *newcursorpos to suppress compiler warning */</comment>
	<expr_stmt><expr><operator>*</operator><name>newcursorpos</name> <operator>=</operator> <name>newcp</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>oid_array_to_list</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>,
					  <argument><expr><name>OIDOID</name></expr></argument>,
					  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>values</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
