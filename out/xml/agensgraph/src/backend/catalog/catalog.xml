<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/catalog/catalog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * catalog.c
 *		routines concerned with catalog naming conventions and other
 *		bits of hard-wired knowledge
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/catalog/catalog.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_auth_members.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_db_role_setting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_replication_origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shdepend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shdescription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shseclabel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * IsSystemRelation
 *		True iff the relation is either a system catalog or a toast table.
 *		See IsCatalogRelation for the exact definition of a system catalog.
 *
 *		We treat toast tables of user relations as "system relations" for
 *		protection purposes, e.g. you can't change their schemas without
 *		special permissions.  Therefore, most uses of this function are
 *		checking whether allow_system_table_mods restrictions apply.
 *		For other purposes, consider whether you shouldn't be using
 *		IsCatalogRelation instead.
 *
 *		This function does not perform any catalog accesses.
 *		Some callers rely on that!
 */</comment>
<function><type><name>bool</name></type>
<name>IsSystemRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsSystemClass</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsSystemClass
 *		Like the above, but takes a Form_pg_class as argument.
 *		Used when we do not want to open the relation and have to
 *		search pg_class directly.
 */</comment>
<function><type><name>bool</name></type>
<name>IsSystemClass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* IsCatalogRelationOid is a bit faster, so test that first */</comment>
	<return>return <expr><operator>(</operator><call><name>IsCatalogRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsToastClass</name><argument_list>(<argument><expr><name>reltuple</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsCatalogRelation
 *		True iff the relation is a system catalog.
 *
 *		By a system catalog, we mean one that is created during the bootstrap
 *		phase of initdb.  That includes not just the catalogs per se, but
 *		also their indexes, and TOAST tables and indexes if any.
 *
 *		This function does not perform any catalog accesses.
 *		Some callers rely on that!
 */</comment>
<function><type><name>bool</name></type>
<name>IsCatalogRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsCatalogRelationOid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsCatalogRelationOid
 *		True iff the relation identified by this OID is a system catalog.
 *
 *		By a system catalog, we mean one that is created during the bootstrap
 *		phase of initdb.  That includes not just the catalogs per se, but
 *		also their indexes, and TOAST tables and indexes if any.
 *
 *		This function does not perform any catalog accesses.
 *		Some callers rely on that!
 */</comment>
<function><type><name>bool</name></type>
<name>IsCatalogRelationOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We consider a relation to be a system catalog if it has an OID that was
	 * manually assigned or assigned by genbki.pl.  This includes all the
	 * defined catalogs, their indexes, and their TOAST tables and indexes.
	 *
	 * This rule excludes the relations in information_schema, which are not
	 * integral to the system and can be treated the same as user relations.
	 * (Since it's valid to drop and recreate information_schema, any rule
	 * that did not act this way would be wrong.)
	 *
	 * This test is reliable since an OID wraparound will skip this range of
	 * OIDs; see GetNewObjectId().
	 */</comment>
	<return>return <expr><operator>(</operator><name>relid</name> <operator>&lt;</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstBootstrapObjectId</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsToastRelation
 *		True iff relation is a TOAST support relation (or index).
 *
 *		Does not perform any catalog accesses.
 */</comment>
<function><type><name>bool</name></type>
<name>IsToastRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * What we actually check is whether the relation belongs to a pg_toast
	 * namespace.  This should be equivalent because of restrictions that are
	 * enforced elsewhere against creating user relations in, or moving
	 * relations into/out of, a pg_toast namespace.  Notice also that this
	 * will not say "true" for toast tables belonging to other sessions' temp
	 * tables; we expect that other mechanisms will prevent access to those.
	 */</comment>
	<return>return <expr><call><name>IsToastNamespace</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsToastClass
 *		Like the above, but takes a Form_pg_class as argument.
 *		Used when we do not want to open the relation and have to
 *		search pg_class directly.
 */</comment>
<function><type><name>bool</name></type>
<name>IsToastClass</name><parameter_list>(<parameter><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relnamespace</name> <init>= <expr><name><name>reltuple</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>IsToastNamespace</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsCatalogNamespace
 *		True iff namespace is pg_catalog.
 *
 *		Does not perform any catalog accesses.
 *
 * NOTE: the reason this isn't a macro is to avoid having to include
 * catalog/pg_namespace.h in a lot of places.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCatalogNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>namespaceId</name> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsToastNamespace
 *		True iff namespace is pg_toast or my temporary-toast-table namespace.
 *
 *		Does not perform any catalog accesses.
 *
 * Note: this will return false for temporary-toast-table namespaces belonging
 * to other backends.  Those are treated the same as other backends' regular
 * temp table namespaces, and access is prevented where appropriate.
 * If you need to check for those, you may be able to use isAnyTempNamespace,
 * but beware that that does involve a catalog access.
 */</comment>
<function><type><name>bool</name></type>
<name>IsToastNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>namespaceId</name> <operator>==</operator> <name>PG_TOAST_NAMESPACE</name><operator>)</operator> <operator>||</operator>
		<call><name>isTempToastNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsReservedName
 *		True iff name starts with the pg_ prefix.
 *
 *		For some classes of objects, the prefix pg_ is reserved for
 *		system objects only.  As of 8.0, this was only true for
 *		schema and tablespace names.  With 9.6, this is also true
 *		for roles.
 */</comment>
<function><type><name>bool</name></type>
<name>IsReservedName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* ugly coding for speed */</comment>
	<return>return <expr><operator>(</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator>
			<name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal> <operator>&amp;&amp;</operator>
			<name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsSharedRelation
 *		Given the OID of a relation, determine whether it's supposed to be
 *		shared across an entire database cluster.
 *
 * In older releases, this had to be hard-wired so that we could compute the
 * locktag for a relation and lock it before examining its catalog entry.
 * Since we now have MVCC catalog access, the race conditions that made that
 * a hard requirement are gone, so we could look at relaxing this restriction.
 * However, if we scanned the pg_class entry to find relisshared, and only
 * then locked the relation, pg_class could get updated in the meantime,
 * forcing us to scan the relation again, which would definitely be complex
 * and might have undesirable performance consequences.  Fortunately, the set
 * of shared relations is fairly static, so a hand-maintained list of their
 * OIDs isn't completely impractical.
 */</comment>
<function><type><name>bool</name></type>
<name>IsSharedRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* These are the shared catalogs (look for BKI_SHARED_RELATION) */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>AuthIdRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthMemRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DatabaseRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDescriptionRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDependRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedSecLabelRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>TableSpaceRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DbRoleSettingRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ReplicationOriginRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SubscriptionRelationId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* These are their indexes (see indexing.h) */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>AuthIdRolnameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthIdOidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthMemRoleMemIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthMemMemRoleIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DatabaseNameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DatabaseOidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDescriptionObjIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDependDependerIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDependReferenceIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedSecLabelObjectIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>TablespaceOidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>TablespaceNameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DbRoleSettingDatidRolidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ReplicationOriginIdentIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ReplicationOriginNameIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SubscriptionObjectIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SubscriptionNameIndexId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* These are their toast tables and toast indexes (see toasting.h) */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>PgAuthidToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgAuthidToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgDatabaseToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgDatabaseToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgDbRoleSettingToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgDbRoleSettingToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgReplicationOriginToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgReplicationOriginToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgShdescriptionToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgShdescriptionToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgShseclabelToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgShseclabelToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgSubscriptionToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgSubscriptionToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgTablespaceToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgTablespaceToastIndex</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetNewOidWithIndex
 *		Generate a new OID that is unique within the system relation.
 *
 * Since the OID is not immediately inserted into the table, there is a
 * race condition here; but a problem could occur only if someone else
 * managed to cycle through 2^32 OIDs and generate the same OID before we
 * finish inserting our row.  This seems unlikely to be a problem.  Note
 * that if we had to *commit* the row to end the race condition, the risk
 * would be rather higher; therefore we use SnapshotAny in the test, so that
 * we will see uncommitted rows.  (We used to use SnapshotDirty, but that has
 * the disadvantage that it ignores recently-deleted rows, creating a risk
 * of transient conflicts for as long as our own MVCC snapshots think a
 * recently-deleted row is live.  The risk is far higher when selecting TOAST
 * OIDs, because SnapshotToast considers dead rows as active indefinitely.)
 *
 * Note that we are effectively assuming that the table has a relatively small
 * number of entries (much less than 2^32) and there aren't very long runs of
 * consecutive existing OIDs.  This is a mostly reasonable assumption for
 * system catalogs.
 *
 * Caller must have a suitable lock on the relation.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetNewOidWithIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>oidcolumn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>collides</name></decl>;</decl_stmt>

	<comment type="block">/* Only system relations are supported */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* In bootstrap mode, we don't have any indexes to use */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>GetNewObjectId</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We should never be asked to generate a new pg_type OID during
	 * pg_upgrade; doing so would risk collisions with the OIDs it wants to
	 * assign.  Hitting this assert means there's some path where we failed to
	 * ensure that a type OID is determined by commands in the dump script.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsBinaryUpgrade</name> <operator>||</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TypeRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Generate new OIDs until we find one not in the table */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newOid</name> <operator>=</operator> <call><name>GetNewObjectId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
					<argument><expr><name>oidcolumn</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* see notes above about using SnapshotAny */</comment>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>collides</name> <operator>=</operator> <call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>collides</name></expr>)</condition>;</do>

	<return>return <expr><name>newOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNewRelFileNode
 *		Generate a new relfilenode number that is unique within the
 *		database of the given tablespace.
 *
 * If the relfilenode will also be used as the relation's OID, pass the
 * opened pg_class catalog, and this routine will guarantee that the result
 * is also an unused OID within pg_class.  If the result is to be used only
 * as a relfilenode for an existing relation, pass NULL for pg_class.
 *
 * As with GetNewOidWithIndex(), there is some theoretical risk of a race
 * condition, but it doesn't seem worth worrying about.
 *
 * Note: we don't support using this in bootstrap mode.  All relations
 * created by bootstrap have preassigned OIDs, so there's no need.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetNewRelFileNode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reltablespace</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pg_class</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>collides</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>backend</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we ever get here during pg_upgrade, there's something wrong; all
	 * relfilenode assignments during a binary-upgrade run should be
	 * determined by commands in the dump script.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsBinaryUpgrade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>relpersistence</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
			<expr_stmt><expr><name>backend</name> <operator>=</operator> <call><name>BackendIdForTempRelations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
		<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
			<expr_stmt><expr><name>backend</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid relpersistence: %c"</literal></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidOid</name></expr>;</return>	<comment type="block">/* placate compiler */</comment>
	</block_content>}</block></switch>

	<comment type="block">/* This logic should match RelationInitPhysicalAddr */</comment>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <ternary><condition><expr><name>reltablespace</name></expr> ?</condition><then> <expr><name>reltablespace</name></expr> </then><else>: <expr><name>MyDatabaseTableSpace</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>MyDatabaseId</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * The relpath will vary based on the backend ID, so we must initialize
	 * that properly here to make sure that any collisions based on filename
	 * are properly detected.
	 */</comment>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name>backend</name></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Generate the OID */</comment>
		<if_stmt><if>if <condition>(<expr><name>pg_class</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>ClassOidIndexId</name></expr></argument>,
													<argument><expr><name>Anum_pg_class_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <call><name>GetNewObjectId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Check for existing file of same name */</comment>
		<expr_stmt><expr><name>rpath</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>rpath</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* definite collision */</comment>
			<expr_stmt><expr><name>collides</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Here we have a little bit of a dilemma: if errno is something
			 * other than ENOENT, should we declare a collision and loop? In
			 * practice it seems best to go ahead regardless of the errno.  If
			 * there is a colliding file we will get an smgr failure when we
			 * attempt to create the new relation file.
			 */</comment>
			<expr_stmt><expr><name>collides</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>collides</name></expr>)</condition>;</do>

	<return>return <expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SQL callable interface for GetNewOidWithIndex().  Outside of initdb's
 * direct insertions into catalog tables, and recovering from corruption, this
 * should rarely be needed.
 *
 * Function is intentionally not documented in the user facing docs.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_nextoid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type>		<name>attname</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>idxoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newoid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * As this function is not intended to be used during normal running, and
	 * only supports system catalogs (which require superuser permissions to
	 * modify), just checking for superuser ought to not obstruct valid
	 * usecases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to call pg_nextoid()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>idxoid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_nextoid() can only be used on system catalogs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>idx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not belong to table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is not of type oid"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<name><name>idx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>attno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not the index for column \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newoid</name> <operator>=</operator> <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>idxoid</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newoid</name></expr>;</return>
</block_content>}</block></function>
</unit>
