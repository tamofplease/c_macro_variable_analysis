<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/lib/integerset.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * integerset.c
 *	  Data structure to hold a large set of 64-bit integers efficiently
 *
 * IntegerSet provides an in-memory data structure to hold a set of
 * arbitrary 64-bit integers.  Internally, the values are stored in a
 * B-tree, with a special packed representation at the leaf level using
 * the Simple-8b algorithm, which can pack clusters of nearby values
 * very tightly.
 *
 * Memory consumption depends on the number of values stored, but also
 * on how far the values are from each other.  In the best case, with
 * long runs of consecutive integers, memory consumption can be as low as
 * 0.1 bytes per integer.  In the worst case, if integers are more than
 * 2^32 apart, it uses about 8 bytes per integer.  In typical use, the
 * consumption per integer is somewhere between those extremes, depending
 * on the range of integers stored, and how "clustered" they are.
 *
 *
 * Interface
 * ---------
 *
 *	intset_create			- Create a new, empty set
 *	intset_add_member		- Add an integer to the set
 *	intset_is_member		- Test if an integer is in the set
 *	intset_begin_iterate	- Begin iterating through all integers in set
 *	intset_iterate_next		- Return next set member, if any
 *
 * intset_create() creates the set in the current memory context.  Subsequent
 * operations that add to the data structure will continue to allocate from
 * that same context, even if it's not current anymore.
 *
 * Note that there is no function to free an integer set.  If you need to do
 * that, create a dedicated memory context to hold it, and destroy the memory
 * context instead.
 *
 *
 * Limitations
 * -----------
 *
 * - Values must be added in order.  (Random insertions would require
 *   splitting nodes, which hasn't been implemented.)
 *
 * - Values cannot be added while iteration is in progress.
 *
 * - No support for removing values.
 *
 * None of these limitations are fundamental to the data structure, so they
 * could be lifted if needed, by writing some new code.  But the current
 * users of this facility don't need them.
 *
 *
 * References
 * ----------
 *
 * Simple-8b encoding is based on:
 *
 * Vo Ngoc Anh, Alistair Moffat, Index compression using 64-bit words,
 *   Software - Practice &amp; Experience, v.40 n.2, p.131-147, February 2010
 *   (https://doi.org/10.1002/spe.948)
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/lib/integerset.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/integerset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bitutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Maximum number of integers that can be encoded in a single Simple-8b
 * codeword. (Defined here before anything else, so that we can size arrays
 * using this.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLE8B_MAX_VALUES_PER_CODEWORD</name></cpp:macro> <cpp:value>240</cpp:value></cpp:define>

<comment type="block">/*
 * Parameters for shape of the in-memory B-tree.
 *
 * These set the size of each internal and leaf node.  They don't necessarily
 * need to be the same, because the tree is just an in-memory structure.
 * With the default 64, each node is about 1 kb.
 *
 * If you change these, you must recalculate MAX_TREE_LEVELS, too!
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INTERNAL_ITEMS</name></cpp:macro>	<cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_LEAF_ITEMS</name></cpp:macro>	<cpp:value>64</cpp:value></cpp:define>

<comment type="block">/*
 * Maximum height of the tree.
 *
 * MAX_TREE_ITEMS is calculated from the "fan-out" of the B-tree.  The
 * theoretical maximum number of items that we can store in a set is 2^64,
 * so MAX_TREE_LEVELS should be set so that:
 *
 *   MAX_LEAF_ITEMS * MAX_INTERNAL_ITEMS ^ (MAX_TREE_LEVELS - 1) &gt;= 2^64.
 *
 * In practice, we'll need far fewer levels, because you will run out of
 * memory long before reaching that number, but let's be conservative.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TREE_LEVELS</name></cpp:macro>		<cpp:value>11</cpp:value></cpp:define>

<comment type="block">/*
 * Node structures, for the in-memory B-tree.
 *
 * An internal node holds a number of downlink pointers to leaf nodes, or
 * to internal nodes on a lower level.  For each downlink, the key value
 * corresponding to the lower level node is stored in a sorted array.  The
 * stored key values are low keys.  In other words, if the downlink has value
 * X, then all items stored on that child are &gt;= X.
 *
 * Each leaf node holds a number of "items", with a varying number of
 * integers packed into each item.  Each item consists of two 64-bit words:
 * The first word holds the first integer stored in the item, in plain format.
 * The second word contains between 0 and 240 more integers, packed using
 * Simple-8b encoding.  By storing the first integer in plain, unpacked,
 * format, we can use binary search to quickly find an item that holds (or
 * would hold) a particular integer.  And by storing the rest in packed form,
 * we still get pretty good memory density, if there are clusters of integers
 * with similar values.
 *
 * Each leaf node also has a pointer to the next leaf node, so that the leaf
 * nodes can be easily walked from beginning to end when iterating.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>intset_node</name></name></type> <name>intset_node</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>intset_leaf_node</name></name></type> <name>intset_leaf_node</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>intset_internal_node</name></name></type> <name>intset_internal_node</name>;</typedef>

<comment type="block">/* Common structure of both leaf and internal nodes. */</comment>
<struct>struct <name>intset_node</name>
<block>{
	<decl_stmt><decl><type><name>uint16</name></type>		<name>level</name></decl>;</decl_stmt>			<comment type="block">/* tree level of this node */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>num_items</name></decl>;</decl_stmt>		<comment type="block">/* number of items in this node */</comment>
}</block>;</struct>

<comment type="block">/* Internal node */</comment>
<struct>struct <name>intset_internal_node</name>
<block>{
	<comment type="block">/* common header, must match intset_node */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>level</name></decl>;</decl_stmt>			<comment type="block">/* &gt;= 1 on internal nodes */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>num_items</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * 'values' is an array of key values, and 'downlinks' are pointers to
	 * lower-level nodes, corresponding to the key values.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name><name>values</name><index>[<expr><name>MAX_INTERNAL_ITEMS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>intset_node</name> <modifier>*</modifier></type><name><name>downlinks</name><index>[<expr><name>MAX_INTERNAL_ITEMS</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Leaf node */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>uint64</name></type>		<name>first</name></decl>;</decl_stmt>			<comment type="block">/* first integer in this item */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>codeword</name></decl>;</decl_stmt>		<comment type="block">/* simple8b encoded differences from 'first' */</comment>
}</block></struct></type> <name>leaf_item</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_VALUES_PER_LEAF_ITEM</name></cpp:macro>	<cpp:value>(1 + SIMPLE8B_MAX_VALUES_PER_CODEWORD)</cpp:value></cpp:define>

<struct>struct <name>intset_leaf_node</name>
<block>{
	<comment type="block">/* common header, must match intset_node */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>level</name></decl>;</decl_stmt>			<comment type="block">/* 0 on leafs */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>num_items</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>intset_leaf_node</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>		<comment type="block">/* right sibling, if any */</comment>

	<decl_stmt><decl><type><name>leaf_item</name></type>	<name><name>items</name><index>[<expr><name>MAX_LEAF_ITEMS</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * We buffer insertions in a simple array, before packing and inserting them
 * into the B-tree.  MAX_BUFFERED_VALUES sets the size of the buffer.  The
 * encoder assumes that it is large enough that we can always fill a leaf
 * item with buffered new items.  In other words, MAX_BUFFERED_VALUES must be
 * larger than MAX_VALUES_PER_LEAF_ITEM.  For efficiency, make it much larger.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BUFFERED_VALUES</name></cpp:macro>			<cpp:value>(MAX_VALUES_PER_LEAF_ITEM * 2)</cpp:value></cpp:define>

<comment type="block">/*
 * IntegerSet is the top-level object representing the set.
 *
 * The integers are stored in an in-memory B-tree structure, plus an array
 * for newly-added integers.  IntegerSet also tracks information about memory
 * usage, as well as the current position when iterating the set with
 * intset_begin_iterate / intset_iterate_next.
 */</comment>
<struct>struct <name>IntegerSet</name>
<block>{
	<comment type="block">/*
	 * 'context' is the memory context holding this integer set and all its
	 * tree nodes.
	 *
	 * 'mem_used' tracks the amount of memory used.  We don't do anything with
	 * it in integerset.c itself, but the callers can ask for it with
	 * intset_memory_usage().
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>mem_used</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>		<name>num_entries</name></decl>;</decl_stmt>	<comment type="block">/* total # of values in the set */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>highest_value</name></decl>;</decl_stmt>	<comment type="block">/* highest value stored in this set */</comment>

	<comment type="block">/*
	 * B-tree to hold the packed values.
	 *
	 * 'rightmost_nodes' hold pointers to the rightmost node on each level.
	 * rightmost_parent[0] is rightmost leaf, rightmost_parent[1] is its
	 * parent, and so forth, all the way up to the root. These are needed when
	 * adding new values. (Currently, we require that new values are added at
	 * the end.)
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_levels</name></decl>;</decl_stmt>		<comment type="block">/* height of the tree */</comment>
	<decl_stmt><decl><type><name>intset_node</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>			<comment type="block">/* root node */</comment>
	<decl_stmt><decl><type><name>intset_node</name> <modifier>*</modifier></type><name><name>rightmost_nodes</name><index>[<expr><name>MAX_TREE_LEVELS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>intset_leaf_node</name> <modifier>*</modifier></type><name>leftmost_leaf</name></decl>;</decl_stmt>	<comment type="block">/* leftmost leaf node */</comment>

	<comment type="block">/*
	 * Holding area for new items that haven't been inserted to the tree yet.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name><name>buffered_values</name><index>[<expr><name>MAX_BUFFERED_VALUES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_buffered_values</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterator support.
	 *
	 * 'iter_values' is an array of integers ready to be returned to the
	 * caller; 'iter_num_values' is the length of that array, and
	 * 'iter_valueno' is the next index.  'iter_node' and 'iter_itemno' point
	 * to the leaf node, and item within the leaf node, to get the next batch
	 * of values from.
	 *
	 * Normally, 'iter_values' points to 'iter_values_buf', which holds items
	 * decoded from a leaf item.  But after we have scanned the whole B-tree,
	 * we iterate through all the unbuffered values, too, by pointing
	 * iter_values to 'buffered_values'.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>iter_active</name></decl>;</decl_stmt>	<comment type="block">/* is iteration in progress? */</comment>

	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name> <modifier>*</modifier></type><name>iter_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iter_num_values</name></decl>;</decl_stmt>	<comment type="block">/* number of elements in 'iter_values' */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>iter_valueno</name></decl>;</decl_stmt>	<comment type="block">/* next index into 'iter_values' */</comment>

	<decl_stmt><decl><type><name>intset_leaf_node</name> <modifier>*</modifier></type><name>iter_node</name></decl>;</decl_stmt>	<comment type="block">/* current leaf node */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>iter_itemno</name></decl>;</decl_stmt>	<comment type="block">/* next item in 'iter_node' to decode */</comment>

	<decl_stmt><decl><type><name>uint64</name></type>		<name><name>iter_values_buf</name><index>[<expr><name>MAX_VALUES_PER_LEAF_ITEM</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Prototypes for internal functions.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>intset_update_upper</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
								<parameter><decl><type><name>intset_node</name> <modifier>*</modifier></type><name>child</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>child_key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>intset_flush_buffered_values</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>intset_binsrch_uint64</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arr_elems</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>nextkey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>intset_binsrch_leaf</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>leaf_item</name> <modifier>*</modifier></type><name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arr_elems</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>nextkey</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>simple8b_encode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint64</name> <modifier>*</modifier></type><name>ints</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_encoded</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>base</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>simple8b_decode</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>codeword</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>decoded</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>base</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>simple8b_contains</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>codeword</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>base</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Create a new, initially empty, integer set.
 *
 * The integer set is created in the current memory context.
 * We will do all subsequent allocations in the same context, too, regardless
 * of which memory context is current when new integers are added to the set.
 */</comment>
<function><type><name>IntegerSet</name> <modifier>*</modifier></type>
<name>intset_create</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>intset</name> <operator>=</operator> <operator>(</operator><name>IntegerSet</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IntegerSet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>mem_used</name></name> <operator>=</operator> <call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>highest_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>intset</name><operator>-&gt;</operator><name>rightmost_nodes</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>intset</name><operator>-&gt;</operator><name>rightmost_nodes</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>leftmost_leaf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_node</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_itemno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_valueno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_num_values</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_values</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>intset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new node.
 */</comment>
<function><type><specifier>static</specifier> <name>intset_internal_node</name> <modifier>*</modifier></type>
<name>intset_new_internal_node</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>intset_internal_node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>intset_internal_node</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>intset</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
													<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>intset_internal_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>mem_used</name></name> <operator>+=</operator> <call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* caller must set */</comment>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>intset_leaf_node</name> <modifier>*</modifier></type>
<name>intset_new_leaf_node</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>intset_leaf_node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>intset_leaf_node</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>intset</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
												<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>intset_leaf_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>mem_used</name></name> <operator>+=</operator> <call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the number of entries in the integer set.
 */</comment>
<function><type><name>uint64</name></type>
<name>intset_num_entries</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>intset</name><operator>-&gt;</operator><name>num_entries</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the amount of memory used by the integer set.
 */</comment>
<function><type><name>uint64</name></type>
<name>intset_memory_usage</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>intset</name><operator>-&gt;</operator><name>mem_used</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a value to the set.
 *
 * Values must be added in order.
 */</comment>
<function><type><name>void</name></type>
<name>intset_add_member</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>intset</name><operator>-&gt;</operator><name>iter_active</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot add new values to integer set while iteration is in progress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;=</operator> <name><name>intset</name><operator>-&gt;</operator><name>highest_value</name></name> <operator>&amp;&amp;</operator> <name><name>intset</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot add value to integer set out of order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name> <operator>&gt;=</operator> <name>MAX_BUFFERED_VALUES</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Time to flush our buffer */</comment>
		<expr_stmt><expr><call><name>intset_flush_buffered_values</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name> <operator>&lt;</operator> <name>MAX_BUFFERED_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add it to the buffer of newly-added values */</comment>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>buffered_values</name><index>[<expr><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>num_entries</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>highest_value</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Take a batch of buffered values, and pack them into the B-tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>intset_flush_buffered_values</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>intset</name><operator>-&gt;</operator><name>buffered_values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>num_values</name> <init>= <expr><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_packed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>intset_leaf_node</name> <modifier>*</modifier></type><name>leaf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>leaf</name> <operator>=</operator> <operator>(</operator><name>intset_leaf_node</name> <operator>*</operator><operator>)</operator> <name><name>intset</name><operator>-&gt;</operator><name>rightmost_nodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the tree is completely empty, create the first leaf page, which is
	 * also the root.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>leaf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is the very first item in the set.
		 *
		 * Allocate root node. It's also a leaf.
		 */</comment>
		<expr_stmt><expr><name>leaf</name> <operator>=</operator> <call><name>intset_new_leaf_node</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <operator>(</operator><name>intset_node</name> <operator>*</operator><operator>)</operator> <name>leaf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>leftmost_leaf</name></name> <operator>=</operator> <name>leaf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>rightmost_nodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>intset_node</name> <operator>*</operator><operator>)</operator> <name>leaf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there are less than MAX_VALUES_PER_LEAF_ITEM values in the buffer,
	 * stop.  In most cases, we cannot encode that many values in a single
	 * value, but this way, the encoder doesn't have to worry about running
	 * out of input.
	 */</comment>
	<while>while <condition>(<expr><name>num_values</name> <operator>-</operator> <name>num_packed</name> <operator>&gt;=</operator> <name>MAX_VALUES_PER_LEAF_ITEM</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>leaf_item</name></type>	<name>item</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_encoded</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Construct the next leaf item, packing as many buffered values as
		 * possible.
		 */</comment>
		<expr_stmt><expr><name><name>item</name><operator>.</operator><name>first</name></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>num_packed</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>.</operator><name>codeword</name></name> <operator>=</operator> <call><name>simple8b_encode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>num_packed</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>num_encoded</name></expr></argument>,
										<argument><expr><name><name>item</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add the item to the node, allocating a new node if the old one is
		 * full.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>leaf</name><operator>-&gt;</operator><name>num_items</name></name> <operator>&gt;=</operator> <name>MAX_LEAF_ITEMS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Allocate new leaf and link it to the tree */</comment>
			<decl_stmt><decl><type><name>intset_leaf_node</name> <modifier>*</modifier></type><name>old_leaf</name> <init>= <expr><name>leaf</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>leaf</name> <operator>=</operator> <call><name>intset_new_leaf_node</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>old_leaf</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>leaf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>rightmost_nodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>intset_node</name> <operator>*</operator><operator>)</operator> <name>leaf</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>intset_update_upper</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>intset_node</name> <operator>*</operator><operator>)</operator> <name>leaf</name></expr></argument>, <argument><expr><name><name>item</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>leaf</name><operator>-&gt;</operator><name>num_items</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>num_packed</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>num_encoded</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Move any remaining buffered values to the beginning of the array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_packed</name> <operator>&lt;</operator> <name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>intset</name><operator>-&gt;</operator><name>buffered_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>intset</name><operator>-&gt;</operator><name>buffered_values</name><index>[<expr><name>num_packed</name></expr>]</index></name></expr></argument>,
				<argument><expr><operator>(</operator><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name> <operator>-</operator> <name>num_packed</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name> <operator>-=</operator> <name>num_packed</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a downlink into parent node, after creating a new node.
 *
 * Recurses if the parent node is full, too.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>intset_update_upper</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>intset_node</name> <modifier>*</modifier></type><name>child</name></decl></parameter>,
					<parameter><decl><type><name>uint64</name></type> <name>child_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>intset_internal_node</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a new root node, if necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;=</operator> <name><name>intset</name><operator>-&gt;</operator><name>num_levels</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>intset_node</name> <modifier>*</modifier></type><name>oldroot</name> <init>= <expr><name><name>intset</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>downlink_key</name></decl>;</decl_stmt>

		<comment type="block">/* MAX_TREE_LEVELS should be more than enough, this shouldn't happen */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>intset</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>==</operator> <name>MAX_TREE_LEVELS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not expand integer set, maximum number of levels reached"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>num_levels</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the first value on the old root page, to be used as the
		 * downlink.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>intset</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>downlink_key</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>intset_leaf_node</name> <operator>*</operator><operator>)</operator> <name>oldroot</name><operator>)</operator><operator>-&gt;</operator><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>downlink_key</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>intset_internal_node</name> <operator>*</operator><operator>)</operator> <name>oldroot</name><operator>)</operator><operator>-&gt;</operator><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>intset_new_internal_node</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>downlink_key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>downlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>oldroot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <operator>(</operator><name>intset_node</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>rightmost_nodes</name><index>[<expr><name>level</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>intset_node</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Place the downlink on the parent page.
	 */</comment>
	<expr_stmt><expr><name>parent</name> <operator>=</operator> <operator>(</operator><name>intset_internal_node</name> <operator>*</operator><operator>)</operator> <name><name>intset</name><operator>-&gt;</operator><name>rightmost_nodes</name><index>[<expr><name>level</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>num_items</name></name> <operator>&lt;</operator> <name>MAX_INTERNAL_ITEMS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>values</name><index>[<expr><name><name>parent</name><operator>-&gt;</operator><name>num_items</name></name></expr>]</index></name> <operator>=</operator> <name>child_key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>downlinks</name><index>[<expr><name><name>parent</name><operator>-&gt;</operator><name>num_items</name></name></expr>]</index></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>num_items</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Doesn't fit.  Allocate new parent, with the downlink as the first
		 * item on it, and recursively insert the downlink to the new parent
		 * to the grandparent.
		 */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>intset_new_internal_node</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>child_key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>downlinks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>num_items</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>rightmost_nodes</name><index>[<expr><name>level</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>intset_node</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>intset_update_upper</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>intset_node</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr></argument>, <argument><expr><name>child_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Does the set contain the given value?
 */</comment>
<function><type><name>bool</name></type>
<name>intset_is_member</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>intset_node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>intset_leaf_node</name> <modifier>*</modifier></type><name>leaf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>leaf_item</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The value might be in the buffer of newly-added values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>x</name> <operator>&gt;=</operator> <name><name>intset</name><operator>-&gt;</operator><name>buffered_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>itemno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemno</name> <operator>=</operator> <call><name>intset_binsrch_uint64</name><argument_list>(<argument><expr><name>x</name></expr></argument>,
									   <argument><expr><name><name>intset</name><operator>-&gt;</operator><name>buffered_values</name></name></expr></argument>,
									   <argument><expr><name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>itemno</name> <operator>&gt;=</operator> <name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name><name>intset</name><operator>-&gt;</operator><name>buffered_values</name><index>[<expr><name>itemno</name></expr>]</index></name> <operator>==</operator> <name>x</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start from the root, and walk down the B-tree to find the right leaf
	 * node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>intset</name><operator>-&gt;</operator><name>root</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>intset</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <name><name>intset</name><operator>-&gt;</operator><name>num_levels</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>level</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>intset_internal_node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>intset_internal_node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>itemno</name> <operator>=</operator> <call><name>intset_binsrch_uint64</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>num_items</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>itemno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>downlinks</name><index>[<expr><name>itemno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leaf</name> <operator>=</operator> <operator>(</operator><name>intset_leaf_node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Binary search to find the right item on the leaf page
	 */</comment>
	<expr_stmt><expr><name>itemno</name> <operator>=</operator> <call><name>intset_binsrch_leaf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>items</name></name></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>num_items</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>itemno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>itemno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Is this a match to the first value on the item? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>first</name></name> <operator>==</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>x</name> <operator>&gt;</operator> <name><name>item</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Is it in the packed codeword? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>simple8b_contains</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>codeword</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Begin in-order scan through all the values.
 *
 * While the iteration is in-progress, you cannot add new values to the set.
 */</comment>
<function><type><name>void</name></type>
<name>intset_begin_iterate</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Note that we allow an iteration to be abandoned midway */</comment>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_node</name></name> <operator>=</operator> <name><name>intset</name><operator>-&gt;</operator><name>leftmost_leaf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_itemno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_valueno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_num_values</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_values</name></name> <operator>=</operator> <name><name>intset</name><operator>-&gt;</operator><name>iter_values_buf</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the next integer, when iterating.
 *
 * intset_begin_iterate() must be called first.  intset_iterate_next() returns
 * the next value in the set.  Returns true, if there was another value, and
 * stores the value in *next.  Otherwise, returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>intset_iterate_next</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>next</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Return next iter_values[] entry if any */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>intset</name><operator>-&gt;</operator><name>iter_valueno</name></name> <operator>&lt;</operator> <name><name>intset</name><operator>-&gt;</operator><name>iter_num_values</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <name><name>intset</name><operator>-&gt;</operator><name>iter_values</name><index>[<expr><name><name>intset</name><operator>-&gt;</operator><name>iter_valueno</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Decode next item in current leaf node, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>intset</name><operator>-&gt;</operator><name>iter_node</name></name> <operator>&amp;&amp;</operator>
			<name><name>intset</name><operator>-&gt;</operator><name>iter_itemno</name></name> <operator>&lt;</operator> <name><name>intset</name><operator>-&gt;</operator><name>iter_node</name><operator>-&gt;</operator><name>num_items</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>leaf_item</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>num_decoded</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>&amp;</operator><name><name>intset</name><operator>-&gt;</operator><name>iter_node</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>intset</name><operator>-&gt;</operator><name>iter_itemno</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_values_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>first</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_decoded</name> <operator>=</operator> <call><name>simple8b_decode</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>codeword</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>intset</name><operator>-&gt;</operator><name>iter_values_buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>item</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_num_values</name></name> <operator>=</operator> <name>num_decoded</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_valueno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No more items on this leaf, step to next node */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>intset</name><operator>-&gt;</operator><name>iter_node</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_node</name></name> <operator>=</operator> <name><name>intset</name><operator>-&gt;</operator><name>iter_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_itemno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We have reached the end of the B-tree.  But we might still have
		 * some integers in the buffer of newly-added values.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>intset</name><operator>-&gt;</operator><name>iter_values</name></name> <operator>==</operator> <operator>(</operator><specifier>const</specifier> <name>uint64</name> <operator>*</operator><operator>)</operator> <name><name>intset</name><operator>-&gt;</operator><name>iter_values_buf</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_values</name></name> <operator>=</operator> <name><name>intset</name><operator>-&gt;</operator><name>buffered_values</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_num_values</name></name> <operator>=</operator> <name><name>intset</name><operator>-&gt;</operator><name>num_buffered_values</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_valueno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<break>break;</break>
	</block_content>}</block></for>

	<comment type="block">/* No more results. */</comment>
	<expr_stmt><expr><name><name>intset</name><operator>-&gt;</operator><name>iter_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>					<comment type="block">/* prevent uninitialized-variable warnings */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * intset_binsrch_uint64() -- search a sorted array of uint64s
 *
 * Returns the first position with key equal or less than the given key.
 * The returned position would be the "insert" location for the given key,
 * that is, the position where the new key should be inserted to.
 *
 * 'nextkey' affects the behavior on equal keys.  If true, and there is an
 * equal key in the array, this returns the position immediately after the
 * equal key.  If false, this returns the position of the equal key itself.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>intset_binsrch_uint64</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>item</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arr_elems</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nextkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>low</name></decl>,
				<decl><type ref="prev"/><name>high</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <name>arr_elems</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>high</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>mid</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nextkey</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&gt;=</operator> <name><name>arr</name><index>[<expr><name>mid</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&gt;</operator> <name><name>arr</name><index>[<expr><name>mid</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>low</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* same, but for an array of leaf items */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>intset_binsrch_leaf</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>item</name></decl></parameter>, <parameter><decl><type><name>leaf_item</name> <modifier>*</modifier></type><name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arr_elems</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nextkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>low</name></decl>,
				<decl><type ref="prev"/><name>high</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <name>arr_elems</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>high</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>mid</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nextkey</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&gt;=</operator> <name><name>arr</name><index>[<expr><name>mid</name></expr>]</index></name><operator>.</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&gt;</operator> <name><name>arr</name><index>[<expr><name>mid</name></expr>]</index></name><operator>.</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>low</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Simple-8b encoding.
 *
 * The simple-8b algorithm packs between 1 and 240 integers into 64-bit words,
 * called "codewords".  The number of integers packed into a single codeword
 * depends on the integers being packed; small integers are encoded using
 * fewer bits than large integers.  A single codeword can store a single
 * 60-bit integer, or two 30-bit integers, for example.
 *
 * Since we're storing a unique, sorted, set of integers, we actually encode
 * the *differences* between consecutive integers.  That way, clusters of
 * integers that are close to each other are packed efficiently, regardless
 * of their absolute values.
 *
 * In Simple-8b, each codeword consists of a 4-bit selector, which indicates
 * how many integers are encoded in the codeword, and the encoded integers are
 * packed into the remaining 60 bits.  The selector allows for 16 different
 * ways of using the remaining 60 bits, called "modes".  The number of integers
 * packed into a single codeword in each mode is listed in the simple8b_modes
 * table below.  For example, consider the following codeword:
 *
 *      20-bit integer       20-bit integer       20-bit integer
 * 1101 00000000000000010010 01111010000100100000 00000000000000010100
 * ^
 * selector
 *
 * The selector 1101 is 13 in decimal.  From the modes table below, we see
 * that it means that the codeword encodes three 20-bit integers.  In decimal,
 * those integers are 18, 500000 and 20.  Because we encode deltas rather than
 * absolute values, the actual values that they represent are 18, 500018 and
 * 500038.
 *
 * Modes 0 and 1 are a bit special; they encode a run of 240 or 120 zeroes
 * (which means 240 or 120 consecutive integers, since we're encoding the
 * deltas between integers), without using the rest of the codeword bits
 * for anything.
 *
 * Simple-8b cannot encode integers larger than 60 bits.  Values larger than
 * that are always stored in the 'first' field of a leaf item, never in the
 * packed codeword.  If there is a sequence of integers that are more than
 * 2^60 apart, the codeword will go unused on those items.  To represent that,
 * we use a magic EMPTY_CODEWORD codeword value.
 */</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct <name>simple8b_mode</name>
<block>{
	<decl_stmt><decl><type><name>uint8</name></type>		<name>bits_per_int</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>num_ints</name></decl>;</decl_stmt>
}</block>			<decl><name><name>simple8b_modes</name><index>[<expr><literal type="number">17</literal></expr>]</index></name> <init>=

<expr><block>{
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">240</literal></expr>}</block></expr>,					<comment type="block">/* mode  0: 240 zeroes */</comment>
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">120</literal></expr>}</block></expr>,					<comment type="block">/* mode  1: 120 zeroes */</comment>
	<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">60</literal></expr>}</block></expr>,					<comment type="block">/* mode  2: sixty 1-bit integers */</comment>
	<expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">30</literal></expr>}</block></expr>,					<comment type="block">/* mode  3: thirty 2-bit integers */</comment>
	<expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">20</literal></expr>}</block></expr>,					<comment type="block">/* mode  4: twenty 3-bit integers */</comment>
	<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">15</literal></expr>}</block></expr>,					<comment type="block">/* mode  5: fifteen 4-bit integers */</comment>
	<expr><block>{<expr><literal type="number">5</literal></expr>, <expr><literal type="number">12</literal></expr>}</block></expr>,					<comment type="block">/* mode  6: twelve 5-bit integers */</comment>
	<expr><block>{<expr><literal type="number">6</literal></expr>, <expr><literal type="number">10</literal></expr>}</block></expr>,					<comment type="block">/* mode  7: ten 6-bit integers */</comment>
	<expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>}</block></expr>,						<comment type="block">/* mode  8: eight 7-bit integers (four bits
								 * are wasted) */</comment>
	<expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,						<comment type="block">/* mode  9: seven 8-bit integers (four bits
								 * are wasted) */</comment>
	<expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,					<comment type="block">/* mode 10: six 10-bit integers */</comment>
	<expr><block>{<expr><literal type="number">12</literal></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,					<comment type="block">/* mode 11: five 12-bit integers */</comment>
	<expr><block>{<expr><literal type="number">15</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,					<comment type="block">/* mode 12: four 15-bit integers */</comment>
	<expr><block>{<expr><literal type="number">20</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,					<comment type="block">/* mode 13: three 20-bit integers */</comment>
	<expr><block>{<expr><literal type="number">30</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,					<comment type="block">/* mode 14: two 30-bit integers */</comment>
	<expr><block>{<expr><literal type="number">60</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,					<comment type="block">/* mode 15: one 60-bit integer */</comment>

	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>						<comment type="block">/* sentinel value */</comment>
}</block></expr></init></decl>;</struct>

<comment type="block">/*
 * EMPTY_CODEWORD is a special value, used to indicate "no values".
 * It is used if the next value is too large to be encoded with Simple-8b.
 *
 * This value looks like a mode-0 codeword, but we can distinguish it
 * because a regular mode-0 codeword would have zeroes in the unused bits.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY_CODEWORD</name></cpp:macro>		<cpp:value>UINT64CONST(0x0FFFFFFFFFFFFFFF)</cpp:value></cpp:define>

<comment type="block">/*
 * Encode a number of integers into a Simple-8b codeword.
 *
 * (What we actually encode are deltas between successive integers.
 * "base" is the value before ints[0].)
 *
 * The input array must contain at least SIMPLE8B_MAX_VALUES_PER_CODEWORD
 * elements, ensuring that we can produce a full codeword.
 *
 * Returns the encoded codeword, and sets *num_encoded to the number of
 * input integers that were encoded.  That can be zero, if the first delta
 * is too large to be encoded.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>simple8b_encode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint64</name> <modifier>*</modifier></type><name>ints</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_encoded</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>selector</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>diff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>last_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>codeword</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ints</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Select the "mode" to use for this codeword.
	 *
	 * In each iteration, check if the next value can be represented in the
	 * current mode we're considering.  If it's too large, then step up the
	 * mode to a wider one, and repeat.  If it fits, move on to the next
	 * integer.  Repeat until the codeword is full, given the current mode.
	 *
	 * Note that we don't have any way to represent unused slots in the
	 * codeword, so we require each codeword to be "full".  It is always
	 * possible to produce a full codeword unless the very first delta is too
	 * large to be encoded.  For example, if the first delta is small but the
	 * second is too large to be encoded, we'll end up using the last "mode",
	 * which has nints == 1.
	 */</comment>
	<expr_stmt><expr><name>selector</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nints</name> <operator>=</operator> <name><name>simple8b_modes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>num_ints</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bits</name> <operator>=</operator> <name><name>simple8b_modes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>bits_per_int</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>diff</name> <operator>=</operator> <name><name>ints</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>base</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_val</name> <operator>=</operator> <name><name>ints</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>						<comment type="block">/* number of deltas we have accepted */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;=</operator> <operator>(</operator><call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>bits</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* too large, step up to next mode */</comment>
			<expr_stmt><expr><name>selector</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>nints</name> <operator>=</operator> <name><name>simple8b_modes</name><index>[<expr><name>selector</name></expr>]</index></name><operator>.</operator><name>num_ints</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bits</name> <operator>=</operator> <name><name>simple8b_modes</name><index>[<expr><name>selector</name></expr>]</index></name><operator>.</operator><name>bits_per_int</name></expr>;</expr_stmt>
			<comment type="block">/* we might already have accepted enough deltas for this mode */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>nints</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* accept this delta; then done if codeword is full */</comment>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>nints</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* examine next delta */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ints</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>last_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>diff</name> <operator>=</operator> <name><name>ints</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>last_val</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_val</name> <operator>=</operator> <name><name>ints</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>nints</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The first delta is too large to be encoded with Simple-8b.
		 *
		 * If there is at least one not-too-large integer in the input, we
		 * will encode it using mode 15 (or a more compact mode).  Hence, we
		 * can only get here if the *first* delta is &gt;= 2^60.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>num_encoded</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>EMPTY_CODEWORD</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Encode the integers using the selected mode.  Note that we shift them
	 * into the codeword in reverse order, so that they will come out in the
	 * correct order in the decoder.
	 */</comment>
	<expr_stmt><expr><name>codeword</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nints</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>diff</name> <operator>=</operator> <name><name>ints</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>ints</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>codeword</name> <operator>|=</operator> <name>diff</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>codeword</name> <operator>&lt;&lt;=</operator> <name>bits</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>diff</name> <operator>=</operator> <name><name>ints</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>base</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>codeword</name> <operator>|=</operator> <name>diff</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* add selector to the codeword, and return */</comment>
	<expr_stmt><expr><name>codeword</name> <operator>|=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>selector</name> <operator>&lt;&lt;</operator> <literal type="number">60</literal></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_encoded</name> <operator>=</operator> <name>nints</name></expr>;</expr_stmt>
	<return>return <expr><name>codeword</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Decode a codeword into an array of integers.
 * Returns the number of integers decoded.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>simple8b_decode</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>codeword</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>decoded</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>selector</name> <init>= <expr><operator>(</operator><name>codeword</name> <operator>&gt;&gt;</operator> <literal type="number">60</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nints</name> <init>= <expr><name><name>simple8b_modes</name><index>[<expr><name>selector</name></expr>]</index></name><operator>.</operator><name>num_ints</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bits</name> <init>= <expr><name><name>simple8b_modes</name><index>[<expr><name>selector</name></expr>]</index></name><operator>.</operator><name>bits_per_int</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>mask</name> <init>= <expr><operator>(</operator><call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>bits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>curr_value</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>codeword</name> <operator>==</operator> <name>EMPTY_CODEWORD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>curr_value</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nints</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>diff</name> <init>= <expr><name>codeword</name> <operator>&amp;</operator> <name>mask</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>curr_value</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>diff</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>decoded</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>curr_value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>codeword</name> <operator>&gt;&gt;=</operator> <name>bits</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>nints</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This is very similar to simple8b_decode(), but instead of decoding all
 * the values to an array, it just checks if the given "key" is part of
 * the codeword.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>simple8b_contains</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>codeword</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>selector</name> <init>= <expr><operator>(</operator><name>codeword</name> <operator>&gt;&gt;</operator> <literal type="number">60</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nints</name> <init>= <expr><name><name>simple8b_modes</name><index>[<expr><name>selector</name></expr>]</index></name><operator>.</operator><name>num_ints</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bits</name> <init>= <expr><name><name>simple8b_modes</name><index>[<expr><name>selector</name></expr>]</index></name><operator>.</operator><name>bits_per_int</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>codeword</name> <operator>==</operator> <name>EMPTY_CODEWORD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Special handling for 0-bit cases. */</comment>
		<return>return <expr><operator>(</operator><name>key</name> <operator>-</operator> <name>base</name><operator>)</operator> <operator>&lt;=</operator> <name>nints</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>mask</name> <init>= <expr><operator>(</operator><call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>bits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>curr_value</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>curr_value</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nints</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>diff</name> <init>= <expr><name>codeword</name> <operator>&amp;</operator> <name>mask</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>curr_value</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>diff</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>curr_value</name> <operator>&gt;=</operator> <name>key</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>curr_value</name> <operator>==</operator> <name>key</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>codeword</name> <operator>&gt;&gt;=</operator> <name>bits</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
