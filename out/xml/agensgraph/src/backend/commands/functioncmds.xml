<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/commands/functioncmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * functioncmds.c
 *
 *	  Routines for CREATE and DROP FUNCTION commands and CREATE and DROP
 *	  CAST commands.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/functioncmds.c
 *
 * DESCRIPTION
 *	  These routines take the parse tree and pick out the
 *	  appropriate arguments/flags, and pass the results to the
 *	  corresponding "FooDefine" routines (in src/catalog) that do
 *	  the actual catalog-munging.  These routines also verify permission
 *	  of the user to execute the command.
 *
 * NOTES
 *	  These things must be defined and committed in the following order:
 *		"create function":
 *				input/output, recv/send procedures
 *		"create type":
 *				type
 *		"create operator":
 *				operators
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/proclang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/*
 *	 Examine the RETURNS clause of the CREATE FUNCTION statement
 *	 and return information about it as *prorettype_p and *returnsSet.
 *
 * This is more complex than the average typename lookup because we want to
 * allow a shell type to be used, or even created if the specified return type
 * doesn't exist yet.  (Without this, there's no way to define the I/O procs
 * for a new type.)  But SQL function creation won't cope, so error out if
 * the target language is SQL.  (We do this here, not in the SQL-function
 * validator, so as not to produce a NOTICE and then an ERROR for the same
 * condition.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_return_type</name><parameter_list>(<parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>returnType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>languageOid</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>prorettype_p</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>returnsSet_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Type</name></type>		<name>typtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typtup</name> <operator>=</operator> <call><name>LookupTypeName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>returnType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>typtup</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typisdefined</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>languageOid</name> <operator>==</operator> <name>SQLlanguageId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SQL function cannot return shell type %s"</literal></expr></argument>,
								<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return type %s is only a shell"</literal></expr></argument>,
								<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rettype</name> <operator>=</operator> <call><name>typeTypeId</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typnam</name> <init>= <expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Only C-coded functions can be I/O functions.  We enforce this
		 * restriction here mainly to prevent littering the catalogs with
		 * shell types due to simple typos in user-defined function
		 * definitions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>languageOid</name> <operator>!=</operator> <name>INTERNALlanguageId</name> <operator>&amp;&amp;</operator>
			<name>languageOid</name> <operator>!=</operator> <name>ClanguageId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>typnam</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Reject if there's typmod decoration, too */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>returnType</name><operator>-&gt;</operator><name>typmods</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type modifier cannot be specified for shell type \"%s\""</literal></expr></argument>,
							<argument><expr><name>typnam</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Otherwise, go ahead and make a shell type */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" is not yet defined"</literal></expr></argument>, <argument><expr><name>typnam</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Creating a shell type definition."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name><name>returnType</name><operator>-&gt;</operator><name>names</name></name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										  <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
						   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>TypeShellMake</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rettype</name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>prorettype_p</name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>returnsSet_p</name> <operator>=</operator> <name><name>returnType</name><operator>-&gt;</operator><name>setof</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Interpret the function parameter list of a CREATE FUNCTION or
 * CREATE AGGREGATE statement.
 *
 * Input parameters:
 * parameters: list of FunctionParameter structs
 * languageOid: OID of function language (InvalidOid if it's CREATE AGGREGATE)
 * objtype: needed only to determine error handling and required result type
 *
 * Results are stored into output parameters.  parameterTypes must always
 * be created, but the other arrays are set to NULL if not needed.
 * variadicArgType is set to the variadic array type if there's a VARIADIC
 * parameter (there can be only one); or to InvalidOid if not.
 * requiredResultType is set to InvalidOid if there are no OUT parameters,
 * else it is set to the OID of the implied result type.
 */</comment>
<function><type><name>void</name></type>
<name>interpret_function_parameter_list</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parameters</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>languageOid</name></decl></parameter>,
								  <parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>,
								  <parameter><decl><type><name>oidvector</name> <modifier>*</modifier><modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
								  <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier><modifier>*</modifier></type><name>allParameterTypes</name></decl></parameter>,
								  <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier><modifier>*</modifier></type><name>parameterModes</name></decl></parameter>,
								  <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier><modifier>*</modifier></type><name>parameterNames</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>parameterDefaults</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>variadicArgType</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>requiredResultType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>parameterCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>inTypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>allTypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>paramModes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>paramNames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_names</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_defaults</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>variadicArgType</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* default result */</comment>
	<expr_stmt><expr><operator>*</operator><name>requiredResultType</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* default result */</comment>

	<expr_stmt><expr><name>inTypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>parameterCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>allTypes</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>parameterCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>paramModes</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>parameterCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>paramNames</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>parameterCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>parameterDefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Scan the list and extract data into work arrays */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>x</argument>, <argument>parameters</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FunctionParameter</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>(</operator><name>FunctionParameter</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>fp</name><operator>-&gt;</operator><name>argType</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isinput</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>toid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Type</name></type>		<name>typtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typtup</name> <operator>=</operator> <call><name>LookupTypeName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typtup</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typisdefined</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* As above, hard error if language is SQL */</comment>
				<if_stmt><if>if <condition>(<expr><name>languageOid</name> <operator>==</operator> <name>SQLlanguageId</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SQL function cannot accept shell type %s"</literal></expr></argument>,
									<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<comment type="block">/* We don't allow creating aggregates on shell types either */</comment>
				<if type="elseif">else if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_AGGREGATE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate cannot accept shell type %s"</literal></expr></argument>,
									<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument type %s is only a shell"</literal></expr></argument>,
									<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>toid</name> <operator>=</operator> <call><name>typeTypeId</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s does not exist"</literal></expr></argument>,
							<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>toid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>toid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>toid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>setof</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_AGGREGATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregates cannot accept set arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_PROCEDURE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"procedures cannot accept set arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"functions cannot accept set arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_PROCEDURE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_OUT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"procedures cannot have OUT arguments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"INOUT arguments are permitted."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* handle input parameters */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>FUNC_PARAM_OUT</name> <operator>&amp;&amp;</operator> <name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>FUNC_PARAM_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* other input parameters can't follow a VARIADIC parameter */</comment>
			<if_stmt><if>if <condition>(<expr><name>varCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VARIADIC parameter must be the last input parameter"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>inTypes</name><index>[<expr><name>inCount</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>toid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>isinput</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* handle output parameters */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>FUNC_PARAM_IN</name> <operator>&amp;&amp;</operator> <name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>FUNC_PARAM_VARIADIC</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_PROCEDURE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>requiredResultType</name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>outCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* save first output param's type */</comment>
				<expr_stmt><expr><operator>*</operator><name>requiredResultType</name> <operator>=</operator> <name>toid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>outCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_VARIADIC</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>variadicArgType</name> <operator>=</operator> <name>toid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>varCount</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* validate variadic parameter type */</comment>
			<switch>switch <condition>(<expr><name>toid</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>ANYARRAYOID</name></expr>:</case>
				<case>case <expr><name>ANYCOMPATIBLEARRAYOID</name></expr>:</case>
				<case>case <expr><name>ANYOID</name></expr>:</case>
					<comment type="block">/* okay */</comment>
					<break>break;</break>
				<default>default:</default>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>toid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VARIADIC parameter must be an array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>allTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>toid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>paramModes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name><name>fp</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fp</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>fp</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>px</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * As of Postgres 9.0 we disallow using the same name for two
			 * input or two output function parameters.  Depending on the
			 * function's language, conflicting input and output names might
			 * be bad too, but we leave it to the PL to complain if so.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>px</argument>, <argument>parameters</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FunctionParameter</name> <modifier>*</modifier></type><name>prevfp</name> <init>= <expr><operator>(</operator><name>FunctionParameter</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>px</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>prevfp</name> <operator>==</operator> <name>fp</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<comment type="block">/* pure in doesn't conflict with pure out */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_IN</name> <operator>||</operator>
					 <name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_VARIADIC</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>prevfp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_OUT</name> <operator>||</operator>
					 <name><name>prevfp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_TABLE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>prevfp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_IN</name> <operator>||</operator>
					 <name><name>prevfp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_VARIADIC</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_OUT</name> <operator>||</operator>
					 <name><name>fp</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FUNC_PARAM_TABLE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>prevfp</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>prevfp</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>prevfp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>fp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter name \"%s\" used more than once"</literal></expr></argument>,
									<argument><expr><name><name>fp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>paramNames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>fp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_names</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fp</name><operator>-&gt;</operator><name>defexpr</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isinput</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only input parameters can have default values"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fp</name><operator>-&gt;</operator><name>defexpr</name></name></expr></argument>,
								<argument><expr><name>EXPR_KIND_FUNCTION_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>toid</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Make sure no variables are referred to (this is probably dead
			 * code now that add_missing_from is history).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>contain_var_clause</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use table references in parameter default value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * transformExpr() should have already rejected subqueries,
			 * aggregates, and window functions, based on the EXPR_KIND_ for a
			 * default expression.
			 *
			 * It can't return a set either --- but coerce_to_specific_type
			 * already checked that for us.
			 *
			 * Note: the point of these restrictions is to ensure that an
			 * expression that, on its face, hasn't got subplans, aggregates,
			 * etc cannot suddenly have them after function default arguments
			 * are inserted.
			 */</comment>

			<expr_stmt><expr><operator>*</operator><name>parameterDefaults</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>parameterDefaults</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_defaults</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isinput</name> <operator>&amp;&amp;</operator> <name>have_defaults</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input parameters after one with a default value must also have defaults"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Now construct the proper outputs as needed */</comment>
	<expr_stmt><expr><operator>*</operator><name>parameterTypes</name> <operator>=</operator> <call><name>buildoidvector</name><argument_list>(<argument><expr><name>inTypes</name></expr></argument>, <argument><expr><name>inCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>outCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>varCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>allParameterTypes</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>allTypes</name></expr></argument>, <argument><expr><name>parameterCount</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>parameterModes</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>paramModes</name></expr></argument>, <argument><expr><name>parameterCount</name></expr></argument>, <argument><expr><name>CHAROID</name></expr></argument>,
										  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>TYPALIGN_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>outCount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>requiredResultType</name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* otherwise we set requiredResultType correctly above */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>allParameterTypes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>parameterModes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_names</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>parameterCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>paramNames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>paramNames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><operator>*</operator><name>parameterNames</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>paramNames</name></expr></argument>, <argument><expr><name>parameterCount</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
										  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>parameterNames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Recognize one of the options that can be passed to both CREATE
 * FUNCTION and ALTER FUNCTION and return it via one of the out
 * parameters. Returns true if the passed option was recognized. If
 * the out parameter we were going to assign to points to non-NULL,
 * raise a duplicate-clause error.  (We don't try to detect duplicate
 * SET parameters though --- if you're redundant, the last one wins.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>compute_common_attribute</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>is_procedure</name></decl></parameter>,
						 <parameter><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name></decl></parameter>,
						 <parameter><decl><type><name>DefElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>volatility_item</name></decl></parameter>,
						 <parameter><decl><type><name>DefElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>strict_item</name></decl></parameter>,
						 <parameter><decl><type><name>DefElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>security_item</name></decl></parameter>,
						 <parameter><decl><type><name>DefElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>leakproof_item</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>set_items</name></decl></parameter>,
						 <parameter><decl><type><name>DefElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>cost_item</name></decl></parameter>,
						 <parameter><decl><type><name>DefElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>rows_item</name></decl></parameter>,
						 <parameter><decl><type><name>DefElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>support_item</name></decl></parameter>,
						 <parameter><decl><type><name>DefElem</name> <modifier>*</modifier><modifier>*</modifier></type><name>parallel_item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"volatility"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>procedure_error</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>volatility_item</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>duplicate_error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>volatility_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"strict"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>procedure_error</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strict_item</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>duplicate_error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>strict_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"security"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>security_item</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>duplicate_error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>security_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"leakproof"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>procedure_error</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>leakproof_item</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>duplicate_error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>leakproof_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"set"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>set_items</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>set_items</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>procedure_error</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cost_item</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>duplicate_error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>cost_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"rows"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>procedure_error</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rows_item</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>duplicate_error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>rows_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"support"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>procedure_error</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>support_item</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>duplicate_error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>support_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"parallel"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>procedure_error</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>parallel_item</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>duplicate_error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>parallel_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/* Recognized an option */</comment>
	<return>return <expr><name>true</name></expr>;</return>

<label><name>duplicate_error</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>

<label><name>procedure_error</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid attribute in procedure definition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name></type>
<name>interpret_func_volatility</name><parameter_list>(<parameter><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"immutable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PROVOLATILE_IMMUTABLE</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"stable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PROVOLATILE_STABLE</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"volatile"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PROVOLATILE_VOLATILE</name></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid volatility \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name></type>
<name>interpret_func_parallel</name><parameter_list>(<parameter><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"safe"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PROPARALLEL_SAFE</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"unsafe"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PROPARALLEL_UNSAFE</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"restricted"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PROPARALLEL_RESTRICTED</name></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"parallel\" must be SAFE, RESTRICTED, or UNSAFE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>PROPARALLEL_UNSAFE</name></expr>;</return>	<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update a proconfig value according to a list of VariableSetStmt items.
 *
 * The input and result may be NULL to signify a null entry.
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type>
<name>update_proconfig_value</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>set_items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>set_items</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VariableSetStmt</name> <modifier>*</modifier></type><name>sstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>VariableSetStmt</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sstmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>VAR_RESET_ALL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>valuestr</name> <init>= <expr><call><name>ExtractSetVariableArgs</name><argument_list>(<argument><expr><name>sstmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>valuestr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>GUCArrayAdd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>sstmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>valuestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>				<comment type="block">/* RESET */</comment>
				<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>GUCArrayDelete</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>sstmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>interpret_func_support</name><parameter_list>(<parameter><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>procName</name> <init>= <expr><call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Support functions always take one INTERNAL argument and return
	 * INTERNAL.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procName</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procName</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INTERNALOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"support function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>procName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Someday we might want an ACL check here; but for now, we insist that
	 * you be superuser to specify a support function, so privilege on the
	 * support function is moot.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to specify a support function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>procOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Dissect the list of options assembled in gram.y into function
 * attributes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_function_attributes</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>is_procedure</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>as</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>language</name></decl></parameter>,
							<parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>transform</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>windowfunc_p</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>volatility_p</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>strict_p</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>security_definer</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>leakproof_p</name></decl></parameter>,
							<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier><modifier>*</modifier></type><name>proconfig</name></decl></parameter>,
							<parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>procost</name></decl></parameter>,
							<parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>prorows</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>prosupport</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>parallel_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>as_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>language_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>transform_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>windowfunc_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>volatility_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>strict_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>security_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>leakproof_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>set_items</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>cost_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>rows_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>support_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>parallel_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"as"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>as_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>as_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"language"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>language_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>language_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transform"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>transform_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>transform_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"window"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>windowfunc_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid attribute in procedure definition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>windowfunc_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>compute_common_attribute</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><name>is_procedure</name></expr></argument>,
										  <argument><expr><name>defel</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>volatility_item</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>strict_item</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>security_item</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>leakproof_item</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>set_items</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>cost_item</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>rows_item</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>support_item</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>parallel_item</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* recognized common option */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
				 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* process required items */</comment>
	<if_stmt><if>if <condition>(<expr><name>as_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>as</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>as_item</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no function body specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>as</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>				<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>language_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>language</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>language_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no language specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>language</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* process optional items */</comment>
	<if_stmt><if>if <condition>(<expr><name>transform_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>transform</name> <operator>=</operator> <name><name>transform_item</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>windowfunc_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>windowfunc_p</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>windowfunc_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>volatility_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>volatility_p</name> <operator>=</operator> <call><name>interpret_func_volatility</name><argument_list>(<argument><expr><name>volatility_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>strict_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>strict_p</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>strict_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>security_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>security_definer</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>security_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>leakproof_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>leakproof_p</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>leakproof_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>set_items</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>proconfig</name> <operator>=</operator> <call><name>update_proconfig_value</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>set_items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cost_item</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>procost</name> <operator>=</operator> <call><name>defGetNumeric</name><argument_list>(<argument><expr><name>cost_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>procost</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COST must be positive"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rows_item</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>prorows</name> <operator>=</operator> <call><name>defGetNumeric</name><argument_list>(<argument><expr><name>rows_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>prorows</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROWS must be positive"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>support_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>prosupport</name> <operator>=</operator> <call><name>interpret_func_support</name><argument_list>(<argument><expr><name>support_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>parallel_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>parallel_p</name> <operator>=</operator> <call><name>interpret_func_parallel</name><argument_list>(<argument><expr><name>parallel_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * For a dynamically linked C language object, the form of the clause is
 *
 *	   AS &lt;object file name&gt; [, &lt;link symbol name&gt; ]
 *
 * In all other cases
 *
 *	   AS &lt;object reference, or sql code&gt;
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>interpret_AS_clause</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>languageOid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>languageName</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>as</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>prosrc_str_p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>probin_str_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>as</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>languageOid</name> <operator>==</operator> <name>ClanguageId</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For "C" language, store the file name in probin and, when given,
		 * the link symbol name in prosrc.  If link symbol is omitted,
		 * substitute procedure name.  We also allow link symbol to be
		 * specified as "-", since that was the habit in PG versions before
		 * 8.4, and there might be dump files out there that don't translate
		 * that back to "omitted".
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>probin_str_p</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>prosrc_str_p</name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>prosrc_str_p</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>prosrc_str_p</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>prosrc_str_p</name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Everything else wants the given string in prosrc. */</comment>
		<expr_stmt><expr><operator>*</operator><name>prosrc_str_p</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>probin_str_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only one AS item needed for language \"%s\""</literal></expr></argument>,
							<argument><expr><name>languageName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>languageOid</name> <operator>==</operator> <name>INTERNALlanguageId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In PostgreSQL versions before 6.5, the SQL name of the created
			 * function could not be different from the internal name, and
			 * "prosrc" wasn't used.  So there is code out there that does
			 * CREATE FUNCTION xyz AS '' LANGUAGE internal. To preserve some
			 * modicum of backwards compatibility, accept an empty "prosrc"
			 * value as meaning the supplied SQL function name.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>prosrc_str_p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>prosrc_str_p</name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateFunction
 *	 Execute a CREATE FUNCTION (or CREATE PROCEDURE) utility statement.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CreateFunction</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>probin_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>prorettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>returnsSet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>language</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>languageOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>languageValidator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>transformDefElem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>parameterTypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>allParameterTypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>parameterModes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>parameterNames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parameterDefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>variadicArgType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>trftypes_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>trftypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>requiredResultType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isWindowFunc</name></decl>,
				<decl><type ref="prev"/><name>isStrict</name></decl>,
				<decl><type ref="prev"/><name>security</name></decl>,
				<decl><type ref="prev"/><name>isLeakProof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>volatility</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>proconfig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>procost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>prorows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>prosupport</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>languageTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_language</name></type> <name>languageStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>as_clause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>parallel</name></decl>;</decl_stmt>

	<comment type="block">/* Convert list of names to a name and namespace */</comment>
	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check we have creation rights in target namespace */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set default attributes */</comment>
	<expr_stmt><expr><name>isWindowFunc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>isStrict</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>security</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>isLeakProof</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>volatility</name> <operator>=</operator> <name>PROVOLATILE_VOLATILE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>proconfig</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>procost</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* indicates not set */</comment>
	<expr_stmt><expr><name>prorows</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* indicates not set */</comment>
	<expr_stmt><expr><name>prosupport</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parallel</name> <operator>=</operator> <name>PROPARALLEL_UNSAFE</name></expr>;</expr_stmt>

	<comment type="block">/* Extract non-default attributes from stmt-&gt;options list */</comment>
	<expr_stmt><expr><call><name>compute_function_attributes</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_procedure</name></name></expr></argument>,
								<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>as_clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>language</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>transformDefElem</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isWindowFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>volatility</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isStrict</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>security</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isLeakProof</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>proconfig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>procost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prorows</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>prosupport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parallel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the language and validate permissions */</comment>
	<expr_stmt><expr><name>languageTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>language</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>languageTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"language \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>language</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><ternary><condition><expr><call><name>extension_file_exists</name><argument_list>(<argument><expr><name>language</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
				  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use CREATE EXTENSION to load the language into the database."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>languageStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>languageTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>languageOid</name> <operator>=</operator> <name><name>languageStruct</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>languageStruct</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if trusted language, need USAGE privilege */</comment>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_language_aclcheck</name><argument_list>(<argument><expr><name>languageOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_LANGUAGE</name></expr></argument>,
						   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>languageStruct</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* if untrusted language, must be superuser */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NO_PRIV</name></expr></argument>, <argument><expr><name>OBJECT_LANGUAGE</name></expr></argument>,
						   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>languageStruct</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>languageValidator</name> <operator>=</operator> <name><name>languageStruct</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>languageTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only superuser is allowed to create leakproof functions because
	 * leakproof functions can see tuples which have not yet been filtered out
	 * by security barrier views or row level security policies.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isLeakProof</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only superuser can define a leakproof function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>transformDefElem</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>castNode(List, transformDefElem)</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name> <init>= <expr><call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>elt</name> <init>= <expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>typeid</name> <operator>=</operator> <ternary><condition><expr><name>elt</name></expr> ?</condition><then> <expr><name>elt</name></expr> </then><else>: <expr><name>typeid</name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>get_transform_oid</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>, <argument><expr><name>languageOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>trftypes_list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>trftypes_list</name></expr></argument>, <argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Convert remaining parameters of CREATE to form wanted by
	 * ProcedureCreate.
	 */</comment>
	<expr_stmt><expr><call><name>interpret_function_parameter_list</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>parameters</name></name></expr></argument>,
									  <argument><expr><name>languageOid</name></expr></argument>,
									  <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_procedure</name></name></expr> ?</condition><then> <expr><name>OBJECT_PROCEDURE</name></expr> </then><else>: <expr><name>OBJECT_FUNCTION</name></expr></else></ternary></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>parameterTypes</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>allParameterTypes</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>parameterModes</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>parameterNames</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>parameterDefaults</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>variadicArgType</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>requiredResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_procedure</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>returnType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prorettype</name> <operator>=</operator> <ternary><condition><expr><name>requiredResultType</name></expr> ?</condition><then> <expr><name>requiredResultType</name></expr> </then><else>: <expr><name>VOIDOID</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>returnsSet</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>returnType</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* explicit RETURNS clause */</comment>
		<expr_stmt><expr><call><name>compute_return_type</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>returnType</name></name></expr></argument>, <argument><expr><name>languageOid</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>prorettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>returnsSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>requiredResultType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>prorettype</name> <operator>!=</operator> <name>requiredResultType</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function result type must be %s because of OUT parameters"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>requiredResultType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>requiredResultType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* default RETURNS clause from OUT parameters */</comment>
		<expr_stmt><expr><name>prorettype</name> <operator>=</operator> <name>requiredResultType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>returnsSet</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function result type must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Alternative possibility: default to RETURNS VOID */</comment>
		<expr_stmt><expr><name>prorettype</name> <operator>=</operator> <name>VOIDOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>returnsSet</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>trftypes_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>trftypes_list</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>trftypes_list</argument>)</argument_list></macro>
			<expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>trftypes</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>trftypes_list</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* store SQL NULL instead of empty array */</comment>
		<expr_stmt><expr><name>trftypes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>interpret_AS_clause</name><argument_list>(<argument><expr><name>languageOid</name></expr></argument>, <argument><expr><name>language</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>as_clause</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>prosrc_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>probin_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set default values for COST and ROWS depending on other parameters;
	 * reject ROWS if it's not returnsSet.  NB: pg_dump knows these default
	 * values, keep it in sync if you change them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>procost</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* SQL and PL-language functions are assumed more expensive */</comment>
		<if_stmt><if>if <condition>(<expr><name>languageOid</name> <operator>==</operator> <name>INTERNALlanguageId</name> <operator>||</operator>
			<name>languageOid</name> <operator>==</operator> <name>ClanguageId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>procost</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>procost</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>prorows</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>returnsSet</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prorows</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prorows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>		<comment type="block">/* dummy value if not returnsSet */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>returnsSet</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROWS is not applicable when function does not return a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * And now that we have all the parameters, and know we're permitted to do
	 * so, go ahead and create the function.
	 */</comment>
	<return>return <expr><call><name>ProcedureCreate</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>,
						   <argument><expr><name>namespaceId</name></expr></argument>,
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>,
						   <argument><expr><name>returnsSet</name></expr></argument>,
						   <argument><expr><name>prorettype</name></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><name>languageOid</name></expr></argument>,
						   <argument><expr><name>languageValidator</name></expr></argument>,
						   <argument><expr><name>prosrc_str</name></expr></argument>,	<comment type="block">/* converted to text later */</comment>
						   <argument><expr><name>probin_str</name></expr></argument>,	<comment type="block">/* converted to text later */</comment>
						   <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_procedure</name></name></expr> ?</condition><then> <expr><name>PROKIND_PROCEDURE</name></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>isWindowFunc</name></expr> ?</condition><then> <expr><name>PROKIND_WINDOW</name></expr> </then><else>: <expr><name>PROKIND_FUNCTION</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>,
						   <argument><expr><name>security</name></expr></argument>,
						   <argument><expr><name>isLeakProof</name></expr></argument>,
						   <argument><expr><name>isStrict</name></expr></argument>,
						   <argument><expr><name>volatility</name></expr></argument>,
						   <argument><expr><name>parallel</name></expr></argument>,
						   <argument><expr><name>parameterTypes</name></expr></argument>,
						   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>allParameterTypes</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>parameterModes</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>parameterNames</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>parameterDefaults</name></expr></argument>,
						   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>trftypes</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>proconfig</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>prosupport</name></expr></argument>,
						   <argument><expr><name>procost</name></expr></argument>,
						   <argument><expr><name>prorows</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Guts of function deletion.
 *
 * Note: this is also used for aggregate deletion, since the OIDs of
 * both functions and aggregates point to pg_proc.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveFunctionById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>prokind</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Delete the pg_proc tuple.
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>prokind</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>prokind</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's a pg_aggregate tuple, delete that too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>prokind</name> <operator>==</operator> <name>PROKIND_AGGREGATE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AggregateRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for pg_aggregate tuple for function %u"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Implements the ALTER FUNCTION utility command (except for the
 * RENAME and OWNER clauses, which are handled as part of the generic
 * ALTER framework).
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterFunction</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>AlterFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_procedure</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>volatility_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>strict_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>security_def_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>leakproof_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>set_items</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>cost_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>rows_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>support_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>parallel_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>funcOid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>procForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Permission check: must own function */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_AGGREGATE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is an aggregate function"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>is_procedure</name> <operator>=</operator> <operator>(</operator><name><name>procForm</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_PROCEDURE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Examine requested actions. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;actions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>compute_common_attribute</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									 <argument><expr><name>is_procedure</name></expr></argument>,
									 <argument><expr><name>defel</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>volatility_item</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>strict_item</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>security_def_item</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>leakproof_item</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>set_items</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>cost_item</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>rows_item</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>support_item</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>parallel_item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>volatility_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>procForm</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>=</operator> <call><name>interpret_func_volatility</name><argument_list>(<argument><expr><name>volatility_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>strict_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>procForm</name><operator>-&gt;</operator><name>proisstrict</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>strict_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>security_def_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>procForm</name><operator>-&gt;</operator><name>prosecdef</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>security_def_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>leakproof_item</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>procForm</name><operator>-&gt;</operator><name>proleakproof</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>leakproof_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>proleakproof</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only superuser can define a leakproof function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cost_item</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>procForm</name><operator>-&gt;</operator><name>procost</name></name> <operator>=</operator> <call><name>defGetNumeric</name><argument_list>(<argument><expr><name>cost_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>procost</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COST must be positive"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rows_item</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>procForm</name><operator>-&gt;</operator><name>prorows</name></name> <operator>=</operator> <call><name>defGetNumeric</name><argument_list>(<argument><expr><name>rows_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>prorows</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROWS must be positive"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>procForm</name><operator>-&gt;</operator><name>proretset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROWS is not applicable when function does not return a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>support_item</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* interpret_func_support handles the privilege check */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>newsupport</name> <init>= <expr><call><name>interpret_func_support</name><argument_list>(<argument><expr><name>support_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Add or replace dependency on support function */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>procForm</name><operator>-&gt;</operator><name>prosupport</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>,
								<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name><name>procForm</name><operator>-&gt;</operator><name>prosupport</name></name></expr></argument>,
								<argument><expr><name>newsupport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>referenced</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>newsupport</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>procForm</name><operator>-&gt;</operator><name>prosupport</name></name> <operator>=</operator> <name>newsupport</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>parallel_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>procForm</name><operator>-&gt;</operator><name>proparallel</name></name> <operator>=</operator> <call><name>interpret_func_parallel</name><argument_list>(<argument><expr><name>parallel_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>set_items</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* extract existing proconfig setting */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proconfig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* update according to each SET or RESET item, left to right */</comment>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>update_proconfig_value</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>set_items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* update the tuple */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_proc_proconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_proc_proconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_proc_proconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_proc_proconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_proc_proconfig</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* DO NOT put more touches of procForm below here; it's now dangling. */</comment>

	<comment type="block">/* Do the update */</comment>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CREATE CAST
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CreateCast</name><parameter_list>(<parameter><decl><type><name>CreateCastStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sourcetypeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targettypeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>sourcetyptype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>targettyptype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>castcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>castmethod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sourcetypeid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sourcetype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targettypeid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targettype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sourcetyptype</name> <operator>=</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name>sourcetypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targettyptype</name> <operator>=</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name>targettypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No pseudo-types allowed */</comment>
	<if_stmt><if>if <condition>(<expr><name>sourcetyptype</name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source data type %s is a pseudo-type"</literal></expr></argument>,
						<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>sourcetype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>targettyptype</name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"target data type %s is a pseudo-type"</literal></expr></argument>,
						<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>targettype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permission check */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><name>sourcetypeid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><name>targettypeid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be owner of type %s or type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>sourcetypeid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettypeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>sourcetypeid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>sourcetypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>targettypeid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>targettypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Domains are allowed for historical reasons, but we warn */</comment>
	<if_stmt><if>if <condition>(<expr><name>sourcetyptype</name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cast will be ignored because the source data type is a domain"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<if type="elseif">else if <condition>(<expr><name>targettyptype</name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cast will be ignored because the target data type is a domain"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Determine the cast method */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>func</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>castmethod</name> <operator>=</operator> <name>COERCION_METHOD_FUNCTION</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>inout</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>castmethod</name> <operator>=</operator> <name>COERCION_METHOD_INOUT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>castmethod</name> <operator>=</operator> <name>COERCION_METHOD_BINARY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>castmethod</name> <operator>==</operator> <name>COERCION_METHOD_FUNCTION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procstruct</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>procstruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>nargs</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>nargs</name></expr></argument> &gt;</argument_list></name> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cast function must take one to three arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>sourcetypeid</name></expr></argument>, <argument><expr><name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of cast function must match or be binary-coercible from source data type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"second argument of cast function must be type %s"</literal></expr></argument>,
							<argument><expr><literal type="string">"integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"third argument of cast function must be type %s"</literal></expr></argument>,
							<argument><expr><literal type="string">"boolean"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>procstruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>, <argument><expr><name>targettypeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return data type of cast function must match or be binary-coercible to target data type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Restricting the volatility of a cast function may or may not be a
		 * good idea in the abstract, but it definitely breaks many old
		 * user-defined types.  Disable this check --- tgl 2/1/03
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cast function must not be volatile"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>prokind</name></name> <operator>!=</operator> <name>PROKIND_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cast function must be a normal function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cast function must not return a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>castmethod</name> <operator>==</operator> <name>COERCION_METHOD_BINARY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int16</name></type>		<name>typ1len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>typ2len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typ1byval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typ2byval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>typ1align</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>typ2align</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Must be superuser to create binary-compatible casts, since
		 * erroneous casts can easily crash the backend.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to create a cast WITHOUT FUNCTION"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also, insist that the types match as to size, alignment, and
		 * pass-by-value attributes; this provides at least a crude check that
		 * they have similar representations.  A pair of types that fail this
		 * test should certainly not be equated.
		 */</comment>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>sourcetypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typ1len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typ1byval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typ1align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>targettypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typ2len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typ2byval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typ2align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typ1len</name> <operator>!=</operator> <name>typ2len</name> <operator>||</operator>
			<name>typ1byval</name> <operator>!=</operator> <name>typ2byval</name> <operator>||</operator>
			<name>typ1align</name> <operator>!=</operator> <name>typ2align</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source and target data types are not physically compatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We know that composite, enum and array types are never binary-
		 * compatible with each other.  They all have OIDs embedded in them.
		 *
		 * Theoretically you could build a user-defined base type that is
		 * binary-compatible with a composite, enum, or array type.  But we
		 * disallow that too, as in practice such a cast is surely a mistake.
		 * You can always work around that by writing a cast function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sourcetyptype</name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>||</operator>
			<name>targettyptype</name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"composite data types are not binary-compatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>sourcetyptype</name> <operator>==</operator> <name>TYPTYPE_ENUM</name> <operator>||</operator>
			<name>targettyptype</name> <operator>==</operator> <name>TYPTYPE_ENUM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"enum data types are not binary-compatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>sourcetypeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>targettypeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array data types are not binary-compatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We also disallow creating binary-compatibility casts involving
		 * domains.  Casting from a domain to its base type is already
		 * allowed, and casting the other way ought to go through domain
		 * coercion to permit constraint checking.  Again, if you're intent on
		 * having your own semantics for that, create a no-op cast function.
		 *
		 * NOTE: if we were to relax this, the above checks for composites
		 * etc. would have to be modified to look through domains to their
		 * base types.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sourcetyptype</name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name> <operator>||</operator>
			<name>targettyptype</name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"domain data types must not be marked binary-compatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Allow source and target types to be same only for length coercion
	 * functions.  We assume a multi-arg function does length coercion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sourcetypeid</name> <operator>==</operator> <name>targettypeid</name> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source data type and target data type are the same"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* convert CoercionContext enum to char value for castcontext */</comment>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>COERCION_IMPLICIT</name></expr>:</case>
			<expr_stmt><expr><name>castcontext</name> <operator>=</operator> <name>COERCION_CODE_IMPLICIT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COERCION_ASSIGNMENT</name></expr>:</case>
			<expr_stmt><expr><name>castcontext</name> <operator>=</operator> <name>COERCION_CODE_ASSIGNMENT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COERCION_EXPLICIT</name></expr>:</case>
			<expr_stmt><expr><name>castcontext</name> <operator>=</operator> <name>COERCION_CODE_EXPLICIT</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized CoercionContext: %d"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>castcontext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>myself</name> <operator>=</operator> <call><name>CastCreate</name><argument_list>(<argument><expr><name>sourcetypeid</name></expr></argument>, <argument><expr><name>targettypeid</name></expr></argument>, <argument><expr><name>funcid</name></expr></argument>, <argument><expr><name>castcontext</name></expr></argument>,
						<argument><expr><name>castmethod</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DropCastById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>castOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>CastRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_cast_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>castOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>CastOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for cast %u"</literal></expr></argument>, <argument><expr><name>castOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_transform_function</name><parameter_list>(<parameter><decl><type><name>Form_pg_proc</name></type> <name>procstruct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transform function must not be volatile"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>prokind</name></name> <operator>!=</operator> <name>PROKIND_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transform function must be a normal function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transform function must not return a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transform function must take one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>INTERNALOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"first argument of transform function must be type %s"</literal></expr></argument>,
						<argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CREATE TRANSFORM
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CreateTransform</name><parameter_list>(<parameter><decl><type><name>CreateTransformStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>langid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>fromsqlfuncid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tosqlfuncid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procstruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_transform</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_transform</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_transform</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>transformid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_replace</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the type
	 */</comment>
	<expr_stmt><expr><name>typeid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>type_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typtype</name> <operator>=</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>typtype</name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s is a pseudo-type"</literal></expr></argument>,
						<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>type_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typtype</name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s is a domain"</literal></expr></argument>,
						<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>type_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the language
	 */</comment>
	<expr_stmt><expr><name>langid</name> <operator>=</operator> <call><name>get_language_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_language_aclcheck</name><argument_list>(<argument><expr><name>langid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_LANGUAGE</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the functions
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>fromsql</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fromsqlfuncid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromsql</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>fromsqlfuncid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromsql</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>fromsqlfuncid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromsql</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>fromsqlfuncid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>fromsqlfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>procstruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>INTERNALOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return data type of FROM SQL function must be %s"</literal></expr></argument>,
							<argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>check_transform_function</name><argument_list>(<argument><expr><name>procstruct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fromsqlfuncid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>tosql</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tosqlfuncid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tosql</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>tosqlfuncid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tosql</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>tosqlfuncid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tosql</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tosqlfuncid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>tosqlfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>procstruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>procstruct</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>typeid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return data type of TO SQL function must be the transform data type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>check_transform_function</name><argument_list>(<argument><expr><name>procstruct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tosqlfuncid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Ready to go
	 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transform_trftype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transform_trflang</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>langid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transform_trffromsql</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>fromsqlfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transform_trftosql</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tosqlfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TransformRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>TRFTYPELANG</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>langid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_transform</name></type> <name>form</name> <init>= <expr><operator>(</operator><name>Form_pg_transform</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>replace</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transform for type %s language \"%s\" already exists"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_transform_trffromsql</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_transform_trftosql</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>transformid</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_replace</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>transformid</name> <operator>=</operator> <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>TransformOidIndexId</name></expr></argument>,
										 <argument><expr><name>Anum_pg_transform_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_transform_oid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>transformid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_replace</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_replace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>TransformRelationId</name></expr></argument>, <argument><expr><name>transformid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* make dependency entries */</comment>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TransformRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>transformid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* dependency on language */</comment>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>LanguageRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>langid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dependency on type */</comment>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>typeid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dependencies on functions */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>fromsqlfuncid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>fromsqlfuncid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tosqlfuncid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>tosqlfuncid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* dependency on extension */</comment>
	<expr_stmt><expr><call><name>recordDependencyOnCurrentExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>is_replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Post creation hook for new transform */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>TransformRelationId</name></expr></argument>, <argument><expr><name>transformid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_transform_oid - given type OID and language OID, look up a transform OID
 *
 * If missing_ok is false, throw an error if the transform is not found.  If
 * true, just return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_transform_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>lang_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TRFTYPELANG</name></expr></argument>, <argument><expr><name>Anum_pg_transform_oid</name></expr></argument>,
						  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>lang_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transform for type %s language \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>get_language_name</name><argument_list>(<argument><expr><name>lang_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>oid</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>DropTransformById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>transformOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TransformRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_transform_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>transformOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>TransformOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for transform %u"</literal></expr></argument>, <argument><expr><name>transformOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Subroutine for ALTER FUNCTION/AGGREGATE SET SCHEMA/RENAME
 *
 * Is there a function with the given name and signature already in the given
 * namespace?  If so, raise an appropriate error message.
 */</comment>
<function><type><name>void</name></type>
<name>IsThereFunctionInNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pronargs</name></decl></parameter>,
						   <parameter><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>proargtypes</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* check for duplicate name (more friendly than unique-index failure) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists3</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>,
							  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>proargtypes</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s already exists in schema \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>funcname_signature_string</name><argument_list>(<argument><expr><name>proname</name></expr></argument>, <argument><expr><name>pronargs</name></expr></argument>,
												  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>proargtypes</name><operator>-&gt;</operator><name>values</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecuteDoStmt
 *		Execute inline procedural-language code
 *
 * See at ExecuteCallStmt() about the atomic argument.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteDoStmt</name><parameter_list>(<parameter><decl><type><name>DoStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>atomic</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InlineCodeBlock</name> <modifier>*</modifier></type><name>codeblock</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>InlineCodeBlock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>as_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>language_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>language</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>laninline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>languageTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_language</name></type> <name>languageStruct</name></decl>;</decl_stmt>

	<comment type="block">/* Process options we got from gram.y */</comment>
	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>stmt-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"as"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>as_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>as_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"language"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>language_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>language_item</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
				 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>as_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>codeblock</name><operator>-&gt;</operator><name>source_text</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>as_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no inline code specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* if LANGUAGE option wasn't specified, use the default */</comment>
	<if_stmt><if>if <condition>(<expr><name>language_item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>language</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>language_item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>language</name> <operator>=</operator> <literal type="string">"plpgsql"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Look up the language and validate permissions */</comment>
	<expr_stmt><expr><name>languageTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>language</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>languageTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"language \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>language</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><ternary><condition><expr><call><name>extension_file_exists</name><argument_list>(<argument><expr><name>language</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
				  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use CREATE EXTENSION to load the language into the database."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>languageStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>languageTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>codeblock</name><operator>-&gt;</operator><name>langOid</name></name> <operator>=</operator> <name><name>languageStruct</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>codeblock</name><operator>-&gt;</operator><name>langIsTrusted</name></name> <operator>=</operator> <name><name>languageStruct</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>codeblock</name><operator>-&gt;</operator><name>atomic</name></name> <operator>=</operator> <name>atomic</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>languageStruct</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if trusted language, need USAGE privilege */</comment>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_language_aclcheck</name><argument_list>(<argument><expr><name><name>codeblock</name><operator>-&gt;</operator><name>langOid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										 <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_LANGUAGE</name></expr></argument>,
						   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>languageStruct</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* if untrusted language, must be superuser */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NO_PRIV</name></expr></argument>, <argument><expr><name>OBJECT_LANGUAGE</name></expr></argument>,
						   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>languageStruct</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* get the handler function's OID */</comment>
	<expr_stmt><expr><name>laninline</name> <operator>=</operator> <name><name>languageStruct</name><operator>-&gt;</operator><name>laninline</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>laninline</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"language \"%s\" does not support inline code execution"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>languageStruct</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>languageTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* execute the inline handler */</comment>
	<expr_stmt><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>laninline</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>codeblock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute CALL statement
 *
 * Inside a top-level CALL statement, transaction-terminating commands such as
 * COMMIT or a PL-specific equivalent are allowed.  The terminology in the SQL
 * standard is that CALL establishes a non-atomic execution context.  Most
 * other commands establish an atomic execution context, in which transaction
 * control actions are not allowed.  If there are nested executions of CALL,
 * we want to track the execution context recursively, so that the nested
 * CALLs can also do transaction control.  Note, however, that for example in
 * CALL -&gt; SELECT -&gt; CALL, the second call cannot do transaction control,
 * because the SELECT in between establishes an atomic execution context.
 *
 * So when ExecuteCallStmt() is called from the top level, we pass in atomic =
 * false (recall that that means transactions = yes).  We then create a
 * CallContext node with content atomic = false, which is passed in the
 * fcinfo-&gt;context field to the procedure invocation.  The language
 * implementation should then take appropriate measures to allow or prevent
 * transaction commands based on that information, e.g., call
 * SPI_connect_ext(SPI_OPT_NONATOMIC).  The language should also pass on the
 * atomic flag to any nested invocations to CALL.
 *
 * The expression data structures and execution context that we create
 * within this function are children of the portalContext of the Portal
 * that the CALL utility statement runs in.  Therefore, any pass-by-ref
 * values that we're passing to the procedure will survive transaction
 * commits that might occur inside the procedure.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteCallStmt</name><parameter_list>(<parameter><decl><type><name>CallStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>atomic</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CallContext</name> <modifier>*</modifier></type><name>callcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_FunctionCallUsage</name></type> <name>fcusage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>funcexpr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_PROCEDURE</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prep the context object we'll pass to the procedure */</comment>
	<expr_stmt><expr><name>callcontext</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CallContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>callcontext</name><operator>-&gt;</operator><name>atomic</name></name> <operator>=</operator> <name>atomic</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If proconfig is set we can't allow transaction commands because of the
	 * way the GUC stacking works: The transaction boundary would have to pop
	 * the proconfig setting off the stack.  That restriction could be lifted
	 * by redesigning the GUC nesting mechanism a bit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proconfig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>callcontext</name><operator>-&gt;</operator><name>atomic</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In security definer procedures, we can't allow transaction commands.
	 * StartTransaction() insists that the security context stack is empty,
	 * and AbortTransaction() resets the security context.  This could be
	 * reorganized, but right now it doesn't work.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>prosecdef</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>callcontext</name><operator>-&gt;</operator><name>atomic</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Expand named arguments, defaults, etc.  We do not want to scribble on
	 * the passed-in CallStmt parse tree, so first flat-copy fexpr, allowing
	 * us to replace its args field.  (Note that expand_function_arguments
	 * will not modify any of the passed-in data structure.)
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>nexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nexpr</name></expr></argument>, <argument><expr><name>fexpr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <name>nexpr</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>expand_function_arguments</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
											<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>,
											<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* safety check; see ExecInitFunc() */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"cannot pass more than %d argument to a procedure"</literal></expr></argument>,
							   <argument><expr><literal type="string">"cannot pass more than %d arguments to a procedure"</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize function call structure */</comment>
	<expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>callcontext</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Evaluate procedure arguments inside a suitable execution context.  Note
	 * we can't free this context till the procedure returns.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're called in non-atomic context, we also have to ensure that the
	 * argument expressions run with an up-to-date snapshot.  Our caller will
	 * have provided a current snapshot in atomic contexts, but not in
	 * non-atomic contexts, because the possibility of a COMMIT/ROLLBACK
	 * destroying the snapshot makes higher-level management too complicated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>atomic</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fexpr-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exprstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Get rid of temporary snapshot for arguments, if we made one */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>atomic</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Here we actually call the procedure */</comment>
	<expr_stmt><expr><call><name>pgstat_init_function_usage</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_end_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle the procedure's outputs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>==</operator> <name>VOIDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* do nothing */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* send tuple to client */</comment>
		<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>retdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>rettupdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"procedure returned null record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ensure there's an active snapshot whilst we execute whatever's
		 * involved here.  Note that this is *not* sufficient to make the
		 * world safe for TOAST pointers to be included in the returned data:
		 * the referenced data could have gone away while we didn't hold a
		 * snapshot.  Hence, it's incumbent on PLs that can do COMMIT/ROLLBACK
		 * to not return TOAST pointers, unless those pointers were fetched
		 * after the last COMMIT/ROLLBACK in the procedure.
		 *
		 * XXX that is a really nasty, hard-to-test requirement.  Is there a
		 * way to remove it?
		 */</comment>
		<expr_stmt><expr><call><name>EnsurePortalSnapshotExists</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>retdesc</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>TTSOpsHeapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rettupdata</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rettupdata</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rettupdata</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rettupdata</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rettupdata</name></expr></argument>, <argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>tstate</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>tstate</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>retdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected result type for procedure: %u"</literal></expr></argument>,
			 <argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct the tuple descriptor for a CALL statement return
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>CallStmtResultDesc</name><parameter_list>(<parameter><decl><type><name>CallStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>funcexpr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for procedure %u"</literal></expr></argument>, <argument><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>build_function_result_tupdesc_t</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tupdesc</name></expr>;</return>
</block_content>}</block></function>
</unit>
