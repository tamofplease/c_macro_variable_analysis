<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/commands/policy.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * policy.c
 *	  Commands for manipulating policies.
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/commands/policy.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rowsecurity.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForPolicy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>parse_policy_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type><name>policy_role_list_to_array</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>roles</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_roles</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Callback to RangeVarGetRelidExtended().
 *
 * Checks the following:
 *	- the relation specified is a table.
 *	- current user owns the table.
 *	- the table is not a system table.
 *
 * If any of these checks fails then an error is raised.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForPolicy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>,
						  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>

	<comment type="block">/* Must own relation. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* No system table modifications unless explicitly allowed. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Relation type MUST be a table. */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * parse_policy_command -
 *	 helper function to convert full command strings to their char
 *	 representation.
 *
 * cmd_name - full string command name. Valid values are 'all', 'select',
 *			  'insert', 'update' and 'delete'.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>char</name></type>
<name>parse_policy_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>polcmd</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmd_name</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized policy command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polcmd</name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polcmd</name> <operator>=</operator> <name>ACL_SELECT_CHR</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>, <argument><expr><literal type="string">"insert"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polcmd</name> <operator>=</operator> <name>ACL_INSERT_CHR</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>, <argument><expr><literal type="string">"update"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polcmd</name> <operator>=</operator> <name>ACL_UPDATE_CHR</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polcmd</name> <operator>=</operator> <name>ACL_DELETE_CHR</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized policy command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>polcmd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * policy_role_list_to_array
 *	 helper function to convert a list of RoleSpecs to an array of
 *	 role id Datums.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type>
<name>policy_role_list_to_array</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>roles</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_roles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>role_oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Handle no roles being passed in as being for public */</comment>
	<if_stmt><if>if <condition>(<expr><name>roles</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>num_roles</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>role_oids</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>num_roles</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>role_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ACL_ID_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>role_oids</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_roles</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>role_oids</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>num_roles</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>roles</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RoleSpec</name>   <modifier>*</modifier></type><name>spec</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * PUBLIC covers all roles, so it only makes sense alone.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>roletype</name></name> <operator>==</operator> <name>ROLESPEC_PUBLIC</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>num_roles</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ignoring specified roles other than PUBLIC"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"All roles are members of the PUBLIC role."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>num_roles</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>role_oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ACL_ID_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>role_oids</name></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>role_oids</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name>spec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>role_oids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Load row security policy from the catalog, and store it in
 * the relation's relcache entry.
 *
 * Note that caller should have verified that pg_class.relrowsecurity
 * is true for this relation.
 */</comment>
<function><type><name>void</name></type>
<name>RelationBuildRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>rscxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowSecurityDesc</name> <modifier>*</modifier></type><name>rsdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create a memory context to hold everything associated with this
	 * relation's row security policy.  This makes it easy to clean up during
	 * a relcache flush.  However, to cover the possibility of an error
	 * partway through, we don't make the context long-lived till we're done.
	 */</comment>
	<expr_stmt><expr><name>rscxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"row security descriptor"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name>rscxt</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rsdesc</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>rscxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RowSecurityDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsdesc</name><operator>-&gt;</operator><name>rscxt</name></name> <operator>=</operator> <name>rscxt</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now scan pg_policy for RLS policies associated with this relation.
	 * Because we use the index on (polrelid, polname), we should consistently
	 * visit the rel's policies in name order, at least when system indexes
	 * aren't disabled.  This simplifies equalRSDesc().
	 */</comment>
	<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>PolicyPolrelidPolnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_policy</name></type> <name>policy_form</name> <init>= <expr><operator>(</operator><name>Form_pg_policy</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str_value</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>rscxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RowSecurityPolicy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: we must be sure that pass-by-reference data gets copied into
		 * rscxt.  We avoid making that context current over wider spans than
		 * we have to, though.
		 */</comment>

		<comment type="block">/* Get policy command */</comment>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>=</operator> <name><name>policy_form</name><operator>-&gt;</operator><name>polcmd</name></name></expr>;</expr_stmt>

		<comment type="block">/* Get policy, permissive or restrictive */</comment>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>permissive</name></name> <operator>=</operator> <name><name>policy_form</name><operator>-&gt;</operator><name>polpermissive</name></name></expr>;</expr_stmt>

		<comment type="block">/* Get policy name */</comment>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>policy_name</name></name> <operator>=</operator>
			<call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>rscxt</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>policy_form</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get policy roles */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_policy_polroles</name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* shouldn't be null, but let's check for luck */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected null value in pg_policy.polroles"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>roles</name></name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get policy qual */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_policy_polqual</name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>str_value</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>str_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Get WITH CHECK qual */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_policy_polwithcheck</name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>str_value</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>with_check_qual</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>str_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>with_check_qual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* We want to cache whether there are SubLinks in these expressions */</comment>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>hassublinks</name></name> <operator>=</operator> <call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>policy</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>policy</name><operator>-&gt;</operator><name>with_check_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add this object to list.  For historical reasons, the list is built
		 * in reverse order.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rsdesc</name><operator>-&gt;</operator><name>policies</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>policy</name></expr></argument>, <argument><expr><name><name>rsdesc</name><operator>-&gt;</operator><name>policies</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Success.  Reparent the descriptor's memory context under
	 * CacheMemoryContext so that it will live indefinitely, then attach the
	 * policy descriptor to the relcache entry.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name>rscxt</name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name></name> <operator>=</operator> <name>rsdesc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RemovePolicyById -
 *	 remove a policy by its OID.  If a policy does not exist with the provided
 *	 oid, then an error is raised.
 *
 * policy_id - the oid of the policy.
 */</comment>
<function><type><name>void</name></type>
<name>RemovePolicyById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>policy_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_policy_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_policy_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the policy to delete.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>policy_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>PolicyOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the policy exists, then remove it, otherwise raise an error. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for policy %u"</literal></expr></argument>, <argument><expr><name>policy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Open and exclusive-lock the relation the policy belongs to.  (We need
	 * exclusive lock to lock out queries that might otherwise depend on the
	 * set of policies the rel has; furthermore we've got to hold the lock
	 * till commit.)
	 */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_policy</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>polrelid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that, unlike some of the other flags in pg_class, relrowsecurity
	 * is not just an indication of if policies exist.  When relrowsecurity is
	 * set by a user, then all access to the relation must be through a
	 * policy.  If no policy is defined for the relation then a default-deny
	 * policy is created and all records are filtered (except for queries from
	 * the owner).
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveRoleFromObjectPolicy -
 *	 remove a role from a policy's applicable-roles list.
 *
 * Returns true if the role was successfully removed from the policy.
 * Returns false if the role was not removed because it would have left
 * polroles empty (which is disallowed, though perhaps it should not be).
 * On false return, the caller should instead drop the policy altogether.
 *
 * roleid - the oid of the role to remove
 * classid - should always be PolicyRelationId
 * policy_id - the oid of the policy.
 */</comment>
<function><type><name>bool</name></type>
<name>RemoveRoleFromObjectPolicy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>policy_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_policy_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>policy_roles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>roles_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>roles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_roles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>role_oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>attr_isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>keep_policy</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>classid</name> <operator>==</operator> <name>PolicyRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_policy_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the policy to update.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>policy_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>PolicyOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Raise an error if we don't find the policy. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for policy %u"</literal></expr></argument>, <argument><expr><name>policy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Identify rel the policy belongs to */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_policy</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>polrelid</name></expr>;</expr_stmt>

	<comment type="block">/* Get the current set of roles */</comment>
	<expr_stmt><expr><name>roles_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							   <argument><expr><name>Anum_pg_policy_polroles</name></expr></argument>,
							   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>policy_roles</name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>roles_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>roles</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>policy_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_roles</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>policy_roles</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>

	<comment type="block">/*
	 * Rebuild the polroles array, without any mentions of the target role.
	 * Ordinarily there'd be exactly one, but we must cope with duplicate
	 * mentions, since CREATE/ALTER POLICY historically have allowed that.
	 */</comment>
	<expr_stmt><expr><name>role_oids</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_roles</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_roles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>roles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>roleid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>role_oids</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>roles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>num_roles</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

	<comment type="block">/* If any roles remain, update the policy entry. */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_roles</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>role_ids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_policy</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>Natts_pg_policy</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_policy</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>new_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>target</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>

		<comment type="block">/* zero-clear */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* This is the array for the new tuple */</comment>
		<expr_stmt><expr><name>role_ids</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>role_oids</name></expr></argument>, <argument><expr><name>num_roles</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_policy_polroles</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polroles</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>role_ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
									  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>new_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remove all the old shared dependencies (roles) */</comment>
		<expr_stmt><expr><call><name>deleteSharedDependencyRecordsFor</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>policy_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Record the new shared dependencies (roles) */</comment>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>PolicyRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>policy_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>target</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AuthIdRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_roles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>role_oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* no need for dependency on the public role */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>objectId</name></name> <operator>!=</operator> <name>ACL_ID_PUBLIC</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>recordSharedDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>,
										 <argument><expr><name>SHARED_DEPENDENCY_POLICY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>policy_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make updates visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Invalidate relcache entry for rel the policy belongs to, to force
		 * redoing any dependent plans.  In case of a race condition where the
		 * rel was just dropped, we need do nothing.
		 */</comment>
		<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No roles would remain, so drop the policy instead. */</comment>
		<expr_stmt><expr><name>keep_policy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>keep_policy</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreatePolicy -
 *	 handles the execution of the CREATE POLICY command.
 *
 * stmt - the CreatePolicyStmt that describes the policy to create.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>CreatePolicy</name><parameter_list>(<parameter><decl><type><name>CreatePolicyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_policy_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>policy_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>target_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>table_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>polcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>role_oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>role_ids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>qual_pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>with_check_pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>with_check_qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>policy_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_policy</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>Natts_pg_policy</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Parse command */</comment>
	<expr_stmt><expr><name>polcmd</name> <operator>=</operator> <call><name>parse_policy_command</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmd_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the command is SELECT or DELETE then WITH CHECK should be NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>polcmd</name> <operator>==</operator> <name>ACL_SELECT_CHR</name> <operator>||</operator> <name>polcmd</name> <operator>==</operator> <name>ACL_DELETE_CHR</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>with_check</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH CHECK cannot be applied to SELECT or DELETE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the command is INSERT then WITH CHECK should be the only expression
	 * provided.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polcmd</name> <operator>==</operator> <name>ACL_INSERT_CHR</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>qual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only WITH CHECK expression allowed for INSERT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Collect role ids */</comment>
	<expr_stmt><expr><name>role_oids</name> <operator>=</operator> <call><name>policy_role_list_to_array</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>role_ids</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>role_oids</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse the supplied clause */</comment>
	<expr_stmt><expr><name>qual_pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>with_check_pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* zero-clear */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get id of table.  Also handles permissions checks. */</comment>
	<expr_stmt><expr><name>table_id</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>RangeVarCallbackForPolicy</name></expr></argument>,
										<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open target_table to build quals. No additional lock is necessary. */</comment>
	<expr_stmt><expr><name>target_table</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>table_id</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add for the regular security quals */</comment>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><name>target_table</name></expr></argument>,
										   <argument><expr><name>AccessShareLock</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add for the with-check quals */</comment>
	<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>, <argument><expr><name>target_table</name></expr></argument>,
										   <argument><expr><name>AccessShareLock</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>,
								<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>EXPR_KIND_POLICY</name></expr></argument>,
								<argument><expr><literal type="string">"POLICY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>with_check_qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>,
										   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>with_check</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>EXPR_KIND_POLICY</name></expr></argument>,
										   <argument><expr><literal type="string">"POLICY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fix up collation information */</comment>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>, <argument><expr><name>with_check_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open pg_policy catalog */</comment>
	<expr_stmt><expr><name>pg_policy_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set key - policy's relation id. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set key - policy's name. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>,
							   <argument><expr><name>PolicyPolrelidPolnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							   <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>policy_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Complain if the policy name already exists for the table */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"policy \"%s\" for table \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>policy_id</name> <operator>=</operator> <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>PolicyOidIndexId</name></expr></argument>,
								   <argument><expr><name>Anum_pg_policy_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_oid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>policy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>,
															 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polcmd</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>polcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polpermissive</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>permissive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polroles</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>role_ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add qual if present. */</comment>
	<if_stmt><if>if <condition>(<expr><name>qual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polqual</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_policy_polqual</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Add WITH CHECK qual if present */</comment>
	<if_stmt><if>if <condition>(<expr><name>with_check_qual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polwithcheck</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>with_check_qual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_policy_polwithcheck</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>policy_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
								   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Record Dependencies */</comment>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>table_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>PolicyRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>policy_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOnExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name><name>qual_pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>,
						   <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOnExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>with_check_qual</name></expr></argument>,
						   <argument><expr><name><name>with_check_pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Register role dependencies */</comment>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AuthIdRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>role_oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* no dependency if public */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>objectId</name></name> <operator>!=</operator> <name>ACL_ID_PUBLIC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordSharedDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>,
									 <argument><expr><name>SHARED_DEPENDENCY_POLICY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>policy_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Invalidate Relation Cache */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterPolicy -
 *	 handles the execution of the ALTER POLICY command.
 *
 * stmt - the AlterPolicyStmt that describes the policy and how to alter it.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterPolicy</name><parameter_list>(<parameter><decl><type><name>AlterPolicyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_policy_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>policy_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>target_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>table_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>role_oids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>role_ids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qual_parse_rtable</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>with_check_parse_rtable</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>with_check_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>policy_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_policy</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>Natts_pg_policy</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_policy</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>polcmd_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>polcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>polcmd_isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Parse role_ids */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>role_oids</name> <operator>=</operator> <call><name>policy_role_list_to_array</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>role_ids</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>role_oids</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>TYPALIGN_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get id of table.  Also handles permissions checks. */</comment>
	<expr_stmt><expr><name>table_id</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>RangeVarCallbackForPolicy</name></expr></argument>,
										<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>target_table</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>table_id</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse the using policy clause */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>qual_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><name>target_table</name></expr></argument>,
											   <argument><expr><name>AccessShareLock</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>EXPR_KIND_POLICY</name></expr></argument>,
									<argument><expr><literal type="string">"POLICY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fix up collation information */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>qual_parse_rtable</name> <operator>=</operator> <name><name>qual_pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Parse the with-check policy clause */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>with_check</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>with_check_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>, <argument><expr><name>target_table</name></expr></argument>,
											   <argument><expr><name>AccessShareLock</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>with_check_qual</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>,
											   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>with_check</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>EXPR_KIND_POLICY</name></expr></argument>,
											   <argument><expr><literal type="string">"POLICY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fix up collation information */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>, <argument><expr><name>with_check_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>with_check_parse_rtable</name> <operator>=</operator> <name><name>with_check_pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* zero-clear */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find policy to update. */</comment>
	<expr_stmt><expr><name>pg_policy_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set key - policy's relation id. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set key - policy's name. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>,
							   <argument><expr><name>PolicyPolrelidPolnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							   <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>policy_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that the policy is found, raise an error if not. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"policy \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get policy command */</comment>
	<expr_stmt><expr><name>polcmd_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>, <argument><expr><name>Anum_pg_policy_polcmd</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>polcmd_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>polcmd_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polcmd</name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>polcmd_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the command is SELECT or DELETE then WITH CHECK should be NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>polcmd</name> <operator>==</operator> <name>ACL_SELECT_CHR</name> <operator>||</operator> <name>polcmd</name> <operator>==</operator> <name>ACL_DELETE_CHR</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>with_check</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only USING expression allowed for SELECT, DELETE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the command is INSERT then WITH CHECK should be the only expression
	 * provided.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>polcmd</name> <operator>==</operator> <name>ACL_INSERT_CHR</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>qual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only WITH CHECK expression allowed for INSERT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>policy_id</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_policy</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>role_ids</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_policy_polroles</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polroles</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>role_ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>roles</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>roles_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>attr_isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>policy_roles</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We need to pull the set of roles this policy applies to from what's
		 * in the catalog, so that we can recreate the dependencies correctly
		 * for the policy.
		 */</comment>

		<expr_stmt><expr><name>roles_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>, <argument><expr><name>Anum_pg_policy_polroles</name></expr></argument>,
								   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>policy_roles</name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>roles_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>roles</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>policy_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>policy_roles</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>

		<expr_stmt><expr><name>role_oids</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>role_oids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>roles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_policy_polqual</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polqual</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
			<operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>attr_isnull</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We need to pull the USING expression and build the range table for
		 * the policy from what's in the catalog, so that we can recreate the
		 * dependencies correctly for the policy.
		 */</comment>

		<comment type="block">/* Check if the policy has a USING expr */</comment>
		<expr_stmt><expr><name>value_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>, <argument><expr><name>Anum_pg_policy_polqual</name></expr></argument>,
								   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attr_isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qual_value</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>qual_pstate</name></decl>;</decl_stmt>

			<comment type="block">/* parsestate is built just to build the range table */</comment>
			<expr_stmt><expr><name>qual_pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>qual_value</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>value_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>qual_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add this rel to the parsestate's rangetable, for dependencies */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><name>target_table</name></expr></argument>,
												 <argument><expr><name>AccessShareLock</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>qual_parse_rtable</name> <operator>=</operator> <name><name>qual_pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>with_check_qual</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_policy_polwithcheck</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_policy_polwithcheck</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
			<operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>with_check_qual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>attr_isnull</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We need to pull the WITH CHECK expression and build the range table
		 * for the policy from what's in the catalog, so that we can recreate
		 * the dependencies correctly for the policy.
		 */</comment>

		<comment type="block">/* Check if the policy has a WITH CHECK expr */</comment>
		<expr_stmt><expr><name>value_datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>, <argument><expr><name>Anum_pg_policy_polwithcheck</name></expr></argument>,
								   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>attr_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attr_isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>with_check_value</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>with_check_pstate</name></decl>;</decl_stmt>

			<comment type="block">/* parsestate is built just to build the range table */</comment>
			<expr_stmt><expr><name>with_check_pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>with_check_value</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>value_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>with_check_qual</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>with_check_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add this rel to the parsestate's rangetable, for dependencies */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>,
												 <argument><expr><name>target_table</name></expr></argument>,
												 <argument><expr><name>AccessShareLock</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>with_check_parse_rtable</name> <operator>=</operator> <name><name>with_check_pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>,
								  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>new_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update Dependencies. */</comment>
	<expr_stmt><expr><call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>policy_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Record Dependencies */</comment>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>table_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>PolicyRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>policy_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOnExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>qual_parse_rtable</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOnExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>with_check_qual</name></expr></argument>, <argument><expr><name>with_check_parse_rtable</name></expr></argument>,
						   <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Register role dependencies */</comment>
	<expr_stmt><expr><call><name>deleteSharedDependencyRecordsFor</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>policy_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AuthIdRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>target</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>role_oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* no dependency if public */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>objectId</name></name> <operator>!=</operator> <name>ACL_ID_PUBLIC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordSharedDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>,
									 <argument><expr><name>SHARED_DEPENDENCY_POLICY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>policy_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Invalidate Relation Cache */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * rename_policy -
 *	 change the name of a policy on a relation
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>rename_policy</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_policy_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>target_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>table_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opoloid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>policy_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Get id of table.  Also handles permissions checks. */</comment>
	<expr_stmt><expr><name>table_id</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>RangeVarCallbackForPolicy</name></expr></argument>,
										<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>target_table</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>table_id</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_policy_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First pass -- check for conflict */</comment>

	<comment type="block">/* Add key - policy's relation id. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add key - policy's name. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>,
							   <argument><expr><name>PolicyPolrelidPolnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							   <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"policy \"%s\" for table \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Second pass -- find existing policy and update */</comment>
	<comment type="block">/* Add key - policy's relation id. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add key - policy's name. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>,
							   <argument><expr><name>PolicyPolrelidPolnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							   <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>policy_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Complain if we did not find the policy */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"policy \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>opoloid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_policy</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>policy_tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>Form_pg_policy</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>polname</name></expr></argument>,
			   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>policy_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>opoloid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>opoloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invalidate relation's relcache entry so that other backends (and this
	 * one too!) are sent SI message to make them rebuild relcache entries.
	 * (Ideally this should happen automatically...)
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_relation_policy_oid - Look up a policy by name to find its OID
 *
 * If missing_ok is false, throw an error if policy not found.  If
 * true, just return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_relation_policy_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>policy_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_policy_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>policy_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>policy_oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_policy_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add key - policy's relation id. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add key - policy's name. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>policy_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>,
							   <argument><expr><name>PolicyPolrelidPolnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
							   <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>policy_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"policy \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>policy_name</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>policy_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>policy_oid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_policy</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_policy_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>policy_oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * relation_has_policies - Determine if relation has any policies
 */</comment>
<function><type><name>bool</name></type>
<name>relation_has_policies</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>policy_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PolicyRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_policy_polrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>PolicyPolrelidPolnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>policy_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>policy_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
</unit>
