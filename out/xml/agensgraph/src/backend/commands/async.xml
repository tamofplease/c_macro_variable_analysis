<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/commands/async.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * async.c
 *	  Asynchronous notification: NOTIFY, LISTEN, UNLISTEN
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/commands/async.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*-------------------------------------------------------------------------
 * Async Notification Model as of 9.0:
 *
 * 1. Multiple backends on same machine. Multiple backends listening on
 *	  several channels. (Channels are also called "conditions" in other
 *	  parts of the code.)
 *
 * 2. There is one central queue in disk-based storage (directory pg_notify/),
 *	  with actively-used pages mapped into shared memory by the slru.c module.
 *	  All notification messages are placed in the queue and later read out
 *	  by listening backends.
 *
 *	  There is no central knowledge of which backend listens on which channel;
 *	  every backend has its own list of interesting channels.
 *
 *	  Although there is only one queue, notifications are treated as being
 *	  database-local; this is done by including the sender's database OID
 *	  in each notification message.  Listening backends ignore messages
 *	  that don't match their database OID.  This is important because it
 *	  ensures senders and receivers have the same database encoding and won't
 *	  misinterpret non-ASCII text in the channel name or payload string.
 *
 *	  Since notifications are not expected to survive database crashes,
 *	  we can simply clean out the pg_notify data at any reboot, and there
 *	  is no need for WAL support or fsync'ing.
 *
 * 3. Every backend that is listening on at least one channel registers by
 *	  entering its PID into the array in AsyncQueueControl. It then scans all
 *	  incoming notifications in the central queue and first compares the
 *	  database OID of the notification with its own database OID and then
 *	  compares the notified channel with the list of channels that it listens
 *	  to. In case there is a match it delivers the notification event to its
 *	  frontend.  Non-matching events are simply skipped.
 *
 * 4. The NOTIFY statement (routine Async_Notify) stores the notification in
 *	  a backend-local list which will not be processed until transaction end.
 *
 *	  Duplicate notifications from the same transaction are sent out as one
 *	  notification only. This is done to save work when for example a trigger
 *	  on a 2 million row table fires a notification for each row that has been
 *	  changed. If the application needs to receive every single notification
 *	  that has been sent, it can easily add some unique string into the extra
 *	  payload parameter.
 *
 *	  When the transaction is ready to commit, PreCommit_Notify() adds the
 *	  pending notifications to the head of the queue. The head pointer of the
 *	  queue always points to the next free position and a position is just a
 *	  page number and the offset in that page. This is done before marking the
 *	  transaction as committed in clog. If we run into problems writing the
 *	  notifications, we can still call elog(ERROR, ...) and the transaction
 *	  will roll back.
 *
 *	  Once we have put all of the notifications into the queue, we return to
 *	  CommitTransaction() which will then do the actual transaction commit.
 *
 *	  After commit we are called another time (AtCommit_Notify()). Here we
 *	  make any actual updates to the effective listen state (listenChannels).
 *	  Then we signal any backends that may be interested in our messages
 *	  (including our own backend, if listening).  This is done by
 *	  SignalBackends(), which scans the list of listening backends and sends a
 *	  PROCSIG_NOTIFY_INTERRUPT signal to every listening backend (we don't
 *	  know which backend is listening on which channel so we must signal them
 *	  all).  We can exclude backends that are already up to date, though, and
 *	  we can also exclude backends that are in other databases (unless they
 *	  are way behind and should be kicked to make them advance their
 *	  pointers).
 *
 *	  Finally, after we are out of the transaction altogether and about to go
 *	  idle, we scan the queue for messages that need to be sent to our
 *	  frontend (which might be notifies from other backends, or self-notifies
 *	  from our own).  This step is not part of the CommitTransaction sequence
 *	  for two important reasons.  First, we could get errors while sending
 *	  data to our frontend, and it's really bad for errors to happen in
 *	  post-commit cleanup.  Second, in cases where a procedure issues commits
 *	  within a single frontend command, we don't want to send notifies to our
 *	  frontend until the command is done; but notifies to other backends
 *	  should go out immediately after each commit.
 *
 * 5. Upon receipt of a PROCSIG_NOTIFY_INTERRUPT signal, the signal handler
 *	  sets the process's latch, which triggers the event to be processed
 *	  immediately if this backend is idle (i.e., it is waiting for a frontend
 *	  command and is not within a transaction block. C.f.
 *	  ProcessClientReadInterrupt()).  Otherwise the handler may only set a
 *	  flag, which will cause the processing to occur just before we next go
 *	  idle.
 *
 *	  Inbound-notify processing consists of reading all of the notifications
 *	  that have arrived since scanning last time. We read every notification
 *	  until we reach either a notification from an uncommitted transaction or
 *	  the head pointer's position.
 *
 * 6. To avoid SLRU wraparound and limit disk space consumption, the tail
 *	  pointer needs to be advanced so that old pages can be truncated.
 *	  This is relatively expensive (notably, it requires an exclusive lock),
 *	  so we don't want to do it often.  We make sending backends do this work
 *	  if they advanced the queue head into a new page, but only once every
 *	  QUEUE_CLEANUP_DELAY pages.
 *
 * An application that listens on the same channel it notifies will get
 * NOTIFY messages for its own NOTIFYs.  These can be ignored, if not useful,
 * by comparing be_pid in the NOTIFY message to the application's own backend's
 * PID.  (As of FE/BE protocol 2.0, the backend's PID is provided to the
 * frontend during startup.)  The above design guarantees that notifies from
 * other backends will never be missed by ignoring self-notifies.
 *
 * The amount of shared memory used for notify management (NUM_NOTIFY_BUFFERS)
 * can be varied without affecting anything but performance.  The maximum
 * amount of notification data that can be queued at one time is determined
 * by slru.c's wraparound limit; see QUEUE_MAX_PAGE below.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/slru.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Maximum size of a NOTIFY payload, including terminating NULL.  This
 * must be kept small enough so that a notification message fits on one
 * SLRU page.  The magic fudge factor here is noncritical as long as it's
 * more than AsyncQueueEntryEmptySize --- we make it significantly bigger
 * than that, so changes in that data structure won't affect user-visible
 * restrictions.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOTIFY_PAYLOAD_MAX_LENGTH</name></cpp:macro>	<cpp:value>(BLCKSZ - NAMEDATALEN - 128)</cpp:value></cpp:define>

<comment type="block">/*
 * Struct representing an entry in the global notify queue
 *
 * This struct declaration has the maximal length, but in a real queue entry
 * the data area is only big enough for the actual channel and payload strings
 * (each null-terminated).  AsyncQueueEntryEmptySize is the minimum possible
 * entry size, if both channel and payload strings are empty (but note it
 * doesn't include alignment padding).
 *
 * The "length" field should always be rounded up to the next QUEUEALIGN
 * multiple so that all fields are properly aligned.
 */</comment>
<typedef>typedef <type><struct>struct <name>AsyncQueueEntry</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>length</name></decl>;</decl_stmt>			<comment type="block">/* total allocated length of entry */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dboid</name></decl>;</decl_stmt>			<comment type="block">/* sender's database OID */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>			<comment type="block">/* sender's XID */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>srcPid</name></decl>;</decl_stmt>			<comment type="block">/* sender's PID */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>data</name><index>[<expr><name>NAMEDATALEN</name> <operator>+</operator> <name>NOTIFY_PAYLOAD_MAX_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>AsyncQueueEntry</name>;</typedef>

<comment type="block">/* Currently, no field of AsyncQueueEntry requires more than int alignment */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUEALIGN</name><parameter_list>(<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>INTALIGN(len)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AsyncQueueEntryEmptySize</name></cpp:macro>	<cpp:value>(offsetof(AsyncQueueEntry, data) + 2)</cpp:value></cpp:define>

<comment type="block">/*
 * Struct describing a queue position, and assorted macros for working with it
 */</comment>
<typedef>typedef <type><struct>struct <name>QueuePosition</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>page</name></decl>;</decl_stmt>			<comment type="block">/* SLRU page number */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>			<comment type="block">/* byte offset within page */</comment>
}</block></struct></type> <name>QueuePosition</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_POS_PAGE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((x).page)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_POS_OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((x).offset)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_QUEUE_POS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		(x).page = (y); \
		(x).offset = (z); \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_POS_EQUAL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((x).page == (y).page &amp;&amp; (x).offset == (y).offset)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_POS_IS_ZERO</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((x).page == 0 &amp;&amp; (x).offset == 0)</cpp:value></cpp:define>

<comment type="block">/* choose logically smaller QueuePosition */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_POS_MIN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(asyncQueuePagePrecedes((x).page, (y).page) ? (x) : \
	 (x).page != (y).page ? (y) : \
	 (x).offset &lt; (y).offset ? (x) : (y))</cpp:value></cpp:define>

<comment type="block">/* choose logically larger QueuePosition */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_POS_MAX</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(asyncQueuePagePrecedes((x).page, (y).page) ? (y) : \
	 (x).page != (y).page ? (x) : \
	 (x).offset &gt; (y).offset ? (x) : (y))</cpp:value></cpp:define>

<comment type="block">/*
 * Parameter determining how often we try to advance the tail pointer:
 * we do that after every QUEUE_CLEANUP_DELAY pages of NOTIFY data.  This is
 * also the distance by which a backend in another database needs to be
 * behind before we'll decide we need to wake it up to advance its pointer.
 *
 * Resist the temptation to make this really large.  While that would save
 * work in some places, it would add cost in others.  In particular, this
 * should likely be less than NUM_NOTIFY_BUFFERS, to ensure that backends
 * catch up before the pages they'll need to read fall out of SLRU cache.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_CLEANUP_DELAY</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*
 * Struct describing a listening backend's status
 */</comment>
<typedef>typedef <type><struct>struct <name>QueueBackendStatus</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type>		<name>pid</name></decl>;</decl_stmt>			<comment type="block">/* either a PID or InvalidPid */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dboid</name></decl>;</decl_stmt>			<comment type="block">/* backend's database OID, or InvalidOid */</comment>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>nextListener</name></decl>;</decl_stmt>	<comment type="block">/* id of next listener, or InvalidBackendId */</comment>
	<decl_stmt><decl><type><name>QueuePosition</name></type> <name>pos</name></decl>;</decl_stmt>			<comment type="block">/* backend has read queue up to here */</comment>
}</block></struct></type> <name>QueueBackendStatus</name>;</typedef>

<comment type="block">/*
 * Shared memory state for LISTEN/NOTIFY (excluding its SLRU stuff)
 *
 * The AsyncQueueControl structure is protected by the NotifyQueueLock and
 * NotifyQueueTailLock.
 *
 * When holding NotifyQueueLock in SHARED mode, backends may only inspect
 * their own entries as well as the head and tail pointers. Consequently we
 * can allow a backend to update its own record while holding only SHARED lock
 * (since no other backend will inspect it).
 *
 * When holding NotifyQueueLock in EXCLUSIVE mode, backends can inspect the
 * entries of other backends and also change the head pointer. When holding
 * both NotifyQueueLock and NotifyQueueTailLock in EXCLUSIVE mode, backends
 * can change the tail pointers.
 *
 * NotifySLRULock is used as the control lock for the pg_notify SLRU buffers.
 * In order to avoid deadlocks, whenever we need multiple locks, we first get
 * NotifyQueueTailLock, then NotifyQueueLock, and lastly NotifySLRULock.
 *
 * Each backend uses the backend[] array entry with index equal to its
 * BackendId (which can range from 1 to MaxBackends).  We rely on this to make
 * SendProcSignal fast.
 *
 * The backend[] array entries for actively-listening backends are threaded
 * together using firstListener and the nextListener links, so that we can
 * scan them without having to iterate over inactive entries.  We keep this
 * list in order by BackendId so that the scan is cache-friendly when there
 * are many active entries.
 */</comment>
<typedef>typedef <type><struct>struct <name>AsyncQueueControl</name>
<block>{
	<decl_stmt><decl><type><name>QueuePosition</name></type> <name>head</name></decl>;</decl_stmt>			<comment type="block">/* head points to the next free location */</comment>
	<decl_stmt><decl><type><name>QueuePosition</name></type> <name>tail</name></decl>;</decl_stmt>			<comment type="block">/* tail must be &lt;= the queue position of every
								 * listening backend */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>stopPage</name></decl>;</decl_stmt>		<comment type="block">/* oldest unrecycled page; must be &lt;=
								 * tail.page */</comment>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>firstListener</name></decl>;</decl_stmt>	<comment type="block">/* id of first listener, or InvalidBackendId */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>lastQueueFillWarn</name></decl>;</decl_stmt>	<comment type="block">/* time of last queue-full msg */</comment>
	<decl_stmt><decl><type><name>QueueBackendStatus</name></type> <name><name>backend</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* backend[0] is not used; used entries are from [1] to [MaxBackends] */</comment>
}</block></struct></type> <name>AsyncQueueControl</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>AsyncQueueControl</name> <modifier>*</modifier></type><name>asyncQueueControl</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_HEAD</name></cpp:macro>					<cpp:value>(asyncQueueControl-&gt;head)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_TAIL</name></cpp:macro>					<cpp:value>(asyncQueueControl-&gt;tail)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_STOP_PAGE</name></cpp:macro>				<cpp:value>(asyncQueueControl-&gt;stopPage)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_FIRST_LISTENER</name></cpp:macro>		<cpp:value>(asyncQueueControl-&gt;firstListener)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_BACKEND_PID</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(asyncQueueControl-&gt;backend[i].pid)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_BACKEND_DBOID</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(asyncQueueControl-&gt;backend[i].dboid)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_NEXT_LISTENER</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(asyncQueueControl-&gt;backend[i].nextListener)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_BACKEND_POS</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(asyncQueueControl-&gt;backend[i].pos)</cpp:value></cpp:define>

<comment type="block">/*
 * The SLRU buffer area through which we access the notification queue
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SlruCtlData</name></type> <name>NotifyCtlData</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NotifyCtl</name></cpp:macro>					<cpp:value>(&amp;NotifyCtlData)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_PAGESIZE</name></cpp:macro>				<cpp:value>BLCKSZ</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_FULL_WARN_INTERVAL</name></cpp:macro>	<cpp:value>5000</cpp:value></cpp:define>	<comment type="block">/* warn at most once every 5s */</comment>

<comment type="block">/*
 * slru.c currently assumes that all filenames are four characters of hex
 * digits. That means that we can use segments 0000 through FFFF.
 * Each segment contains SLRU_PAGES_PER_SEGMENT pages which gives us
 * the pages from 0 to SLRU_PAGES_PER_SEGMENT * 0x10000 - 1.
 *
 * It's of course possible to enhance slru.c, but this gives us so much
 * space already that it doesn't seem worth the trouble.
 *
 * The most data we can have in the queue at a time is QUEUE_MAX_PAGE/2
 * pages, because more than that would confuse slru.c into thinking there
 * was a wraparound condition.  With the default BLCKSZ this means there
 * can be up to 8GB of queued-and-not-read data.
 *
 * Note: it's possible to redefine QUEUE_MAX_PAGE with a smaller multiple of
 * SLRU_PAGES_PER_SEGMENT, for easier testing of queue-full behaviour.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_MAX_PAGE</name></cpp:macro>			<cpp:value>(SLRU_PAGES_PER_SEGMENT * 0x10000 - 1)</cpp:value></cpp:define>

<comment type="block">/*
 * listenChannels identifies the channels we are actually listening to
 * (ie, have committed a LISTEN on).  It is a simple list of channel names,
 * allocated in TopMemoryContext.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>listenChannels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* list of C strings */</comment>

<comment type="block">/*
 * State for pending LISTEN/UNLISTEN actions consists of an ordered list of
 * all actions requested in the current transaction.  As explained above,
 * we don't actually change listenChannels until we reach transaction commit.
 *
 * The list is kept in CurTransactionContext.  In subtransactions, each
 * subtransaction has its own list in its own CurTransactionContext, but
 * successful subtransactions attach their lists to their parent's list.
 * Failed subtransactions simply discard their lists.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>LISTEN_LISTEN</name></decl>,
	<decl><name>LISTEN_UNLISTEN</name></decl>,
	<decl><name>LISTEN_UNLISTEN_ALL</name></decl>
}</block></enum></type> <name>ListenActionKind</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ListenActionKind</name></type> <name>action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>channel</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* nul-terminated string */</comment>
}</block></struct></type> <name>ListenAction</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ActionList</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nestingLevel</name></decl>;</decl_stmt>	<comment type="block">/* current transaction nesting depth */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>actions</name></decl>;</decl_stmt>		<comment type="block">/* list of ListenAction structs */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>ActionList</name></name> <modifier>*</modifier></type><name>upper</name></decl>;</decl_stmt>	<comment type="block">/* details for upper transaction levels */</comment>
}</block></struct></type> <name>ActionList</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ActionList</name> <modifier>*</modifier></type><name>pendingActions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * State for outbound notifies consists of a list of all channels+payloads
 * NOTIFYed in the current transaction.  We do not actually perform a NOTIFY
 * until and unless the transaction commits.  pendingNotifies is NULL if no
 * NOTIFYs have been done in the current (sub) transaction.
 *
 * We discard duplicate notify events issued in the same transaction.
 * Hence, in addition to the list proper (which we need to track the order
 * of the events, since we guarantee to deliver them in order), we build a
 * hash table which we can probe to detect duplicates.  Since building the
 * hash table is somewhat expensive, we do so only once we have at least
 * MIN_HASHABLE_NOTIFIES events queued in the current (sub) transaction;
 * before that we just scan the events linearly.
 *
 * The list is kept in CurTransactionContext.  In subtransactions, each
 * subtransaction has its own list in its own CurTransactionContext, but
 * successful subtransactions add their entries to their parent's list.
 * Failed subtransactions simply discard their lists.  Since these lists
 * are independent, there may be notify events in a subtransaction's list
 * that duplicate events in some ancestor (sub) transaction; we get rid of
 * the dups when merging the subtransaction's list into its parent's.
 *
 * Note: the action and notify lists do not interact within a transaction.
 * In particular, if a transaction does NOTIFY and then LISTEN on the same
 * condition name, it will get a self-notify at commit.  This is a bit odd
 * but is consistent with our historical behavior.
 */</comment>
<typedef>typedef <type><struct>struct <name>Notification</name>
<block>{
	<decl_stmt><decl><type><name>uint16</name></type>		<name>channel_len</name></decl>;</decl_stmt>	<comment type="block">/* length of channel-name string */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>payload_len</name></decl>;</decl_stmt>	<comment type="block">/* length of payload string */</comment>
	<comment type="block">/* null-terminated channel name, then null-terminated payload follow */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>data</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>Notification</name>;</typedef>

<typedef>typedef <type><struct>struct <name>NotificationList</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nestingLevel</name></decl>;</decl_stmt>	<comment type="block">/* current transaction nesting depth */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>events</name></decl>;</decl_stmt>			<comment type="block">/* list of Notification structs */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>hashtab</name></decl>;</decl_stmt>		<comment type="block">/* hash of NotificationHash structs, or NULL */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>NotificationList</name></name> <modifier>*</modifier></type><name>upper</name></decl>;</decl_stmt> <comment type="block">/* details for upper transaction levels */</comment>
}</block></struct></type> <name>NotificationList</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_HASHABLE_NOTIFIES</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>	<comment type="block">/* threshold to build hashtab */</comment>

<typedef>typedef <type><struct>struct <name>NotificationHash</name>
<block>{
	<decl_stmt><decl><type><name>Notification</name> <modifier>*</modifier></type><name>event</name></decl>;</decl_stmt>		<comment type="block">/* =&gt; the actual Notification struct */</comment>
}</block></struct></type> <name>NotificationHash</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>NotificationList</name> <modifier>*</modifier></type><name>pendingNotifies</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Inbound notifications are initially processed by HandleNotifyInterrupt(),
 * called from inside a signal handler. That just sets the
 * notifyInterruptPending flag and sets the process
 * latch. ProcessNotifyInterrupt() will then be called whenever it's safe to
 * actually deal with the interrupt.
 */</comment>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>notifyInterruptPending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* True if we've registered an on_shmem_exit cleanup */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>unlistenExitRegistered</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* True if we're currently registered as a listener in asyncQueueControl */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>amRegisteredListener</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* have we advanced to a page that's a multiple of QUEUE_CLEANUP_DELAY? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>tryAdvanceTail</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* GUC parameter */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>Trace_notify</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>asyncQueuePageDiff</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>asyncQueuePagePrecedes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>queue_listen</name><parameter_list>(<parameter><decl><type><name>ListenActionKind</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Async_UnlistenOnExit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Exec_ListenPreCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Exec_ListenCommit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Exec_UnlistenCommit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Exec_UnlistenAllCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsListeningOn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asyncQueueUnregister</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>asyncQueueIsFull</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>asyncQueueAdvance</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>QueuePosition</name> <modifier>*</modifier></type><name>position</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>entryLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asyncQueueNotificationToEntry</name><parameter_list>(<parameter><decl><type><name>Notification</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>AsyncQueueEntry</name> <modifier>*</modifier></type><name>qe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>asyncQueueAddEntries</name><parameter_list>(<parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>nextNotify</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>asyncQueueUsage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asyncQueueFillWarning</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SignalBackends</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asyncQueueReadAllNotifications</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>asyncQueueProcessPageEntries</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>QueuePosition</name> <modifier>*</modifier></type><name>current</name></decl></parameter>,
										 <parameter><decl><type><name>QueuePosition</name></type> <name>stop</name></decl></parameter>,
										 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>page_buffer</name></decl></parameter>,
										 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asyncQueueAdvanceTail</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessIncomingNotify</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>flush</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AsyncExistsPendingNotify</name><parameter_list>(<parameter><decl><type><name>Notification</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddEventToPendingNotifies</name><parameter_list>(<parameter><decl><type><name>Notification</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>notification_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>notification_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ClearPendingActionsAndNotifies</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Compute the difference between two queue page numbers (i.e., p - q),
 * accounting for wraparound.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>asyncQueuePageDiff</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>diff</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We have to compare modulo (QUEUE_MAX_PAGE+1)/2.  Both inputs should be
	 * in the range 0..QUEUE_MAX_PAGE.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>p</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;=</operator> <name>QUEUE_MAX_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>q</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>q</name> <operator>&lt;=</operator> <name>QUEUE_MAX_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>q</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;=</operator> <operator>(</operator><operator>(</operator><name>QUEUE_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>diff</name> <operator>-=</operator> <name>QUEUE_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>diff</name> <operator>&lt;</operator> <operator>-</operator><operator>(</operator><operator>(</operator><name>QUEUE_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>diff</name> <operator>+=</operator> <name>QUEUE_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>diff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is p &lt; q, accounting for wraparound?
 *
 * Since asyncQueueIsFull() blocks creation of a page that could precede any
 * extant page, we need not assess entries within a page.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>asyncQueuePagePrecedes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>asyncQueuePageDiff</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Report space needed for our shared memory area
 */</comment>
<function><type><name>Size</name></type>
<name>AsyncShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* This had better match AsyncShmemInit */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueueBackendStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>AsyncQueueControl</name></expr></argument>, <argument><expr><name>backend</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>SimpleLruShmemSize</name><argument_list>(<argument><expr><name>NUM_NOTIFY_BUFFERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize our shared memory area
 */</comment>
<function><type><name>void</name></type>
<name>AsyncShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create or attach to the AsyncQueueControl structure.
	 *
	 * The used entries in the backend[] array run from 1 to MaxBackends; the
	 * zero'th entry is unused but must be allocated.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueueBackendStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>AsyncQueueControl</name></expr></argument>, <argument><expr><name>backend</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>asyncQueueControl</name> <operator>=</operator> <operator>(</operator><name>AsyncQueueControl</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Async Queue Control"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, so initialize it */</comment>
		<expr_stmt><expr><call><name>SET_QUEUE_POS</name><argument_list>(<argument><expr><name>QUEUE_HEAD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_QUEUE_POS</name><argument_list>(<argument><expr><name>QUEUE_TAIL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>QUEUE_STOP_PAGE</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>QUEUE_FIRST_LISTENER</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>asyncQueueControl</name><operator>-&gt;</operator><name>lastQueueFillWarn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* zero'th entry won't be used, but let's initialize it anyway */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>QUEUE_BACKEND_PID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>QUEUE_BACKEND_DBOID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_QUEUE_POS</name><argument_list>(<argument><expr><call><name>QUEUE_BACKEND_POS</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up SLRU management of the pg_notify data.
	 */</comment>
	<expr_stmt><expr><name><name>NotifyCtl</name><operator>-&gt;</operator><name>PagePrecedes</name></name> <operator>=</operator> <name>asyncQueuePagePrecedes</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SimpleLruInit</name><argument_list>(<argument><expr><name>NotifyCtl</name></expr></argument>, <argument><expr><literal type="string">"Notify"</literal></expr></argument>, <argument><expr><name>NUM_NOTIFY_BUFFERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				  <argument><expr><name>NotifySLRULock</name></expr></argument>, <argument><expr><literal type="string">"pg_notify"</literal></expr></argument>, <argument><expr><name>LWTRANCHE_NOTIFY_BUFFER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Override default assumption that writes should be fsync'd */</comment>
	<expr_stmt><expr><name><name>NotifyCtl</name><operator>-&gt;</operator><name>do_fsync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * During start or reboot, clean out the pg_notify directory.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SlruScanDirectory</name><argument_list>(<argument><expr><name>NotifyCtl</name></expr></argument>, <argument><expr><name>SlruScanDirCbDeleteAll</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_notify -
 *	  SQL function to send a notification event
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_notify</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>payload</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>channel</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>channel</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>payload</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>payload</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* For NOTIFY as a statement, this is checked in ProcessUtility */</comment>
	<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"NOTIFY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Async_Notify</name><argument_list>(<argument><expr><name>channel</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Async_Notify
 *
 *		This is executed by the SQL notify command.
 *
 *		Adds the message to the list of pending notifies.
 *		Actual notification happens during transaction commit.
 *		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 */</comment>
<function><type><name>void</name></type>
<name>Async_Notify</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>payload</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>channel_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>payload_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Notification</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot send notifications from a parallel worker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Async_Notify(%s)"</literal></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>channel_len</name> <operator>=</operator> <ternary><condition><expr><name>channel</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>payload_len</name> <operator>=</operator> <ternary><condition><expr><name>payload</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* a channel name must be specified */</comment>
	<if_stmt><if>if <condition>(<expr><name>channel_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"channel name cannot be empty"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* enforce length limits */</comment>
	<if_stmt><if>if <condition>(<expr><name>channel_len</name> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"channel name too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>payload_len</name> <operator>&gt;=</operator> <name>NOTIFY_PAYLOAD_MAX_LENGTH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"payload string too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must construct the Notification entry, even if we end up not using
	 * it, in order to compare it cheaply to existing list entries.
	 *
	 * The notification list needs to live until end of transaction, so store
	 * it in the transaction context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>Notification</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>Notification</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>+</operator>
								<name>channel_len</name> <operator>+</operator> <name>payload_len</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>channel_len</name></name> <operator>=</operator> <name>channel_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>payload_len</name></name> <operator>=</operator> <name>payload_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>payload</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>channel_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>channel_len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pendingNotifies</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>my_level</name> <operator>&gt;</operator> <name><name>pendingNotifies</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NotificationList</name> <modifier>*</modifier></type><name>notifies</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First notify event in current (sub)xact. Note that we allocate the
		 * NotificationList in TopTransactionContext; the nestingLevel might
		 * get changed later by AtSubCommit_Notify.
		 */</comment>
		<expr_stmt><expr><name>notifies</name> <operator>=</operator> <operator>(</operator><name>NotificationList</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NotificationList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>notifies</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>=</operator> <name>my_level</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>notifies</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We certainly don't need a hashtable yet */</comment>
		<expr_stmt><expr><name><name>notifies</name><operator>-&gt;</operator><name>hashtab</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>notifies</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <name>pendingNotifies</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pendingNotifies</name> <operator>=</operator> <name>notifies</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Now check for duplicates */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AsyncExistsPendingNotify</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* It's a dup, so forget it */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Append more events to existing list */</comment>
		<expr_stmt><expr><call><name>AddEventToPendingNotifies</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * queue_listen
 *		Common code for listen, unlisten, unlisten all commands.
 *
 *		Adds the request to the list of pending actions.
 *		Actual update of the listenChannels list happens during transaction
 *		commit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>queue_listen</name><parameter_list>(<parameter><decl><type><name>ListenActionKind</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListenAction</name> <modifier>*</modifier></type><name>actrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unlike Async_Notify, we don't try to collapse out duplicates. It would
	 * be too complicated to ensure we get the right interactions of
	 * conflicting LISTEN/UNLISTEN/UNLISTEN_ALL, and it's unlikely that there
	 * would be any performance benefit anyway in sane applications.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* space for terminating null is included in sizeof(ListenAction) */</comment>
	<expr_stmt><expr><name>actrec</name> <operator>=</operator> <operator>(</operator><name>ListenAction</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ListenAction</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call> <operator>+</operator>
									 <call><name>strlen</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>actrec</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>actrec</name><operator>-&gt;</operator><name>channel</name></name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pendingActions</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>my_level</name> <operator>&gt;</operator> <name><name>pendingActions</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ActionList</name> <modifier>*</modifier></type><name>actions</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First action in current sub(xact). Note that we allocate the
		 * ActionList in TopTransactionContext; the nestingLevel might get
		 * changed later by AtSubCommit_Notify.
		 */</comment>
		<expr_stmt><expr><name>actions</name> <operator>=</operator> <operator>(</operator><name>ActionList</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ActionList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>actions</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>=</operator> <name>my_level</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>actions</name><operator>-&gt;</operator><name>actions</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>actrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>actions</name><operator>-&gt;</operator><name>upper</name></name> <operator>=</operator> <name>pendingActions</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pendingActions</name> <operator>=</operator> <name>actions</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pendingActions</name><operator>-&gt;</operator><name>actions</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pendingActions</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>, <argument><expr><name>actrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Async_Listen
 *
 *		This is executed by the SQL listen command.
 */</comment>
<function><type><name>void</name></type>
<name>Async_Listen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Async_Listen(%s,%d)"</literal></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>queue_listen</name><argument_list>(<argument><expr><name>LISTEN_LISTEN</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Async_Unlisten
 *
 *		This is executed by the SQL unlisten command.
 */</comment>
<function><type><name>void</name></type>
<name>Async_Unlisten</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Async_Unlisten(%s,%d)"</literal></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If we couldn't possibly be listening, no need to queue anything */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingActions</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>unlistenExitRegistered</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>queue_listen</name><argument_list>(<argument><expr><name>LISTEN_UNLISTEN</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Async_UnlistenAll
 *
 *		This is invoked by UNLISTEN * command, and also at backend exit.
 */</comment>
<function><type><name>void</name></type>
<name>Async_UnlistenAll</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Async_UnlistenAll(%d)"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If we couldn't possibly be listening, no need to queue anything */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingActions</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>unlistenExitRegistered</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>queue_listen</name><argument_list>(<argument><expr><name>LISTEN_UNLISTEN_ALL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function: return a set of the channel names this backend is actively
 * listening to.
 *
 * Note: this coding relies on the fact that the listenChannels list cannot
 * change within a transaction.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_listening_channels</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>listenChannels</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>channel</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>listenChannels</name></expr></argument>,
												<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Async_UnlistenOnExit
 *
 * This is executed at backend exit if we have done any LISTENs in this
 * backend.  It might not be necessary anymore, if the user UNLISTENed
 * everything, but we don't try to detect that case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Async_UnlistenOnExit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Exec_UnlistenAllCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>asyncQueueUnregister</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtPrepare_Notify
 *
 *		This is called at the prepare phase of a two-phase
 *		transaction.  Save the state for possible commit later.
 */</comment>
<function><type><name>void</name></type>
<name>AtPrepare_Notify</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* It's not allowed to have any pending LISTEN/UNLISTEN/NOTIFY actions */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingActions</name> <operator>||</operator> <name>pendingNotifies</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE a transaction that has executed LISTEN, UNLISTEN, or NOTIFY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PreCommit_Notify
 *
 *		This is called at transaction commit, before actually committing to
 *		clog.
 *
 *		If there are pending LISTEN actions, make sure we are listed in the
 *		shared-memory listener array.  This must happen before commit to
 *		ensure we don't miss any notifies from transactions that commit
 *		just after ours.
 *
 *		If there are outbound notify requests in the pendingNotifies list,
 *		add them to the global queue.  We do that before commit so that
 *		we can still throw error if we run out of queue space.
 */</comment>
<function><type><name>void</name></type>
<name>PreCommit_Notify</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pendingActions</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pendingNotifies</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* no relevant statements in this xact */</comment>

	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PreCommit_Notify"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Preflight for any pending listen/unlisten actions */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingActions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>p</argument>, <argument>pendingActions-&gt;actions</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListenAction</name> <modifier>*</modifier></type><name>actrec</name> <init>= <expr><operator>(</operator><name>ListenAction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>actrec</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>LISTEN_LISTEN</name></expr>:</case>
					<expr_stmt><expr><call><name>Exec_ListenPreCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LISTEN_UNLISTEN</name></expr>:</case>
					<comment type="block">/* there is no Exec_UnlistenPreCommit() */</comment>
					<break>break;</break>
				<case>case <expr><name>LISTEN_UNLISTEN_ALL</name></expr>:</case>
					<comment type="block">/* there is no Exec_UnlistenAllPreCommit() */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Queue any pending notifies (must happen after the above) */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingNotifies</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nextNotify</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Make sure that we have an XID assigned to the current transaction.
		 * GetCurrentTransactionId is cheap if we already have an XID, but not
		 * so cheap if we don't, and we'd prefer not to do that work while
		 * holding NotifyQueueLock.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Serialize writers by acquiring a special lock that we hold till
		 * after commit.  This ensures that queue entries appear in commit
		 * order, and in particular that there are never uncommitted queue
		 * entries ahead of committed ones, so an uncommitted transaction
		 * can't block delivery of deliverable notifications.
		 *
		 * We use a heavyweight lock so that it'll automatically be released
		 * after either commit or abort.  This also allows deadlocks to be
		 * detected, though really a deadlock shouldn't be possible here.
		 *
		 * The lock is on "database 0", which is pretty ugly but it doesn't
		 * seem worth inventing a special locktag category just for this.
		 * (Historical note: before PG 9.0, a similar lock on "database 0" was
		 * used by the flatfiles mechanism.)
		 */</comment>
		<expr_stmt><expr><call><name>LockSharedObject</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now push the notifications into the queue */</comment>
		<expr_stmt><expr><name>nextNotify</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>nextNotify</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Add the pending notifications to the queue.  We acquire and
			 * release NotifyQueueLock once per page, which might be overkill
			 * but it does allow readers to get in while we're doing this.
			 *
			 * A full queue is very uncommon and should really not happen,
			 * given that we have so much space available in the SLRU pages.
			 * Nevertheless we need to deal with this possibility. Note that
			 * when we get here we are in the process of committing our
			 * transaction, but we have not yet committed to clog, so at this
			 * point in time we can still roll the transaction back.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>asyncQueueFillWarning</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>asyncQueueIsFull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many notifications in the NOTIFY queue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nextNotify</name> <operator>=</operator> <call><name>asyncQueueAddEntries</name><argument_list>(<argument><expr><name>nextNotify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* Note that we don't clear pendingNotifies; AtCommit_Notify will. */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtCommit_Notify
 *
 *		This is called at transaction commit, after committing to clog.
 *
 *		Update listenChannels and clear transaction-local state.
 *
 *		If we issued any notifications in the transaction, send signals to
 *		listening backends (possibly including ourselves) to process them.
 *		Also, if we filled enough queue pages with new notifies, try to
 *		advance the queue tail pointer.
 */</comment>
<function><type><name>void</name></type>
<name>AtCommit_Notify</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allow transactions that have not executed LISTEN/UNLISTEN/NOTIFY to
	 * return as soon as possible
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pendingActions</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pendingNotifies</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"AtCommit_Notify"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Perform any pending listen/unlisten actions */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingActions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>p</argument>, <argument>pendingActions-&gt;actions</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListenAction</name> <modifier>*</modifier></type><name>actrec</name> <init>= <expr><operator>(</operator><name>ListenAction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>actrec</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>LISTEN_LISTEN</name></expr>:</case>
					<expr_stmt><expr><call><name>Exec_ListenCommit</name><argument_list>(<argument><expr><name><name>actrec</name><operator>-&gt;</operator><name>channel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LISTEN_UNLISTEN</name></expr>:</case>
					<expr_stmt><expr><call><name>Exec_UnlistenCommit</name><argument_list>(<argument><expr><name><name>actrec</name><operator>-&gt;</operator><name>channel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LISTEN_UNLISTEN_ALL</name></expr>:</case>
					<expr_stmt><expr><call><name>Exec_UnlistenAllCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If no longer listening to anything, get out of listener array */</comment>
	<if_stmt><if>if <condition>(<expr><name>amRegisteredListener</name> <operator>&amp;&amp;</operator> <name>listenChannels</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>asyncQueueUnregister</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Send signals to listening backends.  We need do this only if there are
	 * pending notifies, which were previously added to the shared queue by
	 * PreCommit_Notify().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingNotifies</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SignalBackends</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's time to try to advance the global tail pointer, do that.
	 *
	 * (It might seem odd to do this in the sender, when more than likely the
	 * listeners won't yet have read the messages we just sent.  However,
	 * there's less contention if only the sender does it, and there is little
	 * need for urgency in advancing the global tail.  So this typically will
	 * be clearing out messages that were sent some time ago.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tryAdvanceTail</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tryAdvanceTail</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>asyncQueueAdvanceTail</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* And clean up */</comment>
	<expr_stmt><expr><call><name>ClearPendingActionsAndNotifies</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exec_ListenPreCommit --- subroutine for PreCommit_Notify
 *
 * This function must make sure we are ready to catch any incoming messages.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Exec_ListenPreCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueuePosition</name></type> <name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueuePosition</name></type> <name>max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>prevListener</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Nothing to do if we are already listening to something, nor if we
	 * already ran this routine in this transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>amRegisteredListener</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Exec_ListenPreCommit(%d)"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Before registering, make sure we will unlisten before dying. (Note:
	 * this action does not get undone if we abort later.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>unlistenExitRegistered</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>Async_UnlistenOnExit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>unlistenExitRegistered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This is our first LISTEN, so establish our pointer.
	 *
	 * We set our pointer to the global tail pointer and then move it forward
	 * over already-committed notifications.  This ensures we cannot miss any
	 * not-yet-committed notifications.  We might get a few more but that
	 * doesn't hurt.
	 *
	 * In some scenarios there might be a lot of committed notifications that
	 * have not yet been pruned away (because some backend is being lazy about
	 * reading them).  To reduce our startup time, we can look at other
	 * backends and adopt the maximum "pos" pointer of any backend that's in
	 * our database; any notifications it's already advanced over are surely
	 * committed and need not be re-examined by us.  (We must consider only
	 * backends connected to our DB, because others will not have bothered to
	 * check committed-ness of notifications in our DB.)
	 *
	 * We need exclusive lock here so we can look at other backends' entries
	 * and manipulate the list links.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>head</name> <operator>=</operator> <name>QUEUE_HEAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max</name> <operator>=</operator> <name>QUEUE_TAIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prevListener</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>BackendId</name></type> <name>i</name> <init>= <expr><name>QUEUE_FIRST_LISTENER</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>QUEUE_BACKEND_DBOID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MyDatabaseId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>QUEUE_POS_MAX</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><call><name>QUEUE_BACKEND_POS</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Also find last listening backend before this one */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>MyBackendId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prevListener</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>QUEUE_BACKEND_POS</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>max</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QUEUE_BACKEND_PID</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QUEUE_BACKEND_DBOID</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<comment type="block">/* Insert backend into list of listeners at correct position */</comment>
	<if_stmt><if>if <condition>(<expr><name>prevListener</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>prevListener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>prevListener</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>QUEUE_FIRST_LISTENER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>QUEUE_FIRST_LISTENER</name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we are listed in the global array, so remember we're listening */</comment>
	<expr_stmt><expr><name>amRegisteredListener</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to move our pointer forward as far as possible.  This will skip
	 * over already-committed notifications, which we want to do because they
	 * might be quite stale.  Note that we are not yet listening on anything,
	 * so we won't deliver such notifications to our frontend.  Also, although
	 * our transaction might have executed NOTIFY, those message(s) aren't
	 * queued yet so we won't skip them here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>QUEUE_POS_EQUAL</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>asyncQueueReadAllNotifications</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exec_ListenCommit --- subroutine for AtCommit_Notify
 *
 * Add the channel to the list of channels we are listening on.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Exec_ListenCommit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing if we are already listening on this channel */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsListeningOn</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add the new channel name to listenChannels.
	 *
	 * XXX It is theoretically possible to get an out-of-memory failure here,
	 * which would be bad because we already committed.  For the moment it
	 * doesn't seem worth trying to guard against that, but maybe improve this
	 * later.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>listenChannels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>listenChannels</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exec_UnlistenCommit --- subroutine for AtCommit_Notify
 *
 * Remove the specified channel name from listenChannels.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Exec_UnlistenCommit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Exec_UnlistenCommit(%s,%d)"</literal></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>q</argument>, <argument>listenChannels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lchan</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>lchan</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>listenChannels</name> <operator>=</operator> <call><name>foreach_delete_current</name><argument_list>(<argument><expr><name>listenChannels</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lchan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We do not complain about unlistening something not being listened;
	 * should we?
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Exec_UnlistenAllCommit --- subroutine for AtCommit_Notify
 *
 *		Unlisten on all channels for this backend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Exec_UnlistenAllCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Exec_UnlistenAllCommit(%d)"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>listenChannels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>listenChannels</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessCompletedNotifies --- nowadays this does nothing
 *
 * This routine used to send signals and handle self-notifies,
 * but that functionality has been moved elsewhere.
 * We'd delete it entirely, except that the documentation used to instruct
 * background-worker authors to call it.  To avoid an ABI break in stable
 * branches, keep it as a no-op routine.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessCompletedNotifies</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether we are actively listening on the given channel name.
 *
 * Note: this function is executed for every notification found in the queue.
 * Perhaps it is worth further optimization, eg convert the list to a sorted
 * array so we can binary-search it.  In practice the list is likely to be
 * fairly short, though.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsListeningOn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>p</argument>, <argument>listenChannels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lchan</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>lchan</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove our entry from the listeners array when we are no longer listening
 * on any channel.  NB: must not fail if we're already not listening.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>asyncQueueUnregister</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>listenChannels</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else caller error */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>amRegisteredListener</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* nothing to do */</comment>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Need exclusive lock here to manipulate list links.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Mark our entry as invalid */</comment>
	<expr_stmt><expr><call><name>QUEUE_BACKEND_PID</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QUEUE_BACKEND_DBOID</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<comment type="block">/* and remove it from the list */</comment>
	<if_stmt><if>if <condition>(<expr><name>QUEUE_FIRST_LISTENER</name> <operator>==</operator> <name>MyBackendId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>QUEUE_FIRST_LISTENER</name> <operator>=</operator> <call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>BackendId</name></type> <name>i</name> <init>= <expr><name>QUEUE_FIRST_LISTENER</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MyBackendId</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mark ourselves as no longer listed in the global array */</comment>
	<expr_stmt><expr><name>amRegisteredListener</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether there is room to insert more notification messages.
 *
 * Caller must hold at least shared NotifyQueueLock.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>asyncQueueIsFull</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nexthead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>boundary</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The queue is full if creating a new head page would create a page that
	 * logically precedes the current global tail pointer, ie, the head
	 * pointer would wrap around compared to the tail.  We cannot create such
	 * a head page for fear of confusing slru.c.  For safety we round the tail
	 * pointer back to a segment boundary (truncation logic in
	 * asyncQueueAdvanceTail does not do this, so doing it here is optional).
	 *
	 * Note that this test is *not* dependent on how much space there is on
	 * the current head page.  This is necessary because asyncQueueAddEntries
	 * might try to create the next head page in any case.
	 */</comment>
	<expr_stmt><expr><name>nexthead</name> <operator>=</operator> <call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>QUEUE_HEAD</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nexthead</name> <operator>&gt;</operator> <name>QUEUE_MAX_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nexthead</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* wrap around */</comment>
	<expr_stmt><expr><name>boundary</name> <operator>=</operator> <name>QUEUE_STOP_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>boundary</name> <operator>-=</operator> <name>boundary</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>
	<return>return <expr><call><name>asyncQueuePagePrecedes</name><argument_list>(<argument><expr><name>nexthead</name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance the QueuePosition to the next entry, assuming that the current
 * entry is of length entryLength.  If we jump to a new page the function
 * returns true, else false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>asyncQueueAdvance</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>QueuePosition</name> <modifier>*</modifier></type><name>position</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>entryLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name> <init>= <expr><call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><operator>*</operator><name>position</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><call><name>QUEUE_POS_OFFSET</name><argument_list>(<argument><expr><operator>*</operator><name>position</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pageJump</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Move to the next writing position: First jump over what we have just
	 * written or read.
	 */</comment>
	<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>entryLength</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&lt;=</operator> <name>QUEUE_PAGESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a second step check if another entry can possibly be written to the
	 * page. If so, stay here, we have reached the next position. If not, then
	 * we need to move on to the next page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <call><name>QUEUEALIGN</name><argument_list>(<argument><expr><name>AsyncQueueEntryEmptySize</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>QUEUE_PAGESIZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pageno</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pageno</name> <operator>&gt;</operator> <name>QUEUE_MAX_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pageno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* wrap around */</comment>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pageJump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_QUEUE_POS</name><argument_list>(<argument><expr><operator>*</operator><name>position</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>pageJump</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fill the AsyncQueueEntry at *qe with an outbound notification message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>asyncQueueNotificationToEntry</name><parameter_list>(<parameter><decl><type><name>Notification</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>AsyncQueueEntry</name> <modifier>*</modifier></type><name>qe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>channellen</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>channel_len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>payloadlen</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>payload_len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>entryLength</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>channellen</name> <operator>&lt;</operator> <name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>payloadlen</name> <operator>&lt;</operator> <name>NOTIFY_PAYLOAD_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The terminators are already included in AsyncQueueEntryEmptySize */</comment>
	<expr_stmt><expr><name>entryLength</name> <operator>=</operator> <name>AsyncQueueEntryEmptySize</name> <operator>+</operator> <name>payloadlen</name> <operator>+</operator> <name>channellen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>entryLength</name> <operator>=</operator> <call><name>QUEUEALIGN</name><argument_list>(<argument><expr><name>entryLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qe</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>entryLength</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qe</name><operator>-&gt;</operator><name>dboid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qe</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qe</name><operator>-&gt;</operator><name>srcPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>qe</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>channellen</name> <operator>+</operator> <name>payloadlen</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add pending notifications to the queue.
 *
 * We go page by page here, i.e. we stop once we have to go to a new page but
 * we will be called again and then fill that next page. If an entry does not
 * fit into the current page, we write a dummy entry with an InvalidOid as the
 * database OID in order to fill the page. So every page is always used up to
 * the last byte which simplifies reading the page later.
 *
 * We are passed the list cell (in pendingNotifies-&gt;events) containing the next
 * notification to write and return the first still-unwritten cell back.
 * Eventually we will return NULL indicating all is done.
 *
 * We are holding NotifyQueueLock already from the caller and grab
 * NotifySLRULock locally in this function.
 */</comment>
<function><type><specifier>static</specifier> <name>ListCell</name> <modifier>*</modifier></type>
<name>asyncQueueAddEntries</name><parameter_list>(<parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>nextNotify</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AsyncQueueEntry</name></type> <name>qe</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueuePosition</name></type> <name>queue_head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<comment type="block">/* We hold both NotifyQueueLock and NotifySLRULock during this operation */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifySLRULock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We work with a local copy of QUEUE_HEAD, which we write back to shared
	 * memory upon exiting.  The reason for this is that if we have to advance
	 * to a new page, SimpleLruZeroPage might fail (out of disk space, for
	 * instance), and we must not advance QUEUE_HEAD if it does.  (Otherwise,
	 * subsequent insertions would try to put entries into a page that slru.c
	 * thinks doesn't exist yet.)  So, use a local position variable.  Note
	 * that if we do fail, any already-inserted queue entries are forgotten;
	 * this is okay, since they'd be useless anyway after our transaction
	 * rolls back.
	 */</comment>
	<expr_stmt><expr><name>queue_head</name> <operator>=</operator> <name>QUEUE_HEAD</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is the first write since the postmaster started, we need to
	 * initialize the first page of the async SLRU.  Otherwise, the current
	 * page should be initialized already, so just fetch it.
	 *
	 * (We could also take the first path when the SLRU position has just
	 * wrapped around, but re-zeroing the page is harmless in that case.)
	 */</comment>
	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>queue_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>QUEUE_POS_IS_ZERO</name><argument_list>(<argument><expr><name>queue_head</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruZeroPage</name><argument_list>(<argument><expr><name>NotifyCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>NotifyCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Note we mark the page dirty before writing in it */</comment>
	<expr_stmt><expr><name><name>NotifyCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>nextNotify</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Notification</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>Notification</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>nextNotify</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Construct a valid queue entry in local variable qe */</comment>
		<expr_stmt><expr><call><name>asyncQueueNotificationToEntry</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>QUEUE_POS_OFFSET</name><argument_list>(<argument><expr><name>queue_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check whether the entry really fits on the current page */</comment>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <name><name>qe</name><operator>.</operator><name>length</name></name> <operator>&lt;=</operator> <name>QUEUE_PAGESIZE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK, so advance nextNotify past this item */</comment>
			<expr_stmt><expr><name>nextNotify</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name>nextNotify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Write a dummy entry to fill up the page. Actually readers will
			 * only check dboid and since it won't match any reader's database
			 * OID, they will ignore this entry and move on.
			 */</comment>
			<expr_stmt><expr><name><name>qe</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>QUEUE_PAGESIZE</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>qe</name><operator>.</operator><name>dboid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>qe</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* empty channel */</comment>
			<expr_stmt><expr><name><name>qe</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* empty payload */</comment>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Now copy qe into the shared buffer page */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>NotifyCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>+</operator> <name>offset</name></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name>qe</name></expr></argument>,
			   <argument><expr><name><name>qe</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Advance queue_head appropriately, and detect if page is full */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>asyncQueueAdvance</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name>queue_head</name><operator>)</operator></expr></argument>, <argument><expr><name><name>qe</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Page is full, so we're done here, but first fill the next page
			 * with zeroes.  The reason to do this is to ensure that slru.c's
			 * idea of the head page is always the same as ours, which avoids
			 * boundary problems in SimpleLruTruncate.  The test in
			 * asyncQueueIsFull() ensured that there is room to create this
			 * page without overrunning the queue.
			 */</comment>
			<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruZeroPage</name><argument_list>(<argument><expr><name>NotifyCtl</name></expr></argument>, <argument><expr><call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>queue_head</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the new page address is a multiple of QUEUE_CLEANUP_DELAY,
			 * set flag to remember that we should try to advance the tail
			 * pointer (we don't want to actually do that right here).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>queue_head</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>QUEUE_CLEANUP_DELAY</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tryAdvanceTail</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* And exit the loop */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Success, so update the global QUEUE_HEAD */</comment>
	<expr_stmt><expr><name>QUEUE_HEAD</name> <operator>=</operator> <name>queue_head</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifySLRULock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nextNotify</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function to return the fraction of the notification queue currently
 * occupied.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_notification_queue_usage</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>usage</name></decl>;</decl_stmt>

	<comment type="block">/* Advance the queue tail so we don't report a too-large result */</comment>
	<expr_stmt><expr><call><name>asyncQueueAdvanceTail</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>usage</name> <operator>=</operator> <call><name>asyncQueueUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>usage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the fraction of the queue that is currently occupied.
 *
 * The caller must hold NotifyQueueLock in (at least) shared mode.
 *
 * Note: we measure the distance to the logical tail page, not the physical
 * tail page.  In some sense that's wrong, but the relative position of the
 * physical tail is affected by details such as SLRU segment boundaries,
 * so that a result based on that is unpleasantly unstable.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>asyncQueueUsage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>headPage</name> <init>= <expr><call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>QUEUE_HEAD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tailPage</name> <init>= <expr><call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>QUEUE_TAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>occupied</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>occupied</name> <operator>=</operator> <name>headPage</name> <operator>-</operator> <name>tailPage</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>occupied</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* fast exit for common case */</comment>

	<if_stmt><if>if <condition>(<expr><name>occupied</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* head has wrapped around, tail not yet */</comment>
		<expr_stmt><expr><name>occupied</name> <operator>+=</operator> <name>QUEUE_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <name>occupied</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>QUEUE_MAX_PAGE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the queue is at least half full, and emit a warning if so.
 *
 * This is unlikely given the size of the queue, but possible.
 * The warnings show up at most once every QUEUE_FULL_WARN_INTERVAL.
 *
 * Caller must hold exclusive NotifyQueueLock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>asyncQueueFillWarning</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>fillDegree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>t</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fillDegree</name> <operator>=</operator> <call><name>asyncQueueUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fillDegree</name> <operator>&lt;</operator> <literal type="number">0.5</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>asyncQueueControl</name><operator>-&gt;</operator><name>lastQueueFillWarn</name></name></expr></argument>,
								   <argument><expr><name>t</name></expr></argument>, <argument><expr><name>QUEUE_FULL_WARN_INTERVAL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QueuePosition</name></type> <name>min</name> <init>= <expr><name>QUEUE_HEAD</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>minPid</name> <init>= <expr><name>InvalidPid</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>BackendId</name></type> <name>i</name> <init>= <expr><name>QUEUE_FIRST_LISTENER</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>QUEUE_BACKEND_PID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>QUEUE_POS_MIN</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><call><name>QUEUE_BACKEND_POS</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>QUEUE_POS_EQUAL</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><call><name>QUEUE_BACKEND_POS</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>minPid</name> <operator>=</operator> <call><name>QUEUE_BACKEND_PID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NOTIFY queue is %.0f%% full"</literal></expr></argument>, <argument><expr><name>fillDegree</name> <operator>*</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><ternary><condition><expr><name>minPid</name> <operator>!=</operator> <name>InvalidPid</name></expr> ?</condition><then>
				  <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The server process with PID %d is among those with the oldest transactions."</literal></expr></argument>, <argument><expr><name>minPid</name></expr></argument>)</argument_list></call></expr>
				  </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>,</operator>
				 <operator>(</operator><ternary><condition><expr><name>minPid</name> <operator>!=</operator> <name>InvalidPid</name></expr> ?</condition><then>
				  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The NOTIFY queue cannot be emptied until that process ends its current transaction."</literal></expr></argument>)</argument_list></call></expr>
				  </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>asyncQueueControl</name><operator>-&gt;</operator><name>lastQueueFillWarn</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send signals to listening backends.
 *
 * Normally we signal only backends in our own database, since only those
 * backends could be interested in notifies we send.  However, if there's
 * notify traffic in our database but no traffic in another database that
 * does have listener(s), those listeners will fall further and further
 * behind.  Waken them anyway if they're far enough behind, so that they'll
 * advance their queue position pointers, allowing the global tail to advance.
 *
 * Since we know the BackendId and the Pid the signaling is quite cheap.
 *
 * This is called during CommitTransaction(), so it's important for it
 * to have very low probability of failure.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SignalBackends</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>pids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendId</name>  <modifier>*</modifier></type><name>ids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Identify backends that we need to signal.  We don't want to send
	 * signals while holding the NotifyQueueLock, so this loop just builds a
	 * list of target PIDs.
	 *
	 * XXX in principle these pallocs could fail, which would be bad. Maybe
	 * preallocate the arrays?  They're not that large, though.
	 */</comment>
	<expr_stmt><expr><name>pids</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ids</name> <operator>=</operator> <operator>(</operator><name>BackendId</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BackendId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>BackendId</name></type> <name>i</name> <init>= <expr><name>QUEUE_FIRST_LISTENER</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>pid</name> <init>= <expr><call><name>QUEUE_BACKEND_PID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QueuePosition</name></type> <name>pos</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pid</name> <operator>!=</operator> <name>InvalidPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>QUEUE_BACKEND_POS</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>QUEUE_BACKEND_DBOID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MyDatabaseId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Always signal listeners in our own database, unless they're
			 * already caught up (unlikely, but possible).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>QUEUE_POS_EQUAL</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>QUEUE_HEAD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Listeners in other databases should be signaled only if they
			 * are far behind.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>asyncQueuePageDiff</name><argument_list>(<argument><expr><call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>QUEUE_HEAD</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>QUEUE_CLEANUP_DELAY</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* OK, need to signal this one */</comment>
		<expr_stmt><expr><name><name>pids</name><index>[<expr><name>count</name></expr>]</index></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ids</name><index>[<expr><name>count</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now send signals */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>pid</name> <init>= <expr><name><name>pids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we are signaling our own process, no need to involve the kernel;
		 * just set the flag directly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>MyProcPid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>notifyInterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Note: assuming things aren't broken, a signal failure here could
		 * only occur if the target backend exited since we released
		 * NotifyQueueLock; which is unlikely but certainly possible. So we
		 * just log a low-level debug message if it happens.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SendProcSignal</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>PROCSIG_NOTIFY_INTERRUPT</name></expr></argument>, <argument><expr><name><name>ids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"could not signal backend with PID %d: %m"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtAbort_Notify
 *
 *	This is called at transaction abort.
 *
 *	Gets rid of pending actions and outbound notifies that we would have
 *	executed if the transaction got committed.
 */</comment>
<function><type><name>void</name></type>
<name>AtAbort_Notify</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we LISTEN but then roll back the transaction after PreCommit_Notify,
	 * we have registered as a listener but have not made any entry in
	 * listenChannels.  In that case, deregister again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>amRegisteredListener</name> <operator>&amp;&amp;</operator> <name>listenChannels</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>asyncQueueUnregister</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And clean up */</comment>
	<expr_stmt><expr><call><name>ClearPendingActionsAndNotifies</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtSubCommit_Notify() --- Take care of subtransaction commit.
 *
 * Reassign all items in the pending lists to the parent transaction.
 */</comment>
<function><type><name>void</name></type>
<name>AtSubCommit_Notify</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If there are actions at our nesting level, we must reparent them. */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingActions</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>pendingActions</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>&gt;=</operator> <name>my_level</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pendingActions</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>pendingActions</name><operator>-&gt;</operator><name>upper</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>&lt;</operator> <name>my_level</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* nothing to merge; give the whole thing to the parent */</comment>
			<expr_stmt><expr><operator>--</operator><name><name>pendingActions</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ActionList</name> <modifier>*</modifier></type><name>childPendingActions</name> <init>= <expr><name>pendingActions</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>pendingActions</name> <operator>=</operator> <name><name>pendingActions</name><operator>-&gt;</operator><name>upper</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Mustn't try to eliminate duplicates here --- see queue_listen()
			 */</comment>
			<expr_stmt><expr><name><name>pendingActions</name><operator>-&gt;</operator><name>actions</name></name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><name><name>pendingActions</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>,
							<argument><expr><name><name>childPendingActions</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>childPendingActions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If there are notifies at our nesting level, we must reparent them. */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingNotifies</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>pendingNotifies</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>&gt;=</operator> <name>my_level</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>==</operator> <name>my_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>upper</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>pendingNotifies</name><operator>-&gt;</operator><name>upper</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>&lt;</operator> <name>my_level</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* nothing to merge; give the whole thing to the parent */</comment>
			<expr_stmt><expr><operator>--</operator><name><name>pendingNotifies</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Formerly, we didn't bother to eliminate duplicates here, but
			 * now we must, else we fall foul of "Assert(!found)", either here
			 * or during a later attempt to build the parent-level hashtable.
			 */</comment>
			<decl_stmt><decl><type><name>NotificationList</name> <modifier>*</modifier></type><name>childPendingNotifies</name> <init>= <expr><name>pendingNotifies</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pendingNotifies</name> <operator>=</operator> <name><name>pendingNotifies</name><operator>-&gt;</operator><name>upper</name></name></expr>;</expr_stmt>
			<comment type="block">/* Insert all the subxact's events into parent, except for dups */</comment>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>childPendingNotifies-&gt;events</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Notification</name> <modifier>*</modifier></type><name>childn</name> <init>= <expr><operator>(</operator><name>Notification</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AsyncExistsPendingNotify</name><argument_list>(<argument><expr><name>childn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>AddEventToPendingNotifies</name><argument_list>(<argument><expr><name>childn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>childPendingNotifies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtSubAbort_Notify() --- Take care of subtransaction abort.
 */</comment>
<function><type><name>void</name></type>
<name>AtSubAbort_Notify</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>my_level</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * All we have to do is pop the stack --- the actions/notifies made in
	 * this subxact are no longer interesting, and the space will be freed
	 * when CurTransactionContext is recycled. We still have to free the
	 * ActionList and NotificationList objects themselves, though, because
	 * those are allocated in TopTransactionContext.
	 *
	 * Note that there might be no entries at all, or no entries for the
	 * current subtransaction level, either because none were ever created, or
	 * because we reentered this routine due to trouble during subxact abort.
	 */</comment>
	<while>while <condition>(<expr><name>pendingActions</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		   <name><name>pendingActions</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>&gt;=</operator> <name>my_level</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ActionList</name> <modifier>*</modifier></type><name>childPendingActions</name> <init>= <expr><name>pendingActions</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pendingActions</name> <operator>=</operator> <name><name>pendingActions</name><operator>-&gt;</operator><name>upper</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>childPendingActions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<while>while <condition>(<expr><name>pendingNotifies</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		   <name><name>pendingNotifies</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>&gt;=</operator> <name>my_level</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NotificationList</name> <modifier>*</modifier></type><name>childPendingNotifies</name> <init>= <expr><name>pendingNotifies</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pendingNotifies</name> <operator>=</operator> <name><name>pendingNotifies</name><operator>-&gt;</operator><name>upper</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>childPendingNotifies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * HandleNotifyInterrupt
 *
 *		Signal handler portion of interrupt handling. Let the backend know
 *		that there's a pending notify interrupt. If we're currently reading
 *		from the client, this will interrupt the read and
 *		ProcessClientReadInterrupt() will call ProcessNotifyInterrupt().
 */</comment>
<function><type><name>void</name></type>
<name>HandleNotifyInterrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Note: this is called by a SIGNAL HANDLER. You must be very wary what
	 * you do here.
	 */</comment>

	<comment type="block">/* signal that work needs to be done */</comment>
	<expr_stmt><expr><name>notifyInterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* make sure the event is processed in due course */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessNotifyInterrupt
 *
 *		This is called if we see notifyInterruptPending set, just before
 *		transmitting ReadyForQuery at the end of a frontend command, and
 *		also if a notify signal occurs while reading from the frontend.
 *		HandleNotifyInterrupt() will cause the read to be interrupted
 *		via the process's latch, and this routine will get called.
 *		If we are truly idle (ie, *not* inside a transaction block),
 *		process the incoming notifies.
 *
 *		If "flush" is true, force any frontend messages out immediately.
 *		This can be false when being called at the end of a frontend command,
 *		since we'll flush after sending ReadyForQuery.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessNotifyInterrupt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>flush</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* not really idle */</comment>

	<comment type="block">/* Loop in case another signal arrives while sending messages */</comment>
	<while>while <condition>(<expr><name>notifyInterruptPending</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ProcessIncomingNotify</name><argument_list>(<argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Read all pending notifications from the queue, and deliver appropriate
 * ones to my frontend.  Stop when we reach queue head or an uncommitted
 * notification.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>asyncQueueReadAllNotifications</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>QueuePosition</name></type> <name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueuePosition</name></type> <name>oldpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueuePosition</name></type> <name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<comment type="block">/* page_buffer must be adequately aligned, so use a union */</comment>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>QUEUE_PAGESIZE</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AsyncQueueEntry</name></type> <name>align</name></decl>;</decl_stmt>
	}</block>			<decl><name>page_buffer</name></decl>;</union>

	<comment type="block">/* Fetch current state */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Assert checks that we have a valid state entry */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProcPid</name> <operator>==</operator> <call><name>QUEUE_BACKEND_PID</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>oldpos</name> <operator>=</operator> <call><name>QUEUE_BACKEND_POS</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>head</name> <operator>=</operator> <name>QUEUE_HEAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>QUEUE_POS_EQUAL</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Nothing to do, we have read all notifications already. */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * Get snapshot we'll use to decide which xacts are still in progress.
	 * This is trickier than it might seem, because of race conditions.
	 * Consider the following example:
	 *
	 * Backend 1:					 Backend 2:
	 *
	 * transaction starts
	 * UPDATE foo SET ...;
	 * NOTIFY foo;
	 * commit starts
	 * queue the notify message
	 *								 transaction starts
	 *								 LISTEN foo;  -- first LISTEN in session
	 *								 SELECT * FROM foo WHERE ...;
	 * commit to clog
	 *								 commit starts
	 *								 add backend 2 to array of listeners
	 *								 advance to queue head (this code)
	 *								 commit to clog
	 *
	 * Transaction 2's SELECT has not seen the UPDATE's effects, since that
	 * wasn't committed yet.  Ideally we'd ensure that client 2 would
	 * eventually get transaction 1's notify message, but there's no way
	 * to do that; until we're in the listener array, there's no guarantee
	 * that the notify message doesn't get removed from the queue.
	 *
	 * Therefore the coding technique transaction 2 is using is unsafe:
	 * applications must commit a LISTEN before inspecting database state,
	 * if they want to ensure they will see notifications about subsequent
	 * changes to that state.
	 *
	 * What we do guarantee is that we'll see all notifications from
	 * transactions committing after the snapshot we take here.
	 * Exec_ListenPreCommit has already added us to the listener array,
	 * so no not-yet-committed messages can be removed from the queue
	 * before we see them.
	 *----------
	 */</comment>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It is possible that we fail while trying to send a message to our
	 * frontend (for example, because of encoding conversion failure).  If
	 * that happens it is critical that we not try to send the same message
	 * over and over again.  Therefore, we place a PG_TRY block here that will
	 * forcibly advance our queue position before we lose control to an error.
	 * (We could alternatively retake NotifyQueueLock and move the position
	 * before handling each individual message, but that seems like too much
	 * lock traffic.)
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>reachedStop</name></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>curpage</name> <init>= <expr><call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>curoffset</name> <init>= <expr><call><name>QUEUE_POS_OFFSET</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>copysize</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We copy the data from SLRU into a local buffer, so as to avoid
			 * holding the NotifySLRULock while we are examining the entries
			 * and possibly transmitting them to our frontend.  Copy only the
			 * part of the page we will actually inspect.
			 */</comment>
			<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage_ReadOnly</name><argument_list>(<argument><expr><name>NotifyCtl</name></expr></argument>, <argument><expr><name>curpage</name></expr></argument>,
												<argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>curpage</name> <operator>==</operator> <call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we only want to read as far as head */</comment>
				<expr_stmt><expr><name>copysize</name> <operator>=</operator> <call><name>QUEUE_POS_OFFSET</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>curoffset</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>copysize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>copysize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* just for safety */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* fetch all the rest of the page */</comment>
				<expr_stmt><expr><name>copysize</name> <operator>=</operator> <name>QUEUE_PAGESIZE</name> <operator>-</operator> <name>curoffset</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>page_buffer</name><operator>.</operator><name>buf</name></name> <operator>+</operator> <name>curoffset</name></expr></argument>,
				   <argument><expr><name><name>NotifyCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>+</operator> <name>curoffset</name></expr></argument>,
				   <argument><expr><name>copysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Release lock that we got from SimpleLruReadPage_ReadOnly() */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifySLRULock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Process messages up to the stop position, end of page, or an
			 * uncommitted message.
			 *
			 * Our stop position is what we found to be the head's position
			 * when we entered this function. It might have changed already.
			 * But if it has, we will receive (or have already received and
			 * queued) another signal and come here again.
			 *
			 * We are not holding NotifyQueueLock here! The queue can only
			 * extend beyond the head pointer (see above) and we leave our
			 * backend's pointer where it is so nobody will truncate or
			 * rewrite pages under us. Especially we don't want to hold a lock
			 * while sending the notifications to the frontend.
			 */</comment>
			<expr_stmt><expr><name>reachedStop</name> <operator>=</operator> <call><name>asyncQueueProcessPageEntries</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>, <argument><expr><name>head</name></expr></argument>,
													   <argument><expr><name><name>page_buffer</name><operator>.</operator><name>buf</name></name></expr></argument>,
													   <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><operator>!</operator><name>reachedStop</name></expr>)</condition>;</do>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_FINALLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Update shared state */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QUEUE_BACKEND_POS</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done with snapshot */</comment>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch notifications from the shared queue, beginning at position current,
 * and deliver relevant ones to my frontend.
 *
 * The current page must have been fetched into page_buffer from shared
 * memory.  (We could access the page right in shared memory, but that
 * would imply holding the NotifySLRULock throughout this routine.)
 *
 * We stop if we reach the "stop" position, or reach a notification from an
 * uncommitted transaction, or reach the end of the page.
 *
 * The function returns true once we have reached the stop position or an
 * uncommitted notification, and false if we have finished with the page.
 * In other words: once it returns true there is no need to look further.
 * The QueuePosition *current is advanced past all processed messages.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>asyncQueueProcessPageEntries</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>QueuePosition</name> <modifier>*</modifier></type><name>current</name></decl></parameter>,
							 <parameter><decl><type><name>QueuePosition</name></type> <name>stop</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>page_buffer</name></decl></parameter>,
							 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reachedStop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reachedEndOfPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AsyncQueueEntry</name> <modifier>*</modifier></type><name>qe</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>QueuePosition</name></type> <name>thisentry</name> <init>= <expr><operator>*</operator><name>current</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>QUEUE_POS_EQUAL</name><argument_list>(<argument><expr><name>thisentry</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>qe</name> <operator>=</operator> <operator>(</operator><name>AsyncQueueEntry</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>page_buffer</name> <operator>+</operator> <call><name>QUEUE_POS_OFFSET</name><argument_list>(<argument><expr><name>thisentry</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Advance *current over this message, possibly to the next page. As
		 * noted in the comments for asyncQueueReadAllNotifications, we must
		 * do this before possibly failing while processing the message.
		 */</comment>
		<expr_stmt><expr><name>reachedEndOfPage</name> <operator>=</operator> <call><name>asyncQueueAdvance</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>qe</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ignore messages destined for other databases */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>qe</name><operator>-&gt;</operator><name>dboid</name></name> <operator>==</operator> <name>MyDatabaseId</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>XidInMVCCSnapshot</name><argument_list>(<argument><expr><name><name>qe</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The source transaction is still in progress, so we can't
				 * process this message yet.  Break out of the loop, but first
				 * back up *current so we will reprocess the message next
				 * time.  (Note: it is unlikely but not impossible for
				 * TransactionIdDidCommit to fail, so we can't really avoid
				 * this advance-then-back-up behavior when dealing with an
				 * uncommitted message.)
				 *
				 * Note that we must test XidInMVCCSnapshot before we test
				 * TransactionIdDidCommit, else we might return a message from
				 * a transaction that is not yet visible to snapshots; compare
				 * the comments at the head of heapam_visibility.c.
				 *
				 * Also, while our own xact won't be listed in the snapshot,
				 * we need not check for TransactionIdIsCurrentTransactionId
				 * because our transaction cannot (yet) have queued any
				 * messages.
				 */</comment>
				<expr_stmt><expr><operator>*</operator><name>current</name> <operator>=</operator> <name>thisentry</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>reachedStop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name><name>qe</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* qe-&gt;data is the null-terminated channel name */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>channel</name> <init>= <expr><name><name>qe</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsListeningOn</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* payload follows channel name */</comment>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>payload</name> <init>= <expr><name><name>qe</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>channel</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>NotifyMyFrontEnd</name><argument_list>(<argument><expr><name>channel</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>, <argument><expr><name><name>qe</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The source transaction aborted or crashed, so we just
				 * ignore its notifications.
				 */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Loop back if we're not at end of page */</comment>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>reachedEndOfPage</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><call><name>QUEUE_POS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>current</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reachedStop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>reachedStop</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance the shared queue tail variable to the minimum of all the
 * per-backend tail pointers.  Truncate pg_notify space if possible.
 *
 * This is (usually) called during CommitTransaction(), so it's important for
 * it to have very low probability of failure.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>asyncQueueAdvanceTail</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueuePosition</name></type> <name>min</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldtailpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newtailpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>boundary</name></decl>;</decl_stmt>

	<comment type="block">/* Restrict task to one backend per cluster; see SimpleLruTruncate(). */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueTailLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the new tail.  Pre-v13, it's essential that QUEUE_TAIL be exact
	 * (ie, exactly match at least one backend's queue position), so it must
	 * be updated atomically with the actual computation.  Since v13, we could
	 * get away with not doing it like that, but it seems prudent to keep it
	 * so.
	 *
	 * Also, because incoming backends will scan forward from QUEUE_TAIL, that
	 * must be advanced before we can truncate any data.  Thus, QUEUE_TAIL is
	 * the logical tail, while QUEUE_STOP_PAGE is the physical tail, or oldest
	 * un-truncated page.  When QUEUE_STOP_PAGE != QUEUE_POS_PAGE(QUEUE_TAIL),
	 * there are pages we can truncate but haven't yet finished doing so.
	 *
	 * For concurrency's sake, we don't want to hold NotifyQueueLock while
	 * performing SimpleLruTruncate.  This is OK because no backend will try
	 * to access the pages we are in the midst of truncating.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>min</name> <operator>=</operator> <name>QUEUE_HEAD</name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>BackendId</name></type> <name>i</name> <init>= <expr><name>QUEUE_FIRST_LISTENER</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>QUEUE_NEXT_LISTENER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>QUEUE_BACKEND_PID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>QUEUE_POS_MIN</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><call><name>QUEUE_BACKEND_POS</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>QUEUE_TAIL</name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldtailpage</name> <operator>=</operator> <name>QUEUE_STOP_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can truncate something if the global tail advanced across an SLRU
	 * segment boundary.
	 *
	 * XXX it might be better to truncate only once every several segments, to
	 * reduce the number of directory scans.
	 */</comment>
	<expr_stmt><expr><name>newtailpage</name> <operator>=</operator> <call><name>QUEUE_POS_PAGE</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>boundary</name> <operator>=</operator> <name>newtailpage</name> <operator>-</operator> <operator>(</operator><name>newtailpage</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>asyncQueuePagePrecedes</name><argument_list>(<argument><expr><name>oldtailpage</name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * SimpleLruTruncate() will ask for NotifySLRULock but will also
		 * release the lock again.
		 */</comment>
		<expr_stmt><expr><call><name>SimpleLruTruncate</name><argument_list>(<argument><expr><name>NotifyCtl</name></expr></argument>, <argument><expr><name>newtailpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update QUEUE_STOP_PAGE.  This changes asyncQueueIsFull()'s verdict
		 * for the segment immediately prior to the old tail, allowing fresh
		 * data into that segment.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>QUEUE_STOP_PAGE</name> <operator>=</operator> <name>newtailpage</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NotifyQueueTailLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessIncomingNotify
 *
 *		Scan the queue for arriving notifications and report them to the front
 *		end.  The notifications might be from other sessions, or our own;
 *		there's no need to distinguish here.
 *
 *		If "flush" is true, force any frontend messages out immediately.
 *
 *		NOTE: since we are outside any transaction, we must create our own.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessIncomingNotify</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>flush</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We *must* reset the flag */</comment>
	<expr_stmt><expr><name>notifyInterruptPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Do nothing else if we aren't actively listening */</comment>
	<if_stmt><if>if <condition>(<expr><name>listenChannels</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"ProcessIncomingNotify"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"notify interrupt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must run asyncQueueReadAllNotifications inside a transaction, else
	 * bad things happen if it gets an error.
	 */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>asyncQueueReadAllNotifications</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this isn't an end-of-command case, we must flush the notify messages
	 * to ensure frontend gets them promptly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flush</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Trace_notify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"ProcessIncomingNotify: done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send NOTIFY message to my front end.
 */</comment>
<function><type><name>void</name></type>
<name>NotifyMyFrontEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>payload</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>srcPid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'A'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>srcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * NOTE: we do not do pq_flush() here.  Some level of caller will
		 * handle it later, allowing this message to be combined into a packet
		 * with other ones.
		 */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"NOTIFY for \"%s\" payload \"%s\""</literal></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Does pendingNotifies include a match for the given event? */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AsyncExistsPendingNotify</name><parameter_list>(<parameter><decl><type><name>Notification</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>pendingNotifies</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>hashtab</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use the hash table to probe for a match */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>hashtab</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>,
						<argument><expr><name>HASH_FIND</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Must scan the event list */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pendingNotifies-&gt;events</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Notification</name> <modifier>*</modifier></type><name>oldn</name> <init>= <expr><operator>(</operator><name>Notification</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>channel_len</name></name> <operator>==</operator> <name><name>oldn</name><operator>-&gt;</operator><name>channel_len</name></name> <operator>&amp;&amp;</operator>
				<name><name>n</name><operator>-&gt;</operator><name>payload_len</name></name> <operator>==</operator> <name><name>oldn</name><operator>-&gt;</operator><name>payload_len</name></name> <operator>&amp;&amp;</operator>
				<call><name>memcmp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>oldn</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					   <argument><expr><name><name>n</name><operator>-&gt;</operator><name>channel_len</name></name> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>payload_len</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a notification event to a pre-existing pendingNotifies list.
 *
 * Because pendingNotifies-&gt;events is already nonempty, this works
 * correctly no matter what CurrentMemoryContext is.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddEventToPendingNotifies</name><parameter_list>(<parameter><decl><type><name>Notification</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>events</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the hash table if it's time to */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>MIN_HASHABLE_NOTIFIES</name> <operator>&amp;&amp;</operator>
		<name><name>pendingNotifies</name><operator>-&gt;</operator><name>hashtab</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* Create the hash table */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Notification</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NotificationHash</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>notification_hash</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>notification_match</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurTransactionContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>hashtab</name></name> <operator>=</operator>
			<call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Pending Notifies"</literal></expr></argument>,
						<argument><expr><literal type="number">256L</literal></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
						<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Insert all the already-existing events */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pendingNotifies-&gt;events</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Notification</name> <modifier>*</modifier></type><name>oldn</name> <init>= <expr><operator>(</operator><name>Notification</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NotificationHash</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>NotificationHash</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>hashtab</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>oldn</name></expr></argument>,
													  <argument><expr><name>HASH_ENTER</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <name>oldn</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add new event to the list, in order */</comment>
	<expr_stmt><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add event to the hash table if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>hashtab</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NotificationHash</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>NotificationHash</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>pendingNotifies</name><operator>-&gt;</operator><name>hashtab</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>,
												  <argument><expr><name>HASH_ENTER</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * notification_hash: hash function for notification hash table
 *
 * The hash "keys" are pointers to Notification structs.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>notification_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Notification</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>Notification</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Notification</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We don't bother to include the payload's trailing null in the hash */</comment>
	<return>return <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>k</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								   <argument><expr><name><name>k</name><operator>-&gt;</operator><name>channel_len</name></name> <operator>+</operator> <name><name>k</name><operator>-&gt;</operator><name>payload_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * notification_match: match function to use with notification_hash
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>notification_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Notification</name> <modifier>*</modifier></type><name>k1</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>Notification</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>key1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Notification</name> <modifier>*</modifier></type><name>k2</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>Notification</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>key2</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Notification</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k1</name><operator>-&gt;</operator><name>channel_len</name></name> <operator>==</operator> <name><name>k2</name><operator>-&gt;</operator><name>channel_len</name></name> <operator>&amp;&amp;</operator>
		<name><name>k1</name><operator>-&gt;</operator><name>payload_len</name></name> <operator>==</operator> <name><name>k2</name><operator>-&gt;</operator><name>payload_len</name></name> <operator>&amp;&amp;</operator>
		<call><name>memcmp</name><argument_list>(<argument><expr><name><name>k1</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>k2</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
			   <argument><expr><name><name>k1</name><operator>-&gt;</operator><name>channel_len</name></name> <operator>+</operator> <name><name>k1</name><operator>-&gt;</operator><name>payload_len</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* equal */</comment>
	<return>return <expr><literal type="number">1</literal></expr>;</return>					<comment type="block">/* not equal */</comment>
</block_content>}</block></function>

<comment type="block">/* Clear the pendingActions and pendingNotifies lists. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClearPendingActionsAndNotifies</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Everything's allocated in either TopTransactionContext or the context
	 * for the subtransaction to which it corresponds.  So, there's nothing to
	 * do here except reset the pointers; the space will be reclaimed when the
	 * contexts are deleted.
	 */</comment>
	<expr_stmt><expr><name>pendingActions</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pendingNotifies</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
