<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/commands/variable.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * variable.c
 *		Routines for handling specialized SET variables.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/variable.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<comment type="block">/*
 * DATESTYLE
 */</comment>

<comment type="block">/*
 * check_datestyle: GUC check_hook for datestyle
 */</comment>
<function><type><name>bool</name></type>
<name>check_datestyle</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newDateStyle</name> <init>= <expr><name>DateStyle</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newDateOrder</name> <init>= <expr><name>DateOrder</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_style</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_order</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>myextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tok</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ugh. Somebody ought to write a table driven version -- mjl */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"ISO"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_style</name> <operator>&amp;&amp;</operator> <name>newDateStyle</name> <operator>!=</operator> <name>USE_ISO_DATES</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* conflicting styles */</comment>
			<expr_stmt><expr><name>newDateStyle</name> <operator>=</operator> <name>USE_ISO_DATES</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_style</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"SQL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_style</name> <operator>&amp;&amp;</operator> <name>newDateStyle</name> <operator>!=</operator> <name>USE_SQL_DATES</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* conflicting styles */</comment>
			<expr_stmt><expr><name>newDateStyle</name> <operator>=</operator> <name>USE_SQL_DATES</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_style</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"POSTGRES"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_style</name> <operator>&amp;&amp;</operator> <name>newDateStyle</name> <operator>!=</operator> <name>USE_POSTGRES_DATES</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* conflicting styles */</comment>
			<expr_stmt><expr><name>newDateStyle</name> <operator>=</operator> <name>USE_POSTGRES_DATES</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_style</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"GERMAN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_style</name> <operator>&amp;&amp;</operator> <name>newDateStyle</name> <operator>!=</operator> <name>USE_GERMAN_DATES</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* conflicting styles */</comment>
			<expr_stmt><expr><name>newDateStyle</name> <operator>=</operator> <name>USE_GERMAN_DATES</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_style</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* GERMAN also sets DMY, unless explicitly overridden */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_order</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newDateOrder</name> <operator>=</operator> <name>DATEORDER_DMY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"YMD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_order</name> <operator>&amp;&amp;</operator> <name>newDateOrder</name> <operator>!=</operator> <name>DATEORDER_YMD</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* conflicting orders */</comment>
			<expr_stmt><expr><name>newDateOrder</name> <operator>=</operator> <name>DATEORDER_YMD</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_order</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"DMY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"EURO"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_order</name> <operator>&amp;&amp;</operator> <name>newDateOrder</name> <operator>!=</operator> <name>DATEORDER_DMY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* conflicting orders */</comment>
			<expr_stmt><expr><name>newDateOrder</name> <operator>=</operator> <name>DATEORDER_DMY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_order</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"MDY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"US"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"NONEURO"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_order</name> <operator>&amp;&amp;</operator> <name>newDateOrder</name> <operator>!=</operator> <name>DATEORDER_MDY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* conflicting orders */</comment>
			<expr_stmt><expr><name>newDateOrder</name> <operator>=</operator> <name>DATEORDER_MDY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_order</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Easiest way to get the current DEFAULT state is to fetch the
			 * DEFAULT string from guc.c and recursively parse it.
			 *
			 * We can't simply "return check_datestyle(...)" because we need
			 * to handle constructs like "DEFAULT, ISO".
			 */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>subval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>subextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>subval</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>GetConfigOptionResetString</name><argument_list>(<argument><expr><literal type="string">"datestyle"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subval</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_datestyle</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subextra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>subval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>myextra</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>subextra</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_style</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newDateStyle</name> <operator>=</operator> <name><name>myextra</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_order</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newDateOrder</name> <operator>=</operator> <name><name>myextra</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>subval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>subextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Unrecognized key word: \"%s\"."</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Conflicting \"datestyle\" specifications."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prepare the canonical string to return.  GUC wants it malloc'd.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>newDateStyle</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>USE_ISO_DATES</name></expr>:</case>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"ISO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>USE_SQL_DATES</name></expr>:</case>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"SQL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>USE_GERMAN_DATES</name></expr>:</case>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"German"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"Postgres"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<switch>switch <condition>(<expr><name>newDateOrder</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEORDER_YMD</name></expr>:</case>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">", YMD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DATEORDER_DMY</name></expr>:</case>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">", DMY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">", MDY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the "extra" struct actually used by assign_datestyle.
	 */</comment>
	<expr_stmt><expr><name>myextra</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>myextra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>myextra</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>newDateStyle</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myextra</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newDateOrder</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>myextra</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * assign_datestyle: GUC assign_hook for datestyle
 */</comment>
<function><type><name>void</name></type>
<name>assign_datestyle</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>myextra</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>DateStyle</name> <operator>=</operator> <name><name>myextra</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>DateOrder</name> <operator>=</operator> <name><name>myextra</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TIMEZONE
 */</comment>

<comment type="block">/*
 * check_timezone: GUC check_hook for timezone
 */</comment>
<function><type><name>bool</name></type>
<name>check_timezone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>new_tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>gmtoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>hours</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><literal type="string">"interval"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Support INTERVAL 'foo'.  This is for SQL spec compliance, not
		 * because it has any actual real-world usefulness.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valueptr</name> <init>= <expr><operator>*</operator><name>newval</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>valueptr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>valueptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>valueptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>valueptr</name><operator>++</operator> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>valueptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Check and remove trailing quote */</comment>
		<expr_stmt><expr><name>endptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>endptr</name> <operator>||</operator> <name><name>endptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to parse it.  XXX an invalid interval format will result in
		 * ereport(ERROR), which is not desirable for GUC.  We did what we
		 * could to guard against this in flatten_set_variable_args, but a
		 * string coming in from postgresql.conf might contain anything.
		 */</comment>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>interval_in</name></expr></argument>,
														 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot specify months in time zone interval."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot specify days in time zone interval."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Here we change from SQL to Unix sign convention */</comment>
		<expr_stmt><expr><name>gmtoffset</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_tz</name> <operator>=</operator> <call><name>pg_tzset_offset</name><argument_list>(<argument><expr><name>gmtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Try it as a numeric number of hours (possibly fractional).
		 */</comment>
		<expr_stmt><expr><name>hours</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <operator>*</operator><name>newval</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Here we change from SQL to Unix sign convention */</comment>
			<expr_stmt><expr><name>gmtoffset</name> <operator>=</operator> <operator>-</operator><name>hours</name> <operator>*</operator> <name>SECS_PER_HOUR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_tz</name> <operator>=</operator> <call><name>pg_tzset_offset</name><argument_list>(<argument><expr><name>gmtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise assume it is a timezone name, and try to load it.
			 */</comment>
			<expr_stmt><expr><name>new_tz</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_tz</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Doesn't seem to be any great value in errdetail here */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_tz_acceptable</name><argument_list>(<argument><expr><name>new_tz</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" appears to use leap seconds"</literal></expr></argument>,
								 <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"PostgreSQL does not support leap seconds."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Test for failure in pg_tzset_offset, which we assume is out-of-range */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_tz</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"UTC timezone offset is out of range."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Pass back data for assign_timezone to use
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_tz</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>extra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>pg_tz</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>*</operator><name>extra</name><operator>)</operator> <operator>=</operator> <name>new_tz</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * assign_timezone: GUC assign_hook for timezone
 */</comment>
<function><type><name>void</name></type>
<name>assign_timezone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>session_timezone</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>pg_tz</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>extra</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * show_timezone: GUC show_hook for timezone
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_timezone</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name></decl>;</decl_stmt>

	<comment type="block">/* Always show the zone's canonical name */</comment>
	<expr_stmt><expr><name>tzn</name> <operator>=</operator> <call><name>pg_get_timezone_name</name><argument_list>(<argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tzn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tzn</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LOG_TIMEZONE
 *
 * For log_timezone, we don't support the interval-based methods of setting a
 * zone, which are only there for SQL spec compliance not because they're
 * actually useful.
 */</comment>

<comment type="block">/*
 * check_log_timezone: GUC check_hook for log_timezone
 */</comment>
<function><type><name>bool</name></type>
<name>check_log_timezone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>new_tz</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Assume it is a timezone name, and try to load it.
	 */</comment>
	<expr_stmt><expr><name>new_tz</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_tz</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Doesn't seem to be any great value in errdetail here */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_tz_acceptable</name><argument_list>(<argument><expr><name>new_tz</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" appears to use leap seconds"</literal></expr></argument>,
						 <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"PostgreSQL does not support leap seconds."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Pass back data for assign_log_timezone to use
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_tz</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>extra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>pg_tz</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>*</operator><name>extra</name><operator>)</operator> <operator>=</operator> <name>new_tz</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * assign_log_timezone: GUC assign_hook for log_timezone
 */</comment>
<function><type><name>void</name></type>
<name>assign_log_timezone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>log_timezone</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>pg_tz</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>extra</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * show_log_timezone: GUC show_hook for log_timezone
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_log_timezone</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name></decl>;</decl_stmt>

	<comment type="block">/* Always show the zone's canonical name */</comment>
	<expr_stmt><expr><name>tzn</name> <operator>=</operator> <call><name>pg_get_timezone_name</name><argument_list>(<argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tzn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tzn</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SET TRANSACTION READ ONLY and SET TRANSACTION READ WRITE
 *
 * We allow idempotent changes (r/w -&gt; r/w and r/o -&gt; r/o) at any time, and
 * we also always allow changes from read-write to read-only.  However,
 * read-only may be changed to read-write only when in a top-level transaction
 * that has not yet taken an initial snapshot.  Can't do it in a hot standby,
 * either.
 *
 * If we are not in a transaction at all, just allow the change; it means
 * nothing since XactReadOnly will be reset by the next StartTransaction().
 * The IsTransactionState() test protects us against trying to check
 * RecoveryInProgress() in contexts where shared memory is not accessible.
 * (Similarly, if we're restoring state in a parallel worker, just allow
 * the change.)
 */</comment>
<function><type><name>bool</name></type>
<name>check_transaction_read_only</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name>XactReadOnly</name> <operator>&amp;&amp;</operator> <call><name>IsTransactionState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>InitializingParallelWorker</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Can't go to r/w mode inside a r/o transaction */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set transaction read-write mode inside a read-only transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Top level transaction can't change to r/w after first snapshot. */</comment>
		<if_stmt><if>if <condition>(<expr><name>FirstSnapshotSet</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction read-write mode must be set before any query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Can't go to r/w mode while recovery is still active */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set transaction read-write mode during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SET TRANSACTION ISOLATION LEVEL
 *
 * We allow idempotent changes at any time, but otherwise this can only be
 * changed in a toplevel transaction that has not yet taken a snapshot.
 *
 * As in check_transaction_read_only, allow it if not inside a transaction.
 */</comment>
<function><type><name>bool</name></type>
<name>check_XactIsoLevel</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newXactIsoLevel</name> <init>= <expr><operator>*</operator><name>newval</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>newXactIsoLevel</name> <operator>!=</operator> <name>XactIsoLevel</name> <operator>&amp;&amp;</operator> <call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>FirstSnapshotSet</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"SET TRANSACTION ISOLATION LEVEL must be called before any query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* We ignore a subtransaction setting it to the existing value. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"SET TRANSACTION ISOLATION LEVEL must not be called in a subtransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Can't go to serializable mode while recovery is still active */</comment>
		<if_stmt><if>if <condition>(<expr><name>newXactIsoLevel</name> <operator>==</operator> <name>XACT_SERIALIZABLE</name> <operator>&amp;&amp;</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use serializable mode in a hot standby"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GUC_check_errhint</name><argument_list>(<argument><expr><literal type="string">"You can use REPEATABLE READ instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SET TRANSACTION [NOT] DEFERRABLE
 */</comment>

<function><type><name>bool</name></type>
<name>check_transaction_deferrable</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"SET TRANSACTION [NOT] DEFERRABLE cannot be called within a subtransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>FirstSnapshotSet</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"SET TRANSACTION [NOT] DEFERRABLE must be called before any query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Random number seed
 *
 * We can't roll back the random sequence on error, and we don't want
 * config file reloads to affect it, so we only want interactive SET SEED
 * commands to set it.  We use the "extra" storage to ensure that rollbacks
 * don't try to do the operation again.
 */</comment>

<function><type><name>bool</name></type>
<name>check_random_seed</name><parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>extra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Arm the assign only if source of value is an interactive SET */</comment>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>extra</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>source</name> <operator>&gt;=</operator> <name>PGC_S_INTERACTIVE</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_random_seed</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We'll do this at most once for any setting of the GUC variable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>extra</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>setseed</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>extra</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_random_seed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="string">"unavailable"</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SET CLIENT_ENCODING
 */</comment>

<function><type><name>bool</name></type>
<name>check_client_encoding</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>canonical_name</name></decl>;</decl_stmt>

	<comment type="block">/* Look up the encoding by name */</comment>
	<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_valid_client_encoding</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get the canonical name (no aliases, uniform case) */</comment>
	<expr_stmt><expr><name>canonical_name</name> <operator>=</operator> <call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are not within a transaction then PrepareClientEncoding will not
	 * be able to look up the necessary conversion procs.  If we are still
	 * starting up, it will return "OK" anyway, and InitializeClientEncoding
	 * will fix things once initialization is far enough along.  After
	 * startup, we'll fail.  This would only happen if someone tries to change
	 * client_encoding in postgresql.conf and then SIGHUP existing sessions.
	 * It seems like a bad idea for client_encoding to change that way anyhow,
	 * so we don't go out of our way to support it.
	 *
	 * Note: in the postmaster, or any other process that never calls
	 * InitializeClientEncoding, PrepareClientEncoding will always succeed,
	 * and so will SetClientEncoding; but they won't do anything, which is OK.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PrepareClientEncoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Must be a genuine no-such-conversion problem */</comment>
			<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Conversion between %s and %s is not supported."</literal></expr></argument>,
								<argument><expr><name>canonical_name</name></expr></argument>,
								<argument><expr><call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Provide a useful complaint */</comment>
			<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot change \"client_encoding\" now."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Replace the user-supplied string with the encoding's canonical name.
	 * This gets rid of aliases and case-folding variations.
	 *
	 * XXX Although canonicalizing seems like a good idea in the abstract, it
	 * breaks pre-9.1 JDBC drivers, which expect that if they send "UNICODE"
	 * as the client_encoding setting then it will read back the same way. As
	 * a workaround, don't replace the string if it's "UNICODE".  Remove that
	 * hack when pre-9.1 JDBC drivers are no longer in use.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><name>canonical_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><literal type="string">"UNICODE"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>canonical_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>newval</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Save the encoding's ID in *extra, for use by assign_client_encoding.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>extra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>extra</name><operator>)</operator> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_client_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>extra</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Parallel workers send data to the leader, not the client.  They always
	 * send data using the database encoding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * During parallel worker startup, we want to accept the leader's
		 * client_encoding setting so that anyone who looks at the value in
		 * the worker sees the same value that they would see in the leader.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>InitializingParallelWorker</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * A change other than during startup, for example due to a SET clause
		 * attached to a function definition, should be rejected, as there is
		 * nothing we can do inside the worker to make it take effect.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change client_encoding during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We do not expect an error if PrepareClientEncoding succeeded */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SetClientEncoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SetClientEncoding(%d) failed"</literal></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SET SESSION AUTHORIZATION
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* This is the "extra" state for both SESSION AUTHORIZATION and ROLE */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_superuser</name></decl>;</decl_stmt>
}</block></struct></type> <name>role_auth_extra</name>;</typedef>

<function><type><name>bool</name></type>
<name>check_session_authorization</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>roleTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>roleform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_superuser</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>role_auth_extra</name> <modifier>*</modifier></type><name>myextra</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing for the boot_val default of NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Can't do catalog lookups, so fail.  The result of this is that
		 * session_authorization cannot be set in postgresql.conf, which seems
		 * like a good thing anyway, so we don't work hard to avoid it.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Look up the username */</comment>
	<expr_stmt><expr><name>roleTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When source == PGC_S_TEST, we don't throw a hard error for a
		 * nonexistent user name, only a NOTICE.  See comments in guc.h.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_TEST</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role \"%s\" does not exist"</literal></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"role \"%s\" does not exist"</literal></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>roleform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>roleid</name> <operator>=</operator> <name><name>roleform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_superuser</name> <operator>=</operator> <name><name>roleform</name><operator>-&gt;</operator><name>rolsuper</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up "extra" struct for assign_session_authorization to use */</comment>
	<expr_stmt><expr><name>myextra</name> <operator>=</operator> <operator>(</operator><name>role_auth_extra</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>role_auth_extra</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>myextra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>myextra</name><operator>-&gt;</operator><name>roleid</name></name> <operator>=</operator> <name>roleid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myextra</name><operator>-&gt;</operator><name>is_superuser</name></name> <operator>=</operator> <name>is_superuser</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>myextra</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_session_authorization</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>role_auth_extra</name> <modifier>*</modifier></type><name>myextra</name> <init>= <expr><operator>(</operator><name>role_auth_extra</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do nothing for the boot_val default of NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>myextra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetSessionAuthorization</name><argument_list>(<argument><expr><name><name>myextra</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>, <argument><expr><name><name>myextra</name><operator>-&gt;</operator><name>is_superuser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SET ROLE
 *
 * The SQL spec requires "SET ROLE NONE" to unset the role, so we hardwire
 * a translation of "none" to InvalidOid.  Otherwise this is much like
 * SET SESSION AUTHORIZATION.
 */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>role_string</name></decl>;</decl_stmt>		<comment type="block">/* in guc.c */</comment>

<function><type><name>bool</name></type>
<name>check_role</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>roleTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_superuser</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>role_auth_extra</name> <modifier>*</modifier></type><name>myextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>roleform</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* hardwired translation */</comment>
		<expr_stmt><expr><name>roleid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_superuser</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Can't do catalog lookups, so fail.  The result of this is that
			 * role cannot be set in postgresql.conf, which seems like a good
			 * thing anyway, so we don't work hard to avoid it.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * When source == PGC_S_TEST, we don't throw a hard error for a
		 * nonexistent user name or insufficient privileges, only a NOTICE.
		 * See comments in guc.h.
		 */</comment>

		<comment type="block">/* Look up the username */</comment>
		<expr_stmt><expr><name>roleTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_TEST</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role \"%s\" does not exist"</literal></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"role \"%s\" does not exist"</literal></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>roleform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>roleid</name> <operator>=</operator> <name><name>roleform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_superuser</name> <operator>=</operator> <name><name>roleform</name><operator>-&gt;</operator><name>rolsuper</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Verify that session user is allowed to become this role, but skip
		 * this in parallel mode, where we must blindly recreate the parallel
		 * leader's state.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>InitializingParallelWorker</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_TEST</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission will be denied to set role \"%s\""</literal></expr></argument>,
								<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>GUC_check_errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to set role \"%s\""</literal></expr></argument>,
							 <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Set up "extra" struct for assign_role to use */</comment>
	<expr_stmt><expr><name>myextra</name> <operator>=</operator> <operator>(</operator><name>role_auth_extra</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>role_auth_extra</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>myextra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>myextra</name><operator>-&gt;</operator><name>roleid</name></name> <operator>=</operator> <name>roleid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myextra</name><operator>-&gt;</operator><name>is_superuser</name></name> <operator>=</operator> <name>is_superuser</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>myextra</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_role</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>role_auth_extra</name> <modifier>*</modifier></type><name>myextra</name> <init>= <expr><operator>(</operator><name>role_auth_extra</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetCurrentRoleId</name><argument_list>(<argument><expr><name><name>myextra</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>, <argument><expr><name><name>myextra</name><operator>-&gt;</operator><name>is_superuser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_role</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Check whether SET ROLE is active; if not return "none".  This is a
	 * kluge to deal with the fact that SET SESSION AUTHORIZATION logically
	 * resets SET ROLE to NONE, but we cannot set the GUC role variable from
	 * assign_session_authorization (because we haven't got enough info to
	 * call set_config_option).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>GetCurrentRoleId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"none"</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise we can just use the GUC string */</comment>
	<return>return <expr><ternary><condition><expr><name>role_string</name></expr> ?</condition><then> <expr><name>role_string</name></expr> </then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
</unit>
