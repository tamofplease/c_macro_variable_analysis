<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/commands/aggregatecmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * aggregatecmds.c
 *
 *	  Routines for aggregate-manipulation commands
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/aggregatecmds.c
 *
 * DESCRIPTION
 *	  The "DefineFoo" routines take the parse tree and pick out the
 *	  appropriate arguments/flags, passing the results to the
 *	  corresponding "FooDefine" routines (in src/catalog) that do
 *	  the actual catalog-munging.  These routines also verify permission
 *	  of the user to execute the command.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>extractModify</name><parameter_list>(<parameter><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	DefineAggregate
 *
 * "oldstyle" signals the old (pre-8.2) style where the aggregate input type
 * is specified by a BASETYPE element in the parameters.  Otherwise,
 * "args" is a pair, whose first element is a list of FunctionParameter structs
 * defining the agg's arguments (both direct and aggregated), and whose second
 * element is an Integer node with the number of direct args, or -1 if this
 * isn't an ordered-set aggregate.
 * "parameters" is a list of DefElem representing the agg's definition clauses.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineAggregate</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>oldstyle</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parameters</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aggName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aggNamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>aggKind</name> <init>= <expr><name>AGGKIND_NORMAL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>transfuncName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>finalfuncName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>combinefuncName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>serialfuncName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>deserialfuncName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>mtransfuncName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>minvtransfuncName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>mfinalfuncName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>finalfuncExtraArgs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mfinalfuncExtraArgs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>finalfuncModify</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>mfinalfuncModify</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortoperatorName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>baseType</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>transType</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>mtransType</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>transSpace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>mtransSpace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>initval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>minitval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>parallel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numArgs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numDirectArgs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>parameterTypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>allParameterTypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>parameterModes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>parameterNames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parameterDefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>variadicArgType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>transTypeId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>mtransTypeId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>transTypeType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>mtransTypeType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>proparallel</name> <init>= <expr><name>PROPARALLEL_UNSAFE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pl</name></decl>;</decl_stmt>

	<comment type="block">/* Convert list of names to a name and namespace */</comment>
	<expr_stmt><expr><name>aggNamespace</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check we have creation rights in target namespace */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>aggNamespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>aggNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Deconstruct the output of the aggr_args grammar production */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oldstyle</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numDirectArgs</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>numDirectArgs</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>aggKind</name> <operator>=</operator> <name>AGGKIND_ORDERED_SET</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numDirectArgs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Examine aggregate's definition clauses */</comment>
	<macro><name>foreach</name><argument_list>(<argument>pl</argument>, <argument>parameters</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * sfunc1, stype1, and initcond1 are accepted as obsolete spellings
		 * for sfunc, stype, initcond.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sfunc"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>transfuncName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sfunc1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>transfuncName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"finalfunc"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>finalfuncName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"combinefunc"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>combinefuncName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"serialfunc"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>serialfuncName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"deserialfunc"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>deserialfuncName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"msfunc"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mtransfuncName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"minvfunc"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>minvtransfuncName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"mfinalfunc"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mfinalfuncName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"finalfunc_extra"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>finalfuncExtraArgs</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"mfinalfunc_extra"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mfinalfuncExtraArgs</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"finalfunc_modify"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>finalfuncModify</name> <operator>=</operator> <call><name>extractModify</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"mfinalfunc_modify"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mfinalfuncModify</name> <operator>=</operator> <call><name>extractModify</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sortop"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sortoperatorName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"basetype"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>baseType</name> <operator>=</operator> <call><name>defGetTypeName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"hypothetical"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>aggKind</name> <operator>==</operator> <name>AGGKIND_NORMAL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only ordered-set aggregates can be hypothetical"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>aggKind</name> <operator>=</operator> <name>AGGKIND_HYPOTHETICAL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"stype"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>transType</name> <operator>=</operator> <call><name>defGetTypeName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"stype1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>transType</name> <operator>=</operator> <call><name>defGetTypeName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sspace"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>transSpace</name> <operator>=</operator> <call><name>defGetInt32</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"mstype"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mtransType</name> <operator>=</operator> <call><name>defGetTypeName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"msspace"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mtransSpace</name> <operator>=</operator> <call><name>defGetInt32</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"initcond"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initval</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"initcond1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initval</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"minitcond"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>minitval</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"parallel"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parallel</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate attribute \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * make sure we have our required definitions
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>transType</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate stype must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>transfuncName</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate sfunc must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if mtransType is given, mtransfuncName and minvtransfuncName must be as
	 * well; if not, then none of the moving-aggregate options should have
	 * been given.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mtransType</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>mtransfuncName</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate msfunc must be specified when mstype is specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>minvtransfuncName</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate minvfunc must be specified when mstype is specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>mtransfuncName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate msfunc must not be specified without mstype"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>minvtransfuncName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate minvfunc must not be specified without mstype"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>mfinalfuncName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate mfinalfunc must not be specified without mstype"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>mtransSpace</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate msspace must not be specified without mstype"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>minitval</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate minitcond must not be specified without mstype"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Default values for modify flags can only be determined once we know the
	 * aggKind.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>finalfuncModify</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>finalfuncModify</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>aggKind</name> <operator>==</operator> <name>AGGKIND_NORMAL</name><operator>)</operator></expr> ?</condition><then> <expr><name>AGGMODIFY_READ_ONLY</name></expr> </then><else>: <expr><name>AGGMODIFY_READ_WRITE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>mfinalfuncModify</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mfinalfuncModify</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>aggKind</name> <operator>==</operator> <name>AGGKIND_NORMAL</name><operator>)</operator></expr> ?</condition><then> <expr><name>AGGMODIFY_READ_ONLY</name></expr> </then><else>: <expr><name>AGGMODIFY_READ_WRITE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * look up the aggregate's input datatype(s).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldstyle</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Old style: use basetype parameter.  This supports aggregates of
		 * zero or one input, with input type ANY meaning zero inputs.
		 *
		 * Historically we allowed the command to look like basetype = 'ANY'
		 * so we must do a case-insensitive comparison for the name ANY. Ugh.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>aggArgTypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>baseType</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate input type must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ANY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numArgs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aggArgTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>numArgs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aggArgTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>parameterTypes</name> <operator>=</operator> <call><name>buildoidvector</name><argument_list>(<argument><expr><name>aggArgTypes</name></expr></argument>, <argument><expr><name>numArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>allParameterTypes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parameterModes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parameterNames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parameterDefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>variadicArgType</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * New style: args is a list of FunctionParameters (possibly zero of
		 * 'em).  We share functioncmds.c's code for processing them.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>requiredResultType</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>baseType</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"basetype is redundant with aggregate input type specification"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>numArgs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>interpret_function_parameter_list</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><name>args</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>OBJECT_AGGREGATE</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>parameterTypes</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>allParameterTypes</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>parameterModes</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>parameterNames</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>parameterDefaults</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>variadicArgType</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>requiredResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Parameter defaults are not currently allowed by the grammar */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parameterDefaults</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* There shouldn't have been any OUT parameters, either */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>requiredResultType</name> <operator>==</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * look up the aggregate's transtype.
	 *
	 * transtype can't be a pseudo-type, since we need to be able to store
	 * values of the transtype.  However, we can allow polymorphic transtype
	 * in some cases (AggregateCreate will check).  Also, we allow "internal"
	 * for functions that want to pass pointers to private data structures;
	 * but allow that only to superusers, since you could crash the system (or
	 * worse) by connecting up incompatible internal-using functions in an
	 * aggregate.
	 */</comment>
	<expr_stmt><expr><name>transTypeId</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>transType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>transTypeType</name> <operator>=</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name>transTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>transTypeType</name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>transTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>transTypeId</name> <operator>==</operator> <name>INTERNALOID</name> <operator>&amp;&amp;</operator> <call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate transition data type cannot be %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>transTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>serialfuncName</name> <operator>&amp;&amp;</operator> <name>deserialfuncName</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Serialization is only needed/allowed for transtype INTERNAL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>transTypeId</name> <operator>!=</operator> <name>INTERNALOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"serialization functions may be specified only when the aggregate transition data type is %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>INTERNALOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>serialfuncName</name> <operator>||</operator> <name>deserialfuncName</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Cannot specify one function without the other.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must specify both or neither of serialization and deserialization functions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If a moving-aggregate transtype is specified, look that up.  Same
	 * restrictions as for transtype.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mtransType</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>mtransTypeId</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mtransType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mtransTypeType</name> <operator>=</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name>mtransTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mtransTypeType</name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>mtransTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>mtransTypeId</name> <operator>==</operator> <name>INTERNALOID</name> <operator>&amp;&amp;</operator> <call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate transition data type cannot be %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>mtransTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have an initval, and it's not for a pseudotype (particularly a
	 * polymorphic type), make sure it's acceptable to the type's input
	 * function.  We will store the initval as text, because the input
	 * function isn't necessarily immutable (consider "now" for timestamp),
	 * and we want to use the runtime not creation-time interpretation of the
	 * value.  However, if it's an incorrect value it seems much more
	 * user-friendly to complain at CREATE AGGREGATE time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>initval</name> <operator>&amp;&amp;</operator> <name>transTypeType</name> <operator>!=</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>,
					<decl><type ref="prev"/><name>typioparam</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>transTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>initval</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Likewise for moving-aggregate initval.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>minitval</name> <operator>&amp;&amp;</operator> <name>mtransTypeType</name> <operator>!=</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>,
					<decl><type ref="prev"/><name>typioparam</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>mtransTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>minitval</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>parallel</name></expr></argument>, <argument><expr><literal type="string">"safe"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>proparallel</name> <operator>=</operator> <name>PROPARALLEL_SAFE</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>parallel</name></expr></argument>, <argument><expr><literal type="string">"restricted"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>proparallel</name> <operator>=</operator> <name>PROPARALLEL_RESTRICTED</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>parallel</name></expr></argument>, <argument><expr><literal type="string">"unsafe"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>proparallel</name> <operator>=</operator> <name>PROPARALLEL_UNSAFE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"parallel\" must be SAFE, RESTRICTED, or UNSAFE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Most of the argument-checking is done inside of AggregateCreate
	 */</comment>
	<return>return <expr><call><name>AggregateCreate</name><argument_list>(<argument><expr><name>aggName</name></expr></argument>, <comment type="block">/* aggregate name */</comment>
						   <argument><expr><name>aggNamespace</name></expr></argument>,	<comment type="block">/* namespace */</comment>
						   <argument><expr><name>replace</name></expr></argument>,
						   <argument><expr><name>aggKind</name></expr></argument>,
						   <argument><expr><name>numArgs</name></expr></argument>,
						   <argument><expr><name>numDirectArgs</name></expr></argument>,
						   <argument><expr><name>parameterTypes</name></expr></argument>,
						   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>allParameterTypes</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>parameterModes</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>parameterNames</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>parameterDefaults</name></expr></argument>,
						   <argument><expr><name>variadicArgType</name></expr></argument>,
						   <argument><expr><name>transfuncName</name></expr></argument>,	<comment type="block">/* step function name */</comment>
						   <argument><expr><name>finalfuncName</name></expr></argument>,	<comment type="block">/* final function name */</comment>
						   <argument><expr><name>combinefuncName</name></expr></argument>, <comment type="block">/* combine function name */</comment>
						   <argument><expr><name>serialfuncName</name></expr></argument>,	<comment type="block">/* serial function name */</comment>
						   <argument><expr><name>deserialfuncName</name></expr></argument>,	<comment type="block">/* deserial function name */</comment>
						   <argument><expr><name>mtransfuncName</name></expr></argument>,	<comment type="block">/* fwd trans function name */</comment>
						   <argument><expr><name>minvtransfuncName</name></expr></argument>,	<comment type="block">/* inv trans function name */</comment>
						   <argument><expr><name>mfinalfuncName</name></expr></argument>,	<comment type="block">/* final function name */</comment>
						   <argument><expr><name>finalfuncExtraArgs</name></expr></argument>,
						   <argument><expr><name>mfinalfuncExtraArgs</name></expr></argument>,
						   <argument><expr><name>finalfuncModify</name></expr></argument>,
						   <argument><expr><name>mfinalfuncModify</name></expr></argument>,
						   <argument><expr><name>sortoperatorName</name></expr></argument>,	<comment type="block">/* sort operator name */</comment>
						   <argument><expr><name>transTypeId</name></expr></argument>, <comment type="block">/* transition data type */</comment>
						   <argument><expr><name>transSpace</name></expr></argument>,	<comment type="block">/* transition space */</comment>
						   <argument><expr><name>mtransTypeId</name></expr></argument>,	<comment type="block">/* transition data type */</comment>
						   <argument><expr><name>mtransSpace</name></expr></argument>, <comment type="block">/* transition space */</comment>
						   <argument><expr><name>initval</name></expr></argument>, <comment type="block">/* initial condition */</comment>
						   <argument><expr><name>minitval</name></expr></argument>,	<comment type="block">/* initial condition */</comment>
						   <argument><expr><name>proparallel</name></expr></argument>)</argument_list></call></expr>;</return>	<comment type="block">/* parallel safe? */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Convert the string form of [m]finalfunc_modify to the catalog representation
 */</comment>
<function><type><specifier>static</specifier> <name>char</name></type>
<name>extractModify</name><parameter_list>(<parameter><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"read_only"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>AGGMODIFY_READ_ONLY</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"shareable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>AGGMODIFY_SHAREABLE</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"read_write"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>AGGMODIFY_READ_WRITE</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" must be READ_ONLY, SHAREABLE, or READ_WRITE"</literal></expr></argument>,
					<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>
</unit>
