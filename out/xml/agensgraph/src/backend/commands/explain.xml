<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/agensgraph/src/backend/commands/explain.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * explain.c
 *	  Explain query execution plans
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994-5, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/commands/explain.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/createas.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/xml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash2Side.h"</cpp:file></cpp:include>


<comment type="block">/* Hook for plugins to get control in ExplainOneQuery() */</comment>
<decl_stmt><decl><type><name>ExplainOneQuery_hook_type</name></type> <name>ExplainOneQuery_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hook for plugins to get control in explain_get_index_name() */</comment>
<decl_stmt><decl><type><name>explain_get_index_name_hook_type</name></type> <name>explain_get_index_name_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* OR-able flags for ExplainXMLTag() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_OPENING</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_CLOSING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_CLOSE_IMMEDIATE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_NOWHITESPACE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainOneQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>,
							<parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
							<parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainPrintJIT</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jit_flags</name></decl></parameter>,
							<parameter><decl><type><name>JitInstrumentation</name> <modifier>*</modifier></type><name>ji</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_triggers</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>show_relname</name></decl></parameter>,
							<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>elapsed_time</name><parameter_list>(<parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>starttime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExplainPreScanNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>rels_used</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationship</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plan_name</name></decl></parameter>,
						<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_plan_tlist</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
							<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_expression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
							<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>useprefix</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_qual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
					  <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>useprefix</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_scan_qual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
						   <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
						   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_upper_qual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
							<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
							<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_sort_keys</name><parameter_list>(<parameter><decl><type><name>SortState</name> <modifier>*</modifier></type><name>sortstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
						   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_incremental_sort_keys</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>incrsortstate</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_merge_append_keys</name><parameter_list>(<parameter><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>mstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
								   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_agg_keys</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
						  <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_grouping_sets</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>Agg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_grouping_set_keys</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
								   <parameter><decl><type><name>Agg</name> <modifier>*</modifier></type><name>aggnode</name></decl></parameter>, <parameter><decl><type><name>Sort</name> <modifier>*</modifier></type><name>sortnode</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useprefix</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_group_keys</name><parameter_list>(<parameter><decl><type><name>GroupState</name> <modifier>*</modifier></type><name>gstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
							<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_sort_group_keys</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPresortedKeys</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>keycols</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_sortorder_options</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>sortexpr</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name></type> <name>sortOperator</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nullsFirst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_tablesample</name><parameter_list>(<parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_sort_info</name><parameter_list>(<parameter><decl><type><name>SortState</name> <modifier>*</modifier></type><name>sortstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_incremental_sort_info</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>incrsortstate</name></decl></parameter>,
									   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_hash_info</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>hashstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_hashagg_info</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>hashstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_tidbitmap_info</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
								<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_instrumentation_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>which</name></decl></parameter>,
									   <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_foreignscan_info</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>fsstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_eval_params</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bms_params</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>explain_get_index_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_buffer_usage</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BufferUsage</name> <modifier>*</modifier></type><name>usage</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>planning</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_wal_usage</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WalUsage</name> <modifier>*</modifier></type><name>usage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainIndexScanDetails</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>indexorderdir</name></decl></parameter>,
									<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainScanTarget</name><parameter_list>(<parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainModifyTarget</name><parameter_list>(<parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainTargetRel</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_modifytable_info</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
								  <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainMemberNodes</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>planstates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nplans</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainMissingMembers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nplans</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainSubPlans</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plans</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationship</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainCustomChildren</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>css</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ExplainWorkersState</name> <modifier>*</modifier></type><name>ExplainCreateWorkersState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_workers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainOpenWorker</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainCloseWorker</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainFlushWorkersState</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainProperty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>numeric</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainOpenSetAsideGroup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>labelname</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>labeled</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainSaveGroup</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>state_save</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainRestoreGroup</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>state_save</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainDummyGroup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>labelname</name></decl></parameter>,
							  <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainXMLTag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tagname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainIndentText</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainJSONLineEnding</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainYAMLLineStarting</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>escape_yaml</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* AgensGraph join types */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_hash2side_info</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>hashstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ExplainQuery -
 *	  execute an EXPLAIN command
 */</comment>
<function><type><name>void</name></type>
<name>ExplainQuery</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
			 <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><call><name>NewExplainState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rewritten</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>timing_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>summary_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Parse options list. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"verbose"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"costs"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"buffers"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"wal"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>wal</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"settings"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>settings</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"timing"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>timing_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"summary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>summary_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"xml"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>EXPLAIN_FORMAT_XML</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>EXPLAIN_FORMAT_JSON</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"yaml"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>EXPLAIN_FORMAT_YAML</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized value for EXPLAIN option \"%s\": \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized EXPLAIN option \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>wal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EXPLAIN option WAL requires ANALYZE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if the timing was not set explicitly, set default value */</comment>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>timing_set</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr> </then><else>: <expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* check that timing is used with EXPLAIN ANALYZE */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EXPLAIN option TIMING requires ANALYZE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if the summary was not set explicitly, set default value */</comment>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>summary_set</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name></expr> </then><else>: <expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse analysis was done already, but we still have to run the rule
	 * rewriter.  We do not do AcquireRewriteLocks: we assume the query either
	 * came straight from the parser, or suitable locks were acquired by
	 * plancache.c.
	 *
	 * Because the rewriter and planner tend to scribble on the input, we make
	 * a preliminary copy of the source querytree.  This prevents problems in
	 * the case that the EXPLAIN is in a portal or plpgsql function and is
	 * executed repeatedly.  (See also the same hack in DECLARE CURSOR and
	 * PREPARE.)  XXX FIXME someday.
	 */</comment>
	<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* emit opening boilerplate */</comment>
	<expr_stmt><expr><call><name>ExplainBeginOutput</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rewritten</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In the case of an INSTEAD NOTHING, tell at least that.  But in
		 * non-text format, the output is delimited, so this isn't necessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Query rewrites to nothing\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* Explain every plan */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rewritten</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainOneQuery</name><argument_list>(<argument><expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>,
							<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_queryEnv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Separate plans with an appropriate separator */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainSeparatePlans</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* emit closing boilerplate */</comment>
	<expr_stmt><expr><call><name>ExplainEndOutput</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* output tuples */</comment>
	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><call><name>ExplainResultDesc</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_text_output_multiline</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_text_output_oneline</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new ExplainState struct initialized with default options.
 */</comment>
<function><type><name>ExplainState</name> <modifier>*</modifier></type>
<name>NewExplainState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><operator>(</operator><name>ExplainState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExplainState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set default options (most fields can be left as zeroes). */</comment>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* Prepare output buffer. */</comment>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>es</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainResultDesc -
 *	  construct the result tupledesc for an EXPLAIN
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ExplainResultDesc</name><parameter_list>(<parameter><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result_type</name> <init>= <expr><name>TEXTOID</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check for XML format option */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"xml"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result_type</name> <operator>=</operator> <name>XMLOID</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result_type</name> <operator>=</operator> <name>JSONOID</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result_type</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<comment type="block">/* don't "break", as ExplainQuery will use the last value */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Need a tuple descriptor representing a single TEXT or XML column */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"QUERY PLAN"</literal></expr></argument>,
					   <argument><expr><name>result_type</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tupdesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainOneQuery -
 *	  print out the execution plan for one Query
 *
 * "into" is NULL unless we are explaining the contents of a CreateTableAsStmt.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainOneQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>,
				<parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
				<parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* planner will not cope with utility statements */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainOneUtility</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
						  <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if an advisor plugin is present, let it manage things */</comment>
	<if_stmt><if>if <condition>(<expr><name>ExplainOneQuery_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExplainOneQuery_hook</name>) <argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>,
								 <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>instr_time</name></type>	<name>planstart</name></decl>,
					<decl><type ref="prev"/><name>planduration</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferUsage</name></type> <name>bufusage_start</name></decl>,
					<decl><type ref="prev"/><name>bufusage</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bufusage_start</name> <operator>=</operator> <name>pgBufferUsage</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* plan the query */</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planduration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>planduration</name></expr></argument>, <argument><expr><name>planstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* calc differences of buffer counters. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BufferUsageAccumDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgBufferUsage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bufusage_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* run it (if needed) and produce output */</comment>
		<expr_stmt><expr><call><name>ExplainOnePlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>planduration</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>bufusage</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainOneUtility -
 *	  print out the execution plan for one utility statement
 *	  (In general, utility statements don't have plans, but there are some
 *	  we treat as special cases)
 *
 * "into" is NULL unless we are explaining the contents of a CreateTableAsStmt.
 *
 * This is exported because it's called back from prepare.c in the
 * EXPLAIN EXECUTE case.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainOneUtility</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>utilityStmt</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
				  <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>utilityStmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have to rewrite the contained SELECT and then pass it back to
		 * ExplainOneQuery.  It's probably not really necessary to copy the
		 * contained parsetree another time, but let's be safe.
		 */</comment>
		<decl_stmt><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>ctas</name> <init>= <expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>utilityStmt</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rewritten</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>ctas</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainOneQuery</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>rewritten</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name><name>ctas</name><operator>-&gt;</operator><name>into</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>,
						<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>DeclareCursorStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Likewise for DECLARE CURSOR.
		 *
		 * Notice that if you say EXPLAIN ANALYZE DECLARE CURSOR then we'll
		 * actually run the query.  This is different from pre-8.3 behavior
		 * but seems more useful than not running the query.  No cursor will
		 * be created, however.
		 */</comment>
		<decl_stmt><decl><type><name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>dcs</name> <init>= <expr><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator> <name>utilityStmt</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rewritten</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>dcs</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainOneQuery</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>rewritten</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>dcs</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>,
						<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainExecuteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>utilityStmt</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>,
							<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>, <argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"NOTIFY\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainDummyGroup</name><argument_list>(<argument><expr><literal type="string">"Notify"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
								   <argument><expr><literal type="string">"Utility statements have no plan structure\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainDummyGroup</name><argument_list>(<argument><expr><literal type="string">"Utility Statement"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainOnePlan -
 *		given a planned query, execute it if needed, and then print
 *		EXPLAIN output
 *
 * "into" is NULL unless we are explaining the contents of a CreateTableAsStmt,
 * in which case executing the query should result in creating that table.
 *
 * This is exported because it's called back from prepare.c in the
 * EXPLAIN EXECUTE case, and because an index advisor plugin would need
 * to call it.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainOnePlan</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
			   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>instr_time</name> <modifier>*</modifier></type><name>planduration</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>BufferUsage</name> <modifier>*</modifier></type><name>bufusage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>starttime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>totaltime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>instrument_option</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>instrument_option</name> <operator>|=</operator> <name>INSTRUMENT_TIMER</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>instrument_option</name> <operator>|=</operator> <name>INSTRUMENT_ROWS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>instrument_option</name> <operator>|=</operator> <name>INSTRUMENT_BUFFERS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>wal</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>instrument_option</name> <operator>|=</operator> <name>INSTRUMENT_WAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We always collect timing for the entire statement, even when node-level
	 * timing is off, so we don't look at es-&gt;timing here.  (We could skip
	 * this if !es-&gt;summary, but it's hardly worth the complication.)
	 */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use a snapshot with an updated command ID to ensure this query sees
	 * results of any previously executed queries.
	 */</comment>
	<expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normally we discard the query's output, but if explaining CREATE TABLE
	 * AS, we'd better use the appropriate tuple receiver.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>into</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateIntoRelDestReceiver</name><argument_list>(<argument><expr><name>into</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>None_Receiver</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Create a QueryDesc for the query */</comment>
	<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>plannedstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
								<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
								<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>instrument_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select execution options */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* default run-to-completion flags */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>=</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>into</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>|=</operator> <call><name>GetIntoRelEFlags</name><argument_list>(<argument><expr><name>into</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* call ExecutorStart to prepare the plan for execution */</comment>
	<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute the plan for statistics if asked for */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanDirection</name></type> <name>dir</name></decl>;</decl_stmt>

		<comment type="block">/* EXPLAIN ANALYZE CREATE TABLE AS WITH NO DATA is weird */</comment>
		<if_stmt><if>if <condition>(<expr><name>into</name> <operator>&amp;&amp;</operator> <name><name>into</name><operator>-&gt;</operator><name>skipData</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>NoMovementScanDirection</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* run the plan */</comment>
		<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* run cleanup too */</comment>
		<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We can't run ExecutorEnd 'till we're done printing the stats... */</comment>
		<expr_stmt><expr><name>totaltime</name> <operator>+=</operator> <call><name>elapsed_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Query"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create textual dump of plan tree */</comment>
	<expr_stmt><expr><call><name>ExplainPrintPlan</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Show buffer usage in planning */</comment>
	<if_stmt><if>if <condition>(<expr><name>bufusage</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Planning"</literal></expr></argument>, <argument><expr><literal type="string">"Planning"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>show_buffer_usage</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>bufusage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Planning"</literal></expr></argument>, <argument><expr><literal type="string">"Planning"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name> <operator>&amp;&amp;</operator> <name>planduration</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>plantime</name> <init>= <expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><operator>*</operator><name>planduration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Planning Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <name>plantime</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Print info about runtime of triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPrintTriggers</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Print info about JITing. Tied to es-&gt;costs because we don't want to
	 * display this in regression tests, as it'd cause output differences
	 * depending on build options.  Might want to separate that out from COSTS
	 * at a later stage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPrintJITSummary</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Close down the query and free resources.  Include time for this in the
	 * total execution time (although it should be pretty minimal).
	 */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We need a CCI just in case query expanded to multiple plans */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>totaltime</name> <operator>+=</operator> <call><name>elapsed_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We only report execution time if we actually ran the query (that is,
	 * the user specified ANALYZE), and if summary reporting is enabled (the
	 * user can set SUMMARY OFF to not have the timing information included in
	 * the output).  By default, ANALYZE sets SUMMARY to true.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Execution Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <name>totaltime</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
							 <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Query"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainPrintSettings -
 *    Print summary of modified settings affecting query planning.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainPrintSettings</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>gucs</name></decl>;</decl_stmt>

	<comment type="block">/* bail out if information about settings not requested */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>settings</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* request an array of relevant settings */</comment>
	<expr_stmt><expr><name>gucs</name> <operator>=</operator> <call><name>get_explain_guc_options</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Settings"</literal></expr></argument>, <argument><expr><literal type="string">"Settings"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>setting</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><name><name>gucs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>setting</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>setting</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Settings"</literal></expr></argument>, <argument><expr><literal type="string">"Settings"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

		<comment type="block">/* In TEXT mode, print nothing if there are no options */</comment>
		<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>setting</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><name><name>gucs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>setting</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>setting</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s = '%s'"</literal></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>setting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s = NULL"</literal></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Settings"</literal></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainPrintPlan -
 *	  convert a QueryDesc's plan tree to text and append it to es-&gt;str
 *
 * The caller should have set up the options fields of *es, as well as
 * initializing the output buffer es-&gt;str.  Also, output formatting state
 * such as the indent level is assumed valid.  Plan-tree-specific fields
 * in *es are initialized here.
 *
 * NB: will not work on utility statements
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPrintPlan</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>rels_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>

	<comment type="block">/* Set up ExplainState fields associated with this plan tree */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>pstmt</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainPreScanNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rels_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>rtable_names</name></name> <operator>=</operator> <call><name>select_rtable_names_for_explain</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rels_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name> <operator>=</operator> <call><name>deparse_context_for_plan_tree</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>,
													<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>printed_subplans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sometimes we mark a Gather node as "invisible", which means that it's
	 * not to be displayed in EXPLAIN output.  The purpose of this is to allow
	 * running regression tests with force_parallel_mode=regress to get the
	 * same results as running the same tests with force_parallel_mode=off.
	 * Such marking is currently only supported on a Gather at the top of the
	 * plan.  We skip that node, and we must also hide per-worker detail data
	 * further down in the plan tree.
	 */</comment>
	<expr_stmt><expr><name>ps</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>GatherState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name><name>ps</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>invisible</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ps</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>hide_workers</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ExplainNode</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If requested, include information about GUC parameters with values that
	 * don't match the built-in defaults.
	 */</comment>
	<expr_stmt><expr><call><name>ExplainPrintSettings</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainPrintTriggers -
 *	  convert a QueryDesc's trigger statistics to text and append it to
 *	  es-&gt;str
 *
 * The caller should have set up the options fields of *es, as well as
 * initializing the output buffer es-&gt;str.  Other fields in *es are
 * initialized here.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPrintTriggers</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>show_relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrels</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrootrels</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>routerels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>routerels</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_tuple_routing_result_relations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>targrels</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_trig_target_relations</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Triggers"</literal></expr></argument>, <argument><expr><literal type="string">"Triggers"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>show_relname</name> <operator>=</operator> <operator>(</operator><name>numrels</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>numrootrels</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
					<name>routerels</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name>targrels</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>nr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nr</name> <operator>&lt;</operator> <name>numrels</name></expr>;</condition> <incr><expr><name>rInfo</name><operator>++</operator></expr><operator>,</operator> <expr><name>nr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_triggers</name><argument_list>(<argument><expr><name>rInfo</name></expr></argument>, <argument><expr><name>show_relname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>nr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nr</name> <operator>&lt;</operator> <name>numrootrels</name></expr>;</condition> <incr><expr><name>rInfo</name><operator>++</operator></expr><operator>,</operator> <expr><name>nr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_triggers</name><argument_list>(<argument><expr><name>rInfo</name></expr></argument>, <argument><expr><name>show_relname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>routerels</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>report_triggers</name><argument_list>(<argument><expr><name>rInfo</name></expr></argument>, <argument><expr><name>show_relname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targrels</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>report_triggers</name><argument_list>(<argument><expr><name>rInfo</name></expr></argument>, <argument><expr><name>show_relname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Triggers"</literal></expr></argument>, <argument><expr><literal type="string">"Triggers"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainPrintJITSummary -
 *    Print summarized JIT instrumentation from leader and workers
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPrintJITSummary</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JitInstrumentation</name></type> <name>ji</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_jit_flags</name></name> <operator>&amp;</operator> <name>PGJIT_PERFORM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Work with a copy instead of modifying the leader state, since this
	 * function may be called twice
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_jit</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrJitAgg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ji</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_jit</name><operator>-&gt;</operator><name>instr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If this process has done JIT in parallel workers, merge stats */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_jit_worker_instr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrJitAgg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ji</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_jit_worker_instr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainPrintJIT</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_jit_flags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ji</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainPrintJIT -
 *	  Append information about JITing to es-&gt;str.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainPrintJIT</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jit_flags</name></decl></parameter>, <parameter><decl><type><name>JitInstrumentation</name> <modifier>*</modifier></type><name>ji</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>total_time</name></decl>;</decl_stmt>

	<comment type="block">/* don't print information if no JITing happened */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ji</name> <operator>||</operator> <name><name>ji</name><operator>-&gt;</operator><name>created_functions</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* calculate total time */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>, <argument><expr><name><name>ji</name><operator>-&gt;</operator><name>generation_counter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>, <argument><expr><name><name>ji</name><operator>-&gt;</operator><name>inlining_counter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>, <argument><expr><name><name>ji</name><operator>-&gt;</operator><name>optimization_counter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>, <argument><expr><name><name>ji</name><operator>-&gt;</operator><name>emission_counter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"JIT"</literal></expr></argument>, <argument><expr><literal type="string">"JIT"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for higher density, open code the text output format */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"JIT:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Functions"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ji</name><operator>-&gt;</operator><name>created_functions</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Options: %s %s, %s %s, %s %s, %s %s\n"</literal></expr></argument>,
						 <argument><expr><literal type="string">"Inlining"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>jit_flags</name> <operator>&amp;</operator> <name>PGJIT_INLINE</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><literal type="string">"Optimization"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>jit_flags</name> <operator>&amp;</operator> <name>PGJIT_OPT3</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><literal type="string">"Expressions"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>jit_flags</name> <operator>&amp;</operator> <name>PGJIT_EXPR</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><literal type="string">"Deforming"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>jit_flags</name> <operator>&amp;</operator> <name>PGJIT_DEFORM</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
							 <argument><expr><literal type="string">"Timing: %s %.3f ms, %s %.3f ms, %s %.3f ms, %s %.3f ms, %s %.3f ms\n"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Generation"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>ji</name><operator>-&gt;</operator><name>generation_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><literal type="string">"Inlining"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>ji</name><operator>-&gt;</operator><name>inlining_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><literal type="string">"Optimization"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>ji</name><operator>-&gt;</operator><name>optimization_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><literal type="string">"Emission"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>ji</name><operator>-&gt;</operator><name>emission_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><literal type="string">"Total"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Functions"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ji</name><operator>-&gt;</operator><name>created_functions</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Options"</literal></expr></argument>, <argument><expr><literal type="string">"Options"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Inlining"</literal></expr></argument>, <argument><expr><name>jit_flags</name> <operator>&amp;</operator> <name>PGJIT_INLINE</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Optimization"</literal></expr></argument>, <argument><expr><name>jit_flags</name> <operator>&amp;</operator> <name>PGJIT_OPT3</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Expressions"</literal></expr></argument>, <argument><expr><name>jit_flags</name> <operator>&amp;</operator> <name>PGJIT_EXPR</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Deforming"</literal></expr></argument>, <argument><expr><name>jit_flags</name> <operator>&amp;</operator> <name>PGJIT_DEFORM</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Options"</literal></expr></argument>, <argument><expr><literal type="string">"Options"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Timing"</literal></expr></argument>, <argument><expr><literal type="string">"Timing"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Generation"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>,
								 <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>ji</name><operator>-&gt;</operator><name>generation_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Inlining"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>,
								 <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>ji</name><operator>-&gt;</operator><name>inlining_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Optimization"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>,
								 <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>ji</name><operator>-&gt;</operator><name>optimization_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Emission"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>,
								 <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>ji</name><operator>-&gt;</operator><name>emission_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Total"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>,
								 <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>total_time</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Timing"</literal></expr></argument>, <argument><expr><literal type="string">"Timing"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"JIT"</literal></expr></argument>, <argument><expr><literal type="string">"JIT"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainQueryText -
 *	  add a "Query Text" node that contains the actual text of the query
 *
 * The caller should have set up the options fields of *es, as well as
 * initializing the output buffer es-&gt;str.
 *
 */</comment>
<function><type><name>void</name></type>
<name>ExplainQueryText</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Query Text"</literal></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * report_triggers -
 *		report execution stats for a single relation's triggers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_triggers</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>show_relname</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>||</operator> <operator>!</operator><name><name>rInfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>nt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nt</name> <operator>&lt;</operator> <name><name>rInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>nt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trig</name> <init>= <expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>triggers</name></name> <operator>+</operator> <name>nt</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name> <operator>+</operator> <name>nt</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>conname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Must clean up instrumentation state */</comment>
		<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We ignore triggers that were never invoked; they likely aren't
		 * relevant to the current query type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>instr</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Trigger"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>trig</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>conname</name> <operator>=</operator> <call><name>get_constraint_name</name><argument_list>(<argument><expr><name><name>trig</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In text format, we avoid printing both the trigger name and the
		 * constraint name unless VERBOSE is specified.  In non-text formats
		 * we just print everything.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name> <operator>||</operator> <name>conname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Trigger %s"</literal></expr></argument>, <argument><expr><name><name>trig</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>conname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" for constraint %s"</literal></expr></argument>, <argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>show_relname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" on %s"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">": time=%.3f calls=%.0f\n"</literal></expr></argument>,
								 <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <name><name>instr</name><operator>-&gt;</operator><name>total</name></name></expr></argument>, <argument><expr><name><name>instr</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">": calls=%.0f\n"</literal></expr></argument>, <argument><expr><name><name>instr</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Trigger Name"</literal></expr></argument>, <argument><expr><name><name>trig</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>conname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Constraint Name"</literal></expr></argument>, <argument><expr><name>conname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Relation"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <name><name>instr</name><operator>-&gt;</operator><name>total</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
									 <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Calls"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>instr</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>conname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Trigger"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Compute elapsed time in seconds since given timestamp */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>elapsed_time</name><parameter_list>(<parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>starttime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>endtime</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>, <argument><expr><operator>*</operator><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainPreScanNode -
 *	  Prescan the planstate tree to identify which RTEs are referenced
 *
 * Adds the relid of each referenced RTE to *rels_used.  The result controls
 * which RTEs are assigned aliases by select_rtable_names_for_explain.
 * This ensures that we don't confusingly assign un-suffixed aliases to RTEs
 * that never appear in the EXPLAIN output (such as inheritance parents).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExplainPreScanNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>rels_used</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>rels_used</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>rels_used</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>rels_used</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><operator>*</operator><name>rels_used</name></expr></argument>,
										 <argument><expr><operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>fs_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>rels_used</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><operator>*</operator><name>rels_used</name></expr></argument>,
										 <argument><expr><operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>custom_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>rels_used</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>rels_used</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>nominalRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>exclRelRTI</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>rels_used</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>rels_used</name></expr></argument>,
											<argument><expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>exclRelRTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Append</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>rels_used</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><operator>*</operator><name>rels_used</name></expr></argument>,
										 <argument><expr><operator>(</operator><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>apprelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>rels_used</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><operator>*</operator><name>rels_used</name></expr></argument>,
										 <argument><expr><operator>(</operator><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>apprelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExplainPreScanNode</name></expr></argument>, <argument><expr><name>rels_used</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExplainNode -
 *	  Appends a description of a plan tree to es-&gt;str
 *
 * planstate points to the executor state node for the current plan node.
 * We need to work from a PlanState node, not just a Plan node, in order to
 * get at the instrumentation data (if any) as well as the list of subplans.
 *
 * ancestors is a list of parent Plan and SubPlan nodes, most-closely-nested
 * first.  These are needed in order to interpret PARAM_EXEC Params.
 *
 * relationship describes the relationship of this plan node to its parent
 * (eg, "Outer", "Inner"); it can be null at top level.  plan_name is an
 * optional name to be attached to the node.
 *
 * In text format, es-&gt;indent is controlled in this function since we only
 * want it to change at plan-node boundaries (but a few subroutines will
 * transiently increment it).  In non-text formats, es-&gt;indent corresponds
 * to the nesting depth of logical output groups, and therefore is controlled
 * by ExplainOpenGroup/ExplainCloseGroup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationship</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plan_name</name></decl></parameter>,
			<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pname</name></decl>;</decl_stmt>			<comment type="block">/* node type name for text output */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl>;</decl_stmt>			<comment type="block">/* node type name for non-text output */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strategy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>partialmode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>custom_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExplainWorkersState</name> <modifier>*</modifier></type><name>save_workers_state</name> <init>= <expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_indent</name> <init>= <expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haschildren</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Prepare per-worker output buffers, if needed.  We'll append the data in
	 * these to the main output string further down.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>hide_workers</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name> <operator>=</operator> <call><name>ExplainCreateWorkersState</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Identify plan node type, and print generic details */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Result"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ProjectSet</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"ProjectSet"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">"ModifyTable"</literal></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>operation</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>operation</name> <operator>=</operator> <literal type="string">"Insert"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>operation</name> <operator>=</operator> <literal type="string">"Update"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_DELETE</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>operation</name> <operator>=</operator> <literal type="string">"Delete"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>T_Append</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Append"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Merge Append"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Recursive Union"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"BitmapAnd"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"BitmapOr"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
		<case>case <expr><name>T_NestLoopVLE</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Nested Loop"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Merge"</literal></expr>;</expr_stmt>	<comment type="block">/* "Join" gets added by jointype switch */</comment>
			<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">"Merge Join"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Hash"</literal></expr>;</expr_stmt>		<comment type="block">/* "Join" gets added by jointype switch */</comment>
			<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">"Hash Join"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Seq Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Sample Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Gather</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Gather"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GatherMerge</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Gather Merge"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Index Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Index Only Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Bitmap Index Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Bitmap Heap Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Tid Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Subquery Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Function Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Table Function Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Values Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"CTE Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Named Tuplestore Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"WorkTable Scan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">"Foreign Scan"</literal></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>operation</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_SELECT</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Foreign Scan"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Select"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Foreign Insert"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Insert"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Foreign Update"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Update"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_DELETE</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Foreign Delete"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Delete"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">"Custom Scan"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>custom_name</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>methods</name><operator>-&gt;</operator><name>CustomName</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>custom_name</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Custom Scan (%s)"</literal></expr></argument>, <argument><expr><name>custom_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Material</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Materialize"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Sort</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Sort"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IncrementalSort</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Incremental Sort"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Group</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Group"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Agg</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">"Aggregate"</literal></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>AGG_PLAIN</name></expr>:</case>
						<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Aggregate"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>strategy</name> <operator>=</operator> <literal type="string">"Plain"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AGG_SORTED</name></expr>:</case>
						<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"GroupAggregate"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>strategy</name> <operator>=</operator> <literal type="string">"Sorted"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AGG_HASHED</name></expr>:</case>
						<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"HashAggregate"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>strategy</name> <operator>=</operator> <literal type="string">"Hashed"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AGG_MIXED</name></expr>:</case>
						<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"MixedAggregate"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>strategy</name> <operator>=</operator> <literal type="string">"Mixed"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Aggregate ???"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>strategy</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>

				<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>partialmode</name> <operator>=</operator> <literal type="string">"Partial"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>partialmode</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>partialmode</name> <operator>=</operator> <literal type="string">"Finalize"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>partialmode</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>partialmode</name> <operator>=</operator> <literal type="string">"Simple"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"WindowAgg"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Unique</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Unique"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
			<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">"SetOp"</literal></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>strategy</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>SETOP_SORTED</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"SetOp"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <literal type="string">"Sorted"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>SETOP_HASHED</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"HashSetOp"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <literal type="string">"Hashed"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"SetOp ???"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>T_LockRows</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"LockRows"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Limit</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Limit"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Hash</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Hash"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ModifyGraph</name></expr>:</case>
			<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">"ModifyGraph"</literal></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>operation</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>GWROP_CREATE</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Graph Create"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Create"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>GWROP_DELETE</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Graph Delete"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Delete"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>GWROP_SET</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Graph Set"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Set"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>GWROP_MERGE</name></expr>:</case>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Graph Merge"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Merge"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>pname</name> <operator>=</operator> <literal type="string">"Graph ???"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>T_Shortestpath</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Shortestpath</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>limit</name> <operator>==</operator> <name>LONG_MAX</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"All Shortestpaths"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Shortestpath"</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Hash2Side</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Hash2Side"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Dijkstra</name></expr>:</case>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"Dijkstra"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>pname</name> <operator>=</operator> <name>sname</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Plan"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>relationship</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><literal type="string">"Plan"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>plan_name</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>plan_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"-&gt;  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Parallel "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Node Type"</literal></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strategy</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Strategy"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>partialmode</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Partial Mode"</literal></expr></argument>, <argument><expr><name>partialmode</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>operation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Operation"</literal></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>relationship</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Parent Relationship"</literal></expr></argument>, <argument><expr><name>relationship</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>plan_name</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Subplan Name"</literal></expr></argument>, <argument><expr><name>plan_name</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>custom_name</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Custom Plan Provider"</literal></expr></argument>, <argument><expr><name>custom_name</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Parallel Aware"</literal></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainScanTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainScanTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>indexscan</name> <init>= <expr><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExplainIndexScanDetails</name><argument_list>(<argument><expr><name><name>indexscan</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>,
										<argument><expr><name><name>indexscan</name><operator>-&gt;</operator><name>indexorderdir</name></name></expr></argument>,
										<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainScanTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>indexscan</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>indexonlyscan</name> <init>= <expr><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExplainIndexScanDetails</name><argument_list>(<argument><expr><name><name>indexonlyscan</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>,
										<argument><expr><name><name>indexonlyscan</name><operator>-&gt;</operator><name>indexorderdir</name></name></expr></argument>,
										<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainScanTarget</name><argument_list>(<argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>indexonlyscan</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>bitmapindexscan</name> <init>= <expr><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexname</name> <init>=
				<expr><call><name>explain_get_index_name</name><argument_list>(<argument><expr><name><name>bitmapindexscan</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" on %s"</literal></expr></argument>,
									 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Index Name"</literal></expr></argument>, <argument><expr><name>indexname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainModifyTarget</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ModifyGraph</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ModifyGraph</name> <modifier>*</modifier></type><name>modifygraph</name> <init>= <expr><operator>(</operator><name>ModifyGraph</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>modifygraph</name><operator>-&gt;</operator><name>eagerness</name></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" eager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Shortestpath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Shortestpath</name> <modifier>*</modifier></type><name>shortestpath</name> <init>= <expr><operator>(</operator><name>Shortestpath</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" VLE [%ld.."</literal></expr></argument>, <argument><expr><name><name>shortestpath</name><operator>-&gt;</operator><name>minhops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>shortestpath</name><operator>-&gt;</operator><name>maxhops</name></name> <operator>!=</operator> <name>LONG_MAX</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%ld]"</literal></expr></argument>, <argument><expr><name><name>shortestpath</name><operator>-&gt;</operator><name>maxhops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
		<case>case <expr><name>T_NestLoopVLE</name></expr>:</case>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>jointype</name></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>jointype</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>JOIN_INNER</name></expr>:</case>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"Inner"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"Left"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>JOIN_FULL</name></expr>:</case>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"Full"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"Right"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"Semi"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"Anti"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>JOIN_CYPHER_MERGE</name></expr>:</case>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"CypherMerge"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>JOIN_CYPHER_DELETE</name></expr>:</case>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"CypherDelete"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>JOIN_VLE</name></expr>:</case>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"VLE"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * For historical reasons, the join type is interpolated
					 * into the node type name...
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>jointype</name> <operator>==</operator> <name>JOIN_VLE</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>NestLoopVLE</name> <modifier>*</modifier></type><name>nlvPlan</name> <init>= <expr><operator>(</operator><name>NestLoopVLE</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" %s [%d.."</literal></expr></argument>,
										 <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name><name>nlvPlan</name><operator>-&gt;</operator><name>minHops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>nlvPlan</name><operator>-&gt;</operator><name>maxHops</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%d]"</literal></expr></argument>, <argument><expr><name><name>nlvPlan</name><operator>-&gt;</operator><name>maxHops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>jointype</name> <operator>!=</operator> <name>JOIN_INNER</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" %s Join"</literal></expr></argument>, <argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" Join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Join Type"</literal></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>setopcmd</name></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>cmd</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>SETOPCMD_INTERSECT</name></expr>:</case>
						<expr_stmt><expr><name>setopcmd</name> <operator>=</operator> <literal type="string">"Intersect"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SETOPCMD_INTERSECT_ALL</name></expr>:</case>
						<expr_stmt><expr><name>setopcmd</name> <operator>=</operator> <literal type="string">"Intersect All"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SETOPCMD_EXCEPT</name></expr>:</case>
						<expr_stmt><expr><name>setopcmd</name> <operator>=</operator> <literal type="string">"Except"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SETOPCMD_EXCEPT_ALL</name></expr>:</case>
						<expr_stmt><expr><name>setopcmd</name> <operator>=</operator> <literal type="string">"Except All"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><name>setopcmd</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>setopcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Command"</literal></expr></argument>, <argument><expr><name>setopcmd</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  (cost=%.2f..%.2f rows=%.0f width=%d)"</literal></expr></argument>,
							 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
							 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Startup Cost"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
								 <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Total Cost"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
								 <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Plan Rows"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Plan Width"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>,
								   <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have to forcibly clean up the instrumentation state because we
	 * haven't done ExecutorEnd yet.  This is pretty grotty ...
	 *
	 * Note: contrib/auto_explain could cause instrumentation to be set up
	 * even though we didn't ask for it here.  Be careful not to print any
	 * instrumentation results the user didn't ask for.  But we do the
	 * InstrEndLoop call anyway, if possible, to reduce the number of cases
	 * auto_explain has to contend with.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator>
		<name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>nloops</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>nloops</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>nloops</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>startup_ms</name> <init>= <expr><literal type="number">1000.0</literal> <operator>*</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>startup</name></name> <operator>/</operator> <name>nloops</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>total_ms</name> <init>= <expr><literal type="number">1000.0</literal> <operator>*</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>total</name></name> <operator>/</operator> <name>nloops</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>rows</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>/</operator> <name>nloops</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
								 <argument><expr><literal type="string">" (actual time=%.3f..%.3f rows=%.0f loops=%.0f)"</literal></expr></argument>,
								 <argument><expr><name>startup_ms</name></expr></argument>, <argument><expr><name>total_ms</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>nloops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
								 <argument><expr><literal type="string">" (actual rows=%.0f loops=%.0f)"</literal></expr></argument>,
								 <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>nloops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Startup Time"</literal></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>, <argument><expr><name>startup_ms</name></expr></argument>,
									 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Total Time"</literal></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>, <argument><expr><name>total_ms</name></expr></argument>,
									 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Rows"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Loops"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nloops</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" (never executed)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Startup Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Total Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Rows"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Loops"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* in text format, first line ends here */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* prepare per-worker general execution details */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerInstrumentation</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>w</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instrument</name> <init>= <expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>instrument</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>nloops</name> <init>= <expr><name><name>instrument</name><operator>-&gt;</operator><name>nloops</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>startup_ms</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>total_ms</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>rows</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>nloops</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>startup_ms</name> <operator>=</operator> <literal type="number">1000.0</literal> <operator>*</operator> <name><name>instrument</name><operator>-&gt;</operator><name>startup</name></name> <operator>/</operator> <name>nloops</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>total_ms</name> <operator>=</operator> <literal type="number">1000.0</literal> <operator>*</operator> <name><name>instrument</name><operator>-&gt;</operator><name>total</name></name> <operator>/</operator> <name>nloops</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rows</name> <operator>=</operator> <name><name>instrument</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>/</operator> <name>nloops</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExplainOpenWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
									 <argument><expr><literal type="string">"actual time=%.3f..%.3f rows=%.0f loops=%.0f\n"</literal></expr></argument>,
									 <argument><expr><name>startup_ms</name></expr></argument>, <argument><expr><name>total_ms</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>nloops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
									 <argument><expr><literal type="string">"actual rows=%.0f loops=%.0f\n"</literal></expr></argument>,
									 <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>nloops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Startup Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>,
										 <argument><expr><name>startup_ms</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Total Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>,
										 <argument><expr><name>total_ms</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Rows"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Actual Loops"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nloops</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>ExplainCloseWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* target list */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>show_plan_tlist</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* unique join */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<comment type="block">/* try not to be too chatty about this in text mode */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name> <operator>||</operator>
				<operator>(</operator><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>inner_unique</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Inner Unique"</literal></expr></argument>,
									<argument><expr><operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>inner_unique</name></expr></argument>,
									<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* quals, sort keys, etc */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqualorig</name></expr></argument>,
						   <argument><expr><literal type="string">"Index Cond"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqualorig</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Index Recheck"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexorderbyorig</name></expr></argument>,
						   <argument><expr><literal type="string">"Order By"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
						   <argument><expr><literal type="string">"Index Cond"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>recheckqual</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Index Recheck"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexorderby</name></expr></argument>,
						   <argument><expr><literal type="string">"Order By"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Heap Fetches"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>ntuples2</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqualorig</name></expr></argument>,
						   <argument><expr><literal type="string">"Index Cond"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>bitmapqualorig</name></expr></argument>,
						   <argument><expr><literal type="string">"Recheck Cond"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>bitmapqualorig</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Index Recheck"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_tidbitmap_info</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<expr_stmt><expr><call><name>show_tablesample</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SampleScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tablesample</name></expr></argument>,
							 <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* fall through to print additional fields the same as SeqScan */</comment>
			<comment type="block">/* FALLTHROUGH */</comment>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Gather</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Gather</name>	   <modifier>*</modifier></type><name>gather</name> <init>= <expr><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Workers Planned"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name><name>gather</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Show params evaluated at gather node */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>gather</name><operator>-&gt;</operator><name>initParam</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>show_eval_params</name><argument_list>(<argument><expr><name><name>gather</name><operator>-&gt;</operator><name>initParam</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>nworkers</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>nworkers_launched</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Workers Launched"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>nworkers</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>gather</name><operator>-&gt;</operator><name>single_copy</name></name> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Single Copy"</literal></expr></argument>, <argument><expr><name><name>gather</name><operator>-&gt;</operator><name>single_copy</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_GatherMerge</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GatherMerge</name> <modifier>*</modifier></type><name>gm</name> <init>= <expr><operator>(</operator><name>GatherMerge</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Workers Planned"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name><name>gm</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Show params evaluated at gather-merge node */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>gm</name><operator>-&gt;</operator><name>initParam</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>show_eval_params</name><argument_list>(<argument><expr><name><name>gm</name><operator>-&gt;</operator><name>initParam</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>nworkers</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>nworkers_launched</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Workers Launched"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>nworkers</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fexprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((FunctionScan *) plan)-&gt;functions</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>fexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fexprs</name></expr></argument>, <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<comment type="block">/* We rely on show_expression to insert commas as needed */</comment>
				<expr_stmt><expr><call><name>show_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fexprs</name></expr></argument>,
								<argument><expr><literal type="string">"Function Call"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>,
								<argument><expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>tablefunc</name> <init>= <expr><operator>(</operator><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tablefunc</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>show_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tablefunc</name></expr></argument>,
								<argument><expr><literal type="string">"Table Function Call"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>,
								<argument><expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * The tidquals list has OR semantics, so be sure to show it
				 * as an OR condition.
				 */</comment>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tidquals</name> <init>= <expr><operator>(</operator><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tidquals</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tidquals</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>, <argument><expr><literal type="string">"TID Cond"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_foreignscan_info</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>css</name> <init>= <expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>show_scan_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>css</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>ExplainCustomScan</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>css</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>ExplainCustomScan</name></name><argument_list>(<argument><expr><name>css</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>,
							<argument><expr><literal type="string">"Join Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>joinqual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Join Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NestLoopVLE</name></expr>:</case>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>NestLoopVLE</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>nl</name><operator>.</operator><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>,
							<argument><expr><literal type="string">"Join Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>NestLoopVLE</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>nl</name><operator>.</operator><name>join</name><operator>.</operator><name>joinqual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Join Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>mergeclauses</name></expr></argument>,
							<argument><expr><literal type="string">"Merge Cond"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>,
							<argument><expr><literal type="string">"Join Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>joinqual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Join Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>hashclauses</name></expr></argument>,
							<argument><expr><literal type="string">"Hash Cond"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>,
							<argument><expr><literal type="string">"Join Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>joinqual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Join Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Shortestpath</name></expr>:</case>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Shortestpath</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>hashclauses</name></expr></argument>,
							<argument><expr><literal type="string">"Hash Cond"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Shortestpath</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>joinqual</name></name></expr></argument>,
							<argument><expr><literal type="string">"Join Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Shortestpath</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>joinqual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Join Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Agg</name></expr>:</case>
			<expr_stmt><expr><call><name>show_agg_keys</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>AggState</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_hashagg_info</name><argument_list>(<argument><expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Group</name></expr>:</case>
			<expr_stmt><expr><call><name>show_group_keys</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>GroupState</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Sort</name></expr>:</case>
			<expr_stmt><expr><call><name>show_sort_keys</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>SortState</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_sort_info</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>SortState</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IncrementalSort</name></expr>:</case>
			<expr_stmt><expr><call><name>show_incremental_sort_keys</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>IncrementalSortState</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_incremental_sort_info</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>IncrementalSortState</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<expr_stmt><expr><call><name>show_merge_append_keys</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppendState</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>resconstantqual</name></expr></argument>,
							<argument><expr><literal type="string">"One-Time Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><literal type="string">"Filter"</literal></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<expr_stmt><expr><call><name>show_modifytable_info</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>,
								  <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Hash</name></expr>:</case>
			<expr_stmt><expr><call><name>show_hash_info</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>HashState</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Hash2Side</name></expr>:</case>
			<expr_stmt><expr><call><name>show_hash2side_info</name><argument_list>(<argument><expr><operator>(</operator><name>Hash2SideState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Prepare per-worker JIT instrumentation.  As with the overall JIT
	 * summary, this is printed only if printing costs is enabled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>costs</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SharedJitInstrumentation</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_jit_instrument</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>w</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainOpenWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPrintJIT</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_jit_flags</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>jit_instr</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainCloseWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Show buffer/WAL usage */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>show_buffer_usage</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>bufusage</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>wal</name></name> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>show_wal_usage</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>walusage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare per-worker buffer/WAL usage */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>wal</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerInstrumentation</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>w</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instrument</name> <init>= <expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>instrument</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>nloops</name> <init>= <expr><name><name>instrument</name><operator>-&gt;</operator><name>nloops</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>nloops</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ExplainOpenWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_buffer_usage</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>instrument</name><operator>-&gt;</operator><name>bufusage</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>wal</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>show_wal_usage</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>instrument</name><operator>-&gt;</operator><name>walusage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ExplainCloseWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Show per-worker details for this plan node, then pop that stack */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainFlushWorkersState</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name> <operator>=</operator> <name>save_workers_state</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If partition pruning was done during executor initialization, the
	 * number of child plans we'll display below will be less than the number
	 * of subplans that was specified in the plan.  To make this a bit less
	 * mysterious, emit an indication that this happened.  Note that this
	 * field is emitted now because we want it to be a property of the parent
	 * node; it *cannot* be emitted within the Plans sub-node we'll open next.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Append</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainMissingMembers</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>as_nplans</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>appendplans</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainMissingMembers</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>ms_nplans</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>mergeplans</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Get ready to display the child plans */</comment>
	<expr_stmt><expr><name>haschildren</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>||</operator>
		<call><name>outerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>innerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>CustomScanState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		 <operator>(</operator><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>custom_ps</name> <operator>!=</operator> <name>NIL</name><operator>)</operator> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ModifyGraph</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>planstate</name><operator>-&gt;</operator><name>subPlan</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>haschildren</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Plans"</literal></expr></argument>, <argument><expr><literal type="string">"Plans"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Pass current Plan as head of ancestors list for children */</comment>
		<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* initPlan-s */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>initPlan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainSubPlans</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><literal type="string">"InitPlan"</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* lefttree */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>,
					<argument><expr><literal type="string">"Outer"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* righttree */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainNode</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>,
					<argument><expr><literal type="string">"Inner"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* special child plans */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainMemberNodes</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>mt_plans</name></expr></argument>,
							   <argument><expr><operator>(</operator><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>mt_nplans</name></expr></argument>,
							   <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Append</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainMemberNodes</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>appendplans</name></expr></argument>,
							   <argument><expr><operator>(</operator><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>as_nplans</name></expr></argument>,
							   <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainMemberNodes</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>mergeplans</name></expr></argument>,
							   <argument><expr><operator>(</operator><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>ms_nplans</name></expr></argument>,
							   <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainMemberNodes</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>,
							   <argument><expr><operator>(</operator><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>nplans</name></expr></argument>,
							   <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainMemberNodes</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>,
							   <argument><expr><operator>(</operator><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>nplans</name></expr></argument>,
							   <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>,
						<argument><expr><literal type="string">"Subquery"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainCustomChildren</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
								  <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ModifyGraph</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ModifyGraphState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>,
						<argument><expr><literal type="string">"Subquery"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* subPlan-s */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>subPlan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainSubPlans</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>subPlan</name></name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><literal type="string">"SubPlan"</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* end of child plans */</comment>
	<if_stmt><if>if <condition>(<expr><name>haschildren</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Plans"</literal></expr></argument>, <argument><expr><literal type="string">"Plans"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* in text format, undo whatever indentation we added */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>=</operator> <name>save_indent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Plan"</literal></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>relationship</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><literal type="string">"Plan"</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show the targetlist of a plan node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_plan_tlist</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* No work if empty tlist (this occurs eg in bitmap indexscans) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* The tlist of an Append isn't real helpful, so suppress it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Likewise for MergeAppend and RecursiveUnion */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>RecursiveUnion</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Likewise for ForeignScan that executes a direct INSERT/UPDATE/DELETE
	 *
	 * Note: the tlist for a ForeignScan that executes a direct INSERT/UPDATE
	 * might contain subplan output expressions that are confusing in this
	 * context.  The tlist for a ForeignScan that executes a direct UPDATE/
	 * DELETE always contains "junk" target columns to identify the exact row
	 * to update or delete, which would be confusing in this context.  So, we
	 * suppress it in all the cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>operation</name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Set up deparsing context */</comment>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>set_deparse_context_plan</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name></expr></argument>,
									   <argument><expr><name>plan</name></expr></argument>,
									   <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>useprefix</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Deparse each result column (we now include resjunk ones) */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
											<argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Print results */</comment>
	<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><literal type="string">"Output"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show a generic expression
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_expression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
				<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>useprefix</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprstr</name></decl>;</decl_stmt>

	<comment type="block">/* Set up deparsing context */</comment>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>set_deparse_context_plan</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name></expr></argument>,
									   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
									   <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse the expression */</comment>
	<expr_stmt><expr><name>exprstr</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And add to es-&gt;str */</comment>
	<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>exprstr</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show a qualifier expression (which is a List with implicit AND semantics)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_qual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
		  <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>useprefix</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<comment type="block">/* No work if empty qual */</comment>
	<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Convert AND list to explicit AND */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And show it */</comment>
	<expr_stmt><expr><call><name>show_expression</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show a qualifier expression for a scan plan node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_scan_qual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
			   <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
			   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useprefix</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>useprefix</name> <operator>=</operator> <operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show_qual</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show a qualifier expression for an upper-level plan node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_upper_qual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
				<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
				<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useprefix</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>useprefix</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show_qual</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show the sort keys for a Sort node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_sort_keys</name><parameter_list>(<parameter><decl><type><name>SortState</name> <modifier>*</modifier></type><name>sortstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Sort</name> <operator>*</operator><operator>)</operator> <name><name>sortstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>show_sort_group_keys</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>sortstate</name></expr></argument>, <argument><expr><literal type="string">"Sort Key"</literal></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>,
						 <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show the sort keys for a IncrementalSort node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_incremental_sort_keys</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>incrsortstate</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IncrementalSort</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>IncrementalSort</name> <operator>*</operator><operator>)</operator> <name><name>incrsortstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>show_sort_group_keys</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>incrsortstate</name></expr></argument>, <argument><expr><literal type="string">"Sort Key"</literal></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>numCols</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nPresortedCols</name></name></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>sortColIdx</name></name></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>sortOperators</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>collations</name></name></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>nullsFirst</name></name></expr></argument>,
						 <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Likewise, for a MergeAppend node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_merge_append_keys</name><parameter_list>(<parameter><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>mstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
					   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name><name>mstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>show_sort_group_keys</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>mstate</name></expr></argument>, <argument><expr><literal type="string">"Sort Key"</literal></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>,
						 <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show the grouping keys for an Agg node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_agg_keys</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
			  <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name><name>astate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>numCols</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>plan</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* The key columns refer to the tlist of the child plan */</comment>
		<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>show_grouping_sets</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>astate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>show_sort_group_keys</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>astate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Group Key"</literal></expr></argument>,
								 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>grpColIdx</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_grouping_sets</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>Agg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Set up deparsing context */</comment>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>set_deparse_context_plan</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name></expr></argument>,
									   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
									   <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>useprefix</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Grouping Sets"</literal></expr></argument>, <argument><expr><literal type="string">"Grouping Sets"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>show_grouping_set_keys</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>agg-&gt;chain</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>aggnode</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>sortnode</name> <init>= <expr><operator>(</operator><name>Sort</name> <operator>*</operator><operator>)</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>show_grouping_set_keys</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>aggnode</name></expr></argument>, <argument><expr><name>sortnode</name></expr></argument>,
							   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Grouping Sets"</literal></expr></argument>, <argument><expr><literal type="string">"Grouping Sets"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_grouping_set_keys</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
					   <parameter><decl><type><name>Agg</name> <modifier>*</modifier></type><name>aggnode</name></decl></parameter>, <parameter><decl><type><name>Sort</name> <modifier>*</modifier></type><name>sortnode</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useprefix</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gsets</name> <init>= <expr><name><name>aggnode</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>keycols</name> <init>= <expr><name><name>aggnode</name><operator>-&gt;</operator><name>grpColIdx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keysetname</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name> <operator>||</operator> <name><name>aggnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_MIXED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>keyname</name> <operator>=</operator> <literal type="string">"Hash Key"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>keysetname</name> <operator>=</operator> <literal type="string">"Hash Keys"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>keyname</name> <operator>=</operator> <literal type="string">"Group Key"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>keysetname</name> <operator>=</operator> <literal type="string">"Group Keys"</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Grouping Set"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sortnode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>show_sort_group_keys</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><literal type="string">"Sort Key"</literal></expr></argument>,
							 <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
							 <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>, <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
							 <argument><expr><name><name>sortnode</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>,
							 <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><name>keysetname</name></expr></argument>, <argument><expr><name>keysetname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gsets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>(List *) lfirst(lc)</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type>		<name>i</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>keyresno</name> <init>= <expr><name><name>keycols</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
												   <argument><expr><name>keyresno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no tlist entry for key %d"</literal></expr></argument>, <argument><expr><name>keyresno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Deparse the expression, showing any top-level cast */</comment>
			<expr_stmt><expr><name>exprstr</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
										 <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>exprstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><name>keyname</name></expr></argument>, <argument><expr><literal type="string">"()"</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyListNested</name><argument_list>(<argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><name>keysetname</name></expr></argument>, <argument><expr><name>keysetname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sortnode</name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Grouping Set"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show the grouping keys for a Group node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_group_keys</name><parameter_list>(<parameter><decl><type><name>GroupState</name> <modifier>*</modifier></type><name>gstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
				<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Group</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Group</name> <operator>*</operator><operator>)</operator> <name><name>gstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* The key columns refer to the tlist of the child plan */</comment>
	<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>show_sort_group_keys</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>gstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Group Key"</literal></expr></argument>,
						 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>grpColIdx</name></name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common code to show sort/group keys, which are represented in plan nodes
 * as arrays of targetlist indexes.  If it's a sort key rather than a group
 * key, also pass sort operators/collations/nullsFirst arrays.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_sort_group_keys</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nPresortedKeys</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>keycols</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resultPresorted</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sortkeybuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nkeys</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sortkeybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up deparsing context */</comment>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>set_deparse_context_plan</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name></expr></argument>,
									   <argument><expr><name>plan</name></expr></argument>,
									   <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>useprefix</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name><operator>)</operator></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* find key expression in tlist */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>keyresno</name> <init>= <expr><name><name>keycols</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
											   <argument><expr><name>keyresno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprstr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no tlist entry for key %d"</literal></expr></argument>, <argument><expr><name>keyresno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Deparse the expression, showing any top-level cast */</comment>
		<expr_stmt><expr><name>exprstr</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									 <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sortkeybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sortkeybuf</name></expr></argument>, <argument><expr><name>exprstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Append sort order information, if relevant */</comment>
		<if_stmt><if>if <condition>(<expr><name>sortOperators</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>show_sortorder_options</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sortkeybuf</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
								   <argument><expr><name><name>sortOperators</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>collations</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>nullsFirst</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Emit one property-list item per sort key */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>sortkeybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>keyno</name> <operator>&lt;</operator> <name>nPresortedKeys</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>resultPresorted</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultPresorted</name></expr></argument>, <argument><expr><name>exprstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nPresortedKeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><literal type="string">"Presorted Key"</literal></expr></argument>, <argument><expr><name>resultPresorted</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append nondefault characteristics of the sort ordering of a column to buf
 * (collation, direction, NULLS FIRST/LAST)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_sortorder_options</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>sortexpr</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>sortOperator</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sortcoltype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>sortexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reverse</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>sortcoltype</name></expr></argument>,
								 <argument><expr><name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Print COLLATE if it's not default for the column's type.  There are
	 * some cases where this is redundant, eg if expression is a column whose
	 * declared collation is that collation, but it's hard to distinguish that
	 * here (and arguably, printing COLLATE explicitly is a good idea anyway
	 * in such cases).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>collation</name> <operator>!=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>sortcoltype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collname</name> <init>= <expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>collname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Print direction if not ASC, or USING if non-default sort operator */</comment>
	<if_stmt><if>if <condition>(<expr><name>sortOperator</name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>gt_opr</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>sortOperator</name> <operator>!=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opname</name> <init>= <expr><call><name>get_opname</name><argument_list>(<argument><expr><name>sortOperator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>opname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>sortOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Determine whether operator would be considered ASC or DESC */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_equality_op_for_ordering_op</name><argument_list>(<argument><expr><name>sortOperator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add NULLS FIRST/LAST only if it wouldn't be default */</comment>
	<if_stmt><if>if <condition>(<expr><name>nullsFirst</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>reverse</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>nullsFirst</name> <operator>&amp;&amp;</operator> <name>reverse</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show TABLESAMPLE properties
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_tablesample</name><parameter_list>(<parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>method_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>repeatable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Set up deparsing context */</comment>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>set_deparse_context_plan</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name></expr></argument>,
									   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
									   <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>useprefix</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Get the tablesample method name */</comment>
	<expr_stmt><expr><name>method_name</name> <operator>=</operator> <call><name>get_func_name</name><argument_list>(<argument><expr><name><name>tsc</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse parameter expressions */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tsc-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>params</name></expr></argument>,
						 <argument><expr><call><name>deparse_expression</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
											<argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name><name>tsc</name><operator>-&gt;</operator><name>repeatable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>repeatable</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tsc</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
										<argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>repeatable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Print results */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Sampling: %s ("</literal></expr></argument>, <argument><expr><name>method_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>params</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>repeatable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" REPEATABLE (%s)"</literal></expr></argument>, <argument><expr><name>repeatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Sampling Method"</literal></expr></argument>, <argument><expr><name>method_name</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><literal type="string">"Sampling Parameters"</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>repeatable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Repeatable Seed"</literal></expr></argument>, <argument><expr><name>repeatable</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If it's EXPLAIN ANALYZE, show tuplesort stats for a sort node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_sort_info</name><parameter_list>(<parameter><decl><type><name>SortState</name> <modifier>*</modifier></type><name>sortstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sortstate</name><operator>-&gt;</operator><name>sort_Done</name></name> <operator>&amp;&amp;</operator> <name><name>sortstate</name><operator>-&gt;</operator><name>tuplesortstate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>Tuplesortstate</name> <operator>*</operator><operator>)</operator> <name><name>sortstate</name><operator>-&gt;</operator><name>tuplesortstate</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TuplesortInstrumentation</name></type> <name>stats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sortMethod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spaceType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>spaceUsed</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>tuplesort_get_stats</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortMethod</name> <operator>=</operator> <call><name>tuplesort_method_name</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>sortMethod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>spaceType</name> <operator>=</operator> <call><name>tuplesort_space_type_name</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>spaceType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>spaceUsed</name> <operator>=</operator> <name><name>stats</name><operator>.</operator><name>spaceUsed</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Sort Method: %s  %s: "</literal> <name>INT64_FORMAT</name> <literal type="string">"kB\n"</literal></expr></argument>,
							 <argument><expr><name>sortMethod</name></expr></argument>, <argument><expr><name>spaceType</name></expr></argument>, <argument><expr><name>spaceUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Sort Method"</literal></expr></argument>, <argument><expr><name>sortMethod</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Sort Space Used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name>spaceUsed</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Sort Space Type"</literal></expr></argument>, <argument><expr><name>spaceType</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * You might think we should just skip this stanza entirely when
	 * es-&gt;hide_workers is true, but then we'd get no sort-method output at
	 * all.  We have to make it look like worker 0's data is top-level data.
	 * This is easily done by just skipping the OpenWorker/CloseWorker calls.
	 * Currently, we don't worry about the possibility that there are multiple
	 * workers in such a case; if there are, duplicate output fields will be
	 * emitted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sortstate</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>sortstate</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TuplesortInstrumentation</name> <modifier>*</modifier></type><name>sinstrument</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sortMethod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spaceType</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type>		<name>spaceUsed</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sinstrument</name> <operator>=</operator> <operator>&amp;</operator><name><name>sortstate</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>sinstrument</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sinstrument</name><operator>-&gt;</operator><name>sortMethod</name></name> <operator>==</operator> <name>SORT_TYPE_STILL_IN_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore any unfilled slots */</comment>
			<expr_stmt><expr><name>sortMethod</name> <operator>=</operator> <call><name>tuplesort_method_name</name><argument_list>(<argument><expr><name><name>sinstrument</name><operator>-&gt;</operator><name>sortMethod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>spaceType</name> <operator>=</operator> <call><name>tuplesort_space_type_name</name><argument_list>(<argument><expr><name><name>sinstrument</name><operator>-&gt;</operator><name>spaceType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>spaceUsed</name> <operator>=</operator> <name><name>sinstrument</name><operator>-&gt;</operator><name>spaceUsed</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainOpenWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
								 <argument><expr><literal type="string">"Sort Method: %s  %s: "</literal> <name>INT64_FORMAT</name> <literal type="string">"kB\n"</literal></expr></argument>,
								 <argument><expr><name>sortMethod</name></expr></argument>, <argument><expr><name>spaceType</name></expr></argument>, <argument><expr><name>spaceUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Sort Method"</literal></expr></argument>, <argument><expr><name>sortMethod</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Sort Space Used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name>spaceUsed</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Sort Space Type"</literal></expr></argument>, <argument><expr><name>spaceType</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainCloseWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Incremental sort nodes sort in (a potentially very large number of) batches,
 * so EXPLAIN ANALYZE needs to roll up the tuplesort stats from each batch into
 * an intelligible summary.
 *
 * This function is used for both a non-parallel node and each worker in a
 * parallel incremental sort node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_incremental_sort_group_info</name><parameter_list>(<parameter><decl><type><name>IncrementalSortGroupInfo</name> <modifier>*</modifier></type><name>groupInfo</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>groupLabel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>indent</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>methodCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>methodNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Generate a list of sort methods used across all groups. */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>bit</name> <operator>&lt;</operator> <name>NUM_TUPLESORTMETHODS</name></expr>;</condition> <incr><expr><name>bit</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TuplesortMethod</name></type> <name>sortMethod</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bit</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>groupInfo</name><operator>-&gt;</operator><name>sortMethods</name></name> <operator>&amp;</operator> <name>sortMethod</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>methodName</name> <init>= <expr><call><name>tuplesort_method_name</name><argument_list>(<argument><expr><name>sortMethod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>methodNames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>methodNames</name></expr></argument>, <argument><expr><call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>methodName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>indent</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s Groups: "</literal> <name>INT64_FORMAT</name> <literal type="string">"  Sort Method"</literal></expr></argument>, <argument><expr><name>groupLabel</name></expr></argument>,
						 <argument><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>groupCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* plural/singular based on methodNames size */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>methodNames</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"s: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<macro><name>foreach</name><argument_list>(<argument>methodCell</argument>, <argument>methodNames</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>methodCell</name><operator>-&gt;</operator><name>ptr_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>foreach_current_index</name><argument_list>(<argument><expr><name>methodCell</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>methodNames</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxMemorySpaceUsed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>avgSpace</name> <init>= <expr><name><name>groupInfo</name><operator>-&gt;</operator><name>totalMemorySpaceUsed</name></name> <operator>/</operator> <name><name>groupInfo</name><operator>-&gt;</operator><name>groupCount</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spaceTypeName</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>spaceTypeName</name> <operator>=</operator> <call><name>tuplesort_space_type_name</name><argument_list>(<argument><expr><name>SORT_SPACE_TYPE_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  Average %s: "</literal> <name>INT64_FORMAT</name> <literal type="string">"kB  Peak %s: "</literal> <name>INT64_FORMAT</name> <literal type="string">"kB"</literal></expr></argument>,
							 <argument><expr><name>spaceTypeName</name></expr></argument>, <argument><expr><name>avgSpace</name></expr></argument>,
							 <argument><expr><name>spaceTypeName</name></expr></argument>, <argument><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxMemorySpaceUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxDiskSpaceUsed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>avgSpace</name> <init>= <expr><name><name>groupInfo</name><operator>-&gt;</operator><name>totalDiskSpaceUsed</name></name> <operator>/</operator> <name><name>groupInfo</name><operator>-&gt;</operator><name>groupCount</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spaceTypeName</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>spaceTypeName</name> <operator>=</operator> <call><name>tuplesort_space_type_name</name><argument_list>(<argument><expr><name>SORT_SPACE_TYPE_DISK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  Average %s: "</literal> <name>INT64_FORMAT</name> <literal type="string">"kB  Peak %s: "</literal> <name>INT64_FORMAT</name> <literal type="string">"kB"</literal></expr></argument>,
							 <argument><expr><name>spaceTypeName</name></expr></argument>, <argument><expr><name>avgSpace</name></expr></argument>,
							 <argument><expr><name>spaceTypeName</name></expr></argument>, <argument><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxDiskSpaceUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>groupName</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>groupName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>groupName</name></expr></argument>, <argument><expr><literal type="string">"%s Groups"</literal></expr></argument>, <argument><expr><name>groupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Incremental Sort Groups"</literal></expr></argument>, <argument><expr><name><name>groupName</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Group Count"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>groupCount</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><literal type="string">"Sort Methods Used"</literal></expr></argument>, <argument><expr><name>methodNames</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxMemorySpaceUsed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>avgSpace</name> <init>= <expr><name><name>groupInfo</name><operator>-&gt;</operator><name>totalMemorySpaceUsed</name></name> <operator>/</operator> <name><name>groupInfo</name><operator>-&gt;</operator><name>groupCount</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spaceTypeName</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>memoryName</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>spaceTypeName</name> <operator>=</operator> <call><name>tuplesort_space_type_name</name><argument_list>(<argument><expr><name>SORT_SPACE_TYPE_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>memoryName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>memoryName</name></expr></argument>, <argument><expr><literal type="string">"Sort Space %s"</literal></expr></argument>, <argument><expr><name>spaceTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Sort Space"</literal></expr></argument>, <argument><expr><name><name>memoryName</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Average Sort Space Used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name>avgSpace</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Peak Sort Space Used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>,
								   <argument><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxMemorySpaceUsed</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Sort Space"</literal></expr></argument>, <argument><expr><name><name>memoryName</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxDiskSpaceUsed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>avgSpace</name> <init>= <expr><name><name>groupInfo</name><operator>-&gt;</operator><name>totalDiskSpaceUsed</name></name> <operator>/</operator> <name><name>groupInfo</name><operator>-&gt;</operator><name>groupCount</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spaceTypeName</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>diskName</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>spaceTypeName</name> <operator>=</operator> <call><name>tuplesort_space_type_name</name><argument_list>(<argument><expr><name>SORT_SPACE_TYPE_DISK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diskName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diskName</name></expr></argument>, <argument><expr><literal type="string">"Sort Space %s"</literal></expr></argument>, <argument><expr><name>spaceTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Sort Space"</literal></expr></argument>, <argument><expr><name><name>diskName</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Average Sort Space Used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name>avgSpace</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Peak Sort Space Used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>,
								   <argument><expr><name><name>groupInfo</name><operator>-&gt;</operator><name>maxDiskSpaceUsed</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Sort Space"</literal></expr></argument>, <argument><expr><name><name>diskName</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Incremental Sort Groups"</literal></expr></argument>, <argument><expr><name><name>groupName</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If it's EXPLAIN ANALYZE, show tuplesort stats for an incremental sort node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_incremental_sort_info</name><parameter_list>(<parameter><decl><type><name>IncrementalSortState</name> <modifier>*</modifier></type><name>incrsortstate</name></decl></parameter>,
						   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IncrementalSortGroupInfo</name> <modifier>*</modifier></type><name>fullsortGroupInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IncrementalSortGroupInfo</name> <modifier>*</modifier></type><name>prefixsortGroupInfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fullsortGroupInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>incrsortstate</name><operator>-&gt;</operator><name>incsort_info</name><operator>.</operator><name>fullsortGroupInfo</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since we never have any prefix groups unless we've first sorted a full
	 * groups and transitioned modes (copying the tuples into a prefix group),
	 * we don't need to do anything if there were 0 full groups.
	 *
	 * We still have to continue after this block if there are no full groups,
	 * though, since it's possible that we have workers that did real work
	 * even if the leader didn't participate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fullsortGroupInfo</name><operator>-&gt;</operator><name>groupCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>show_incremental_sort_group_info</name><argument_list>(<argument><expr><name>fullsortGroupInfo</name></expr></argument>, <argument><expr><literal type="string">"Full-sort"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prefixsortGroupInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>incrsortstate</name><operator>-&gt;</operator><name>incsort_info</name><operator>.</operator><name>prefixsortGroupInfo</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>prefixsortGroupInfo</name><operator>-&gt;</operator><name>groupCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>show_incremental_sort_group_info</name><argument_list>(<argument><expr><name>prefixsortGroupInfo</name></expr></argument>, <argument><expr><literal type="string">"Pre-sorted"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>incrsortstate</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>indent_first_line</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>incrsortstate</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IncrementalSortInfo</name> <modifier>*</modifier></type><name>incsort_info</name> <init>=
			<expr><operator>&amp;</operator><name><name>incrsortstate</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>sinfo</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If a worker hasn't processed any sort groups at all, then
			 * exclude it from output since it either didn't launch or didn't
			 * contribute anything meaningful.
			 */</comment>
			<expr_stmt><expr><name>fullsortGroupInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>incsort_info</name><operator>-&gt;</operator><name>fullsortGroupInfo</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Since we never have any prefix groups unless we've first sorted
			 * a full groups and transitioned modes (copying the tuples into a
			 * prefix group), we don't need to do anything if there were 0
			 * full groups.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fullsortGroupInfo</name><operator>-&gt;</operator><name>groupCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainOpenWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>indent_first_line</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_incremental_sort_group_info</name><argument_list>(<argument><expr><name>fullsortGroupInfo</name></expr></argument>, <argument><expr><literal type="string">"Full-sort"</literal></expr></argument>,
											 <argument><expr><name>indent_first_line</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prefixsortGroupInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>incsort_info</name><operator>-&gt;</operator><name>prefixsortGroupInfo</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>prefixsortGroupInfo</name><operator>-&gt;</operator><name>groupCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>show_incremental_sort_group_info</name><argument_list>(<argument><expr><name>prefixsortGroupInfo</name></expr></argument>, <argument><expr><literal type="string">"Pre-sorted"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainCloseWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show information on hash buckets/batches.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_hash_info</name><parameter_list>(<parameter><decl><type><name>HashState</name> <modifier>*</modifier></type><name>hashstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashInstrumentation</name></type> <name>hinstrument</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Collect stats from the local process, even when it's a parallel query.
	 * In a parallel query, the leader process may or may not have run the
	 * hash join, and even if it did it may not have built a hash table due to
	 * timing (if it started late it might have seen no tuples in the outer
	 * relation and skipped building the hash table).  Therefore we have to be
	 * prepared to get instrumentation data from all participants.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashstate</name><operator>-&gt;</operator><name>hinstrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hinstrument</name></expr></argument>, <argument><expr><name><name>hashstate</name><operator>-&gt;</operator><name>hinstrument</name></name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashInstrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Merge results from workers.  In the parallel-oblivious case, the
	 * results from all participants should be identical, except where
	 * participants didn't run the join at all so have no data.  In the
	 * parallel-aware case, we need to consider all the results.  Each worker
	 * may have seen a different subset of batches and we want to report the
	 * highest memory usage across all batches.  We take the maxima of other
	 * values too, for the same reasons as in ExecHashAccumInstrumentation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashstate</name><operator>-&gt;</operator><name>shared_info</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SharedHashInfo</name> <modifier>*</modifier></type><name>shared_info</name> <init>= <expr><name><name>hashstate</name><operator>-&gt;</operator><name>shared_info</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HashInstrumentation</name> <modifier>*</modifier></type><name>worker_hi</name> <init>= <expr><operator>&amp;</operator><name><name>shared_info</name><operator>-&gt;</operator><name>hinstrument</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name></expr></argument>,
									   <argument><expr><name><name>worker_hi</name><operator>-&gt;</operator><name>nbuckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets_original</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets_original</name></name></expr></argument>,
												<argument><expr><name><name>worker_hi</name><operator>-&gt;</operator><name>nbuckets_original</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name></expr></argument>,
									 <argument><expr><name><name>worker_hi</name><operator>-&gt;</operator><name>nbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch_original</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch_original</name></name></expr></argument>,
											  <argument><expr><name><name>worker_hi</name><operator>-&gt;</operator><name>nbatch_original</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hinstrument</name><operator>.</operator><name>space_peak</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>hinstrument</name><operator>.</operator><name>space_peak</name></name></expr></argument>,
										 <argument><expr><name><name>worker_hi</name><operator>-&gt;</operator><name>space_peak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>spacePeakKb</name> <init>= <expr><operator>(</operator><name><name>hinstrument</name><operator>.</operator><name>space_peak</name></name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Hash Buckets"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Original Hash Buckets"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets_original</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Hash Batches"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Original Hash Batches"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch_original</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Peak Memory Usage"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>,
								   <argument><expr><name>spacePeakKb</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>hinstrument</name><operator>.</operator><name>nbatch_original</name></name> <operator>!=</operator> <name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name> <operator>||</operator>
				 <name><name>hinstrument</name><operator>.</operator><name>nbuckets_original</name></name> <operator>!=</operator> <name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
							 <argument><expr><literal type="string">"Buckets: %d (originally %d)  Batches: %d (originally %d)  Memory Usage: %ldkB\n"</literal></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets_original</name></name></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch_original</name></name></expr></argument>,
							 <argument><expr><name>spacePeakKb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
							 <argument><expr><literal type="string">"Buckets: %d  Batches: %d  Memory Usage: %ldkB\n"</literal></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name></expr></argument>, <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name></expr></argument>,
							 <argument><expr><name>spacePeakKb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show information on hash buckets/batches. ( AgensGraph feature )
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_hash2side_info</name><parameter_list>(<parameter><decl><type><name>Hash2SideState</name> <modifier>*</modifier></type><name>hashstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashInstrumentation</name></type> <name>hinstrument</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Collect stats from the local process, even when it's a parallel query.
	 * In a parallel query, the leader process may or may not have run the
	 * hash join, and even if it did it may not have built a hash table due to
	 * timing (if it started late it might have seen no tuples in the outer
	 * relation and skipped building the hash table).  Therefore we have to be
	 * prepared to get instrumentation data from all participants.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashstate</name><operator>-&gt;</operator><name>hashtable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecHash2SideGetInstrumentation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hinstrument</name></expr></argument>, <argument><expr><name><name>hashstate</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>spacePeakKb</name> <init>= <expr><operator>(</operator><name><name>hinstrument</name><operator>.</operator><name>space_peak</name></name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Hash Buckets"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Original Hash Buckets"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets_original</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Hash Batches"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Original Hash Batches"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch_original</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Peak Memory Usage"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>,
								   <argument><expr><name>spacePeakKb</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>hinstrument</name><operator>.</operator><name>nbatch_original</name></name> <operator>!=</operator> <name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name> <operator>||</operator>
				 <name><name>hinstrument</name><operator>.</operator><name>nbuckets_original</name></name> <operator>!=</operator> <name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
							 <argument><expr><literal type="string">"Buckets: %d (originally %d)  Batches: %d (originally %d)  Memory Usage: %ldkB\n"</literal></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets_original</name></name></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch_original</name></name></expr></argument>,
							 <argument><expr><name>spacePeakKb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
							 <argument><expr><literal type="string">"Buckets: %d  Batches: %d  Memory Usage: %ldkB\n"</literal></expr></argument>,
							 <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbuckets</name></name></expr></argument>, <argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name></expr></argument>,
							 <argument><expr><name>spacePeakKb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show information on hash aggregate memory usage and batches.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_hashagg_info</name><parameter_list>(<parameter><decl><type><name>AggState</name> <modifier>*</modifier></type><name>aggstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>memPeakKb</name> <init>= <expr><operator>(</operator><name><name>aggstate</name><operator>-&gt;</operator><name>hash_mem_peak</name></name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_HASHED</name> <operator>&amp;&amp;</operator>
		<name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>!=</operator> <name>AGG_MIXED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Planned Partitions"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_planned_partitions</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * During parallel query the leader may have not helped out.  We
		 * detect this by checking how much memory it used.  If we find it
		 * didn't do any work then we don't show its properties.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>hash_mem_peak</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"HashAgg Batches"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_batches_used</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Peak Memory Usage"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name>memPeakKb</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Disk Usage"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>,
								   <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_disk_used</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>gotone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>hash_planned_partitions</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Planned Partitions: %d"</literal></expr></argument>,
							 <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_planned_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>gotone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * During parallel query the leader may have not helped out.  We
		 * detect this by checking how much memory it used.  If we find it
		 * didn't do any work then we don't show its properties.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>hash_mem_peak</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gotone</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Batches: %d  Memory Usage: "</literal> <name>INT64_FORMAT</name> <literal type="string">"kB"</literal></expr></argument>,
							 <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_batches_used</name></name></expr></argument>, <argument><expr><name>memPeakKb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>gotone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/* Only display disk usage if we spilled to disk */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_batches_used</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  Disk Usage: "</literal> <name>UINT64_FORMAT</name> <literal type="string">"kB"</literal></expr></argument>,
					<argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>hash_disk_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>gotone</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Display stats for each parallel worker */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>aggstate</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AggregateInstrumentation</name> <modifier>*</modifier></type><name>sinstrument</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>hash_disk_used</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>hash_batches_used</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sinstrument</name> <operator>=</operator> <operator>&amp;</operator><name><name>aggstate</name><operator>-&gt;</operator><name>shared_info</name><operator>-&gt;</operator><name>sinstrument</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
			<comment type="block">/* Skip workers that didn't do anything */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sinstrument</name><operator>-&gt;</operator><name>hash_mem_peak</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>hash_disk_used</name> <operator>=</operator> <name><name>sinstrument</name><operator>-&gt;</operator><name>hash_disk_used</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hash_batches_used</name> <operator>=</operator> <name><name>sinstrument</name><operator>-&gt;</operator><name>hash_batches_used</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>memPeakKb</name> <operator>=</operator> <operator>(</operator><name><name>sinstrument</name><operator>-&gt;</operator><name>hash_mem_peak</name></name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainOpenWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Batches: %d  Memory Usage: "</literal> <name>INT64_FORMAT</name> <literal type="string">"kB"</literal></expr></argument>,
								 <argument><expr><name>hash_batches_used</name></expr></argument>, <argument><expr><name>memPeakKb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Only display disk usage if we spilled to disk */</comment>
				<if_stmt><if>if <condition>(<expr><name>hash_batches_used</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  Disk Usage: "</literal> <name>UINT64_FORMAT</name> <literal type="string">"kB"</literal></expr></argument>,
									 <argument><expr><name>hash_disk_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"HashAgg Batches"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>hash_batches_used</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Peak Memory Usage"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name>memPeakKb</name></expr></argument>,
									   <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Disk Usage"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name>hash_disk_used</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainCloseWorker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If it's EXPLAIN ANALYZE, show exact/lossy pages for a BitmapHeapScan node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_tidbitmap_info</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Exact Heap Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>exact_pages</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Lossy Heap Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>lossy_pages</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>exact_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>planstate</name><operator>-&gt;</operator><name>lossy_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Heap Blocks:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>exact_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" exact=%ld"</literal></expr></argument>, <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>exact_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>lossy_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" lossy=%ld"</literal></expr></argument>, <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>lossy_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If it's EXPLAIN ANALYZE, show instrumentation information for a plan node
 *
 * "which" identifies which instrumentation counter to print
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_instrumentation_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>which</name></decl></parameter>,
						   <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>nfiltered</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nloops</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>||</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>which</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nfiltered</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>nfiltered2</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nfiltered</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>nfiltered1</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>nloops</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>nloops</name></name></expr>;</expr_stmt>

	<comment type="block">/* In text mode, suppress zero counts; they're not interesting enough */</comment>
	<if_stmt><if>if <condition>(<expr><name>nfiltered</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nloops</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nfiltered</name> <operator>/</operator> <name>nloops</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show extra information for a ForeignScan node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_foreignscan_info</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>fsstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name> <init>= <expr><name><name>fsstate</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Let the FDW emit whatever fields it wants */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>fsstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>operation</name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainDirectModify</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainDirectModify</name></name><argument_list>(<argument><expr><name>fsstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainForeignScan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainForeignScan</name></name><argument_list>(<argument><expr><name>fsstate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show initplan params evaluated at Gather or Gather Merge node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_eval_params</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bms_params</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bms_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>paramid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>bms_params</name></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>param</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>params</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><literal type="string">"Params Evaluated"</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the name of an index in an EXPLAIN
 *
 * We allow plugins to get control here so that plans involving hypothetical
 * indexes can be explained.
 *
 * Note: names returned by this function should be "raw"; the caller will
 * apply quoting if needed.  Formerly the convention was to do quoting here,
 * but we don't want that in non-text output formats.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>explain_get_index_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>explain_get_index_name_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>explain_get_index_name_hook</name>) <argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* default behavior: look it up in the catalogs */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Show buffer usage details.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_buffer_usage</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BufferUsage</name> <modifier>*</modifier></type><name>usage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>planning</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_shared</name> <init>= <expr><operator>(</operator><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_hit</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
								  <name><name>usage</name><operator>-&gt;</operator><name>shared_blks_read</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
								  <name><name>usage</name><operator>-&gt;</operator><name>shared_blks_dirtied</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
								  <name><name>usage</name><operator>-&gt;</operator><name>shared_blks_written</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_local</name> <init>= <expr><operator>(</operator><name><name>usage</name><operator>-&gt;</operator><name>local_blks_hit</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
								 <name><name>usage</name><operator>-&gt;</operator><name>local_blks_read</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
								 <name><name>usage</name><operator>-&gt;</operator><name>local_blks_dirtied</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
								 <name><name>usage</name><operator>-&gt;</operator><name>local_blks_written</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_temp</name> <init>= <expr><operator>(</operator><name><name>usage</name><operator>-&gt;</operator><name>temp_blks_read</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
								<name><name>usage</name><operator>-&gt;</operator><name>temp_blks_written</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_timing</name> <init>= <expr><operator>(</operator><operator>!</operator><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>usage</name><operator>-&gt;</operator><name>blk_read_time</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
								  <operator>!</operator><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>usage</name><operator>-&gt;</operator><name>blk_write_time</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>show_planning</name> <init>= <expr><operator>(</operator><name>planning</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>has_shared</name> <operator>||</operator>
												  <name>has_local</name> <operator>||</operator> <name>has_temp</name> <operator>||</operator> <name>has_timing</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>show_planning</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Planning:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Show only positive counter values. */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_shared</name> <operator>||</operator> <name>has_local</name> <operator>||</operator> <name>has_temp</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Buffers:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>has_shared</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" shared"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_hit</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" hit=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_hit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_read</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" read=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_dirtied</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" dirtied=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_dirtied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_written</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" written=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>has_local</name> <operator>||</operator> <name>has_temp</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>has_local</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" local"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_hit</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" hit=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_hit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_read</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" read=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_dirtied</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" dirtied=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_dirtied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_written</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" written=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>has_temp</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>has_temp</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" temp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>temp_blks_read</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" read=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>temp_blks_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>temp_blks_written</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" written=%ld"</literal></expr></argument>,
									 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>temp_blks_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* As above, show only positive counter values. */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_timing</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"I/O Timings:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>usage</name><operator>-&gt;</operator><name>blk_read_time</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" read=%0.3f"</literal></expr></argument>,
								 <argument><expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name><name>usage</name><operator>-&gt;</operator><name>blk_read_time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>usage</name><operator>-&gt;</operator><name>blk_write_time</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" write=%0.3f"</literal></expr></argument>,
								 <argument><expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name><name>usage</name><operator>-&gt;</operator><name>blk_write_time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>show_planning</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Shared Hit Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_hit</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Shared Read Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_read</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Shared Dirtied Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_dirtied</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Shared Written Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>shared_blks_written</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Local Hit Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_hit</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Local Read Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_read</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Local Dirtied Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_dirtied</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Local Written Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>local_blks_written</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Temp Read Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>temp_blks_read</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Temp Written Blocks"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>temp_blks_written</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>track_io_timing</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"I/O Read Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>,
								 <argument><expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name><name>usage</name><operator>-&gt;</operator><name>blk_read_time</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"I/O Write Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>,
								 <argument><expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name><name>usage</name><operator>-&gt;</operator><name>blk_write_time</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show WAL usage details.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_wal_usage</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WalUsage</name> <modifier>*</modifier></type><name>usage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Show only positive counter values. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>usage</name><operator>-&gt;</operator><name>wal_records</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>usage</name><operator>-&gt;</operator><name>wal_fpi</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>usage</name><operator>-&gt;</operator><name>wal_bytes</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"WAL:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>wal_records</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" records=%ld"</literal></expr></argument>,
								 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>wal_records</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>wal_fpi</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" fpi=%ld"</literal></expr></argument>,
								 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>wal_fpi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>usage</name><operator>-&gt;</operator><name>wal_bytes</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" bytes="</literal> <name>UINT64_FORMAT</name></expr></argument>,
								 <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>wal_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"WAL Records"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>wal_records</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"WAL FPI"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name><name>usage</name><operator>-&gt;</operator><name>wal_fpi</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyUInteger</name><argument_list>(<argument><expr><literal type="string">"WAL Bytes"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name><name>usage</name><operator>-&gt;</operator><name>wal_bytes</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add some additional details about an IndexScan or IndexOnlyScan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainIndexScanDetails</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>indexorderdir</name></decl></parameter>,
						<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexname</name> <init>= <expr><call><name>explain_get_index_name</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>indexorderdir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" Backward"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" using %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>scandir</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>indexorderdir</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BackwardScanDirection</name></expr>:</case>
				<expr_stmt><expr><name>scandir</name> <operator>=</operator> <literal type="string">"Backward"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>NoMovementScanDirection</name></expr>:</case>
				<expr_stmt><expr><name>scandir</name> <operator>=</operator> <literal type="string">"NoMovement"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ForwardScanDirection</name></expr>:</case>
				<expr_stmt><expr><name>scandir</name> <operator>=</operator> <literal type="string">"Forward"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>scandir</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Scan Direction"</literal></expr></argument>, <argument><expr><name>scandir</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Index Name"</literal></expr></argument>, <argument><expr><name>indexname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show the target of a Scan node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainScanTarget</name><parameter_list>(<parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExplainTargetRel</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show the target of a ModifyTable node
 *
 * Here we show the nominal target (ie, the relation that was named in the
 * original query).  If the actual target(s) is/are different, we'll show them
 * in show_modifytable_info().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainModifyTarget</name><parameter_list>(<parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExplainTargetRel</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show the target relation of a scan or modify node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainTargetRel</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>objectname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>namespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objecttag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>, <argument><expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>refname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>refname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<comment type="block">/* Assert it's on a real relation */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>objectname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>namespace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>objecttag</name> <operator>=</operator> <literal type="string">"Relation Name"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>fscan</name> <init>= <expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Assert it's on a RangeFunction */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the expression is still a function call of a single
				 * function, we can get the real name of the function.
				 * Otherwise, punt.  (Even if it was a single function call
				 * originally, the optimizer could have simplified it away.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name> <init>= <expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>objectname</name> <operator>=</operator> <call><name>get_func_name</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>namespace</name> <operator>=</operator>
								<call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_func_namespace</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>objecttag</name> <operator>=</operator> <literal type="string">"Function Name"</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>objectname</name> <operator>=</operator> <literal type="string">"xmltable"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>objecttag</name> <operator>=</operator> <literal type="string">"Table Function Name"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
			<comment type="block">/* Assert it's on a non-self-reference CTE */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>objectname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>objecttag</name> <operator>=</operator> <literal type="string">"CTE Name"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_NAMEDTUPLESTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>objectname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>enrname</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>objecttag</name> <operator>=</operator> <literal type="string">"Tuplestore Name"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<comment type="block">/* Assert it's on a self-reference CTE */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>objectname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>objecttag</name> <operator>=</operator> <literal type="string">"CTE Name"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" %s.%s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>objectname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>objectname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>objectname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>objectname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>objectname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>objecttag</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>objectname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><name>objecttag</name></expr></argument>, <argument><expr><name>objectname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>, <argument><expr><name>namespace</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Alias"</literal></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show extra information for a ModifyTable node
 *
 * We have three objectives here.  First, if there's more than one target
 * table or it's different from the nominal target, identify the actual
 * target(s).  Second, give FDWs a chance to display extra info about foreign
 * targets.  Third, show information about ON CONFLICT.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_modifytable_info</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
					  <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>foperation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>labeltargets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idxNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lst</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Insert"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>foperation</name> <operator>=</operator> <literal type="string">"Foreign Insert"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Update"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>foperation</name> <operator>=</operator> <literal type="string">"Foreign Update"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Delete"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>foperation</name> <operator>=</operator> <literal type="string">"Foreign Delete"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>foperation</name> <operator>=</operator> <literal type="string">"Foreign ???"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Should we explicitly label target relations? */</comment>
	<expr_stmt><expr><name>labeltargets</name> <operator>=</operator> <operator>(</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator>
					<operator>(</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					 <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RangeTableIndex</name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>nominalRelation</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>labeltargets</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Target Tables"</literal></expr></argument>, <argument><expr><literal type="string">"Target Tables"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>+</operator> <name>j</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>labeltargets</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Open a group for this target */</comment>
			<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Target Table"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In text mode, decorate each target with operation type, so that
			 * ExplainTargetRel's output of " on foo" will read nicely.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
									   <argument><expr><ternary><condition><expr><name>fdwroutine</name></expr> ?</condition><then> <expr><name>foperation</name></expr> </then><else>: <expr><name>operation</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Identify target */</comment>
			<expr_stmt><expr><call><name>ExplainTargetRel</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
							 <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
							 <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Give FDW a chance if needed */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>&amp;&amp;</operator>
			<name>fdwroutine</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainForeignModify</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_private</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fdwPrivLists</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainForeignModify</name></name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
											 <argument><expr><name>resultRelInfo</name></expr></argument>,
											 <argument><expr><name>fdw_private</name></expr></argument>,
											 <argument><expr><name>j</name></expr></argument>,
											 <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>labeltargets</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Undo the indentation we added in text format */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Close the group */</comment>
			<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Target Table"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Gather names of ON CONFLICT arbiter indexes */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lst</argument>, <argument>node-&gt;arbiterIndexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indexname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>idxNames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>idxNames</name></expr></argument>, <argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Conflict Resolution"</literal></expr></argument>,
							<argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_NOTHING</name></expr> ?</condition><then>
							<expr><literal type="string">"NOTHING"</literal></expr> </then><else>: <expr><literal type="string">"UPDATE"</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Don't display arbiter indexes at all when DO NOTHING variant
		 * implicitly ignores all conflicts
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>idxNames</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><literal type="string">"Conflict Arbiter Indexes"</literal></expr></argument>, <argument><expr><name>idxNames</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* ON CONFLICT DO UPDATE WHERE qual is specially displayed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>show_upper_qual</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>, <argument><expr><literal type="string">"Conflict Filter"</literal></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>show_instrumentation_count</name><argument_list>(<argument><expr><literal type="string">"Rows Removed by Conflict Filter"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* EXPLAIN ANALYZE display of actual outcome for each tuple proposed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>total</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>insert_path</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>other_path</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>instrument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* count the number of source rows */</comment>
			<expr_stmt><expr><name>total</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>instrument</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>other_path</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name><operator>-&gt;</operator><name>ntuples2</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>insert_path</name> <operator>=</operator> <name>total</name> <operator>-</operator> <name>other_path</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Tuples Inserted"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>insert_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Conflicting Tuples"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>other_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>labeltargets</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Target Tables"</literal></expr></argument>, <argument><expr><literal type="string">"Target Tables"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Explain the constituent plans of a ModifyTable, Append, MergeAppend,
 * BitmapAnd, or BitmapOr node.
 *
 * The ancestors list should already contain the immediate parent of these
 * plans.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainMemberNodes</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>planstates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nplans</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nplans</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainNode</name><argument_list>(<argument><expr><name><name>planstates</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>,
					<argument><expr><literal type="string">"Member"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Report about any pruned subnodes of an Append or MergeAppend node.
 *
 * nplans indicates the number of live subplans.
 * nchildren indicates the original number of subnodes in the Plan;
 * some of these may have been pruned by the run-time pruning code.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainMissingMembers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nplans</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nchildren</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>nplans</name> <operator>&lt;</operator> <name>nchildren</name> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Subplans Removed"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>nchildren</name> <operator>-</operator> <name>nplans</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Explain a list of SubPlans (or initPlans, which also use SubPlan nodes).
 *
 * The ancestors list should already contain the immediate parent of these
 * SubPlans.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainSubPlans</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plans</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationship</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lst</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lst</argument>, <argument>plans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>subplan</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * There can be multiple SubPlan nodes referencing the same physical
		 * subplan (same plan_id, which is its index in PlannedStmt.subplans).
		 * We should print a subplan only once, so track which ones we already
		 * printed.  This state must be global across the plan tree, since the
		 * duplicate nodes could be in different plan nodes, eg both a bitmap
		 * indexscan's indexqual and its parent heapscan's recheck qual.  (We
		 * do not worry too much about which plan node we show the subplan as
		 * attached to in such cases.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>printed_subplans</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>printed_subplans</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>printed_subplans</name></name></expr></argument>,
											  <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Treat the SubPlan node as an ancestor of the plan node(s) within
		 * it, so that ruleutils.c can find the referents of subplan
		 * parameters.
		 */</comment>
		<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainNode</name><argument_list>(<argument><expr><name><name>sps</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>,
					<argument><expr><name>relationship</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Explain a list of children of a CustomScan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainCustomChildren</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>css</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name> <init>=
	<expr><operator>(</operator><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>css</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"children"</literal></expr> </then><else>: <expr><literal type="string">"child"</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>css-&gt;custom_ps</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>ExplainNode</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a per-plan-node workspace for collecting per-worker data.
 *
 * Output related to each worker will be temporarily "set aside" into a
 * separate buffer, which we'll merge into the main output stream once
 * we've processed all data for the plan node.  This makes it feasible to
 * generate a coherent sub-group of fields for each worker, even though the
 * code that produces the fields is in several different places in this file.
 * Formatting of such a set-aside field group is managed by
 * ExplainOpenSetAsideGroup and ExplainSaveGroup/ExplainRestoreGroup.
 */</comment>
<function><type><specifier>static</specifier> <name>ExplainWorkersState</name> <modifier>*</modifier></type>
<name>ExplainCreateWorkersState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_workers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExplainWorkersState</name> <modifier>*</modifier></type><name>wstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>wstate</name> <operator>=</operator> <operator>(</operator><name>ExplainWorkersState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExplainWorkersState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name>num_workers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_inited</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_workers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_str</name></name> <operator>=</operator> <operator>(</operator><name>StringInfoData</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name>num_workers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StringInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_state_save</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_workers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>wstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Begin or resume output into the set-aside group for worker N.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainOpenWorker</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExplainWorkersState</name> <modifier>*</modifier></type><name>wstate</name> <init>= <expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name><name>wstate</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save prior output buffer pointer */</comment>
	<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>prev_str</name></name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>wstate</name><operator>-&gt;</operator><name>worker_inited</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, so create the buffer for this worker */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wstate</name><operator>-&gt;</operator><name>worker_str</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>wstate</name><operator>-&gt;</operator><name>worker_str</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Push suitable initial formatting state for this worker's field
		 * group.  We allow one extra logical nesting level, since this group
		 * will eventually be wrapped in an outer "Workers" group.
		 */</comment>
		<expr_stmt><expr><call><name>ExplainOpenSetAsideGroup</name><argument_list>(<argument><expr><literal type="string">"Worker"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In non-TEXT formats we always emit a "Worker Number" field, even if
		 * there's no other data for this worker.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Worker Number"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_inited</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Resuming output for a worker we've already emitted some data for */</comment>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>wstate</name><operator>-&gt;</operator><name>worker_str</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Restore formatting state saved by last ExplainCloseWorker() */</comment>
		<expr_stmt><expr><call><name>ExplainRestoreGroup</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wstate</name><operator>-&gt;</operator><name>worker_state_save</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * In TEXT format, prefix the first output line for this worker with
	 * "Worker N:".  Then, any additional lines should be indented one more
	 * stop than the "Worker N" line is.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Worker %d:  "</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * End output for worker N --- must pair with previous ExplainOpenWorker call
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainCloseWorker</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExplainWorkersState</name> <modifier>*</modifier></type><name>wstate</name> <init>= <expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name><name>wstate</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_inited</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save formatting state in case we do another ExplainOpenWorker(), then
	 * pop the formatting stack.
	 */</comment>
	<expr_stmt><expr><call><name>ExplainSaveGroup</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wstate</name><operator>-&gt;</operator><name>worker_state_save</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In TEXT format, if we didn't actually produce any output line(s) then
	 * truncate off the partial line emitted by ExplainOpenWorker.  (This is
	 * to avoid bogus output if, say, show_buffer_usage chooses not to print
	 * anything for the worker.)  Also fix up the indent level.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><operator>(</operator><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore prior output buffer pointer */</comment>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <name><name>wstate</name><operator>-&gt;</operator><name>prev_str</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print per-worker info for current node, then free the ExplainWorkersState.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainFlushWorkersState</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExplainWorkersState</name> <modifier>*</modifier></type><name>wstate</name> <init>= <expr><name><name>es</name><operator>-&gt;</operator><name>workers_state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>wstate</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_inited</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* This must match previous ExplainOpenSetAsideGroup call */</comment>
			<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Worker"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_str</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Worker"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_str</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_inited</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>worker_state_save</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Explain a property, such as sort keys or targets, that takes the form of
 * a list of unlabeled items.  "data" is a list of C strings.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPropertyList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>data</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainXMLTag</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>X_OPENING</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>data</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"&lt;Item&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>escape_xml</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"&lt;/Item&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>ExplainXMLTag</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>X_CLOSING</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainJSONLineEnding</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">": ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>data</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainYAMLLineStarting</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>data</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>escape_yaml</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Explain a property that takes the form of a list of unlabeled items within
 * another list.  "data" is a list of C strings.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPropertyListNested</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainJSONLineEnding</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>data</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainYAMLLineStarting</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"- ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>data</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>escape_yaml</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Explain a simple property.
 *
 * If "numeric" is true, the value is a number (or other value that
 * doesn't need quoting in JSON).
 *
 * If unit is non-NULL the text format will display it after the value.
 *
 * This usually should not be invoked directly, but via one of the datatype
 * specific routines ExplainPropertyText, ExplainPropertyInteger, etc.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainProperty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>numeric</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainIndentText</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>unit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s: %s %s\n"</literal></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainXMLTag</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>X_OPENING</name> <operator>|</operator> <name>X_NOWHITESPACE</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>escape_xml</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainXMLTag</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>X_CLOSING</name> <operator>|</operator> <name>X_NOWHITESPACE</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainJSONLineEnding</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>numeric</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainYAMLLineStarting</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>qlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>numeric</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>escape_yaml</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Explain a string-valued property.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPropertyText</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExplainProperty</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Explain an integer-valued property.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPropertyInteger</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>,
					   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainProperty</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Explain an unsigned integer-valued property.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPropertyUInteger</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>,
						<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainProperty</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Explain a float-valued property, using the specified number of
 * fractional digits.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPropertyFloat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>ndigits</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%.*f"</literal></expr></argument>, <argument><expr><name>ndigits</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainProperty</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Explain a bool-valued property.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPropertyBool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExplainProperty</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name>value</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open a group of related objects.
 *
 * objtype is the type of the group object, labelname is its label within
 * a containing object (if any).
 *
 * If labeled is true, the group members will be labeled properties,
 * while if it's false, they'll be unlabeled objects.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainOpenGroup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>labelname</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>labeled</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainXMLTag</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>X_OPENING</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainJSONLineEnding</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name><name>es</name><operator>-&gt;</operator><name>indent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>labelname</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>labelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>labeled</name></expr> ?</condition><then> <expr><literal type="char">'{'</literal></expr> </then><else>: <expr><literal type="char">'['</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In JSON format, the grouping_stack is an integer list.  0 means
			 * we've emitted nothing at this grouping level, 1 means we've
			 * emitted something (and so the next item needs a comma). See
			 * ExplainJSONLineEnding().
			 */</comment>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>

			<comment type="block">/*
			 * In YAML format, the grouping stack is an integer list.  0 means
			 * we've emitted nothing at this grouping level AND this grouping
			 * level is unlabeled and must be marked with "- ".  See
			 * ExplainYAMLLineStarting().
			 */</comment>
			<expr_stmt><expr><call><name>ExplainYAMLLineStarting</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>labelname</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>labelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Close a group of related objects.
 * Parameters must match the corresponding ExplainOpenGroup call.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainCloseGroup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>labelname</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>labeled</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainXMLTag</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>X_CLOSING</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name><name>es</name><operator>-&gt;</operator><name>indent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>labeled</name></expr> ?</condition><then> <expr><literal type="char">'}'</literal></expr> </then><else>: <expr><literal type="char">']'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Open a group of related objects, without emitting actual data.
 *
 * Prepare the formatting state as though we were beginning a group with
 * the identified properties, but don't actually emit anything.  Output
 * subsequent to this call can be redirected into a separate output buffer,
 * and then eventually appended to the main output buffer after doing a
 * regular ExplainOpenGroup call (with the same parameters).
 *
 * The extra "depth" parameter is the new group's depth compared to current.
 * It could be more than one, in case the eventual output will be enclosed
 * in additional nesting group levels.  We assume we don't need to track
 * formatting state for those levels while preparing this group's output.
 *
 * There is no ExplainCloseSetAsideGroup --- in current usage, we always
 * pop this state with ExplainSaveGroup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainOpenSetAsideGroup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>labelname</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>labeled</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <name>depth</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <name>depth</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>labelname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <name>depth</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Pop one level of grouping state, allowing for a re-push later.
 *
 * This is typically used after ExplainOpenSetAsideGroup; pass the
 * same "depth" used for that.
 *
 * This should not emit any output.  If state needs to be saved,
 * save it at *state_save.  Currently, an integer save area is sufficient
 * for all formats, but we might need to revisit that someday.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainSaveGroup</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>state_save</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>-=</operator> <name>depth</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>-=</operator> <name>depth</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>state_save</name> <operator>=</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>-=</operator> <name>depth</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>state_save</name> <operator>=</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Re-push one level of grouping state, undoing the effects of ExplainSaveGroup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainRestoreGroup</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>state_save</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <name>depth</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><operator>*</operator><name>state_save</name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <name>depth</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><operator>*</operator><name>state_save</name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <name>depth</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Emit a "dummy" group that never has any members.
 *
 * objtype is the type of the group object, labelname is its label within
 * a containing object (if any).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainDummyGroup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>labelname</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainXMLTag</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>X_CLOSE_IMMEDIATE</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainJSONLineEnding</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name><name>es</name><operator>-&gt;</operator><name>indent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>labelname</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>labelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainYAMLLineStarting</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>labelname</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>escape_yaml</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>labelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>escape_yaml</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Emit the start-of-output boilerplate.
 *
 * This is just enough different from processing a subgroup that we need
 * a separate pair of subroutines.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainBeginOutput</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
								   <argument><expr><literal type="string">"&lt;explain xmlns=\"http://www.postgresql.org/2009/explain\"&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<comment type="block">/* top-level structure is an array of plans */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Emit the end-of-output boilerplate.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainEndOutput</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"&lt;/explain&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"\n]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Put an appropriate separator between multiple plans
 */</comment>
<function><type><name>void</name></type>
<name>ExplainSeparatePlans</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>:</case>
			<comment type="block">/* add a blank line */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Emit opening or closing XML tag.
 *
 * "flags" must contain X_OPENING, X_CLOSING, or X_CLOSE_IMMEDIATE.
 * Optionally, OR in X_NOWHITESPACE to suppress the whitespace we'd normally
 * add.
 *
 * XML restricts tag names more than our other output formats, eg they can't
 * contain white space or slashes.  Replace invalid characters with dashes,
 * so that for example "I/O Read Time" becomes "I-O-Read-Time".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainXMLTag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tagname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valid</name> <init>= <expr><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_."</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>X_NOWHITESPACE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name><name>es</name><operator>-&gt;</operator><name>indent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>X_CLOSING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>tagname</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>strchr</name><argument_list>(<argument><expr><name>valid</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>*</operator><name>s</name></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>X_CLOSE_IMMEDIATE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" /"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>X_NOWHITESPACE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Indent a text-format line.
 *
 * We indent by two spaces per indentation level.  However, when emitting
 * data for a parallel worker there might already be data on the current line
 * (cf. ExplainOpenWorker); in that case, don't indent any more.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainIndentText</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Emit a JSON line ending.
 *
 * JSON requires a comma after each property but the last.  To facilitate this,
 * in JSON format, the text emitted for each property begins just prior to the
 * preceding line-break (and comma, if applicable).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainJSONLineEnding</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_JSON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Indent a YAML line.
 *
 * YAML lines are ordinarily indented by two spaces per indentation level.
 * The text emitted for each property begins just prior to the preceding
 * line-break, except for the first property in an unlabeled group, for which
 * it begins immediately after the "- " that introduces the group.  The first
 * property of the group appears on the same line as the opening "- ".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainYAMLLineStarting</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_YAML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>grouping_stack</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * YAML is a superset of JSON; unfortunately, the YAML quoting rules are
 * ridiculously complicated -- as documented in sections 5.3 and 7.3.3 of
 * http://yaml.org/spec/1.2/spec.html -- so we chose to just quote everything.
 * Empty strings, strings with leading or trailing whitespace, and strings
 * containing a variety of special characters must certainly be quoted or the
 * output is invalid; and other seemingly harmless strings like "0xa" or
 * "true" must be quoted, lest they be interpreted as a hexadecimal or Boolean
 * constant rather than a string.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>escape_yaml</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
